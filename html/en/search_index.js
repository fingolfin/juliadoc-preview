var documenterSearchIndex = {"docs":
[{"title":"Constructors","page":"Constructors","location":"manual/constructors.html#man-constructors","category":"section","text":"Constructors [1] are functions that create new objects – specifically, instances of Composite Types.\nIn Julia, type objects also serve as constructor functions: they create new instances of themselves\nwhen applied to an argument tuple as a function. This much was already mentioned briefly when\ncomposite types were introduced. For example:\n\njulia> struct Foo\n           bar\n           baz\n       end\n\njulia> foo = Foo(1, 2)\nFoo(1, 2)\n\njulia> foo.bar\n1\n\njulia> foo.baz\n2\n\nFor many types, forming new objects by binding their field values together is all that is ever\nneeded to create instances. However, in some cases more functionality is required when\ncreating composite objects. Sometimes invariants must be enforced, either by checking arguments\nor by transforming them. Recursive data structures,\nespecially those that may be self-referential, often cannot be constructed cleanly without first\nbeing created in an incomplete state and then altered programmatically to be made whole, as a\nseparate step from object creation. Sometimes, it's just convenient to be able to construct objects\nwith fewer or different types of parameters than they have fields. Julia's system for object construction\naddresses all of these cases and more.\n\n[1]: Nomenclature: while the term \"constructor\" generally refers to the entire function which constructs\nobjects of a type, it is common to abuse terminology slightly and refer to specific constructor\nmethods as \"constructors\". In such situations, it is generally clear from the context that the term\nis used to mean \"constructor method\" rather than \"constructor function\", especially as it is often\nused in the sense of singling out a particular method of the constructor from all of the others."},{"title":"Outer Constructor Methods","page":"Constructors","location":"manual/constructors.html#man-outer-constructor-methods","category":"section","text":"A constructor is just like any other function in Julia in that its overall behavior is defined\nby the combined behavior of its methods. Accordingly, you can add functionality to a constructor\nby simply defining new methods. For example, let's say you want to add a constructor method for\nFoo objects that takes only one argument and uses the given value for both the bar and baz\nfields. This is simple:\n\njulia> Foo(x) = Foo(x,x)\nFoo\n\njulia> Foo(1)\nFoo(1, 1)\n\nYou could also add a zero-argument Foo constructor method that supplies default values for both\nof the bar and baz fields:\n\njulia> Foo() = Foo(0)\nFoo\n\njulia> Foo()\nFoo(0, 0)\n\nHere the zero-argument constructor method calls the single-argument constructor method, which\nin turn calls the automatically provided two-argument constructor method. For reasons that will\nbecome clear very shortly, additional constructor methods declared as normal methods like this\nare called outer constructor methods. Outer constructor methods can only ever create a new instance\nby calling another constructor method, such as the automatically provided default ones."},{"title":"Inner Constructor Methods","page":"Constructors","location":"manual/constructors.html#man-inner-constructor-methods","category":"section","text":"While outer constructor methods succeed in addressing the problem of providing additional convenience\nmethods for constructing objects, they fail to address the other two use cases mentioned in the\nintroduction of this chapter: enforcing invariants, and allowing construction of self-referential\nobjects. For these problems, one needs inner constructor methods. An inner constructor method\nis like an outer constructor method, except for two differences:\n\nIt is declared inside the block of a type declaration, rather than outside of it like normal methods.\nIt has access to a special locally existent function called new that creates objects of the\nblock's type.\n\nFor example, suppose one wants to declare a type that holds a pair of real numbers, subject to\nthe constraint that the first number is not greater than the second one. One could declare it\nlike this:\n\njulia> struct OrderedPair\n           x::Real\n           y::Real\n           OrderedPair(x,y) = x > y ? error(\"out of order\") : new(x,y)\n       end\n\nNow OrderedPair objects can only be constructed such that x <= y:\n\njulia> OrderedPair(1, 2)\nOrderedPair(1, 2)\n\njulia> OrderedPair(2,1)\nERROR: out of order\nStacktrace:\n [1] error at ./error.jl:33 [inlined]\n [2] OrderedPair(::Int64, ::Int64) at ./none:4\n [3] top-level scope\n\nIf the type were declared mutable, you could reach in and directly change the field values to\nviolate this invariant. Of course, messing around with an object's internals uninvited is bad practice.\nYou (or someone else) can also provide additional outer constructor methods at any later point, but\nonce a type is declared, there is no way to add more inner constructor methods. Since outer constructor\nmethods can only create objects by calling other constructor methods, ultimately, some inner constructor\nmust be called to create an object. This guarantees that all objects of the declared type must come into\nexistence by a call to one of the inner constructor methods provided with the type, thereby giving\nsome degree of enforcement of a type's invariants.\n\nIf any inner constructor method is defined, no default constructor method is provided: it is presumed\nthat you have supplied yourself with all the inner constructors you need. The default constructor\nis equivalent to writing your own inner constructor method that takes all of the object's fields\nas parameters (constrained to be of the correct type, if the corresponding field has a type),\nand passes them to new, returning the resulting object:\n\njulia> struct Foo\n           bar\n           baz\n           Foo(bar,baz) = new(bar,baz)\n       end\n\n\nThis declaration has the same effect as the earlier definition of the Foo type without an explicit\ninner constructor method. The following two types are equivalent – one with a default constructor,\nthe other with an explicit constructor:\n\njulia> struct T1\n           x::Int64\n       end\n\njulia> struct T2\n           x::Int64\n           T2(x) = new(x)\n       end\n\njulia> T1(1)\nT1(1)\n\njulia> T2(1)\nT2(1)\n\njulia> T1(1.0)\nT1(1)\n\njulia> T2(1.0)\nT2(1)\n\nIt is good practice to provide as few inner constructor methods as possible: only those\ntaking all arguments explicitly and enforcing essential error checking and transformation. Additional\nconvenience constructor methods, supplying default values or auxiliary transformations, should\nbe provided as outer constructors that call the inner constructors to do the heavy lifting. This\nseparation is typically quite natural."},{"title":"Incomplete Initialization","page":"Constructors","location":"manual/constructors.html#Incomplete-Initialization","category":"section","text":"The final problem which has still not been addressed is construction of self-referential objects,\nor more generally, recursive data structures. Since the fundamental difficulty may not be immediately\nobvious, let us briefly explain it. Consider the following recursive type declaration:\n\njulia> mutable struct SelfReferential\n           obj::SelfReferential\n       end\n\n\nThis type may appear innocuous enough, until one considers how to construct an instance of it.\nIf a is an instance of SelfReferential, then a second instance can be created by the call:\n\njulia> b = SelfReferential(a)\n\nBut how does one construct the first instance when no instance exists to provide as a valid value\nfor its obj field? The only solution is to allow creating an incompletely initialized instance\nof SelfReferential with an unassigned obj field, and using that incomplete instance as a valid\nvalue for the obj field of another instance, such as, for example, itself.\n\nTo allow for the creation of incompletely initialized objects, Julia allows the new function\nto be called with fewer than the number of fields that the type has, returning an object with\nthe unspecified fields uninitialized. The inner constructor method can then use the incomplete\nobject, finishing its initialization before returning it. Here, for example, is another attempt\nat defining the SelfReferential type, this time using a zero-argument inner constructor returning instances\nhaving obj fields pointing to themselves:\n\njulia> mutable struct SelfReferential\n           obj::SelfReferential\n           SelfReferential() = (x = new(); x.obj = x)\n       end\n\n\nWe can verify that this constructor works and constructs objects that are, in fact, self-referential:\n\njulia> x = SelfReferential();\n\njulia> x === x\ntrue\n\njulia> x === x.obj\ntrue\n\njulia> x === x.obj.obj\ntrue\n\nAlthough it is generally a good idea to return a fully initialized object from an inner constructor,\nit is possible to return incompletely initialized objects:\n\njulia> mutable struct Incomplete\n           data\n           Incomplete() = new()\n       end\n\njulia> z = Incomplete();\n\nWhile you are allowed to create objects with uninitialized fields, any access to an uninitialized\nreference is an immediate error:\n\njulia> z.data\nERROR: UndefRefError: access to undefined reference\n\nThis avoids the need to continually check for null values. However, not all object fields are\nreferences. Julia considers some types to be \"plain data\", meaning all of their data is self-contained\nand does not reference other objects. The plain data types consist of primitive types (e.g. Int)\nand immutable structs of other plain data types (see also: isbits, isbitstype).\nThe initial contents of a plain data type is undefined:\n\njulia> struct HasPlain\n           n::Int\n           HasPlain() = new()\n       end\n\njulia> HasPlain()\nHasPlain(438103441441)\n\nArrays of plain data types exhibit the same behavior.\n\nYou can pass incomplete objects to other functions from inner constructors to delegate their completion:\n\njulia> mutable struct Lazy\n           data\n           Lazy(v) = complete_me(new(), v)\n       end\n\nAs with incomplete objects returned from constructors, if complete_me or any of its callees\ntry to access the data field of the Lazy object before it has been initialized, an error will\nbe thrown immediately."},{"title":"Parametric Constructors","page":"Constructors","location":"manual/constructors.html#Parametric-Constructors","category":"section","text":"Parametric types add a few wrinkles to the constructor story. Recall from Parametric Types\nthat, by default, instances of parametric composite types can be constructed either with explicitly\ngiven type parameters or with type parameters implied by the types of the arguments given to the\nconstructor. Here are some examples:\n\njulia> struct Point{T<:Real}\n           x::T\n           y::T\n       end\n\njulia> Point(1,2) ## implicit T ##\nPoint{Int64}(1, 2)\n\njulia> Point(1.0,2.5) ## implicit T ##\nPoint{Float64}(1.0, 2.5)\n\njulia> Point(1,2.5) ## implicit T ##\nERROR: MethodError: no method matching Point(::Int64, ::Float64)\nThe type `Point` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  Point(::T, ::T) where T<:Real at none:2\n\njulia> Point{Int64}(1, 2) ## explicit T ##\nPoint{Int64}(1, 2)\n\njulia> Point{Int64}(1.0,2.5) ## explicit T ##\nERROR: InexactError: Int64(2.5)\nStacktrace:\n[...]\n\njulia> Point{Float64}(1.0, 2.5) ## explicit T ##\nPoint{Float64}(1.0, 2.5)\n\njulia> Point{Float64}(1,2) ## explicit T ##\nPoint{Float64}(1.0, 2.0)\n\nAs you can see, for constructor calls with explicit type parameters, the arguments are converted\nto the implied field types: Point{Int64}(1,2) works, but Point{Int64}(1.0,2.5) raises an\nInexactError when converting 2.5 to Int64. When the type is implied\nby the arguments to the constructor call, as in Point(1,2), then the types of the\narguments must agree – otherwise the T cannot be determined – but any pair of real\narguments with matching type may be given to the generic Point constructor.\n\nWhat's really going on here is that Point, Point{Float64} and Point{Int64} are all different\nconstructor functions. In fact, Point{T} is a distinct constructor function for each type T.\nWithout any explicitly provided inner constructors, the declaration of the composite type Point{T<:Real}\nautomatically provides an inner constructor, Point{T}, for each possible type T<:Real, that\nbehaves just like non-parametric default inner constructors do. It also provides a single general\nouter Point constructor that takes pairs of real arguments, which must be of the same type.\nThis automatic provision of constructors is equivalent to the following explicit declaration:\n\njulia> struct Point{T<:Real}\n           x::T\n           y::T\n           Point{T}(x,y) where {T<:Real} = new(x,y)\n       end\n\njulia> Point(x::T, y::T) where {T<:Real} = Point{T}(x,y);\n\nNotice that each definition looks like the form of constructor call that it handles.\nThe call Point{Int64}(1,2) will invoke the definition Point{T}(x,y) inside the\nstruct block.\nThe outer constructor declaration, on the other hand, defines a\nmethod for the general Point constructor which only applies to pairs of values of the same real\ntype. This declaration makes constructor calls without explicit type parameters, like Point(1,2)\nand Point(1.0,2.5), work. Since the method declaration restricts the arguments to being of the\nsame type, calls like Point(1,2.5), with arguments of different types, result in \"no method\"\nerrors.\n\nSuppose we wanted to make the constructor call Point(1,2.5) work by \"promoting\" the integer\nvalue 1 to the floating-point value 1.0. The simplest way to achieve this is to define the\nfollowing additional outer constructor method:\n\njulia> Point(x::Int64, y::Float64) = Point(convert(Float64,x),y);\n\nThis method uses the convert function to explicitly convert x to Float64\nand then delegates construction to the general constructor for the case where both arguments are\nFloat64. With this method definition what was previously a MethodError now\nsuccessfully creates a point of type Point{Float64}:\n\njulia> p = Point(1,2.5)\nPoint{Float64}(1.0, 2.5)\n\njulia> typeof(p)\nPoint{Float64}\n\nHowever, other similar calls still don't work:\n\njulia> Point(1.5,2)\nERROR: MethodError: no method matching Point(::Float64, ::Int64)\nThe type `Point` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  Point(::T, !Matched::T) where T<:Real\n   @ Main none:1\n  Point(!Matched::Int64, !Matched::Float64)\n   @ Main none:1\n\nStacktrace:\n[...]\n\nFor a more general way to make all such calls work sensibly, see Conversion and Promotion.\nAt the risk of spoiling the suspense, we can reveal here that all it takes is the following outer\nmethod definition to make all calls to the general Point constructor work as one would expect:\n\njulia> Point(x::Real, y::Real) = Point(promote(x,y)...);\n\nThe promote function converts all its arguments to a common type – in this case Float64.\nWith this method definition, the Point constructor promotes its arguments the same way that\nnumeric operators like + do, and works for all kinds of real numbers:\n\njulia> Point(1.5,2)\nPoint{Float64}(1.5, 2.0)\n\njulia> Point(1,1//2)\nPoint{Rational{Int64}}(1//1, 1//2)\n\njulia> Point(1.0,1//2)\nPoint{Float64}(1.0, 0.5)\n\nThus, while the implicit type parameter constructors provided by default in Julia are fairly strict,\nit is possible to make them behave in a more relaxed but sensible manner quite easily. Moreover,\nsince constructors can leverage all of the power of the type system, methods, and multiple dispatch,\ndefining sophisticated behavior is typically quite simple."},{"title":"Case Study: Rational","page":"Constructors","location":"manual/constructors.html#Case-Study:-Rational","category":"section","text":"Perhaps the best way to tie all these pieces together is to present a real world example of a\nparametric composite type and its constructor methods. To that end, we implement our own rational number type\nOurRational, similar to Julia's built-in Rational type, defined in\nrational.jl:\n\njulia> struct OurRational{T<:Integer} <: Real\n           num::T\n           den::T\n           function OurRational{T}(num::T, den::T) where T<:Integer\n               if num == 0 && den == 0\n                    error(\"invalid rational: 0//0\")\n               end\n               num = flipsign(num, den)\n               den = flipsign(den, den)\n               g = gcd(num, den)\n               num = div(num, g)\n               den = div(den, g)\n               new(num, den)\n           end\n       end\n\njulia> OurRational(n::T, d::T) where {T<:Integer} = OurRational{T}(n,d)\nOurRational\n\njulia> OurRational(n::Integer, d::Integer) = OurRational(promote(n,d)...)\nOurRational\n\njulia> OurRational(n::Integer) = OurRational(n,one(n))\nOurRational\n\njulia> ⊘(n::Integer, d::Integer) = OurRational(n,d)\n⊘ (generic function with 1 method)\n\njulia> ⊘(x::OurRational, y::Integer) = x.num ⊘ (x.den*y)\n⊘ (generic function with 2 methods)\n\njulia> ⊘(x::Integer, y::OurRational) = (x*y.den) ⊘ y.num\n⊘ (generic function with 3 methods)\n\njulia> ⊘(x::Complex, y::Real) = complex(real(x) ⊘ y, imag(x) ⊘ y)\n⊘ (generic function with 4 methods)\n\njulia> ⊘(x::Real, y::Complex) = (x*y') ⊘ real(y*y')\n⊘ (generic function with 5 methods)\n\njulia> function ⊘(x::Complex, y::Complex)\n           xy = x*y'\n           yy = real(y*y')\n           complex(real(xy) ⊘ yy, imag(xy) ⊘ yy)\n       end\n⊘ (generic function with 6 methods)\n\nThe first line – struct OurRational{T<:Integer} <: Real – declares that OurRational takes one\ntype parameter of an integer type, and is itself a real type. The field declarations num::T\nand den::T indicate that the data held in a OurRational{T} object are a pair of integers of type\nT, one representing the rational value's numerator and the other representing its denominator.\n\nNow things get interesting. OurRational has a single inner constructor method which checks that\nnum and den aren't both zero and ensures that every rational is constructed in \"lowest\nterms\" with a non-negative denominator. This is accomplished by first flipping the signs of numerator\nand denominator if the denominator is negative. Then, both are divided by their greatest common\ndivisor (gcd always returns a non-negative number, regardless of the sign of its arguments). Because\nthis is the only inner constructor for OurRational, we can be certain that OurRational objects are\nalways constructed in this normalized form.\n\nOurRational also provides several outer constructor methods for convenience. The first is the \"standard\"\ngeneral constructor that infers the type parameter T from the type of the numerator and denominator\nwhen they have the same type. The second applies when the given numerator and denominator values\nhave different types: it promotes them to a common type and then delegates construction to the\nouter constructor for arguments of matching type. The third outer constructor turns integer values\ninto rationals by supplying a value of 1 as the denominator.\n\nFollowing the outer constructor definitions, we defined a number of methods for the ⊘\noperator, which provides a syntax for writing rationals (e.g. 1 ⊘ 2). Julia's Rational\ntype uses the // operator for this purpose. Before these definitions, ⊘\nis a completely undefined operator with only syntax and no meaning. Afterwards, it behaves just\nas described in Rational Numbers – its entire behavior is defined in these few lines.\nNote that the infix use of ⊘ works because Julia has a set of symbols that are recognized to be infix operators.\nThe first and most basic definition just makes a ⊘ b construct a OurRational by applying the\nOurRational constructor to a and b when they are integers. When one of the operands of ⊘\nis already a rational number, we construct a new rational for the resulting ratio slightly differently;\nthis behavior is actually identical to division of a rational with an integer.\nFinally, applying\n⊘ to complex integral values creates an instance of Complex{<:OurRational} – a complex\nnumber whose real and imaginary parts are rationals:\n\njulia> z = (1 + 2im) ⊘ (1 - 2im);\n\njulia> typeof(z)\nComplex{OurRational{Int64}}\n\njulia> typeof(z) <: Complex{<:OurRational}\ntrue\n\nThus, although the ⊘ operator usually returns an instance of OurRational, if either\nof its arguments are complex integers, it will return an instance of Complex{<:OurRational} instead.\nThe interested reader should consider perusing the rest of rational.jl:\nit is short, self-contained, and implements an entire basic Julia type."},{"title":"Outer-only constructors","page":"Constructors","location":"manual/constructors.html#Outer-only-constructors","category":"section","text":"As we have seen, a typical parametric type has inner constructors that are called when type parameters\nare known; e.g. they apply to Point{Int} but not to Point. Optionally, outer constructors\nthat determine type parameters automatically can be added, for example constructing a Point{Int}\nfrom the call Point(1,2). Outer constructors call inner constructors to actually\nmake instances. However, in some cases one would rather not provide inner constructors, so\nthat specific type parameters cannot be requested manually.\n\nFor example, say we define a type that stores a vector along with an accurate representation of\nits sum:\n\njulia> struct SummedArray{T<:Number,S<:Number}\n           data::Vector{T}\n           sum::S\n       end\n\njulia> SummedArray(Int32[1; 2; 3], Int32(6))\nSummedArray{Int32, Int32}(Int32[1, 2, 3], 6)\n\nThe problem is that we want S to be a larger type than T, so that we can sum many elements\nwith less information loss. For example, when T is Int32, we would like S to\nbe Int64. Therefore we want to avoid an interface that allows the user to construct\ninstances of the type SummedArray{Int32,Int32}. One way to do this is to provide a\nconstructor only for SummedArray, but inside the struct definition block to suppress\ngeneration of default constructors:\n\njulia> struct SummedArray{T<:Number,S<:Number}\n           data::Vector{T}\n           sum::S\n           function SummedArray(a::Vector{T}) where T\n               S = widen(T)\n               new{T,S}(a, sum(S, a))\n           end\n       end\n\njulia> SummedArray(Int32[1; 2; 3], Int32(6))\nERROR: MethodError: no method matching SummedArray(::Vector{Int32}, ::Int32)\nThe type `SummedArray` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  SummedArray(::Vector{T}) where T\n   @ Main none:4\n\nStacktrace:\n[...]\n\nThis constructor will be invoked by the syntax SummedArray(a). The syntax new{T,S} allows\nspecifying parameters for the type to be constructed, i.e. this call will return a SummedArray{T,S}.\nnew{T,S} can be used in any constructor definition, but for convenience the parameters\nto new{} are automatically derived from the type being constructed when possible."},{"title":"Constructors are just callable objects","page":"Constructors","location":"manual/constructors.html#Constructors-are-just-callable-objects","category":"section","text":"An object of any type may be made callable by defining a\nmethod. This includes types, i.e., objects of type Type; and constructors may,\nin fact, be viewed as just callable type objects. For example, there are many methods\ndefined on Bool and various supertypes of it:\n\nmethods(Bool)\n\nThe usual constructor syntax is exactly equivalent to the function-like object\nsyntax, so trying to define a method with each syntax will cause the first method\nto be overwritten by the next one:\n\njulia> struct S\n           f::Int\n       end\n\njulia> S() = S(7)\nS\n\njulia> (::Type{S})() = S(8)  # overwrites the previous constructor method\n\njulia> S()\nS(8)"},{"title":"SubArrays","page":"SubArrays","location":"devdocs/subarrays.html#SubArrays","category":"section","text":"Julia's SubArray type is a container encoding a \"view\" of a parent AbstractArray. This page\ndocuments some of the design principles and implementation of SubArrays.\n\nOne of the major design goals is to ensure high performance for views of both IndexLinear and\nIndexCartesian arrays. Furthermore, views of IndexLinear arrays should themselves be\nIndexLinear to the extent that it is possible."},{"title":"Index replacement","page":"SubArrays","location":"devdocs/subarrays.html#Index-replacement","category":"section","text":"Consider making 2d slices of a 3d array:\n\njulia> A = rand(2,3,4);\n\njulia> S1 = view(A, :, 1, 2:3)\n2×2 view(::Array{Float64, 3}, :, 1, 2:3) with eltype Float64:\n 0.839622  0.711389\n 0.967143  0.103929\n\njulia> S2 = view(A, 1, :, 2:3)\n3×2 view(::Array{Float64, 3}, 1, :, 2:3) with eltype Float64:\n 0.839622  0.711389\n 0.789764  0.806704\n 0.566704  0.962715\n\nview drops \"singleton\" dimensions (ones that are specified by an Int), so both S1 and S2\nare two-dimensional SubArrays. Consequently, the natural way to index these is with S1[i,j].\nTo extract the value from the parent array A, the natural approach is to replace S1[i,j]\nwith A[i,1,(2:3)[j]] and S2[i,j] with A[1,i,(2:3)[j]].\n\nThe key feature of the design of SubArrays is that this index replacement can be performed without\nany runtime overhead."},{"title":"SubArray design","page":"SubArrays","location":"devdocs/subarrays.html#SubArray-design","category":"section","text":""},{"title":"Type parameters and fields","page":"SubArrays","location":"devdocs/subarrays.html#Type-parameters-and-fields","category":"section","text":"The strategy adopted is first and foremost expressed in the definition of the type:\n\nstruct SubArray{T,N,P,I,L} <: AbstractArray{T,N}\n    parent::P\n    indices::I\n    offset1::Int       # for linear indexing and pointer, only valid when L==true\n    stride1::Int       # used only for linear indexing\n    ...\nend\n\nSubArray has 5 type parameters. The first two are the standard element type and dimensionality.\n The next is the type of the parent AbstractArray. The most heavily-used is the fourth parameter,\na Tuple of the types of the indices for each dimension. The final one, L, is only provided\nas a convenience for dispatch; it's a boolean that represents whether the index types support\nfast linear indexing. More on that later.\n\nIf in our example above A is a Array{Float64, 3}, our S1 case above would be a\nSubArray{Float64,2,Array{Float64,3},Tuple{Base.Slice{Base.OneTo{Int64}},Int64,UnitRange{Int64}},false}.\nNote in particular the tuple parameter, which stores the types of the indices used to create\nS1. Likewise,\n\njulia> S1.indices\n(Base.Slice(Base.OneTo(2)), 1, 2:3)\n\nStoring these values allows index replacement, and having the types encoded as parameters allows\none to dispatch to efficient algorithms."},{"title":"Index translation","page":"SubArrays","location":"devdocs/subarrays.html#Index-translation","category":"section","text":"Performing index translation requires that you do different things for different concrete SubArray\ntypes. For example, for S1, one needs to apply the i,j indices to the first and third dimensions\nof the parent array, whereas for S2 one needs to apply them to the second and third. The simplest\napproach to indexing would be to do the type-analysis at runtime:\n\nparentindices = Vector{Any}()\nfor thisindex in S.indices\n    ...\n    if isa(thisindex, Int)\n        # Don't consume one of the input indices\n        push!(parentindices, thisindex)\n    elseif isa(thisindex, AbstractVector)\n        # Consume an input index\n        push!(parentindices, thisindex[inputindex[j]])\n        j += 1\n    elseif isa(thisindex, AbstractMatrix)\n        # Consume two input indices\n        push!(parentindices, thisindex[inputindex[j], inputindex[j+1]])\n        j += 2\n    elseif ...\nend\nS.parent[parentindices...]\n\nUnfortunately, this would be disastrous in terms of performance: each element access would allocate\nmemory, and involves the running of a lot of poorly-typed code.\n\nThe better approach is to dispatch to specific methods to handle each type of stored index. That's\nwhat reindex does: it dispatches on the type of the first stored index and consumes the appropriate\nnumber of input indices, and then it recurses on the remaining indices. In the case of S1, this\nexpands to\n\nBase.reindex(S1, S1.indices, (i, j)) == (i, S1.indices[2], S1.indices[3][j])\n\nfor any pair of indices (i,j) (except CartesianIndexs and arrays thereof, see below).\n\nThis is the core of a SubArray; indexing methods depend upon reindex to do this index translation.\nSometimes, though, we can avoid the indirection and make it even faster."},{"title":"Linear indexing","page":"SubArrays","location":"devdocs/subarrays.html#Linear-indexing","category":"section","text":"Linear indexing can be implemented efficiently when the entire array has a single stride that\nseparates successive elements, starting from some offset. This means that we can pre-compute these\nvalues and represent linear indexing simply as an addition and multiplication, avoiding the indirection\nof reindex and (more importantly) the slow computation of the cartesian coordinates entirely.\n\nFor SubArray types, the availability of efficient linear indexing is based purely on the types\nof the indices, and does not depend on values like the size of the parent array. You can ask whether\na given set of indices supports fast linear indexing with the internal Base.viewindexing function:\n\njulia> Base.viewindexing(S1.indices)\nIndexCartesian()\n\njulia> Base.viewindexing(S2.indices)\nIndexLinear()\n\nThis is computed during construction of the SubArray and stored in the L type parameter as\na boolean that encodes fast linear indexing support. While not strictly necessary, it means that\nwe can define dispatch directly on SubArray{T,N,A,I,true} without any intermediaries.\n\nSince this computation doesn't depend on runtime values, it can miss some cases in which the stride\nhappens to be uniform:\n\njulia> A = reshape(1:4*2, 4, 2)\n4×2 reshape(::UnitRange{Int64}, 4, 2) with eltype Int64:\n 1  5\n 2  6\n 3  7\n 4  8\n\njulia> diff(A[2:2:4,:][:])\n3-element Vector{Int64}:\n 2\n 2\n 2\n\nA view constructed as view(A, 2:2:4, :) happens to have uniform stride, and therefore linear\nindexing indeed could be performed efficiently. However, success in this case depends on the\nsize of the array: if the first dimension instead were odd,\n\njulia> A = reshape(1:5*2, 5, 2)\n5×2 reshape(::UnitRange{Int64}, 5, 2) with eltype Int64:\n 1   6\n 2   7\n 3   8\n 4   9\n 5  10\n\njulia> diff(A[2:2:4,:][:])\n3-element Vector{Int64}:\n 2\n 3\n 2\n\nthen A[2:2:4,:] does not have uniform stride, so we cannot guarantee efficient linear indexing.\n Since we have to base this decision based purely on types encoded in the parameters of the SubArray,\nS = view(A, 2:2:4, :) cannot implement efficient linear indexing."},{"title":"A few details","page":"SubArrays","location":"devdocs/subarrays.html#A-few-details","category":"section","text":"Note that the Base.reindex function is agnostic to the types of the input indices; it simply\ndetermines how and where the stored indices should be reindexed. It not only supports integer\nindices, but it supports non-scalar indexing, too. This means that views of views don't need two\nlevels of indirection; they can simply re-compute the indices into the original parent array!\nHopefully by now it's fairly clear that supporting slices means that the dimensionality, given\nby the parameter N, is not necessarily equal to the dimensionality of the parent array or the\nlength of the indices tuple. Neither do user-supplied indices necessarily line up with entries\nin the indices tuple (e.g., the second user-supplied index might correspond to the third dimension\nof the parent array, and the third element in the indices tuple).\nWhat might be less obvious is that the dimensionality of the stored parent array must be equal\nto the number of effective indices in the indices tuple. Some examples:\nA = reshape(1:35, 5, 7) # A 2d parent Array\nS = view(A, 2:7)         # A 1d view created by linear indexing\nS = view(A, :, :, 1:1)   # Appending extra indices is supported\nNaively, you'd think you could just set S.parent = A and S.indices = (:,:,1:1), but supporting\nthis dramatically complicates the reindexing process, especially for views of views. Not only\ndo you need to dispatch on the types of the stored indices, but you need to examine whether a\ngiven index is the final one and \"merge\" any remaining stored indices together. This is not an\neasy task, and even worse: it's slow since it implicitly depends upon linear indexing.\nFortunately, this is precisely the computation that ReshapedArray performs, and it does so linearly\nif possible. Consequently, view ensures that the parent array is the appropriate dimensionality\nfor the given indices by reshaping it if needed. The inner SubArray constructor ensures that\nthis invariant is satisfied.\nCartesianIndex and arrays thereof throw a nasty wrench into the reindex scheme. Recall that\nreindex simply dispatches on the type of the stored indices in order to determine how many passed\nindices should be used and where they should go. But with CartesianIndex, there's no longer\na one-to-one correspondence between the number of passed arguments and the number of dimensions\nthat they index into. If we return to the above example of Base.reindex(S1, S1.indices, (i, j)),\nyou can see that the expansion is incorrect for i, j = CartesianIndex(), CartesianIndex(2,1).\nIt should skip the CartesianIndex() entirely and return:\n(CartesianIndex(2,1)[1], S1.indices[2], S1.indices[3][CartesianIndex(2,1)[2]])\nInstead, though, we get:\n(CartesianIndex(), S1.indices[2], S1.indices[3][CartesianIndex(2,1)])\nDoing this correctly would require combined dispatch on both the stored and passed indices across\nall combinations of dimensionalities in an intractable manner. As such, reindex must never be\ncalled with CartesianIndex indices. Fortunately, the scalar case is easily handled by first\nflattening the CartesianIndex arguments to plain integers. Arrays of CartesianIndex, however,\ncannot be split apart into orthogonal pieces so easily. Before attempting to use reindex, view\nmust ensure that there are no arrays of CartesianIndex in the argument list. If there are, it\ncan simply \"punt\" by avoiding the reindex calculation entirely, constructing a nested SubArray\nwith two levels of indirection instead."},{"title":"High-level Overview of the Native-Code Generation Process","page":"High-level Overview of the Native-Code Generation Process","location":"devdocs/compiler.html#High-level-Overview-of-the-Native-Code-Generation-Process","category":"section","text":""},{"title":"Representation of Pointers","page":"High-level Overview of the Native-Code Generation Process","location":"devdocs/compiler.html#Representation-of-Pointers","category":"section","text":"When emitting code to an object file, pointers will be emitted as relocations.\nThe deserialization code will ensure any object that pointed to one of these constants\ngets recreated and contains the right runtime pointer.\n\nOtherwise, they will be emitted as literal constants.\n\nTo emit one of these objects, call literal_pointer_val.\nIt'll handle tracking the Julia value and the LLVM global,\nensuring they are valid both for the current runtime and after deserialization.\n\nWhen emitted into the object file, these globals are stored as references\nin a large gvals table. This allows the deserializer to reference them by index,\nand implement a custom manual mechanism similar to a Global Offset Table (GOT) to restore them.\n\nFunction pointers are handled similarly.\nThey are stored as values in a large fvals table.\nLike globals, this allows the deserializer to reference them by index.\n\nNote that extern functions are handled separately,\nwith names, via the usual symbol resolution mechanism in the linker.\n\nNote too that ccall functions are also handled separately,\nvia a manual GOT and Procedure Linkage Table (PLT)."},{"title":"Representation of Intermediate Values","page":"High-level Overview of the Native-Code Generation Process","location":"devdocs/compiler.html#Representation-of-Intermediate-Values","category":"section","text":"Values are passed around in a jl_cgval_t struct.\nThis represents an R-value, and includes enough information to\ndetermine how to assign or pass it somewhere.\n\nThey are created via one of the helper constructors, usually:\nmark_julia_type (for immediate values) and mark_julia_slot (for pointers to values)."},{"title":"Union representation","page":"High-level Overview of the Native-Code Generation Process","location":"devdocs/compiler.html#Union-representation","category":"section","text":"Inferred union types may be stack allocated via a tagged type representation.\n\nThe primitive routines that need to be able to handle tagged unions are:\n\nmark-type\nload-local\nstore-local\nisa\nis\nemit_typeof\nemit_sizeof\nboxed\nunbox\nspecialized cc-ret\n\nEverything else should be possible to handle in inference by using these\nprimitives to implement union-splitting.\n\nThe representation of the tagged-union is as a pair\nof < void* union, byte selector >.\nThe selector is fixed-size as byte & 0x7f,\nand will union-tag the first 126 isbits.\nIt records the one-based depth-first count into the type-union of the\nisbits objects inside. An index of zero indicates that the union* is\nactually a tagged heap-allocated jl_value_t*,\nand needs to be treated as normal for a boxed object rather than as a\ntagged union.\n\nThe high bit of the selector (byte & 0x80) can be tested to determine if the\nvoid* is actually a heap-allocated (jl_value_t*) box,\nthus avoiding the cost of re-allocating a box,\nwhile maintaining the ability to efficiently handle union-splitting based on the low bits.\n\nIt is guaranteed that byte & 0x7f is an exact test for the type,\nif the value can be represented by a tag – it will never be marked byte = 0x80.\nIt is not necessary to also test the type-tag when testing isa.\n\nThe union* memory region may be allocated at any size.\nThe only constraint is that it is big enough to contain the data\ncurrently specified by selector.\nIt might not be big enough to contain the union of all types that\ncould be stored there according to the associated Union type field.\nUse appropriate care when copying."},{"title":"Specialized Calling Convention Signature Representation","page":"High-level Overview of the Native-Code Generation Process","location":"devdocs/compiler.html#Specialized-Calling-Convention-Signature-Representation","category":"section","text":"A jl_returninfo_t object describes the specialized calling convention details of any\ncallable. It can be generated from any (specTypes, rettype) pair, such as a CodeInstance, or\nother place they are declared. This is the expected calling convention for specptr, but\nother data may be stored there. Only if the function pointer stored there has the\nexpected specialized calling convention will the corresponding flag be set in specsigflags\nto indicate it is useable.\n\nIf any of the arguments or return type of a method can be represented unboxed, and none are\nunable to be represented unboxed (such as an unbounded vararg), it will be given an\noptimized calling convention signature based on the specTypes and rettype values.\n\nThe general principles are that:\n\nPrimitive types get passed in int/float registers.\nTuples of VecElement types get passed in vector registers.\nStructs get passed on the stack.\nReturn values are handled similarly to arguments,\nwith a size-cutoff at which they will instead be returned via a hidden sret argument.\n\nThe total logic for this is implemented by get_specsig_function and deserves_sret.\n\nAdditionally, if the return type is a union, it may be returned as a pair of values (a pointer and a tag).\nIf the union values can be stack-allocated, then sufficient space to store them will also be passed as a hidden first argument.\nIf the struct to return needs gc roots, space for those will be passed as a hidden second argument.\nIt is up to the callee whether the returned pointer will point to this space, a boxed object, or even other constant memory."},{"title":"Code changes","page":"Code changes","location":"devdocs/contributing/code-changes.html#Code-changes","category":"section","text":""},{"title":"Contributing to core functionality or base libraries","page":"Code changes","location":"devdocs/contributing/code-changes.html#Contributing-to-core-functionality-or-base-libraries","category":"section","text":"By contributing code to Julia, you are agreeing to release it under the MIT License.\n\nThe Julia community uses GitHub issues to track and discuss problems, feature requests, and pull requests (PR).\n\nIssues and pull requests should have self explanatory titles such that they can be understood from the list of PRs and Issues.\ni.e. Add {feature} and Fix {bug} are good, Fix #12345. Corrects the bug. is bad.\n\nYou can make pull requests for incomplete features to get code review. The convention is to open these as draft PRs and prefix\nthe pull request title with \"WIP:\" for Work In Progress, or \"RFC:\" for Request for Comments when work is completed and ready\nfor merging. This will prevent accidental merging of work that is in progress.\n\nNote: These instructions are for adding to or improving functionality in the base library. Before getting started, it can be helpful to discuss the proposed changes or additions on the Julia Discourse forum or in a GitHub issue—it's possible your proposed change belongs in a package rather than the core language. Also, keep in mind that changing stuff in the base can potentially break a lot of things. Finally, because of the time required to build Julia, note that it's usually faster to develop your code in stand-alone files, get it working, and then migrate it into the base libraries.\n\nAdd new code to Julia's base libraries as follows (this is the \"basic\" approach; see a more efficient approach in the next section):\n\nEdit the appropriate file in the base/ directory, or add new files if necessary. Create tests for your functionality and add them to files in the test/ directory. If you're editing C or Scheme code, most likely it lives in src/ or one of its subdirectories, although some aspects of Julia's REPL initialization live in cli/.\nAdd any new files to sysimg.jl in order to build them into the Julia system image.\nAdd any necessary export symbols in exports.jl.\nInclude your tests in test/Makefile and test/choosetests.jl.\n\nBuild as usual, and do make clean testall to test your contribution. If your contribution includes changes to Makefiles or external dependencies, make sure you can build Julia from a clean tree using git clean -fdx or equivalent (be careful – this command will delete any files lying around that aren't checked into git)."},{"title":"Running specific tests","page":"Code changes","location":"devdocs/contributing/code-changes.html#Running-specific-tests","category":"section","text":"There are make targets for running specific tests:\n\nmake test-bitarray\n\nYou can also use the runtests.jl script, e.g. to run test/bitarray.jl and test/math.jl:\n\n./usr/bin/julia test/runtests.jl bitarray math"},{"title":"Modifying base more efficiently with Revise.jl","page":"Code changes","location":"devdocs/contributing/code-changes.html#Modifying-base-more-efficiently-with-Revise.jl","category":"section","text":"Revise is a package that\ntracks changes in source files and automatically updates function\ndefinitions in your running Julia session. Using it, you can make\nextensive changes to Base without needing to rebuild in order to test\nyour changes.\n\nHere is the standard procedure:\n\nIf you are planning changes to any types or macros, make those\nchanges and build julia using make. (This is\nnecessary because Revise cannot handle changes to type\ndefinitions or macros.) Unless it's\nrequired to get Julia to build, you do not have to add any\nfunctionality based on the new types, just the type definitions\nthemselves.\nStart a Julia REPL session. Then issue the following commands:\n\nusing Revise    # if you aren't launching it in your `.julia/config/startup.jl`\nRevise.track(Base)\n\nEdit files in base/, save your edits, and test the\nfunctionality.\n\nIf you need to restart your Julia session, just start at step 2 above.\nRevise.track(Base) will note any changes from when Julia was last\nbuilt and incorporate them automatically. You only need to rebuild\nJulia if you made code-changes that Revise cannot handle.\n\nFor convenience, there are also test-revise-* targets for every [test-*\ntarget](https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md#running-specific-tests) that use Revise to load any modifications to Base into the current\nsystem image before running the corresponding test. This can be useful as a shortcut\non the command line (since tests aren't always designed to be run outside the\nruntest harness)."},{"title":"Contributing to the standard library","page":"Code changes","location":"devdocs/contributing/code-changes.html#Contributing-to-the-standard-library","category":"section","text":"The standard library (stdlib) packages are baked into the Julia system image.\nWhen running the ordinary test workflow on the stdlib packages, the system image\nversion overrides the version you are developing.\nTo test stdlib packages, you can do the following steps:\n\nEdit the UUID field of the Project.toml in the stdlib package\nChange the current directory to the directory of the stdlib you are developing\nStart julia with julia --project=.\nYou can now test the package by running pkg> test in Pkg mode.\n\nBecause you changed the UUID, the package manager treats the stdlib package as\ndifferent from the one in the system image, and the system image version will\nnot override the package.\n\nBe sure to change the UUID value back before making the pull request."},{"title":"News-worthy changes","page":"Code changes","location":"devdocs/contributing/code-changes.html#News-worthy-changes","category":"section","text":"For new functionality and other substantial changes, add a brief summary to NEWS.md. The news item should cross reference the pull request (PR) parenthetically, in the form ([#pr]). To add the PR reference number, first create the PR, then push an additional commit updating NEWS.md with the PR reference number. We periodically run ./julia doc/NEWS-update.jl from the julia directory to update the cross-reference links, but this should not be done in a typical PR in order to avoid conflicting commits."},{"title":"Annotations for new features, deprecations and behavior changes","page":"Code changes","location":"devdocs/contributing/code-changes.html#Annotations-for-new-features,-deprecations-and-behavior-changes","category":"section","text":"API additions and deprecations, and minor behavior changes are allowed in minor version releases.\nFor documented features that are part of the public API, a compatibility note should be added into\nthe manual or the docstring. It should state the Julia minor version that changed the behavior\nand have a brief message describing the change.\n\nAt the moment, this should always be done with the following compat admonition\n(so that it would be possible to programmatically find the annotations in the future):\n\n!!! compat \"Julia 1.X\"       This method was added in Julia 1.X."},{"title":"Mathematical Operations and Elementary Functions","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Mathematical-Operations-and-Elementary-Functions","category":"section","text":"Julia provides a complete collection of basic arithmetic and bitwise operators across all of its\nnumeric primitive types, as well as providing portable, efficient implementations of a comprehensive\ncollection of standard mathematical functions."},{"title":"Arithmetic Operators","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Arithmetic-Operators","category":"section","text":"The following arithmetic operators\nare supported on all primitive numeric types:\n\nExpression Name Description\n+x unary plus the identity operation\n-x unary minus maps values to their additive inverses\nx + y binary plus performs addition\nx - y binary minus performs subtraction\nx * y times performs multiplication\nx / y divide performs division\nx ÷ y integer divide x / y, truncated to an integer\nx \\ y inverse divide equivalent to y / x\nx ^ y power raises x to the yth power\nx % y remainder equivalent to rem(x, y)\n\nA numeric literal placed directly before an identifier or parentheses, e.g. 2x or 2(x + y), is treated as a multiplication, except with higher precedence than other binary operations. See Numeric Literal Coefficients for details.\n\nJulia's promotion system makes arithmetic operations on mixtures of argument types \"just work\"\nnaturally and automatically. See Conversion and Promotion for details of the promotion\nsystem.\n\nThe ÷ sign can be conveniently typed by writing \\div<tab> to the REPL or Julia IDE. See the manual section on Unicode input for more information.\n\nHere are some simple examples using arithmetic operators:\n\njulia> 1 + 2 + 3\n6\n\njulia> 1 - 2\n-1\n\njulia> 3*2/12\n0.5\n\n(By convention, we tend to space operators more tightly if they get applied before other nearby\noperators. For instance, we would generally write -x + 2 to reflect that first x gets negated,\nand then 2 is added to that result.)"},{"title":"Boolean Operators","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Boolean-Operators","category":"section","text":"The following Boolean operators are supported on Bool types:\n\nExpression Name\n!x negation\nx && y short-circuiting and\nx || y short-circuiting or\n\nNegation changes true to false and vice versa. The short-circuiting operations are explained on the linked page."},{"title":"Arithmetic operations with Bool values","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Arithmetic-operations-with-Bool-values","category":"section","text":"Note that Bool is an integer type, such that false is numerically equal to 0 and true is numerically equal to 1. All the usual promotion rules and numeric operators are also defined on it, with a special behavior of arithmetic (non-Boolean) operations when all the arguments are Bool: in those cases, the arguments are promoted to Int instead of keeping their type. Compare e.g. the following equivalent operations with Bool and with a different numeric type (UInt8):\n\njulia> true - true\n0\n\njulia> 0x01 - 0x01\n0x00\n\nAlso, when used in multiplication, false acts as a strong zero:\n\njulia> NaN * false\n0.0\n\njulia> false * Inf\n0.0\n\nThis is useful for preventing the propagation of NaN values in quantities that are known to be zero. See Knuth (1992) for motivation."},{"title":"Bitwise Operators","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Bitwise-Operators","category":"section","text":"The following bitwise operators\nare supported on all primitive integer types:\n\nExpression Name\n~x bitwise not\nx & y bitwise and\nx | y bitwise or\nx ⊻ y bitwise xor (exclusive or)\nx ⊼ y bitwise nand (not and)\nx ⊽ y bitwise nor (not or)\nx >>> y logical shift right\nx >> y arithmetic shift right\nx << y logical/arithmetic shift left\n\nHere are some examples with bitwise operators:\n\njulia> ~123\n-124\n\njulia> 123 & 234\n106\n\njulia> 123 | 234\n251\n\njulia> 123 ⊻ 234\n145\n\njulia> xor(123, 234)\n145\n\njulia> nand(123, 123)\n-124\n\njulia> 123 ⊼ 123\n-124\n\njulia> nor(123, 124)\n-128\n\njulia> 123 ⊽ 124\n-128\n\njulia> ~UInt32(123)\n0xffffff84\n\njulia> ~UInt8(123)\n0x84"},{"title":"Updating operators","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Updating-operators","category":"section","text":"Every binary arithmetic and bitwise operator also has an updating version that assigns the result\nof the operation back into its left operand. The updating version of the binary operator is formed\nby placing a = immediately after the operator. For example, writing x += 3 is equivalent to\nwriting x = x + 3:\n\njulia> x = 1\n1\n\njulia> x += 3\n4\n\njulia> x\n4\n\nThe updating versions of all the binary arithmetic and bitwise operators are:\n\n+=  -=  *=  /=  \\=  ÷=  %=  ^=  &=  |=  ⊻=  >>>=  >>=  <<=\n\nnote: Note\nAn updating operator rebinds the variable on the left-hand side. As a result, the type of the\nvariable may change.julia> x = 0x01; typeof(x)\nUInt8\n\njulia> x *= 2 # Same as x = x * 2\n2\n\njulia> typeof(x)\nInt64"},{"title":"Vectorized \"dot\" operators","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#man-dot-operators","category":"section","text":"For every binary operation like ^, there is a corresponding\n\"dot\" operation .^ that is automatically defined\nto perform ^ element-by-element on arrays. For example,\n[1, 2, 3] ^ 3 is not defined, since there is no standard\nmathematical meaning to \"cubing\" a (non-square) array, but\n[1, 2, 3] .^ 3 is defined as computing the elementwise\n(or \"vectorized\") result [1^3, 2^3, 3^3]. Similarly for unary\noperators like ! or √, there is a corresponding .√ that\napplies the operator elementwise.\n\njulia> [1, 2, 3] .^ 3\n3-element Vector{Int64}:\n  1\n  8\n 27\n\nMore specifically, a .^ b is parsed as the \"dot\" call\n(^).(a,b), which performs a broadcast operation:\nit can combine arrays and scalars, arrays of the same size (performing\nthe operation elementwise), and even arrays of different shapes (e.g.\ncombining row and column vectors to produce a matrix). Moreover, like\nall vectorized \"dot calls,\" these \"dot operators\" are\nfusing. For example, if you compute 2 .* A.^2 .+ sin.(A) (or\nequivalently @. 2A^2 + sin(A), using the @. macro) for\nan array A, it performs a single loop over A, computing 2a^2 + sin(a)\nfor each element a of A. In particular, nested dot calls like f.(g.(x))\nare fused, and \"adjacent\" binary operators like x .+ 3 .* x.^2 are\nequivalent to nested dot calls (+).(x, (*).(3, (^).(x, 2))).\n\nFurthermore, \"dotted\" updating operators like a .+= b (or @. a += b) are parsed\nas a .= a .+ b, where .= is a fused in-place assignment operation\n(see the dot syntax documentation).\n\nNote the dot syntax is also applicable to user-defined operators.\nFor example, if you define ⊗(A, B) = kron(A, B) to give a convenient\ninfix syntax A ⊗ B for Kronecker products (kron), then\n[A, B] .⊗ [C, D] will compute [A⊗C, B⊗D] with no additional coding.\n\nCombining dot operators with numeric literals can be ambiguous.\nFor example, it is not clear whether 1.+x means 1. + x or 1 .+ x.\nTherefore this syntax is disallowed, and spaces must be used around\nthe operator in such cases."},{"title":"Numeric Comparisons","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Numeric-Comparisons","category":"section","text":"Standard comparison operations are defined for all the primitive numeric types:\n\nOperator Name\n== equality\n!=, ≠ inequality\n< less than\n<=, ≤ less than or equal to\n> greater than\n>=, ≥ greater than or equal to\n\nHere are some simple examples:\n\njulia> 1 == 1\ntrue\n\njulia> 1 == 2\nfalse\n\njulia> 1 != 2\ntrue\n\njulia> 1 == 1.0\ntrue\n\njulia> 1 < 2\ntrue\n\njulia> 1.0 > 3\nfalse\n\njulia> 1 >= 1.0\ntrue\n\njulia> -1 <= 1\ntrue\n\njulia> -1 <= -1\ntrue\n\njulia> -1 <= -2\nfalse\n\njulia> 3 < -0.5\nfalse\n\nIntegers are compared in the standard manner – by comparison of bits. Floating-point numbers\nare compared according to the IEEE 754 standard:\n\nFinite numbers are ordered in the usual manner.\nPositive zero is equal but not greater than negative zero.\nInf is equal to itself and greater than everything else except NaN.\n-Inf is equal to itself and less than everything else except NaN.\nNaN is not equal to, not less than, and not greater than anything, including itself.\n\nThe last point is potentially surprising and thus worth noting:\n\njulia> NaN == NaN\nfalse\n\njulia> NaN != NaN\ntrue\n\njulia> NaN < NaN\nfalse\n\njulia> NaN > NaN\nfalse\n\nand can cause headaches when working with arrays:\n\njulia> [1 NaN] == [1 NaN]\nfalse\n\nJulia provides additional functions to test numbers for special values, which can be useful in\nsituations like hash key comparisons:\n\nFunction Tests if\nisequal(x, y) x and y are identical\nisfinite(x) x is a finite number\nisinf(x) x is infinite\nisnan(x) x is not a number\n\nisequal considers NaNs equal to each other:\n\njulia> isequal(NaN, NaN)\ntrue\n\njulia> isequal([1 NaN], [1 NaN])\ntrue\n\njulia> isequal(NaN, NaN32)\ntrue\n\nisequal can also be used to distinguish signed zeros:\n\njulia> -0.0 == 0.0\ntrue\n\njulia> isequal(-0.0, 0.0)\nfalse\n\nMixed-type comparisons between signed integers, unsigned integers, and floats can be tricky. A\ngreat deal of care has been taken to ensure that Julia does them correctly.\n\nFor other types, isequal defaults to calling ==, so if you want to define\nequality for your own types then you only need to add a == method. If you define\nyour own equality function, you should probably define a corresponding hash method\nto ensure that isequal(x,y) implies hash(x) == hash(y)."},{"title":"Chaining comparisons","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Chaining-comparisons","category":"section","text":"Unlike most languages, with the notable exception of Python,\ncomparisons can be arbitrarily chained:\n\njulia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5\ntrue\n\nChaining comparisons is often quite convenient in numerical code. Chained comparisons use the\n&& operator for scalar comparisons, and the & operator for elementwise comparisons,\nwhich allows them to work on arrays. For example, 0 .< A .< 1 gives a boolean array whose entries\nare true where the corresponding elements of A are between 0 and 1.\n\nNote the evaluation behavior of chained comparisons:\n\njulia> v(x) = (println(x); x)\nv (generic function with 1 method)\n\njulia> v(1) < v(2) <= v(3)\n2\n1\n3\ntrue\n\njulia> v(1) > v(2) <= v(3)\n2\n1\nfalse\n\nThe middle expression is only evaluated once, rather than twice as it would be if the expression\nwere written as v(1) < v(2) && v(2) <= v(3). However, the order of evaluations in a chained\ncomparison is undefined. It is strongly recommended not to use expressions with side effects (such\nas printing) in chained comparisons. If side effects are required, the short-circuit && operator\nshould be used explicitly (see Short-Circuit Evaluation)."},{"title":"Elementary Functions","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Elementary-Functions","category":"section","text":"Julia provides a comprehensive collection of mathematical functions and operators. These mathematical\noperations are defined over as broad a class of numerical values as permit sensible definitions,\nincluding integers, floating-point numbers, rationals, and complex numbers,\nwherever such definitions make sense.\n\nMoreover, these functions (like any Julia function) can be applied in \"vectorized\" fashion to\narrays and other collections with the dot syntax f.(A),\ne.g. sin.(A) will compute the sine of each element of an array A."},{"title":"Operator Precedence and Associativity","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Operator-Precedence-and-Associativity","category":"section","text":"Julia applies the following order and associativity of operations, from highest precedence to lowest:\n\nCategory Operators Associativity\nSyntax . followed by :: Left\nExponentiation ^ Right\nUnary + - ! ~ ¬ √ ∛ ∜ ⋆ ± ∓ <: >: Right[1]\nBitshifts << >> >>> Left\nFractions // Left\nMultiplication * / % & \\ ÷ Left[2]\nAddition + - | ⊻ Left[2]\nSyntax : .. Left\nSyntax |> Left\nSyntax <| Right\nComparisons > < >= <= == === != !== <: Non-associative\nControl flow && followed by || followed by ? Right\nPair => Right\nAssignments = += -= *= /= //= \\= ^= ÷= %= |= &= ⊻= <<= >>= >>>= Right\n\n[1]: The unary operators + and - require explicit parentheses around their argument to disambiguate them from the operator ++, etc. Other compositions of unary operators are parsed with right-associativity, e. g., √√-a as √(√(-a)).\n\n[2]: The operators +, ++ and * are non-associative. a + b + c is parsed as +(a, b, c) not +(+(a, b), c). However, the fallback methods for +(a, b, c, d...) and *(a, b, c, d...) both default to left-associative evaluation.\n\nFor a complete list of every Julia operator's precedence, see the top of this file:\nsrc/julia-parser.scm. Note that some of the operators there are not defined\nin the Base module but may be given definitions by standard libraries, packages or user code.\n\nYou can also find the numerical precedence for any given operator via the built-in function Base.operator_precedence, where higher numbers take precedence:\n\njulia> Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)\n(11, 12, 17)\n\njulia> Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)\n(0, 1, 1)\n\nA symbol representing the operator associativity can also be found by calling the built-in function Base.operator_associativity:\n\njulia> Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)\n(:left, :none, :right)\n\njulia> Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)\n(:left, :none, :right)\n\nNote that symbols such as :sin return precedence 0. This value represents invalid operators and not\noperators of lowest precedence. Similarly, such operators are assigned associativity :none.\n\nNumeric literal coefficients, e.g. 2x, are treated as multiplications with higher precedence than any other binary operation, with the exception of ^ where they have higher precedence only as the exponent.\n\njulia> x = 3; 2x^2\n18\n\njulia> x = 3; 2^2x\n64\n\nJuxtaposition parses like a unary operator, which has the same natural asymmetry around exponents: -x^y and 2x^y parse as -(x^y) and 2(x^y) whereas x^-y and x^2y parse as x^(-y) and x^(2y)."},{"title":"Numerical Conversions","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Numerical-Conversions","category":"section","text":"Julia supports three forms of numerical conversion, which differ in their handling of inexact\nconversions.\n\nThe notation T(x) or convert(T, x) converts x to a value of type T.\nIf T is a floating-point type, the result is the nearest representable value, which could be\npositive or negative infinity.\nIf T is an integer type, an InexactError is raised if x is not representable by T.\nx % T converts an integer x to a value of integer type T congruent to x modulo 2^n,\nwhere n is the number of bits in T. In other words, the binary representation is truncated\nto fit.\nThe Rounding functions take a type T as an optional argument. For example, round(Int,x)\nis a shorthand for Int(round(x)).\n\nThe following examples show the different forms.\n\njulia> Int8(127)\n127\n\njulia> Int8(128)\nERROR: InexactError: trunc(Int8, 128)\nStacktrace:\n[...]\n\njulia> Int8(127.0)\n127\n\njulia> Int8(3.14)\nERROR: InexactError: Int8(3.14)\nStacktrace:\n[...]\n\njulia> Int8(128.0)\nERROR: InexactError: Int8(128.0)\nStacktrace:\n[...]\n\njulia> 127 % Int8\n127\n\njulia> 128 % Int8\n-128\n\njulia> round(Int8,127.4)\n127\n\njulia> round(Int8,127.6)\nERROR: InexactError: Int8(128.0)\nStacktrace:\n[...]\n\nSee Conversion and Promotion for how to define your own conversions and promotions."},{"title":"Rounding functions","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Rounding-functions","category":"section","text":"Function Description Return type\nround(x) round x to the nearest integer typeof(x)\nround(T, x) round x to the nearest integer T\nfloor(x) round x towards -Inf typeof(x)\nfloor(T, x) round x towards -Inf T\nceil(x) round x towards +Inf typeof(x)\nceil(T, x) round x towards +Inf T\ntrunc(x) round x towards zero typeof(x)\ntrunc(T, x) round x towards zero T"},{"title":"Division functions","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Division-functions","category":"section","text":"Function Description\ndiv(x, y), x÷y truncated division; quotient rounded towards zero\nfld(x, y) floored division; quotient rounded towards -Inf\ncld(x, y) ceiling division; quotient rounded towards +Inf\nrem(x, y), x%y remainder; satisfies x == div(x, y)*y + rem(x, y); sign matches x\nmod(x, y) modulus; satisfies x == fld(x, y)*y + mod(x, y); sign matches y\nmod1(x, y) mod with offset 1; returns r∈(0, y] for y>0 or r∈[y, 0) for y<0, where mod(r, y) == mod(x, y)\nmod2pi(x) modulus with respect to 2pi;  0 <= mod2pi(x) < 2pi\ndivrem(x, y) returns (div(x, y),rem(x, y))\nfldmod(x, y) returns (fld(x, y), mod(x, y))\ngcd(x, y...) greatest positive common divisor of x, y,...\nlcm(x, y...) least positive common multiple of x, y,..."},{"title":"Sign and absolute value functions","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Sign-and-absolute-value-functions","category":"section","text":"Function Description\nabs(x) a positive value with the magnitude of x\nabs2(x) the squared magnitude of x\nsign(x) indicates the sign of x, returning -1, 0, or +1\nsignbit(x) indicates whether the sign bit is on (true) or off (false)\ncopysign(x, y) a value with the magnitude of x and the sign of y\nflipsign(x, y) a value with the magnitude of x and the sign of x*y"},{"title":"Powers, logs and roots","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Powers,-logs-and-roots","category":"section","text":"Function Description\nsqrt(x), √x square root of x\ncbrt(x), ∛x cube root of x\nfourthroot(x), ∜x fourth root of x\nhypot(x, y) hypotenuse of right-angled triangle with other sides of length x and y\nexp(x) natural exponential function at x\nexpm1(x) accurate exp(x) - 1 for x near zero\nldexp(x, n) x * 2^n computed efficiently for integer values of n\nlog(x) natural logarithm of x\nlog(b, x) base b logarithm of x\nlog2(x) base 2 logarithm of x\nlog10(x) base 10 logarithm of x\nlog1p(x) accurate log(1 + x) for x near zero\nexponent(x) binary exponent of x\nsignificand(x) binary significand (a.k.a. mantissa) of a floating-point number x\n\nFor an overview of why functions like hypot, expm1, and log1p\nare necessary and useful, see John D. Cook's excellent pair of blog posts on the subject: expm1, log1p, erfc,\nand hypot."},{"title":"Trigonometric and hyperbolic functions","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Trigonometric-and-hyperbolic-functions","category":"section","text":"All the standard trigonometric and hyperbolic functions are also defined:\n\nsin    cos    tan    cot    sec    csc\nsinh   cosh   tanh   coth   sech   csch\nasin   acos   atan   acot   asec   acsc\nasinh  acosh  atanh  acoth  asech  acsch\nsinc   cosc\n\nThese are all single-argument functions, with atan also accepting two arguments\ncorresponding to a traditional atan2 function.\n\nAdditionally, sinpi(x) and cospi(x) are provided for more accurate computations\nof sin(pi * x) and cos(pi * x) respectively.\n\nIn order to compute trigonometric functions with degrees instead of radians, suffix the function\nwith d. For example, sind(x) computes the sine of x where x is specified in degrees.\nThe complete list of trigonometric functions with degree variants is:\n\nsind   cosd   tand   cotd   secd   cscd\nasind  acosd  atand  acotd  asecd  acscd"},{"title":"Special functions","page":"Mathematical Operations and Elementary Functions","location":"manual/mathematical-operations.html#Special-functions","category":"section","text":"Many other special mathematical functions are provided by the package\nSpecialFunctions.jl."},{"title":"Markdown","page":"Markdown","location":"stdlib/Markdown.html#markdown_stdlib","category":"section","text":"This section describes Julia's markdown syntax, which is enabled by the\nMarkdown standard library. The following Markdown elements are supported:"},{"title":"Inline elements","page":"Markdown","location":"stdlib/Markdown.html#Inline-elements","category":"section","text":"Here \"inline\" refers to elements that can be found within blocks of text, i.e. paragraphs. These\ninclude the following elements."},{"title":"Bold","page":"Markdown","location":"stdlib/Markdown.html#Bold","category":"section","text":"Surround words with two asterisks, **, to display the enclosed text in boldface.\n\nA paragraph containing a **bold** word."},{"title":"Italics","page":"Markdown","location":"stdlib/Markdown.html#Italics","category":"section","text":"Surround words with one asterisk, *, to display the enclosed text in italics.\n\nA paragraph containing an *italicized* word."},{"title":"Strikethrough","page":"Markdown","location":"stdlib/Markdown.html#Strikethrough","category":"section","text":"Surround words with one or two tildes, ~ or~~, to display the enclosed text with a strikethrough, or a line through it.\n\nA paragraph containing a ~~struck~~ word."},{"title":"Literals","page":"Markdown","location":"stdlib/Markdown.html#Literals","category":"section","text":"Surround text that should be displayed exactly as written with single backticks, ` .\n\nA paragraph containing a `literal` word.\n\nLiterals should be used when writing text that refers to names of variables, functions, or other\nparts of a Julia program.\n\ntip: Tip\nTo include a backtick character within literal text use three backticks rather than one to enclose\nthe text.A paragraph containing ``` `backtick` characters ```.By extension any odd number of backticks may be used to enclose a lesser number of backticks."},{"title":"LaTeX","page":"Markdown","location":"stdlib/Markdown.html#\\LaTeX","category":"section","text":"Surround text that should be displayed as mathematics using LaTeX syntax with double backticks:\n``.\n\nA paragraph containing some ``\\LaTeX`` markup.\n\nSee the Display equations section for non-inline LaTeX.\n\ntip: Tip\nAs with literals in the previous section, if literal backticks need to be written within double\nbackticks use an even number greater than two. Note that if a single literal backtick needs to\nbe included within LaTeX markup then two enclosing backticks is sufficient.\n\nnote: Note\nThe \\ character should be escaped appropriately if the text is embedded in a Julia source code,\nfor example, \"``\\\\LaTeX`` syntax in a docstring.\", since it is interpreted as a string\nliteral. Alternatively, in order to avoid escaping, it is possible to use the raw string macro\ntogether with the @doc macro:@doc raw\"``\\LaTeX`` syntax in a docstring.\" functionname\n\nnote: Note\nInline LaTeX can also be created using a pair of single $ characters. However\nthis is not recommended as $ is also used for string interpolation. Thus using it can\neasily lead to unintended results. For example, inside an md string the parser will\ninterpret an unmatched $ as string interpolation, leading to unexpected errors or\nworse, undesired behavior, when a variable is unexpectedly interpolated into a string.\nIn contrast, an unmatched `` results in a helpful error message."},{"title":"Links","page":"Markdown","location":"stdlib/Markdown.html#Links","category":"section","text":"Links to either external or internal targets can be written using the following syntax, where\nthe text enclosed in square brackets, [ ], is the name of the link and the text enclosed in\nparentheses, ( ), is the URL.\n\nA paragraph containing a link to [Julia](https://www.julialang.org).\n\nIt's also possible to add cross-references to other documented functions/methods/variables within\nthe Julia documentation itself. For example:\n\n\"\"\"\n    tryparse(type, str; base)\n\nLike [`parse`](@ref), but returns either a value of the requested type,\nor [`nothing`](@ref) if the string does not contain a valid number.\n\"\"\"\n\nThis will create a link in the generated docs to the parse documentation\n(which has more information about what this function actually does), and to the\nnothing documentation. It's good to include cross references to mutating/non-mutating\nversions of a function, or to highlight a difference between two similar-seeming functions.\n\nnote: Note\nThe above cross referencing is not a Markdown feature, and relies on\nDocumenter.jl, which is\nused to build base Julia's documentation."},{"title":"Footnote references","page":"Markdown","location":"stdlib/Markdown.html#Footnote-references","category":"section","text":"Named and numbered footnote references can be written using the following syntax. A footnote name\nmust be a single alphanumeric word containing no punctuation.\n\nA paragraph containing a numbered footnote [^1] and a named one [^named].\n\nnote: Note\nThe text associated with a footnote can be written anywhere within the same page as the footnote\nreference. The syntax used to define the footnote text is discussed in the Footnotes section\nbelow."},{"title":"Toplevel elements","page":"Markdown","location":"stdlib/Markdown.html#Toplevel-elements","category":"section","text":"The following elements can be written either at the \"toplevel\" of a document or within another\n\"toplevel\" element."},{"title":"Paragraphs","page":"Markdown","location":"stdlib/Markdown.html#Paragraphs","category":"section","text":"A paragraph is a block of plain text, possibly containing any number of inline elements defined\nin the Inline elements section above, with one or more blank lines above and below it.\n\nThis is a paragraph.\n\nAnd this is *another* paragraph containing some emphasized text.\nA new line, but still part of the same paragraph."},{"title":"Headers","page":"Markdown","location":"stdlib/Markdown.html#Headers","category":"section","text":"A document can be split up into different sections using headers. Headers use the following syntax:\n\n# Level One\n## Level Two\n### Level Three\n#### Level Four\n##### Level Five\n###### Level Six\n\nA header line can contain any inline syntax in the same way as a paragraph can.\n\ntip: Tip\nTry to avoid using too many levels of header within a single document. A heavily nested document\nmay be indicative of a need to restructure it or split it into several pages covering separate\ntopics."},{"title":"Code blocks","page":"Markdown","location":"stdlib/Markdown.html#Code-blocks","category":"section","text":"Source code can be displayed as a literal block using an indent of four spaces or one tab as shown\nin the following example.\n\nThis is a paragraph.\n\n    function func(x)\n        # ...\n    end\n\nAnother paragraph.\n\nAdditionally, code blocks can be enclosed using triple backticks with an optional \"language\" to\nspecify how a block of code should be highlighted.\n\nA code block without a \"language\":\n\n```\nfunction func(x)\n    # ...\nend\n```\n\nand another one with the \"language\" specified as `julia`:\n\n```julia\nfunction func(x)\n    # ...\nend\n```\n\nnote: Note\n\"Fenced\" code blocks, as shown in the last example, should be preferred over indented code blocks\nsince there is no way to specify what language an indented code block is written in."},{"title":"Block quotes","page":"Markdown","location":"stdlib/Markdown.html#Block-quotes","category":"section","text":"Text from external sources, such as quotations from books or websites, can be quoted using >\ncharacters prepended to each line of the quote as follows.\n\nHere's a quote:\n\n> Julia is a high-level, high-performance dynamic programming language for\n> technical computing, with syntax that is familiar to users of other\n> technical computing environments.\n\nNote that a single space must appear after the > character on each line. Quoted blocks may themselves\ncontain other toplevel or inline elements."},{"title":"Images","page":"Markdown","location":"stdlib/Markdown.html#Images","category":"section","text":"The syntax for images is similar to the link syntax mentioned above. Prepending a ! character\nto a link will display an image from the specified URL rather than a link to it.\n\n![alternative text](link/to/image.png)"},{"title":"Lists","page":"Markdown","location":"stdlib/Markdown.html#Lists","category":"section","text":"Unordered lists can be written by prepending each item in a list with either *, +, or -.\n\nA list of items:\n\n  * item one\n  * item two\n  * item three\n\nNote the two spaces before each * and the single space after each one.\n\nLists can contain other nested toplevel elements such as lists, code blocks, or quoteblocks. A\nblank line should be left between each list item when including any toplevel elements within a\nlist.\n\nAnother list:\n\n  * item one\n\n  * item two\n\n    ```\n    f(x) = x\n    ```\n\n  * And a sublist:\n\n      + sub-item one\n      + sub-item two\n\nnote: Note\nThe contents of each item in the list must line up with the first line of the item. In the above\nexample the fenced code block must be indented by four spaces to align with the i in item two.\n\nOrdered lists are written by replacing the \"bullet\" character, either *, +, or -, with a\npositive integer followed by either . or ).\n\nTwo ordered lists:\n\n 1. item one\n 2. item two\n 3. item three\n\n 5) item five\n 6) item six\n 7) item seven\n\nAn ordered list may start from a number other than one, as in the second list of the above example,\nwhere it is numbered from five. As with unordered lists, ordered lists can contain nested toplevel\nelements."},{"title":"Display equations","page":"Markdown","location":"stdlib/Markdown.html#Display-equations","category":"section","text":"Large LaTeX equations that do not fit inline within a paragraph may be written as display\nequations using a fenced code block with the \"language\" math as in the example below.\n\n```math\nf(a) = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} (\\alpha+R\\cos(\\theta))d\\theta\n```\n\nNote that the \\$\\$ version is available but deprecated:\n\nraw\"$$H = - \\sum p(x) \\log p(x)$$\"\n\nSee the Inline elements for inline LaTeX and a note about the status of the dollar-sign (\\$) deprecated form."},{"title":"Footnotes","page":"Markdown","location":"stdlib/Markdown.html#Footnotes","category":"section","text":"This syntax is paired with the inline syntax for Footnote references. Make sure to read\nthat section as well.\n\nFootnote text is defined using the following syntax, which is similar to footnote reference syntax,\naside from the : character that is appended to the footnote label.\n\n[^1]: Numbered footnote text.\n\n[^note]:\n\n    Named footnote text containing several toplevel elements\n    indented by 4 spaces or one tab.\n\n      * item one\n      * item two\n      * item three\n\n    ```julia\n    function func(x)\n        # ...\n    end\n    ```\n\nnote: Note\nNo checks are done during parsing to make sure that all footnote references have matching footnotes."},{"title":"Horizontal rules","page":"Markdown","location":"stdlib/Markdown.html#Horizontal-rules","category":"section","text":"The equivalent of an <hr> HTML tag can be achieved using three hyphens (---).\nFor example:\n\nText above the line.\n\n---\n\nAnd text below the line."},{"title":"Tables","page":"Markdown","location":"stdlib/Markdown.html#Tables","category":"section","text":"Basic tables can be written using the syntax described below. Note that markdown tables have limited\nfeatures and cannot contain nested toplevel elements unlike other elements discussed above –\nonly inline elements are allowed. Tables must always contain a header row with column names. Cells\ncannot span multiple rows or columns of the table.\n\n| Column One | Column Two | Column Three |\n|:---------- | ---------- |:------------:|\n| Row `1`    | Column `2` |              |\n| *Row* 2    | **Row** 2  | Column ``3`` |\n\nnote: Note\nAs illustrated in the above example each column of | characters must be aligned vertically.A : character on either end of a column's header separator (the row containing - characters)\nspecifies whether the row is left-aligned, right-aligned, or (when : appears on both ends) center-aligned.\nProviding no : characters will default to right-aligning the column."},{"title":"Admonitions","page":"Markdown","location":"stdlib/Markdown.html#Admonitions","category":"section","text":"Specially formatted blocks, known as admonitions, can be used to highlight particular remarks.\nThey can be defined using the following !!! syntax:\n\n!!! note\n\n    This is the content of the note.\n    It is indented by 4 spaces. A tab would work as well.\n\n!!! warning \"Beware!\"\n\n    And this is another one.\n\n    This warning admonition has a custom title: `\"Beware!\"`.\n\nThe first word after !!! declares the type of the admonition.\nThere are standard admonition types that should produce special styling.\nNamely (in order of decreasing severity): danger, warning, info/note, and tip.\n\nYou can also use your own admonition types, as long as the type name only contains lowercase Latin characters (a-z).\nFor example, you could have a terminology block like this:\n\n!!! terminology \"julia vs Julia\"\n\n    Strictly speaking, \"Julia\" refers to the language,\n    and \"julia\" to the standard implementation.\n\nHowever, unless the code rendering the Markdown special-cases that particular admonition type, it will get the default styling.\n\nA custom title for the box can be provided as a string (in double quotes) after the admonition type.\nIf no title text is specified after the admonition type, then the type name will be used as the title (e.g. \"Note\" for the note admonition).\n\nAdmonitions, like most other toplevel elements, can contain other toplevel elements (e.g. lists, images)."},{"title":"Markdown String Literals","page":"Markdown","location":"stdlib/Markdown.html#stdlib-markdown-literals","category":"section","text":"The md\"\" macro allows you to embed Markdown strings directly into your Julia code.\nThis macro is designed to simplify the inclusion of Markdown-formatted text within your Julia source files."},{"title":"Usage","page":"Markdown","location":"stdlib/Markdown.html#Usage","category":"section","text":"result = md\"This is a **custom** Markdown string with [a link](http://example.com).\""},{"title":"Markdown Syntax Extensions","page":"Markdown","location":"stdlib/Markdown.html#Markdown-Syntax-Extensions","category":"section","text":"Julia's markdown supports interpolation in a very similar way to basic string literals, with the\ndifference that it will store the object itself in the Markdown tree (as opposed to converting\nit to a string). When the Markdown content is rendered the usual show methods will be called,\nand these can be overridden as usual. This design allows the Markdown to be extended with arbitrarily\ncomplex features (such as references) without cluttering the basic syntax.\n\nIn principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely\ncustom flavour of Markdown can be used, but this should generally be unnecessary."},{"title":"API reference","page":"Markdown","location":"stdlib/Markdown.html#stdlib-markdown-api","category":"section","text":""},{"title":"Markdown.MD","page":"Markdown","location":"stdlib/Markdown.html#Markdown.MD","category":"type","text":"MD\n\nMD represents a Markdown document. Note that the MD constructor should not generally be\nused directly, since it constructs the internal data structures. Instead, you can construct\nMD objects using the exported macros @md_str and @doc_str.\n\n\n\n\n\n"},{"title":"Markdown.@md_str","page":"Markdown","location":"stdlib/Markdown.html#Markdown.@md_str","category":"macro","text":"@md_str -> MD\n\nParse the given string as Markdown text and return a corresponding MD object.\n\nSee also Markdown.parse.\n\nExamples\n\njulia> s = md\"# Hello, world!\"\n  Hello, world!\n  ≡≡≡≡≡≡≡≡≡≡≡≡≡\n\njulia> typeof(s)\nMarkdown.MD\n\n\n\n\n\n\n"},{"title":"Markdown.@doc_str","page":"Markdown","location":"stdlib/Markdown.html#Markdown.@doc_str","category":"macro","text":"@doc_str -> MD\n\nParse the given string as Markdown text, add line and module information and return a\ncorresponding MD object.\n\n@doc_str can be used in conjunction with the Base.Docs module. Please also refer to\nthe manual section on documentation for more information.\n\nExamples\n\njulia> s = doc\"f(x) = 2*x\"\n  f(x) = 2*x\n\njulia> typeof(s)\nMarkdown.MD\n\n\n\n\n\n\n"},{"title":"Markdown.parse","page":"Markdown","location":"stdlib/Markdown.html#Markdown.parse","category":"function","text":"parse(stream::IO)::MD\n\nParse the content of stream as Julia-flavored Markdown text and return the corresponding MD object.\n\n\n\n\n\nMarkdown.parse(markdown::AbstractString)::MD\n\nParse markdown as Julia-flavored Markdown text and return the corresponding MD object.\n\nSee also @md_str.\n\n\n\n\n\n"},{"title":"Markdown.html","page":"Markdown","location":"stdlib/Markdown.html#Markdown.html","category":"function","text":"html([io::IO], md)\n\nOutput the contents of the Markdown object md in HTML format, either\nwriting to an (optional) io stream or returning a string.\n\nOne can alternatively use show(io, \"text/html\", md) or repr(\"text/html\", md), which\ndiffer in that they wrap the output in a <div class=\"markdown\"> ... </div> element.\n\nExamples\n\njulia> html(md\"hello _world_\")\n\"<p>hello <em>world</em></p>\\n\"\n\n\n\n\n\n"},{"title":"Markdown.latex","page":"Markdown","location":"stdlib/Markdown.html#Markdown.latex","category":"function","text":"latex([io::IO], md)\n\nOutput the contents of the Markdown object md in LaTeX format, either\nwriting to an (optional) io stream or returning a string.\n\nOne can alternatively use show(io, \"text/latex\", md) or repr(\"text/latex\", md).\n\nExamples\n\njulia> latex(md\"hello _world_\")\n\"hello \\\\emph{world}\\n\\n\"\n\n\n\n\n\n"},{"title":"TOML","page":"TOML","location":"stdlib/TOML.html#TOML","category":"section","text":"TOML.jl is a Julia standard library for parsing and writing [TOML\nv1.0](https://toml.io/en/) files."},{"title":"Parsing TOML data","page":"TOML","location":"stdlib/TOML.html#Parsing-TOML-data","category":"section","text":"julia> using TOML\n\njulia> data = \"\"\"\n           [database]\n           server = \"192.168.1.1\"\n           ports = [ 8001, 8001, 8002 ]\n       \"\"\";\n\njulia> TOML.parse(data)\nDict{String, Any} with 1 entry:\n  \"database\" => Dict{String, Any}(\"server\"=>\"192.168.1.1\", \"ports\"=>[8001, 8001…\n\nTo parse a file, use TOML.parsefile. If the file has a syntax error,\nan exception is thrown:\n\njulia> using TOML\n\njulia> TOML.parse(\"\"\"\n           value = 0.0.0\n       \"\"\")\nERROR: TOML Parser error:\nnone:1:16 error: failed to parse value\n      value = 0.0.0\n                 ^\n[...]\n\nThere are other versions of the parse functions (TOML.tryparse\nand TOML.tryparsefile) that instead of throwing exceptions on parser error\nreturns a TOML.ParserError with information:\n\njulia> using TOML\n\njulia> err = TOML.tryparse(\"\"\"\n           value = 0.0.0\n       \"\"\");\n\njulia> err.type\nErrGenericValueError::ErrorType = 14\n\njulia> err.line\n1\n\njulia> err.column\n16"},{"title":"Exporting data to TOML file","page":"TOML","location":"stdlib/TOML.html#Exporting-data-to-TOML-file","category":"section","text":"The TOML.print function is used to print (or serialize) data into TOML\nformat.\n\njulia> using TOML\n\njulia> data = Dict(\n          \"names\" => [\"Julia\", \"Julio\"],\n          \"age\" => [10, 20],\n       );\n\njulia> TOML.print(data)\nnames = [\"Julia\", \"Julio\"]\nage = [10, 20]\n\njulia> fname = tempname();\n\njulia> open(fname, \"w\") do io\n           TOML.print(io, data)\n       end\n\njulia> TOML.parsefile(fname)\nDict{String, Any} with 2 entries:\n  \"names\" => [\"Julia\", \"Julio\"]\n  \"age\"   => [10, 20]\n\nKeys can be sorted according to some value\n\njulia> using TOML\n\njulia> TOML.print(Dict(\n       \"abc\"  => 1,\n       \"ab\"   => 2,\n       \"abcd\" => 3,\n       ); sorted=true, by=length)\nab = 2\nabc = 1\nabcd = 3\n\nFor custom structs, pass a function that converts the struct to a supported\ntype\n\njulia> using TOML\n\njulia> struct MyStruct\n           a::Int\n           b::String\n       end\n\njulia> TOML.print(Dict(\"foo\" => MyStruct(5, \"bar\"))) do x\n           x isa MyStruct && return [x.a, x.b]\n           error(\"unhandled type $(typeof(x))\")\n       end\nfoo = [5, \"bar\"]"},{"title":"References","page":"TOML","location":"stdlib/TOML.html#References","category":"section","text":""},{"title":"TOML.parse","page":"TOML","location":"stdlib/TOML.html#TOML.parse","category":"function","text":"parse(x::Union{AbstractString, IO})\nparse(p::Parser, x::Union{AbstractString, IO})\n\nParse the string  or stream x, and return the resulting table (dictionary).\nThrow a ParserError upon failure.\n\nSee also TOML.tryparse.\n\n\n\n\n\n"},{"title":"TOML.parsefile","page":"TOML","location":"stdlib/TOML.html#TOML.parsefile","category":"function","text":"parsefile(f::AbstractString)\nparsefile(p::Parser, f::AbstractString)\n\nParse file f and return the resulting table (dictionary). Throw a\nParserError upon failure.\n\nSee also TOML.tryparsefile.\n\n\n\n\n\n"},{"title":"TOML.tryparse","page":"TOML","location":"stdlib/TOML.html#TOML.tryparse","category":"function","text":"tryparse(x::Union{AbstractString, IO})\ntryparse(p::Parser, x::Union{AbstractString, IO})\n\nParse the string or stream x, and return the resulting table (dictionary).\nReturn a ParserError upon failure.\n\nSee also TOML.parse.\n\n\n\n\n\n"},{"title":"TOML.tryparsefile","page":"TOML","location":"stdlib/TOML.html#TOML.tryparsefile","category":"function","text":"tryparsefile(f::AbstractString)\ntryparsefile(p::Parser, f::AbstractString)\n\nParse file f and return the resulting table (dictionary). Return a\nParserError upon failure.\n\nSee also TOML.parsefile.\n\n\n\n\n\n"},{"title":"TOML.print","page":"TOML","location":"stdlib/TOML.html#TOML.print","category":"function","text":"print([to_toml::Function], io::IO [=stdout], data::AbstractDict; sorted=false, by=identity, inline_tables::IdSet{<:AbstractDict})\n\nWrite data as TOML syntax to the stream io. If the keyword argument sorted is set to true,\nsort tables according to the function given by the keyword argument by. If the keyword argument\ninline_tables is given, it should be a set of tables that should be printed \"inline\".\n\ncompat: Julia 1.11\nThe inline_tables keyword argument is supported by Julia 1.11 or later.\n\nThe following data types are supported: AbstractDict, AbstractVector, AbstractString, Integer, AbstractFloat, Bool,\nDates.DateTime, Dates.Time, Dates.Date. Note that the integers and floats\nneed to be convertible to Float64 and Int64 respectively. For other data types,\npass the function to_toml that takes the data types and returns a value of a\nsupported type.\n\n\n\n\n\n"},{"title":"TOML.Parser","page":"TOML","location":"stdlib/TOML.html#TOML.Parser","category":"type","text":"Parser()\n\nConstructor for a TOML Parser.  Note that in most cases one does not need to\nexplicitly create a Parser but instead one directly uses\nTOML.parsefile or TOML.parse.  Using an explicit parser\nwill however reuse some internal data structures which can be beneficial for\nperformance if a larger number of small files are parsed.\n\n\n\n\n\n"},{"title":"TOML.ParserError","page":"TOML","location":"stdlib/TOML.html#TOML.ParserError","category":"type","text":"ParserError\n\nType that is returned from tryparse and tryparsefile\nwhen parsing fails. It contains (among others) the following fields:\n\npos, the position in the string when the error happened\ntable, the result that so far was successfully parsed\ntype, an error type, different for different types of errors\n\n\n\n\n\n"},{"title":"Mathematics","page":"Mathematics","location":"base/math.html#Mathematics","category":"section","text":""},{"title":"Mathematical Operators","page":"Mathematics","location":"base/math.html#math-ops","category":"section","text":""},{"title":"Comparisons","page":"Mathematics","location":"base/math.html#Comparisons","category":"section","text":""},{"title":"Bit Operators","page":"Mathematics","location":"base/math.html#Bit-Operators","category":"section","text":""},{"title":"Logical Operators","page":"Mathematics","location":"base/math.html#Logical-Operators","category":"section","text":""},{"title":"Trigonometry","page":"Mathematics","location":"base/math.html#Trigonometry","category":"section","text":""},{"title":"... in Radians","page":"Mathematics","location":"base/math.html#...-in-Radians","category":"section","text":""},{"title":"... in Degrees","page":"Mathematics","location":"base/math.html#...-in-Degrees","category":"section","text":""},{"title":"... in Multiples of π","page":"Mathematics","location":"base/math.html#...-in-Multiples-of-π","category":"section","text":""},{"title":"Hyperbolic","page":"Mathematics","location":"base/math.html#Hyperbolic","category":"section","text":""},{"title":"Other Trigonometric Functions","page":"Mathematics","location":"base/math.html#Other-Trigonometric-Functions","category":"section","text":""},{"title":"Logarithms","page":"Mathematics","location":"base/math.html#Logarithms","category":"section","text":""},{"title":"Exponentiation","page":"Mathematics","location":"base/math.html#Exponentiation","category":"section","text":""},{"title":"Rounding","page":"Mathematics","location":"base/math.html#Rounding","category":"section","text":""},{"title":"Extrema","page":"Mathematics","location":"base/math.html#Extrema","category":"section","text":""},{"title":"Clamping","page":"Mathematics","location":"base/math.html#Clamping","category":"section","text":""},{"title":"Checked Operations","page":"Mathematics","location":"base/math.html#Checked-Operations","category":"section","text":""},{"title":"Signs","page":"Mathematics","location":"base/math.html#Signs","category":"section","text":""},{"title":"Roots","page":"Mathematics","location":"base/math.html#Roots","category":"section","text":""},{"title":"Complex Functions","page":"Mathematics","location":"base/math.html#Complex-Functions","category":"section","text":""},{"title":"Combinatorics and Number Theory","page":"Mathematics","location":"base/math.html#Combinatorics-and-Number-Theory","category":"section","text":""},{"title":"Other Mathematical Functions","page":"Mathematics","location":"base/math.html#Other-Mathematical-Functions","category":"section","text":""},{"title":"Customizable binary operators","page":"Mathematics","location":"base/math.html#Customizable-binary-operators","category":"section","text":"Some unicode characters can be used to define new binary operators\nthat support infix notation.\nFor example\n⊗(x,y) = kron(x,y)\ndefines the ⊗ (otimes) function to be the Kronecker product,\nand one can call it as binary operator using infix syntax:\nC = A ⊗ B\nas well as with the usual prefix syntax\nC = ⊗(A,B).\n\nOther characters that support such extensions include\n\\odot ⊙\nand\n\\oplus ⊕\n\nThe complete list is in the parser code:\nhttps://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm\n\nThose that are parsed like * (in terms of precedence) include\n* / ÷ % & ⋅ ∘ × |\\\\| ∩ ∧ ⊗ ⊘ ⊙ ⊚ ⊛ ⊠ ⊡ ⊓ ∗ ∙ ∤ ⅋ ≀ ⊼ ⋄ ⋆ ⋇ ⋉ ⋊ ⋋ ⋌ ⋏ ⋒ ⟑ ⦸ ⦼ ⦾ ⦿ ⧶ ⧷ ⨇ ⨰ ⨱ ⨲ ⨳ ⨴ ⨵ ⨶ ⨷ ⨸ ⨻ ⨼ ⨽ ⩀ ⩃ ⩄ ⩋ ⩍ ⩎ ⩑ ⩓ ⩕ ⩘ ⩚ ⩜ ⩞ ⩟ ⩠ ⫛ ⊍ ▷ ⨝ ⟕ ⟖ ⟗\nand those that are parsed like + include\n+ - |\\|| ⊕ ⊖ ⊞ ⊟ |++| ∪ ∨ ⊔ ± ∓ ∔ ∸ ≏ ⊎ ⊻ ⊽ ⋎ ⋓ ⟇ ⧺ ⧻ ⨈ ⨢ ⨣ ⨤ ⨥ ⨦ ⨧ ⨨ ⨩ ⨪ ⨫ ⨬ ⨭ ⨮ ⨹ ⨺ ⩁ ⩂ ⩅ ⩊ ⩌ ⩏ ⩐ ⩒ ⩔ ⩖ ⩗ ⩛ ⩝ ⩡ ⩢ ⩣\nThere are many others that are related to arrows, comparisons, and powers."},{"title":"Base.:-","page":"Mathematics","location":"base/math.html#Base.:--Tuple{Any}","category":"method","text":"-(x)\n\nUnary minus operator.\n\nSee also: abs, flipsign.\n\nExamples\n\njulia> -1\n-1\n\njulia> -(2)\n-2\n\njulia> -[1 2; 3 4]\n2×2 Matrix{Int64}:\n -1  -2\n -3  -4\n\njulia> -(true)  # promotes to Int\n-1\n\njulia> -(0x003)\n0xfffd\n\n\n\n\n\n"},{"title":"Base.:+","page":"Mathematics","location":"base/math.html#Base.:+","category":"function","text":"+(x, y...)\n\nAddition operator.\n\nInfix x+y+z+... calls this function with all arguments, i.e. +(x, y, z, ...),\nwhich by default then calls (x+y) + z + ... starting from the left.\n\nNote that overflow is possible for most integer types, including the\ndefault Int, when adding large numbers.\n\nExamples\n\njulia> 1 + 20 + 4\n25\n\njulia> +(1, 20, 4)\n25\n\njulia> [1,2] + [3,4]\n2-element Vector{Int64}:\n 4\n 6\n\njulia> typemax(Int) + 1 < 0\ntrue\n\n\n\n\n\ndt::Date + t::Time -> DateTime\n\nThe addition of a Date with a Time produces a DateTime. The hour, minute, second, and millisecond parts of\nthe Time are used along with the year, month, and day of the Date to create the new DateTime.\nNon-zero microseconds or nanoseconds in the Time type will result in an InexactError being thrown.\n\n\n\n\n\n"},{"title":"Base.:-","page":"Mathematics","location":"base/math.html#Base.:--Tuple{Any, Any}","category":"method","text":"-(x, y)\n\nSubtraction operator.\n\nExamples\n\njulia> 2 - 3\n-1\n\njulia> -(2, 4.5)\n-2.5\n\n\n\n\n\n"},{"title":"Base.:*","page":"Mathematics","location":"base/math.html#Base.:*-Tuple{Any, Vararg{Any}}","category":"method","text":"*(x, y...)\n\nMultiplication operator.\n\nInfix x*y*z*... calls this function with all arguments, i.e. *(x, y, z, ...),\nwhich by default then calls (x*y) * z * ... starting from the left.\n\nJuxtaposition such as 2pi also calls *(2, pi). Note that this operation\nhas higher precedence than a literal *. Note also that juxtaposition \"0x...\"\n(integer zero times a variable whose name starts with x) is forbidden as\nit clashes with unsigned integer literals: 0x01 isa UInt8.\n\nNote that overflow is possible for most integer types, including the default Int,\nwhen multiplying large numbers.\n\nExamples\n\njulia> 2 * 7 * 8\n112\n\njulia> *(2, 7, 8)\n112\n\njulia> [2 0; 0 3] * [1, 10]  # matrix * vector\n2-element Vector{Int64}:\n  2\n 30\n\njulia> 1/2pi, 1/2*pi  # juxtaposition has higher precedence\n(0.15915494309189535, 1.5707963267948966)\n\njulia> x = [1, 2]; x'x  # adjoint vector * vector\n5\n\n\n\n\n\n"},{"title":"Base.:/","page":"Mathematics","location":"base/math.html#Base.:/","category":"function","text":"/(x, y)\n\nRight division operator: multiplication of x by the inverse of y on the right.\n\nGives floating-point results for integer arguments.\nSee ÷ for integer division, or // for Rational results.\n\nExamples\n\njulia> 1/2\n0.5\n\njulia> 4/2\n2.0\n\njulia> 4.5/2\n2.25\n\n\n\n\n\nA / B\n\nMatrix right-division: A / B is equivalent to (B' \\ A')' where \\ is the left-division operator.\nFor square matrices, the result X is such that A == X*B.\n\nSee also: rdiv!.\n\nExamples\n\njulia> A = Float64[1 4 5; 3 9 2]; B = Float64[1 4 2; 3 4 2; 8 7 1];\n\njulia> X = A / B\n2×3 Matrix{Float64}:\n -0.65   3.75  -1.2\n  3.25  -2.75   1.0\n\njulia> isapprox(A, X*B)\ntrue\n\njulia> isapprox(X, A*pinv(B))\ntrue\n\n\n\n\n\n"},{"title":"Base.:\\","page":"Mathematics","location":"base/math.html#Base.:\\-Tuple{Any, Any}","category":"method","text":"\\(x, y)\n\nLeft division operator: multiplication of y by the inverse of x on the left. Gives\nfloating-point results for integer arguments.\n\nExamples\n\njulia> 3 \\ 6\n2.0\n\njulia> inv(3) * 6\n2.0\n\njulia> A = [4 3; 2 1]; x = [5, 6];\n\njulia> A \\ x\n2-element Vector{Float64}:\n  6.5\n -7.0\n\njulia> inv(A) * x\n2-element Vector{Float64}:\n  6.5\n -7.0\n\n\n\n\n\n"},{"title":"Base.:^","page":"Mathematics","location":"base/math.html#Base.:^-Tuple{Number, Number}","category":"method","text":"^(x, y)\n\nExponentiation operator.\n\nIf x and y are integers, the result may overflow.\nTo enter numbers in scientific notation, use Float64 literals\nsuch as 1.2e3 rather than 1.2 * 10^3.\n\nIf y is an Int literal (e.g. 2 in x^2 or -3 in x^-3), the Julia code\nx^y is transformed by the compiler to Base.literal_pow(^, x, Val(y)), to\nenable compile-time specialization on the value of the exponent.\n(As a default fallback we have Base.literal_pow(^, x, Val(y)) = ^(x,y),\nwhere usually ^ == Base.^ unless ^ has been defined in the calling\nnamespace.) If y is a negative integer literal, then Base.literal_pow\ntransforms the operation to inv(x)^-y by default, where -y is positive.\n\nSee also exp2, <<.\n\nExamples\n\njulia> 3^5\n243\n\njulia> 3^-1  # uses Base.literal_pow\n0.3333333333333333\n\njulia> p = -1;\n\njulia> 3^p\nERROR: DomainError with -1:\nCannot raise an integer x to a negative power -1.\n[...]\n\njulia> 3.0^p\n0.3333333333333333\n\njulia> 10^19 > 0  # integer overflow\nfalse\n\njulia> big(10)^19 == 1e19\ntrue\n\n\n\n\n\n"},{"title":"Base.fma","page":"Mathematics","location":"base/math.html#Base.fma","category":"function","text":"fma(x, y, z)\n\nCompute x*y+z without rounding the intermediate result x*y. On some systems this is\nsignificantly more expensive than x*y+z. fma is used to improve accuracy in certain\nalgorithms. See muladd.\n\n\n\n\n\n"},{"title":"Base.muladd","page":"Mathematics","location":"base/math.html#Base.muladd","category":"function","text":"muladd(x, y, z)\n\nCombined multiply-add: computes x*y+z, but allowing the add and multiply to be merged\nwith each other or with surrounding operations for performance.\nFor example, this may be implemented as an fma if the hardware supports it\nefficiently.\nThe result can be different on different machines and can also be different on the same machine\ndue to constant propagation or other optimizations.\nSee fma.\n\nExamples\n\njulia> muladd(3, 2, 1)\n7\n\njulia> 3 * 2 + 1\n7\n\n\n\n\n\nmuladd(A, y, z)\n\nCombined multiply-add, A*y .+ z, for matrix-matrix or matrix-vector multiplication.\nThe result is always the same size as A*y, but z may be smaller, or a scalar.\n\ncompat: Julia 1.6\nThese methods require Julia 1.6 or later.\n\nExamples\n\njulia> A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; z=[0, 100];\n\njulia> muladd(A, B, z)\n2×2 Matrix{Float64}:\n   3.0    3.0\n 107.0  107.0\n\n\n\n\n\n"},{"title":"Base.inv","page":"Mathematics","location":"base/math.html#Base.inv-Tuple{Number}","category":"method","text":"inv(x)\n\nReturn the multiplicative inverse of x, such that x*inv(x) or inv(x)*x\nyields one(x) (the multiplicative identity) up to roundoff errors.\n\nIf x is a number, this is essentially the same as one(x)/x, but for\nsome types inv(x) may be slightly more efficient.\n\nExamples\n\njulia> inv(2)\n0.5\n\njulia> inv(1 + 2im)\n0.2 - 0.4im\n\njulia> inv(1 + 2im) * (1 + 2im)\n1.0 + 0.0im\n\njulia> inv(2//3)\n3//2\n\ncompat: Julia 1.2\ninv(::Missing) requires at least Julia 1.2.\n\n\n\n\n\n"},{"title":"Base.div","page":"Mathematics","location":"base/math.html#Base.div","category":"function","text":"div(x, y)\n÷(x, y)\n\nThe quotient from Euclidean (integer) division. Generally equivalent\nto a mathematical operation x/y without a fractional part.\n\nSee also: cld, fld, rem, divrem.\n\nExamples\n\njulia> 9 ÷ 4\n2\n\njulia> -5 ÷ 3\n-1\n\njulia> 5.0 ÷ 2\n2.0\n\njulia> div.(-5:5, 3)'\n1×11 adjoint(::Vector{Int64}) with eltype Int64:\n -1  -1  -1  0  0  0  0  0  1  1  1\n\n\n\n\n\n"},{"title":"Base.div","page":"Mathematics","location":"base/math.html#Base.div-Tuple{Any, Any, RoundingMode}","category":"method","text":"div(x, y, r::RoundingMode=RoundToZero)\n\nThe quotient from Euclidean (integer) division. Computes x / y, rounded to\nan integer according to the rounding mode r. In other words, the quantity\n\nround(x / y, r)\n\nwithout any intermediate rounding.\n\ncompat: Julia 1.4\nThe three-argument method taking a RoundingMode requires Julia 1.4 or later.\n\nSee also fld and cld, which are special cases of this function.\n\ncompat: Julia 1.9\nRoundFromZero requires at least Julia 1.9.\n\nExamples:\n\njulia> div(4, 3, RoundToZero) # Matches div(4, 3)\n1\njulia> div(4, 3, RoundDown) # Matches fld(4, 3)\n1\njulia> div(4, 3, RoundUp) # Matches cld(4, 3)\n2\njulia> div(5, 2, RoundNearest)\n2\njulia> div(5, 2, RoundNearestTiesAway)\n3\njulia> div(-5, 2, RoundNearest)\n-2\njulia> div(-5, 2, RoundNearestTiesAway)\n-3\njulia> div(-5, 2, RoundNearestTiesUp)\n-2\njulia> div(4, 3, RoundFromZero)\n2\njulia> div(-4, 3, RoundFromZero)\n-2\n\nBecause div(x, y) implements strictly correct truncated rounding based on the true\nvalue of floating-point numbers, unintuitive situations can arise. For example:\n\njulia> div(6.0, 0.1)\n59.0\njulia> 6.0 / 0.1\n60.0\njulia> 6.0 / big(0.1)\n59.99999999999999666933092612453056361837965690217069245739573412231113406246995\n\nWhat is happening here is that the true value of the floating-point number written\nas 0.1 is slightly larger than the numerical value 1/10 while 6.0 represents\nthe number 6 precisely. Therefore the true value of 6.0 / 0.1 is slightly less\nthan 60. When doing division, this is rounded to precisely 60.0, but\ndiv(6.0, 0.1, RoundToZero) always truncates the true value, so the result is 59.0.\n\n\n\n\n\n"},{"title":"Base.fld","page":"Mathematics","location":"base/math.html#Base.fld","category":"function","text":"fld(x, y)\n\nLargest integer less than or equal to x / y. Equivalent to div(x, y, RoundDown).\n\nSee also div, cld, fld1.\n\nExamples\n\njulia> fld(7.3, 5.5)\n1.0\n\njulia> fld.(-5:5, 3)'\n1×11 adjoint(::Vector{Int64}) with eltype Int64:\n -2  -2  -1  -1  -1  0  0  0  1  1  1\n\nBecause fld(x, y) implements strictly correct floored rounding based on the true\nvalue of floating-point numbers, unintuitive situations can arise. For example:\n\njulia> fld(6.0, 0.1)\n59.0\njulia> 6.0 / 0.1\n60.0\njulia> 6.0 / big(0.1)\n59.99999999999999666933092612453056361837965690217069245739573412231113406246995\n\nWhat is happening here is that the true value of the floating-point number written\nas 0.1 is slightly larger than the numerical value 1/10 while 6.0 represents\nthe number 6 precisely. Therefore the true value of 6.0 / 0.1 is slightly less\nthan 60. When doing division, this is rounded to precisely 60.0, but\nfld(6.0, 0.1) always takes the floor of the true value, so the result is 59.0.\n\n\n\n\n\n"},{"title":"Base.cld","page":"Mathematics","location":"base/math.html#Base.cld","category":"function","text":"cld(x, y)\n\nSmallest integer larger than or equal to x / y. Equivalent to div(x, y, RoundUp).\n\nSee also div, fld.\n\nExamples\n\njulia> cld(5.5, 2.2)\n3.0\n\njulia> cld.(-5:5, 3)'\n1×11 adjoint(::Vector{Int64}) with eltype Int64:\n -1  -1  -1  0  0  0  1  1  1  2  2\n\n\n\n\n\n"},{"title":"Base.mod","page":"Mathematics","location":"base/math.html#Base.mod","category":"function","text":"rem(x::Integer, T::Type{<:Integer})::T\nmod(x::Integer, T::Type{<:Integer})::T\n%(x::Integer, T::Type{<:Integer})::T\n\nFind y::T such that x ≡ y (mod n), where n is the number of integers representable\nin T, and y is an integer in [typemin(T),typemax(T)].\nIf T can represent any integer (e.g. T == BigInt), then this operation corresponds to\na conversion to T.\n\nExamples\n\njulia> x = 129 % Int8\n-127\n\njulia> typeof(x)\nInt8\n\njulia> x = 129 % BigInt\n129\n\njulia> typeof(x)\nBigInt\n\n\n\n\n\nmod(x, y)\nrem(x, y, RoundDown)\n\nThe reduction of x modulo y, or equivalently, the remainder of x after floored\ndivision by y, i.e. x - y*fld(x,y) if computed without intermediate rounding.\n\nThe result will have the same sign as y if isfinite(y), and magnitude less than abs(y) (with some\nexceptions, see note below).\n\nnote: Note\nWhen used with floating point values, the exact result may not be representable by the\ntype, and so rounding error may occur. In particular, if the exact result is very\nclose to y, then it may be rounded to y.\n\nSee also: rem, div, fld, mod1, invmod.\n\njulia> mod(8, 3)\n2\n\njulia> mod(9, 3)\n0\n\njulia> mod(8.9, 3)\n2.9000000000000004\n\njulia> mod(eps(), 3)\n2.220446049250313e-16\n\njulia> mod(-eps(), 3)\n3.0\n\njulia> mod.(-5:5, 3)'\n1×11 adjoint(::Vector{Int64}) with eltype Int64:\n 1  2  0  1  2  0  1  2  0  1  2\n\n\n\n\n\nmod(x::Integer, r::AbstractUnitRange)\n\nFind y in the range r such that x ≡ y (mod n), where n = length(r),\ni.e. y = mod(x - first(r), n) + first(r).\n\nSee also mod1.\n\nExamples\n\njulia> mod(0, Base.OneTo(3))  # mod1(0, 3)\n3\n\njulia> mod(3, 0:2)  # mod(3, 3)\n0\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\n\n\n\n\n"},{"title":"Base.rem","page":"Mathematics","location":"base/math.html#Base.rem","category":"function","text":"rem(x, y)\n%(x, y)\n\nRemainder from Euclidean division, returning a value of the same sign as x, and smaller in\nmagnitude than y. This value is always exact.\n\nSee also: div, mod, mod1, divrem.\n\nExamples\n\njulia> x = 15; y = 4;\n\njulia> x % y\n3\n\njulia> x == div(x, y) * y + rem(x, y)\ntrue\n\njulia> rem.(-5:5, 3)'\n1×11 adjoint(::Vector{Int64}) with eltype Int64:\n -2  -1  0  -2  -1  0  1  2  0  1  2\n\n\n\n\n\n"},{"title":"Base.rem","page":"Mathematics","location":"base/math.html#Base.rem-Tuple{Any, Any, RoundingMode}","category":"method","text":"rem(x, y, r::RoundingMode=RoundToZero)\n\nCompute the remainder of x after integer division by y, with the quotient rounded\naccording to the rounding mode r. In other words, the quantity\n\nx - y * round(x / y, r)\n\nwithout any intermediate rounding.\n\nif r == RoundNearest, then the result is exact, and in the interval\n-y  2 y  2. See also RoundNearest.\nif r == RoundToZero (default), then the result is exact, and in the interval\n0 y) if x is positive, or (-y 0 otherwise. See also RoundToZero.\nif r == RoundDown, then the result is in the interval 0 y) if y is positive, or\n(y 0 otherwise. The result may not be exact if x and y have different signs, and\nabs(x) < abs(y). See also RoundDown.\nif r == RoundUp, then the result is in the interval (-y 0 if y is positive, or\n0 -y) otherwise. The result may not be exact if x and y have the same sign, and\nabs(x) < abs(y). See also RoundUp.\nif r == RoundFromZero, then the result is in the interval (-y 0 if y is positive, or\n0 -y) otherwise. The result may not be exact if x and y have the same sign, and\nabs(x) < abs(y). See also RoundFromZero.\n\ncompat: Julia 1.9\nRoundFromZero requires at least Julia 1.9.\n\nExamples:\n\njulia> x = 9; y = 4;\n\njulia> x % y  # same as rem(x, y)\n1\n\njulia> x ÷ y  # same as div(x, y)\n2\n\njulia> x == div(x, y) * y + rem(x, y)\ntrue\n\n\n\n\n\n"},{"title":"Base.Math.rem2pi","page":"Mathematics","location":"base/math.html#Base.Math.rem2pi","category":"function","text":"rem2pi(x, r::RoundingMode)\n\nCompute the remainder of x after integer division by 2π, with the quotient rounded\naccording to the rounding mode r. In other words, the quantity\n\nx - 2π*round(x/(2π),r)\n\nwithout any intermediate rounding. This internally uses a high precision approximation of\n2π, and so will give a more accurate result than rem(x,2π,r)\n\nif r == RoundNearest, then the result is in the interval -π π. This will generally\nbe the most accurate result. See also RoundNearest.\nif r == RoundToZero, then the result is in the interval 0 2π if x is positive,.\nor -2π 0 otherwise. See also RoundToZero.\nif r == RoundDown, then the result is in the interval 0 2π.\nSee also RoundDown.\nif r == RoundUp, then the result is in the interval -2π 0.\nSee also RoundUp.\n\nExamples\n\njulia> rem2pi(7pi/4, RoundNearest)\n-0.7853981633974485\n\njulia> rem2pi(7pi/4, RoundDown)\n5.497787143782138\n\n\n\n\n\n"},{"title":"Base.Math.mod2pi","page":"Mathematics","location":"base/math.html#Base.Math.mod2pi","category":"function","text":"mod2pi(x)\n\nModulus after division by 2π, returning in the range 02π).\n\nThis function computes a floating point representation of the modulus after division by\nnumerically exact 2π, and is therefore not exactly the same as mod(x,2π), which would\ncompute the modulus of x relative to division by the floating-point number 2π.\n\nnote: Note\nDepending on the format of the input value, the closest representable value to 2π may\nbe less than 2π. For example, the expression mod2pi(2π) will not return 0, because\nthe intermediate value of 2*π is a Float64 and 2*Float64(π) < 2*big(π). See\nrem2pi for more refined control of this behavior.\n\nExamples\n\njulia> mod2pi(9*pi/4)\n0.7853981633974481\n\n\n\n\n\n"},{"title":"Base.divrem","page":"Mathematics","location":"base/math.html#Base.divrem","category":"function","text":"divrem(x, y, r::RoundingMode=RoundToZero)\n\nThe quotient and remainder from Euclidean division.\nEquivalent to (div(x, y, r), rem(x, y, r)). Equivalently, with the default\nvalue of r, this call is equivalent to (x ÷ y, x % y).\n\nSee also: fldmod, cld.\n\nExamples\n\njulia> divrem(3, 7)\n(0, 3)\n\njulia> divrem(7, 3)\n(2, 1)\n\n\n\n\n\n"},{"title":"Base.fldmod","page":"Mathematics","location":"base/math.html#Base.fldmod","category":"function","text":"fldmod(x, y)\n\nThe floored quotient and modulus after division. A convenience wrapper for\ndivrem(x, y, RoundDown). Equivalent to (fld(x, y), mod(x, y)).\n\nSee also: fld, cld, fldmod1.\n\n\n\n\n\n"},{"title":"Base.fld1","page":"Mathematics","location":"base/math.html#Base.fld1","category":"function","text":"fld1(x, y)\n\nFlooring division, returning a value consistent with mod1(x,y)\n\nSee also mod1, fldmod1.\n\nExamples\n\njulia> x = 15; y = 4;\n\njulia> fld1(x, y)\n4\n\njulia> x == fld(x, y) * y + mod(x, y)\ntrue\n\njulia> x == (fld1(x, y) - 1) * y + mod1(x, y)\ntrue\n\n\n\n\n\n"},{"title":"Base.mod1","page":"Mathematics","location":"base/math.html#Base.mod1","category":"function","text":"mod1(x, y)\n\nModulus after flooring division, returning a value r such that mod(r, y) == mod(x, y)\nin the range (0 y for positive y and in the range y0) for negative y.\n\nWith integer arguments and positive y, this is equal to mod(x, 1:y), and hence natural\nfor 1-based indexing. By comparison, mod(x, y) == mod(x, 0:y-1) is natural for computations with\noffsets or strides.\n\nSee also mod, fld1, fldmod1.\n\nExamples\n\njulia> mod1(4, 2)\n2\n\njulia> mod1.(-5:5, 3)'\n1×11 adjoint(::Vector{Int64}) with eltype Int64:\n 1  2  3  1  2  3  1  2  3  1  2\n\njulia> mod1.([-0.1, 0, 0.1, 1, 2, 2.9, 3, 3.1]', 3)\n1×8 Matrix{Float64}:\n 2.9  3.0  0.1  1.0  2.0  2.9  3.0  0.1\n\n\n\n\n\n"},{"title":"Base.fldmod1","page":"Mathematics","location":"base/math.html#Base.fldmod1","category":"function","text":"fldmod1(x, y)\n\nReturn (fld1(x,y), mod1(x,y)).\n\nSee also fld1, mod1.\n\n\n\n\n\n"},{"title":"Base.://","page":"Mathematics","location":"base/math.html#Base.://","category":"function","text":"//(num, den)\n\nDivide two integers or rational numbers, giving a Rational result.\nMore generally, // can be used for exact rational division of other numeric types\nwith integer or rational components, such as complex numbers with integer components.\n\nNote that floating-point (AbstractFloat) arguments are not permitted by //\n(even if the values are rational).\nThe arguments must be subtypes of Integer, Rational, or composites thereof.\n\nExamples\n\njulia> 3 // 5\n3//5\n\njulia> (3 // 5) // (2 // 1)\n3//10\n\njulia> (1+2im) // (3+4im)\n11//25 + 2//25*im\n\njulia> 1.0 // 2\nERROR: MethodError: no method matching //(::Float64, ::Int64)\n[...]\n\n\n\n\n\n"},{"title":"Base.rationalize","page":"Mathematics","location":"base/math.html#Base.rationalize","category":"function","text":"rationalize([T<:Integer=Int,] x; tol::Real=eps(x))\n\nApproximate floating point number x as a Rational number with components\nof the given integer type. The result will differ from x by no more than tol.\n\nExamples\n\njulia> rationalize(5.6)\n28//5\n\njulia> a = rationalize(BigInt, 10.3)\n103//10\n\njulia> typeof(numerator(a))\nBigInt\n\n\n\n\n\n"},{"title":"Base.numerator","page":"Mathematics","location":"base/math.html#Base.numerator","category":"function","text":"numerator(x)\n\nNumerator of the rational representation of x.\n\nExamples\n\njulia> numerator(2//3)\n2\n\njulia> numerator(4)\n4\n\n\n\n\n\n"},{"title":"Base.denominator","page":"Mathematics","location":"base/math.html#Base.denominator","category":"function","text":"denominator(x)\n\nDenominator of the rational representation of x.\n\nExamples\n\njulia> denominator(2//3)\n3\n\njulia> denominator(4)\n1\n\n\n\n\n\n"},{"title":"Base.:==","page":"Mathematics","location":"base/math.html#Base.:==","category":"function","text":"==(x, y)\n\nGeneric equality operator. Falls back to ===.\nShould be implemented for all types with a notion of equality, based on the abstract value\nthat an instance represents. For example, all numeric types are compared by numeric value,\nignoring type. Strings are compared as sequences of characters, ignoring encoding.\nCollections of the same type generally compare their key sets, and if those are ==, then compare the values\nfor each of those keys, returning true if all such pairs are ==.\nOther properties are typically not taken into account (such as the exact type).\n\nThis operator follows IEEE semantics for floating-point numbers: 0.0 == -0.0 and\nNaN != NaN.\n\nThe result is of type Bool, except when one of the operands is missing,\nin which case missing is returned\n(three-valued logic).\nCollections generally implement three-valued logic akin to all, returning\nmissing if any operands contain missing values and all other pairs are equal.\nUse isequal or === to always get a Bool result.\n\nImplementation\n\nNew numeric types should implement this function for two arguments of the new type, and\nhandle comparison to other types via promotion rules where possible.\n\nEquality and hashing are intimately related; two values that are considered isequal must\nhave the same hash and by default isequal falls back to ==. If a type customizes the behavior of == and/or isequal,\nthen hash must be similarly implemented to ensure isequal and hash agree. Sets, Dicts, and many other internal\nimplementations assume that this invariant holds.\n\nIf some type defines ==, isequal, and isless then it should\nalso implement < to ensure consistency of comparisons.\n\n\n\n\n\n"},{"title":"Base.:!=","page":"Mathematics","location":"base/math.html#Base.:!=","category":"function","text":"!=(x)\n\nCreate a function that compares its argument to x using !=, i.e.\na function equivalent to y -> y != x.\nThe returned function is of type Base.Fix2{typeof(!=)}, which can be\nused to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n!=(x, y)\n≠(x,y)\n\nNot-equals comparison operator. Always gives the opposite answer as ==.\n\nImplementation\n\nNew types should generally not implement this, and rely on the fallback definition\n!=(x,y) = !(x==y) instead.\n\nExamples\n\njulia> 3 != 2\ntrue\n\njulia> \"foo\" ≠ \"foo\"\nfalse\n\n\n\n\n\n"},{"title":"Core.:!==","page":"Mathematics","location":"base/math.html#Core.:!==","category":"function","text":"!==(x, y)\n≢(x,y)\n\nAlways gives the opposite answer as ===.\n\nExamples\n\njulia> a = [1, 2]; b = [1, 2];\n\njulia> a ≢ b\ntrue\n\njulia> a ≢ a\nfalse\n\n\n\n\n\n"},{"title":"Base.:<","page":"Mathematics","location":"base/math.html#Base.:<","category":"function","text":"<(x)\n\nCreate a function that compares its argument to x using <, i.e.\na function equivalent to y -> y < x.\nThe returned function is of type Base.Fix2{typeof(<)}, which can be\nused to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n<(x, y)\n\nLess-than comparison operator. Falls back to isless.\nBecause of the behavior of floating-point NaN values, this operator implements\na partial order.\n\nImplementation\n\nNew types with a canonical partial order should implement this function for\ntwo arguments of the new type.\nTypes with a canonical total order should implement isless instead.\n\nSee also isunordered.\n\nExamples\n\njulia> 'a' < 'b'\ntrue\n\njulia> \"abc\" < \"abd\"\ntrue\n\njulia> 5 < 3\nfalse\n\n\n\n\n\n"},{"title":"Base.:<=","page":"Mathematics","location":"base/math.html#Base.:<=","category":"function","text":"<=(x)\n\nCreate a function that compares its argument to x using <=, i.e.\na function equivalent to y -> y <= x.\nThe returned function is of type Base.Fix2{typeof(<=)}, which can be\nused to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n<=(x, y)\n≤(x,y)\n\nLess-than-or-equals comparison operator. Falls back to (x < y) | (x == y).\n\nExamples\n\njulia> 'a' <= 'b'\ntrue\n\njulia> 7 ≤ 7 ≤ 9\ntrue\n\njulia> \"abc\" ≤ \"abc\"\ntrue\n\njulia> 5 <= 3\nfalse\n\n\n\n\n\n"},{"title":"Base.:>","page":"Mathematics","location":"base/math.html#Base.:>","category":"function","text":">(x)\n\nCreate a function that compares its argument to x using >, i.e.\na function equivalent to y -> y > x.\nThe returned function is of type Base.Fix2{typeof(>)}, which can be\nused to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n>(x, y)\n\nGreater-than comparison operator. Falls back to y < x.\n\nImplementation\n\nGenerally, new types should implement < instead of this function,\nand rely on the fallback definition >(x, y) = y < x.\n\nExamples\n\njulia> 'a' > 'b'\nfalse\n\njulia> 7 > 3 > 1\ntrue\n\njulia> \"abc\" > \"abd\"\nfalse\n\njulia> 5 > 3\ntrue\n\n\n\n\n\n"},{"title":"Base.:>=","page":"Mathematics","location":"base/math.html#Base.:>=","category":"function","text":">=(x)\n\nCreate a function that compares its argument to x using >=, i.e.\na function equivalent to y -> y >= x.\nThe returned function is of type Base.Fix2{typeof(>=)}, which can be\nused to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n>=(x, y)\n≥(x,y)\n\nGreater-than-or-equals comparison operator. Falls back to y <= x.\n\nImplementation\n\nNew types should prefer to implement <= instead of this function,\nand rely on the fallback definition >=(x, y) = y <= x.\n\nFurthermore, in many cases it is enough to implement just < and\n==, relying on the fallback definitions of both <= and >=.\n\nExamples\n\njulia> 'a' >= 'b'\nfalse\n\njulia> 7 ≥ 7 ≥ 3\ntrue\n\njulia> \"abc\" ≥ \"abc\"\ntrue\n\njulia> 5 >= 3\ntrue\n\n\n\n\n\n"},{"title":"Base.cmp","page":"Mathematics","location":"base/math.html#Base.cmp","category":"function","text":"cmp(a::AbstractString, b::AbstractString)::Int\n\nCompare two strings. Return 0 if both strings have the same length and the character\nat each index is the same in both strings. Return -1 if a is a prefix of b, or if\na comes before b in alphabetical order. Return 1 if b is a prefix of a, or if\nb comes before a in alphabetical order (technically, lexicographical order by Unicode\ncode points).\n\nExamples\n\njulia> cmp(\"abc\", \"abc\")\n0\n\njulia> cmp(\"ab\", \"abc\")\n-1\n\njulia> cmp(\"abc\", \"ab\")\n1\n\njulia> cmp(\"ab\", \"ac\")\n-1\n\njulia> cmp(\"ac\", \"ab\")\n1\n\njulia> cmp(\"α\", \"a\")\n1\n\njulia> cmp(\"b\", \"β\")\n-1\n\n\n\n\n\ncmp(<, x, y)\n\nReturn -1, 0, or 1 depending on whether x is less than, equal to, or greater than y,\nrespectively. The first argument specifies a less-than comparison function to use.\n\n\n\n\n\ncmp(x,y)\n\nReturn -1, 0, or 1 depending on whether x is less than, equal to, or greater than y,\nrespectively. Uses the total order implemented by isless.\n\nExamples\n\njulia> cmp(1, 2)\n-1\n\njulia> cmp(2, 1)\n1\n\njulia> cmp(2+im, 3-im)\nERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})\n[...]\n\n\n\n\n\n"},{"title":"Base.isapprox","page":"Mathematics","location":"base/math.html#Base.isapprox","category":"function","text":"isapprox(x; kwargs...) / ≈(x; kwargs...)\n\nCreate a function that compares its argument to x using ≈, i.e. a function equivalent to y -> y ≈ x.\n\nThe keyword arguments supported here are the same as those in the 2-argument isapprox.\n\ncompat: Julia 1.5\nThis method requires Julia 1.5 or later.\n\n\n\n\n\nisapprox(x, y; atol::Real=0, rtol::Real=atol>0 ? 0 : √eps, nans::Bool=false[, norm::Function])\n\nInexact equality comparison. Two numbers compare equal if their relative distance or their\nabsolute distance is within tolerance bounds: isapprox returns true if\nnorm(x-y) <= max(atol, rtol*max(norm(x), norm(y))). The default atol (absolute tolerance) is zero and the\ndefault rtol (relative tolerance) depends on the types of x and y. The keyword argument nans determines\nwhether or not NaN values are considered equal (defaults to false).\n\nFor real or complex floating-point values, if an atol > 0 is not specified, rtol defaults to\nthe square root of eps of the type of x or y, whichever is bigger (least precise).\nThis corresponds to requiring equality of about half of the significant digits. Otherwise,\ne.g. for integer arguments or if an atol > 0 is supplied, rtol defaults to zero.\n\nThe norm keyword defaults to abs for numeric (x,y) and to LinearAlgebra.norm for\narrays (where an alternative norm choice is sometimes useful).\nWhen x and y are arrays, if norm(x-y) is not finite (i.e. ±Inf\nor NaN), the comparison falls back to checking whether all elements of x and y are\napproximately equal component-wise.\n\nThe binary operator ≈ is equivalent to isapprox with the default arguments, and x ≉ y\nis equivalent to !isapprox(x,y).\n\nNote that x ≈ 0 (i.e., comparing to zero with the default tolerances) is\nequivalent to x == 0 since the default atol is 0.  In such cases, you should either\nsupply an appropriate atol (or use norm(x) ≤ atol) or rearrange your code (e.g.\nuse x ≈ y rather than x - y ≈ 0).   It is not possible to pick a nonzero atol\nautomatically because it depends on the overall scaling (the \"units\") of your problem:\nfor example, in x - y ≈ 0, atol=1e-9 is an absurdly small tolerance if x is the\nradius of the Earth in meters,\nbut an absurdly large tolerance if x is the\nradius of a Hydrogen atom in meters.\n\ncompat: Julia 1.6\nPassing the norm keyword argument when comparing numeric (non-array) arguments\nrequires Julia 1.6 or later.\n\nExamples\n\njulia> isapprox(0.1, 0.15; atol=0.05)\ntrue\n\njulia> isapprox(0.1, 0.15; rtol=0.34)\ntrue\n\njulia> isapprox(0.1, 0.15; rtol=0.33)\nfalse\n\njulia> 0.1 + 1e-10 ≈ 0.1\ntrue\n\njulia> 1e-10 ≈ 0\nfalse\n\njulia> isapprox(1e-10, 0, atol=1e-8)\ntrue\n\njulia> isapprox([10.0^9, 1.0], [10.0^9, 2.0]) # using `norm`\ntrue\n\n\n\n\n\n"},{"title":"Base.:<<","page":"Mathematics","location":"base/math.html#Base.:<<","category":"function","text":"<<(B::BitVector, n)::BitVector\n\nLeft bit shift operator, B << n. For n >= 0, the result is B\nwith elements shifted n positions backwards, filling with false\nvalues. If n < 0, elements are shifted forwards. Equivalent to\nB >> -n.\n\nExamples\n\njulia> B = BitVector([true, false, true, false, false])\n5-element BitVector:\n 1\n 0\n 1\n 0\n 0\n\njulia> B << 1\n5-element BitVector:\n 0\n 1\n 0\n 0\n 0\n\njulia> B << -1\n5-element BitVector:\n 0\n 1\n 0\n 1\n 0\n\n\n\n\n\n<<(x, n)\n\nLeft bit shift operator, x << n. For n >= 0, the result is x shifted left\nby n bits, filling with 0s. This is equivalent to x * 2^n. For n < 0,\nthis is equivalent to x >> -n.\n\nExamples\n\njulia> Int8(3) << 2\n12\n\njulia> bitstring(Int8(3))\n\"00000011\"\n\njulia> bitstring(Int8(12))\n\"00001100\"\n\nSee also >>, >>>, exp2, ldexp.\n\n\n\n\n\n"},{"title":"Base.:>>","page":"Mathematics","location":"base/math.html#Base.:>>","category":"function","text":">>(B::BitVector, n)::BitVector\n\nRight bit shift operator, B >> n. For n >= 0, the result is B\nwith elements shifted n positions forward, filling with false\nvalues. If n < 0, elements are shifted backwards. Equivalent to\nB << -n.\n\nExamples\n\njulia> B = BitVector([true, false, true, false, false])\n5-element BitVector:\n 1\n 0\n 1\n 0\n 0\n\njulia> B >> 1\n5-element BitVector:\n 0\n 1\n 0\n 1\n 0\n\njulia> B >> -1\n5-element BitVector:\n 0\n 1\n 0\n 0\n 0\n\n\n\n\n\n>>(x, n)\n\nRight bit shift operator, x >> n. For n >= 0, the result is x shifted\nright by n bits, filling with 0s if x >= 0, 1s if x < 0, preserving\nthe sign of x. This is equivalent to fld(x, 2^n). For n < 0, this is\nequivalent to x << -n.\n\nExamples\n\njulia> Int8(13) >> 2\n3\n\njulia> bitstring(Int8(13))\n\"00001101\"\n\njulia> bitstring(Int8(3))\n\"00000011\"\n\njulia> Int8(-14) >> 2\n-4\n\njulia> bitstring(Int8(-14))\n\"11110010\"\n\njulia> bitstring(Int8(-4))\n\"11111100\"\n\nSee also >>>, <<.\n\n\n\n\n\n"},{"title":"Base.:>>>","page":"Mathematics","location":"base/math.html#Base.:>>>","category":"function","text":">>>(B::BitVector, n)::BitVector\n\nUnsigned right bitshift operator, B >>> n. Equivalent to B >> n. See >> for\ndetails and examples.\n\n\n\n\n\n>>>(x, n)\n\nUnsigned right bit shift operator, x >>> n. For n >= 0, the result is x\nshifted right by n bits, filling with 0s. For n < 0, this is equivalent\nto x << -n.\n\nFor Unsigned integer types, this is equivalent to >>. For\nSigned integer types, this is equivalent to signed(unsigned(x) >> n).\n\nExamples\n\njulia> Int8(-14) >>> 2\n60\n\njulia> bitstring(Int8(-14))\n\"11110010\"\n\njulia> bitstring(Int8(60))\n\"00111100\"\n\nBigInts are treated as if having infinite size, so no filling is required and this\nis equivalent to >>.\n\nSee also >>, <<.\n\n\n\n\n\n"},{"title":"Base.bitrotate","page":"Mathematics","location":"base/math.html#Base.bitrotate","category":"function","text":"bitrotate(x::Base.BitInteger, k::Integer)\n\nbitrotate(x, k) implements bitwise rotation.\nIt returns the value of x with its bits rotated left k times.\nA negative value of k will rotate to the right instead.\n\ncompat: Julia 1.5\nThis function requires Julia 1.5 or later.\n\nSee also: <<, circshift, BitArray.\n\njulia> bitrotate(UInt8(114), 2)\n0xc9\n\njulia> bitstring(bitrotate(0b01110010, 2))\n\"11001001\"\n\njulia> bitstring(bitrotate(0b01110010, -2))\n\"10011100\"\n\njulia> bitstring(bitrotate(0b01110010, 8))\n\"01110010\"\n\n\n\n\n\n"},{"title":"Base.:~","page":"Mathematics","location":"base/math.html#Base.:~","category":"function","text":"~(x)\n\nBitwise not.\n\nSee also: !, &, |.\n\nExamples\n\njulia> ~4\n-5\n\njulia> ~10\n-11\n\njulia> ~true\nfalse\n\n\n\n\n\n"},{"title":"Base.:&","page":"Mathematics","location":"base/math.html#Base.:&","category":"function","text":"x & y\n\nBitwise and. Implements three-valued logic,\nreturning missing if one operand is missing and the other is true. Add parentheses for\nfunction application form: (&)(x, y).\n\nSee also: |, xor, &&.\n\nExamples\n\njulia> 4 & 10\n0\n\njulia> 4 & 12\n4\n\njulia> true & missing\nmissing\n\njulia> false & missing\nfalse\n\n\n\n\n\n"},{"title":"Base.:|","page":"Mathematics","location":"base/math.html#Base.:|","category":"function","text":"x | y\n\nBitwise or. Implements three-valued logic,\nreturning missing if one operand is missing and the other is false.\n\nSee also: &, xor, ||.\n\nExamples\n\njulia> 4 | 10\n14\n\njulia> 4 | 1\n5\n\njulia> true | missing\ntrue\n\njulia> false | missing\nmissing\n\n\n\n\n\n"},{"title":"Base.xor","page":"Mathematics","location":"base/math.html#Base.xor","category":"function","text":"xor(x, y)\n⊻(x, y)\n\nBitwise exclusive or of x and y. Implements\nthree-valued logic,\nreturning missing if one of the arguments is missing.\n\nThe infix operation a ⊻ b is a synonym for xor(a,b), and\n⊻ can be typed by tab-completing \\xor or \\veebar in the Julia REPL.\n\nExamples\n\njulia> xor(true, false)\ntrue\n\njulia> xor(true, true)\nfalse\n\njulia> xor(true, missing)\nmissing\n\njulia> false ⊻ false\nfalse\n\njulia> [true; true; false] .⊻ [true; false; false]\n3-element BitVector:\n 0\n 1\n 0\n\n\n\n\n\n"},{"title":"Base.nand","page":"Mathematics","location":"base/math.html#Base.nand","category":"function","text":"nand(x, y)\n⊼(x, y)\n\nBitwise nand (not and) of x and y. Implements\nthree-valued logic,\nreturning missing if one of the arguments is missing.\n\nThe infix operation a ⊼ b is a synonym for nand(a,b), and\n⊼ can be typed by tab-completing \\nand or \\barwedge in the Julia REPL.\n\nExamples\n\njulia> nand(true, false)\ntrue\n\njulia> nand(true, true)\nfalse\n\njulia> nand(true, missing)\nmissing\n\njulia> false ⊼ false\ntrue\n\njulia> [true; true; false] .⊼ [true; false; false]\n3-element BitVector:\n 0\n 1\n 1\n\n\n\n\n\n"},{"title":"Base.nor","page":"Mathematics","location":"base/math.html#Base.nor","category":"function","text":"nor(x, y)\n⊽(x, y)\n\nBitwise nor (not or) of x and y. Implements\nthree-valued logic,\nreturning missing if one of the arguments is missing and the\nother is not true.\n\nThe infix operation a ⊽ b is a synonym for nor(a,b), and\n⊽ can be typed by tab-completing \\nor or \\barvee in the Julia REPL.\n\nExamples\n\njulia> nor(true, false)\nfalse\n\njulia> nor(true, true)\nfalse\n\njulia> nor(true, missing)\nfalse\n\njulia> false ⊽ false\ntrue\n\njulia> false ⊽ missing\nmissing\n\njulia> [true; true; false] .⊽ [true; false; false]\n3-element BitVector:\n 0\n 0\n 1\n\n\n\n\n\n"},{"title":"Base.:!","page":"Mathematics","location":"base/math.html#Base.:!","category":"function","text":"!f::Function\n\nPredicate function negation: when the argument of ! is a function, it returns a composed function which computes the boolean negation of f.\n\nSee also ∘.\n\nExamples\n\njulia> str = \"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε\"\n\"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε\"\n\njulia> filter(isletter, str)\n\"εδxyδfxfyε\"\n\njulia> filter(!isletter, str)\n\"∀  > 0, ∃  > 0: |-| <  ⇒ |()-()| < \"\n\ncompat: Julia 1.9\nStarting with Julia 1.9, !f returns a ComposedFunction instead of an anonymous function.\n\n\n\n\n\n!(x)\n\nBoolean not. Implements three-valued logic,\nreturning missing if x is missing.\n\nSee also ~ for bitwise not.\n\nExamples\n\njulia> !true\nfalse\n\njulia> !false\ntrue\n\njulia> !missing\nmissing\n\njulia> .![true false true]\n1×3 BitMatrix:\n 0  1  0\n\n\n\n\n\n"},{"title":"&&","page":"Mathematics","location":"base/math.html#&&","category":"keyword","text":"x && y\n\nShort-circuiting boolean AND.\n\nThis is equivalent to x ? y : false: it returns false if x is false and the result of evaluating y if x is true.\nNote that if y is an expression, it is only evaluated when x is true, which is called \"short-circuiting\" behavior.\n\nAlso, y does not need to have a boolean value.  This means that (condition) && (statement) can be used as shorthand for\nif condition; statement; end for an arbitrary statement.\n\nSee also &, the ternary operator ? :, and the manual section on control flow.\n\nExamples\n\njulia> x = 3;\n\njulia> x > 1 && x < 10 && x isa Int\ntrue\n\njulia> x < 0 && error(\"expected positive x\")\nfalse\n\njulia> x > 0 && \"not a boolean\"\n\"not a boolean\"\n\n\n\n\n\n"},{"title":"||","page":"Mathematics","location":"base/math.html#||","category":"keyword","text":"x || y\n\nShort-circuiting boolean OR.\n\nThis is equivalent to x ? true : y: it returns true if x is true and the result of evaluating y if x is false.\nNote that if y is an expression, it is only evaluated when x is false, which is called \"short-circuiting\" behavior.\n\nAlso, y does not need to have a boolean value.  This means that (condition) || (statement) can be used as shorthand for\nif !(condition); statement; end for an arbitrary statement.\n\nSee also: |, xor, &&.\n\nExamples\n\njulia> pi < 3 || ℯ < 3\ntrue\n\njulia> false || true || println(\"neither is true!\")\ntrue\n\njulia> pi < 3 || \"not a boolean\"\n\"not a boolean\"\n\n\n\n\n\n"},{"title":"Base.sin","page":"Mathematics","location":"base/math.html#Base.sin-Tuple{Number}","category":"method","text":"sin(x::T) where {T <: Number} -> float(T)\n\nCompute sine of x, where x is in radians.\n\nThrow a DomainError if isinf(x), return a T(NaN) if isnan(x).\n\nSee also sind, sinpi, sincos, cis, asin.\n\nExamples\n\njulia> round.(sin.(range(0, 2pi, length=9)'), digits=3)\n1×9 Matrix{Float64}:\n 0.0  0.707  1.0  0.707  0.0  -0.707  -1.0  -0.707  -0.0\n\njulia> sind(45)\n0.7071067811865476\n\njulia> sinpi(1/4)\n0.7071067811865475\n\njulia> round.(sincos(pi/6), digits=3)\n(0.5, 0.866)\n\njulia> round(cis(pi/6), digits=3)\n0.866 + 0.5im\n\njulia> round(exp(im*pi/6), digits=3)\n0.866 + 0.5im\n\n\n\n\n\n"},{"title":"Base.cos","page":"Mathematics","location":"base/math.html#Base.cos-Tuple{Number}","category":"method","text":"cos(x::T) where {T <: Number} -> float(T)\n\nCompute cosine of x, where x is in radians.\n\nThrow a DomainError if isinf(x), return a T(NaN) if isnan(x).\n\nSee also cosd, cospi, sincos, cis.\n\n\n\n\n\n"},{"title":"Base.Math.sincos","page":"Mathematics","location":"base/math.html#Base.Math.sincos-Tuple{Float64}","category":"method","text":"sincos(x::T) where T -> Tuple{float(T),float(T)}\n\nSimultaneously compute the sine and cosine of x, where x is in radians, returning\na tuple (sine, cosine).\n\nThrow a DomainError if isinf(x), return a (T(NaN), T(NaN)) if isnan(x).\n\nSee also cis, sincospi, sincosd.\n\n\n\n\n\n"},{"title":"Base.tan","page":"Mathematics","location":"base/math.html#Base.tan-Tuple{Number}","category":"method","text":"tan(x::T) where {T <: Number} -> float(T)\n\nCompute tangent of x, where x is in radians.\n\nThrow a DomainError if isinf(x), return a T(NaN) if isnan(x).\n\nSee also tanh.\n\n\n\n\n\n"},{"title":"Base.asin","page":"Mathematics","location":"base/math.html#Base.asin-Tuple{Number}","category":"method","text":"asin(x::T) where {T <: Number} -> float(T)\n\nCompute the inverse sine of x, where the output is in radians.\n\nReturn a T(NaN) if isnan(x).\n\nSee also asind for output in degrees.\n\nExamples\n\njulia> asin.((0, 1/2, 1))\n(0.0, 0.5235987755982989, 1.5707963267948966)\n\njulia> asind.((0, 1/2, 1))\n(0.0, 30.000000000000004, 90.0)\n\n\n\n\n\n"},{"title":"Base.acos","page":"Mathematics","location":"base/math.html#Base.acos-Tuple{Number}","category":"method","text":"acos(x::T) where {T <: Number} -> float(T)\n\nCompute the inverse cosine of x, where the output is in radians.\n\nReturn a T(NaN) if isnan(x).\n\n\n\n\n\n"},{"title":"Base.atan","page":"Mathematics","location":"base/math.html#Base.atan-Tuple{Number}","category":"method","text":"atan(y)\natan(y, x)\n\nCompute the inverse tangent of y or y/x, respectively.\n\nFor one real argument, this is the angle in radians between the positive x-axis and the point\n(1, y), returning a value in the interval -pi2 pi2.\n\nFor two arguments, this is the angle in radians between the positive x-axis and the\npoint (x, y), returning a value in the interval -pi pi. This corresponds to a\nstandard atan2 function. Note that by convention\natan(0.0,x) is defined as pi and atan(-0.0,x) is defined as -pi when x < 0.\n\nSee also atand for degrees.\n\nExamples\n\njulia> rad2deg(atan(-1/√3))\n-30.000000000000004\n\njulia> rad2deg(atan(-1, √3))\n-30.000000000000004\n\njulia> rad2deg(atan(1, -√3))\n150.0\n\n\n\n\n\n"},{"title":"Base.Math.sec","page":"Mathematics","location":"base/math.html#Base.Math.sec-Tuple{Number}","category":"method","text":"sec(x::T) where {T <: Number} -> float(T)\n\nCompute the secant of x, where x is in radians.\n\nThrow a DomainError if isinf(x), return a T(NaN) if isnan(x).\n\n\n\n\n\n"},{"title":"Base.Math.csc","page":"Mathematics","location":"base/math.html#Base.Math.csc-Tuple{Number}","category":"method","text":"csc(x::T) where {T <: Number} -> float(T)\n\nCompute the cosecant of x, where x is in radians.\n\nThrow a DomainError if isinf(x), return a T(NaN) if isnan(x).\n\n\n\n\n\n"},{"title":"Base.Math.cot","page":"Mathematics","location":"base/math.html#Base.Math.cot-Tuple{Number}","category":"method","text":"cot(x::T) where {T <: Number} -> float(T)\n\nCompute the cotangent of x, where x is in radians.\n\nThrow a DomainError if isinf(x), return a T(NaN) if isnan(x).\n\n\n\n\n\n"},{"title":"Base.Math.asec","page":"Mathematics","location":"base/math.html#Base.Math.asec-Tuple{Number}","category":"method","text":"asec(x::T) where {T <: Number} -> float(T)\n\nCompute the inverse secant of x, where the output is in radians.\n\n\n\n\n\n"},{"title":"Base.Math.acsc","page":"Mathematics","location":"base/math.html#Base.Math.acsc-Tuple{Number}","category":"method","text":"acsc(x::T) where {T <: Number} -> float(T)\n\nCompute the inverse cosecant of x, where the output is in radians.\n\n\n\n\n\n"},{"title":"Base.Math.acot","page":"Mathematics","location":"base/math.html#Base.Math.acot-Tuple{Number}","category":"method","text":"acot(x::T) where {T <: Number} -> float(T)\n\nCompute the inverse cotangent of x, where the output is in radians.\n\n\n\n\n\n"},{"title":"Base.Math.sind","page":"Mathematics","location":"base/math.html#Base.Math.sind","category":"function","text":"sind(x::T) where T -> float(T)\n\nCompute sine of x, where x is in degrees.\nIf x is a matrix, x needs to be a square matrix.\n\nThrow a DomainError if isinf(x), return a T(NaN) if isnan(x).\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n"},{"title":"Base.Math.cosd","page":"Mathematics","location":"base/math.html#Base.Math.cosd","category":"function","text":"cosd(x::T) where T -> float(T)\n\nCompute cosine of x, where x is in degrees.\nIf x is a matrix, x needs to be a square matrix.\n\nThrow a DomainError if isinf(x), return a T(NaN) if isnan(x).\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n"},{"title":"Base.Math.tand","page":"Mathematics","location":"base/math.html#Base.Math.tand","category":"function","text":"tand(x::T) where T -> float(T)\n\nCompute tangent of x, where x is in degrees.\nIf x is a matrix, x needs to be a square matrix.\n\nThrow a DomainError if isinf(x), return a T(NaN) if isnan(x).\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n"},{"title":"Base.Math.sincosd","page":"Mathematics","location":"base/math.html#Base.Math.sincosd","category":"function","text":"sincosd(x::T) where T -> Tuple{float(T),float(T)}\n\nSimultaneously compute the sine and cosine of x, where x is in degrees, returning\na tuple (sine, cosine).\n\nThrow a DomainError if isinf(x), return a (T(NaN), T(NaN)) tuple if isnan(x).\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n"},{"title":"Base.Math.asind","page":"Mathematics","location":"base/math.html#Base.Math.asind","category":"function","text":"asind(x)\n\nCompute the inverse sine of x, where the output is in degrees.\nIf x is a matrix, x needs to be a square matrix.\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n"},{"title":"Base.Math.acosd","page":"Mathematics","location":"base/math.html#Base.Math.acosd","category":"function","text":"acosd(x)\n\nCompute the inverse cosine of x, where the output is in degrees.\nIf x is a matrix, x needs to be a square matrix.\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n"},{"title":"Base.Math.atand","page":"Mathematics","location":"base/math.html#Base.Math.atand","category":"function","text":"atand(y::T) where T -> float(T)\natand(y::T, x::S) where {T,S} -> promote_type(T,S)\natand(y::AbstractMatrix{T}) where T -> AbstractMatrix{Complex{float(T)}}\n\nCompute the inverse tangent of y or y/x, respectively, where the output is in degrees.\n\nReturn a NaN if isnan(y) or isnan(x). The returned NaN is either a T in the single\nargument version, or a promote_type(T,S) in the two argument version.\n\ncompat: Julia 1.7\nThe one-argument method supports square matrix arguments as of Julia 1.7.\n\n\n\n\n\n"},{"title":"Base.Math.secd","page":"Mathematics","location":"base/math.html#Base.Math.secd","category":"function","text":"secd(x::T) where {T <: Number} -> float(T)\n\nCompute the secant of x, where x is in degrees.\n\nThrow a DomainError if isinf(x), return a T(NaN) if isnan(x).\n\n\n\n\n\n"},{"title":"Base.Math.cscd","page":"Mathematics","location":"base/math.html#Base.Math.cscd","category":"function","text":"cscd(x::T) where {T <: Number} -> float(T)\n\nCompute the cosecant of x, where x is in degrees.\n\nThrow a DomainError if isinf(x), return a T(NaN) if isnan(x).\n\n\n\n\n\n"},{"title":"Base.Math.cotd","page":"Mathematics","location":"base/math.html#Base.Math.cotd","category":"function","text":"cotd(x::T) where {T <: Number} -> float(T)\n\nCompute the cotangent of x, where x is in degrees.\n\nThrow a DomainError if isinf(x), return a T(NaN) if isnan(x).\n\n\n\n\n\n"},{"title":"Base.Math.asecd","page":"Mathematics","location":"base/math.html#Base.Math.asecd","category":"function","text":"asecd(x)\n\nCompute the inverse secant of x, where the output is in degrees.\nIf x is a matrix, x needs to be a square matrix.\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n"},{"title":"Base.Math.acscd","page":"Mathematics","location":"base/math.html#Base.Math.acscd","category":"function","text":"acscd(x)\n\nCompute the inverse cosecant of x, where the output is in degrees.\nIf x is a matrix, x needs to be a square matrix.\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n"},{"title":"Base.Math.acotd","page":"Mathematics","location":"base/math.html#Base.Math.acotd","category":"function","text":"acotd(x)\n\nCompute the inverse cotangent of x, where the output is in degrees.\nIf x is a matrix, x needs to be a square matrix.\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n"},{"title":"Base.Math.sinpi","page":"Mathematics","location":"base/math.html#Base.Math.sinpi","category":"function","text":"sinpi(x::T) where T -> float(T)\n\nCompute sin(pi x) more accurately than sin(pi*x), especially for large x.\n\nThrow a DomainError if isinf(x), return a T(NaN) if isnan(x).\n\nSee also sind, cospi, sincospi.\n\n\n\n\n\n"},{"title":"Base.Math.cospi","page":"Mathematics","location":"base/math.html#Base.Math.cospi","category":"function","text":"cospi(x::T) where T -> float(T)\n\nCompute cos(pi x) more accurately than cos(pi*x), especially for large x.\n\nThrow a DomainError if isinf(x), return a T(NaN) if isnan(x).\n\nSee also: cispi, sincosd, sinpi.\n\n\n\n\n\n"},{"title":"Base.Math.tanpi","page":"Mathematics","location":"base/math.html#Base.Math.tanpi","category":"function","text":"tanpi(x::T) where T -> float(T)\n\nCompute tan(pi x) more accurately than tan(pi*x), especially for large x.\n\nThrow a DomainError if isinf(x), return a T(NaN) if isnan(x).\n\ncompat: Julia 1.10\nThis function requires at least Julia 1.10.\n\nSee also tand, sinpi, cospi, sincospi.\n\n\n\n\n\n"},{"title":"Base.Math.sincospi","page":"Mathematics","location":"base/math.html#Base.Math.sincospi","category":"function","text":"sincospi(x::T) where T -> Tuple{float(T),float(T)}\n\nSimultaneously compute sinpi(x) and cospi(x) (the sine and cosine of π*x,\nwhere x is in radians), returning a tuple (sine, cosine).\n\nThrow a DomainError if isinf(x), return a (T(NaN), T(NaN)) tuple if isnan(x).\n\ncompat: Julia 1.6\nThis function requires Julia 1.6 or later.\n\nSee also: cispi, sincosd, sinpi.\n\n\n\n\n\n"},{"title":"Base.sinh","page":"Mathematics","location":"base/math.html#Base.sinh-Tuple{Number}","category":"method","text":"sinh(x)\n\nCompute hyperbolic sine of x.\n\nSee also sin.\n\n\n\n\n\n"},{"title":"Base.cosh","page":"Mathematics","location":"base/math.html#Base.cosh-Tuple{Number}","category":"method","text":"cosh(x)\n\nCompute hyperbolic cosine of x.\n\nSee also cos.\n\n\n\n\n\n"},{"title":"Base.tanh","page":"Mathematics","location":"base/math.html#Base.tanh-Tuple{Number}","category":"method","text":"tanh(x)\n\nCompute hyperbolic tangent of x.\n\nSee also tan, atanh.\n\nExamples\n\njulia> tanh.(-3:3f0)  # Here 3f0 isa Float32\n7-element Vector{Float32}:\n -0.9950548\n -0.9640276\n -0.7615942\n  0.0\n  0.7615942\n  0.9640276\n  0.9950548\n\njulia> tan.(im .* (1:3))\n3-element Vector{ComplexF64}:\n 0.0 + 0.7615941559557649im\n 0.0 + 0.9640275800758169im\n 0.0 + 0.9950547536867306im\n\n\n\n\n\n"},{"title":"Base.asinh","page":"Mathematics","location":"base/math.html#Base.asinh-Tuple{Number}","category":"method","text":"asinh(x)\n\nCompute the inverse hyperbolic sine of x.\n\n\n\n\n\n"},{"title":"Base.acosh","page":"Mathematics","location":"base/math.html#Base.acosh-Tuple{Number}","category":"method","text":"acosh(x)\n\nCompute the inverse hyperbolic cosine of x.\n\n\n\n\n\n"},{"title":"Base.atanh","page":"Mathematics","location":"base/math.html#Base.atanh-Tuple{Number}","category":"method","text":"atanh(x)\n\nCompute the inverse hyperbolic tangent of x.\n\n\n\n\n\n"},{"title":"Base.Math.sech","page":"Mathematics","location":"base/math.html#Base.Math.sech-Tuple{Number}","category":"method","text":"sech(x::T) where {T <: Number} -> float(T)\n\nCompute the hyperbolic secant of x.\n\nReturn a T(NaN) if isnan(x).\n\n\n\n\n\n"},{"title":"Base.Math.csch","page":"Mathematics","location":"base/math.html#Base.Math.csch-Tuple{Number}","category":"method","text":"csch(x::T) where {T <: Number} -> float(T)\n\nCompute the hyperbolic cosecant of x.\n\nReturn a T(NaN) if isnan(x).\n\n\n\n\n\n"},{"title":"Base.Math.coth","page":"Mathematics","location":"base/math.html#Base.Math.coth-Tuple{Number}","category":"method","text":"coth(x::T) where {T <: Number} -> float(T)\n\nCompute the hyperbolic cotangent of x.\n\nReturn a T(NaN) if isnan(x).\n\n\n\n\n\n"},{"title":"Base.Math.asech","page":"Mathematics","location":"base/math.html#Base.Math.asech-Tuple{Number}","category":"method","text":"asech(x::T) where {T <: Number} -> float(T)\n\nCompute the inverse hyperbolic secant of x.\n\n\n\n\n\n"},{"title":"Base.Math.acsch","page":"Mathematics","location":"base/math.html#Base.Math.acsch-Tuple{Number}","category":"method","text":"acsch(x::T) where {T <: Number} -> float(T)\n\nCompute the inverse hyperbolic cosecant of x.\n\n\n\n\n\n"},{"title":"Base.Math.acoth","page":"Mathematics","location":"base/math.html#Base.Math.acoth-Tuple{Number}","category":"method","text":"acoth(x::T) where {T <: Number} -> float(T)\n\nCompute the inverse hyperbolic cotangent of x.\n\n\n\n\n\n"},{"title":"Base.Math.sinc","page":"Mathematics","location":"base/math.html#Base.Math.sinc","category":"function","text":"sinc(x::T) where {T <: Number} -> float(T)\n\nCompute normalized sinc function operatornamesinc(x) = sin(pi x)  (pi x) if x neq 0, and 1 if x = 0.\n\nReturn a T(NaN) if isnan(x).\n\nSee also cosc, its derivative.\n\n\n\n\n\n"},{"title":"Base.Math.cosc","page":"Mathematics","location":"base/math.html#Base.Math.cosc","category":"function","text":"cosc(x::T) where {T <: Number} -> float(T)\n\nCompute cos(pi x)  x - sin(pi x)  (pi x^2) if x neq 0, and 0 if\nx = 0. This is the derivative of sinc(x).\n\nReturn a T(NaN) if isnan(x).\n\nSee also sinc.\n\n\n\n\n\n"},{"title":"Base.Math.deg2rad","page":"Mathematics","location":"base/math.html#Base.Math.deg2rad","category":"function","text":"deg2rad(x)\n\nConvert x from degrees to radians.\n\nSee also rad2deg, sind, pi.\n\nExamples\n\njulia> deg2rad(90)\n1.5707963267948966\n\n\n\n\n\n"},{"title":"Base.Math.rad2deg","page":"Mathematics","location":"base/math.html#Base.Math.rad2deg","category":"function","text":"rad2deg(x)\n\nConvert x from radians to degrees.\n\nSee also deg2rad.\n\nExamples\n\njulia> rad2deg(pi)\n180.0\n\n\n\n\n\n"},{"title":"Base.Math.hypot","page":"Mathematics","location":"base/math.html#Base.Math.hypot","category":"function","text":"hypot(x, y)\n\nCompute the hypotenuse sqrtx^2+y^2 avoiding overflow and underflow.\n\nThis code is an implementation of the algorithm described in:\nAn Improved Algorithm for hypot(a,b) by Carlos F. Borges\n\nhypot(x...)\n\nCompute the hypotenuse sqrtsum x_i^2 avoiding overflow and underflow.\n\nSee also norm in the LinearAlgebra standard library.\n\nExamples\n\njulia> a = Int64(10)^10;\n\njulia> hypot(a, a)\n1.4142135623730951e10\n\njulia> √(a^2 + a^2) # a^2 overflows\nERROR: DomainError with -2.914184810805068e18:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n\njulia> hypot(3, 4im)\n5.0\n\njulia> hypot(-5.7)\n5.7\n\njulia> hypot(3, 4im, 12.0)\n13.0\n\njulia> using LinearAlgebra\n\njulia> norm([a, a, a, a]) == hypot(a, a, a, a)\ntrue\n\n\n\n\n\n"},{"title":"Base.log","page":"Mathematics","location":"base/math.html#Base.log-Tuple{Number}","category":"method","text":"log(x)\n\nCompute the natural logarithm of x.\n\nThrow a DomainError for negative Real arguments.\nUse Complex arguments to obtain Complex results.\n\nnote: Branch cut\nlog has a branch cut along the negative real axis; -0.0im is taken\nto be below the axis.\n\nSee also ℯ, log1p, log2, log10.\n\nExamples\n\njulia> log(2)\n0.6931471805599453\n\njulia> log(-3)\nERROR: DomainError with -3.0:\nlog was called with a negative real argument but will only return a complex result if called with a complex argument. Try log(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31\n[...]\n\njulia> log(-3 + 0im)\n1.0986122886681098 + 3.141592653589793im\n\njulia> log(-3 - 0.0im)\n1.0986122886681098 - 3.141592653589793im\n\njulia> log.(exp.(-1:1))\n3-element Vector{Float64}:\n -1.0\n  0.0\n  1.0\n\n\n\n\n\n"},{"title":"Base.log","page":"Mathematics","location":"base/math.html#Base.log-Tuple{Number, Number}","category":"method","text":"log(b,x)\n\nCompute the base b logarithm of x. Throw a DomainError for negative\nReal arguments.\n\nExamples\n\njulia> log(4,8)\n1.5\n\njulia> log(4,2)\n0.5\n\njulia> log(-2, 3)\nERROR: DomainError with -2.0:\nlog was called with a negative real argument but will only return a complex result if called with a complex argument. Try log(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31\n[...]\n\njulia> log(2, -3)\nERROR: DomainError with -3.0:\nlog was called with a negative real argument but will only return a complex result if called with a complex argument. Try log(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31\n[...]\n\nnote: Note\nIf b is a power of 2 or 10, log2 or log10 should be used, as these will\ntypically be faster and more accurate. For example,julia> log(100,1000000)\n2.9999999999999996\n\njulia> log10(1000000)/2\n3.0\n\n\n\n\n\n"},{"title":"Base.log2","page":"Mathematics","location":"base/math.html#Base.log2","category":"function","text":"log2(x)\n\nCompute the logarithm of x to base 2. Throw a DomainError for negative\nReal arguments.\n\nSee also: exp2, ldexp, ispow2.\n\nExamples\n\njulia> log2(4)\n2.0\n\njulia> log2(10)\n3.321928094887362\n\njulia> log2(-2)\nERROR: DomainError with -2.0:\nlog2 was called with a negative real argument but will only return a complex result if called with a complex argument. Try log2(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(f::Symbol, x::Float64) at ./math.jl:31\n[...]\n\njulia> log2.(2.0 .^ (-1:1))\n3-element Vector{Float64}:\n -1.0\n  0.0\n  1.0\n\n\n\n\n\n"},{"title":"Base.log10","page":"Mathematics","location":"base/math.html#Base.log10","category":"function","text":"log10(x)\n\nCompute the logarithm of x to base 10.\nThrow a DomainError for negative Real arguments.\n\nExamples\n\njulia> log10(100)\n2.0\n\njulia> log10(2)\n0.3010299956639812\n\njulia> log10(-2)\nERROR: DomainError with -2.0:\nlog10 was called with a negative real argument but will only return a complex result if called with a complex argument. Try log10(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(f::Symbol, x::Float64) at ./math.jl:31\n[...]\n\n\n\n\n\n"},{"title":"Base.log1p","page":"Mathematics","location":"base/math.html#Base.log1p","category":"function","text":"log1p(x)\n\nAccurate natural logarithm of 1+x. Throw a DomainError for Real\narguments less than -1.\n\nExamples\n\njulia> log1p(-0.5)\n-0.6931471805599453\n\njulia> log1p(0)\n0.0\n\njulia> log1p(-2)\nERROR: DomainError with -2.0:\nlog1p was called with a real argument < -1 but will only return a complex result if called with a complex argument. Try log1p(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31\n[...]\n\n\n\n\n\n"},{"title":"Base.exp","page":"Mathematics","location":"base/math.html#Base.exp-Tuple{Float64}","category":"method","text":"exp(x)\n\nCompute the natural base exponential of x, in other words ℯ^x.\n\nSee also exp2, exp10 and cis.\n\nExamples\n\njulia> exp(1.0)\n2.718281828459045\n\njulia> exp(im * pi) ≈ cis(pi)\ntrue\n\n\n\n\n\n"},{"title":"Base.exp2","page":"Mathematics","location":"base/math.html#Base.exp2","category":"function","text":"exp2(x)\n\nCompute the base 2 exponential of x, in other words 2^x.\n\nSee also ldexp, <<.\n\nExamples\n\njulia> exp2(5)\n32.0\n\njulia> 2^5\n32\n\njulia> exp2(63) > typemax(Int)\ntrue\n\n\n\n\n\n"},{"title":"Base.exp10","page":"Mathematics","location":"base/math.html#Base.exp10","category":"function","text":"exp10(x)\n\nCompute the base 10 exponential of x, in other words 10^x.\n\nExamples\n\njulia> exp10(2)\n100.0\n\njulia> 10^2\n100\n\n\n\n\n\n"},{"title":"Base.expm1","page":"Mathematics","location":"base/math.html#Base.expm1","category":"function","text":"expm1(x)\n\nAccurately compute e^x-1. It avoids the loss of precision involved in the direct\nevaluation of exp(x) - 1 for small values of x.\n\nExamples\n\njulia> expm1(1e-16)\n1.0e-16\n\njulia> exp(1e-16) - 1\n0.0\n\n\n\n\n\n"},{"title":"Base.round","page":"Mathematics","location":"base/math.html#Base.round","category":"function","text":"round([T,] x, [r::RoundingMode])\nround(x, [r::RoundingMode]; digits::Integer=0, base = 10)\nround(x, [r::RoundingMode]; sigdigits::Integer, base = 10)\n\nRounds the number x.\n\nWithout keyword arguments, x is rounded to an integer value, returning a value of type\nT, or of the same type of x if no T is provided. An InexactError will be\nthrown if the value is not representable by T, similar to convert.\n\nIf the digits keyword argument is provided, it rounds to the specified number of digits\nafter the decimal place (or before if digits is negative), in base base.\n\nIf the sigdigits keyword argument is provided, it rounds to the specified number of\nsignificant digits, in base base.\n\nThe RoundingMode r controls the direction of the rounding; the default is\nRoundNearest, which rounds to the nearest integer, with ties (fractional values\nof 0.5) being rounded to the nearest even integer. Note that round may give incorrect\nresults if the global rounding mode is changed (see rounding).\n\nWhen rounding to a floating point type, will round to integers representable by that type\n(and Inf) rather than true integers. Inf is treated as one ulp greater than the\nfloatmax(T) for purposes of determining \"nearest\", similar to convert.\n\nExamples\n\njulia> round(1.7)\n2.0\n\njulia> round(Int, 1.7)\n2\n\njulia> round(1.5)\n2.0\n\njulia> round(2.5)\n2.0\n\njulia> round(pi; digits=2)\n3.14\n\njulia> round(pi; digits=3, base=2)\n3.125\n\njulia> round(123.456; sigdigits=2)\n120.0\n\njulia> round(357.913; sigdigits=4, base=2)\n352.0\n\njulia> round(Float16, typemax(UInt128))\nInf16\n\njulia> floor(Float16, typemax(UInt128))\nFloat16(6.55e4)\n\nnote: Note\nRounding to specified digits in bases other than 2 can be inexact when\noperating on binary floating point numbers. For example, the Float64\nvalue represented by 1.15 is actually less than 1.15, yet will be\nrounded to 1.2. For example:julia> x = 1.15\n1.15\n\njulia> big(1.15)\n1.149999999999999911182158029987476766109466552734375\n\njulia> x < 115//100\ntrue\n\njulia> round(x, digits=1)\n1.2\n\nExtensions\n\nTo extend round to new numeric types, it is typically sufficient to define Base.round(x::NewType, r::RoundingMode).\n\n\n\n\n\n"},{"title":"Base.Rounding.RoundingMode","page":"Mathematics","location":"base/math.html#Base.Rounding.RoundingMode","category":"type","text":"RoundingMode\n\nA type used for controlling the rounding mode of floating point operations (via\nrounding/setrounding functions), or as\noptional arguments for rounding to the nearest integer (via the round\nfunction).\n\nCurrently supported rounding modes are:\n\nRoundNearest (default)\nRoundNearestTiesAway\nRoundNearestTiesUp\nRoundToZero\nRoundFromZero\nRoundUp\nRoundDown\n\ncompat: Julia 1.9\nRoundFromZero requires at least Julia 1.9. Prior versions support\nRoundFromZero for BigFloats only.\n\n\n\n\n\n"},{"title":"Base.Rounding.RoundNearest","page":"Mathematics","location":"base/math.html#Base.Rounding.RoundNearest","category":"constant","text":"RoundNearest\n\nThe default rounding mode. Rounds to the nearest integer, with ties (fractional values of\n0.5) being rounded to the nearest even integer.\n\n\n\n\n\n"},{"title":"Base.Rounding.RoundNearestTiesAway","page":"Mathematics","location":"base/math.html#Base.Rounding.RoundNearestTiesAway","category":"constant","text":"RoundNearestTiesAway\n\nRounds to nearest integer, with ties rounded away from zero (C/C++\nround behaviour).\n\n\n\n\n\n"},{"title":"Base.Rounding.RoundNearestTiesUp","page":"Mathematics","location":"base/math.html#Base.Rounding.RoundNearestTiesUp","category":"constant","text":"RoundNearestTiesUp\n\nRounds to nearest integer, with ties rounded toward positive infinity (Java/JavaScript\nround behaviour).\n\n\n\n\n\n"},{"title":"Base.Rounding.RoundToZero","page":"Mathematics","location":"base/math.html#Base.Rounding.RoundToZero","category":"constant","text":"RoundToZero\n\nround using this rounding mode is an alias for trunc.\n\n\n\n\n\n"},{"title":"Base.Rounding.RoundFromZero","page":"Mathematics","location":"base/math.html#Base.Rounding.RoundFromZero","category":"constant","text":"RoundFromZero\n\nRounds away from zero.\n\ncompat: Julia 1.9\nRoundFromZero requires at least Julia 1.9. Prior versions support\nRoundFromZero for BigFloats only.\n\nExamples\n\njulia> BigFloat(\"1.0000000000000001\", 5, RoundFromZero)\n1.06\n\n\n\n\n\n"},{"title":"Base.Rounding.RoundUp","page":"Mathematics","location":"base/math.html#Base.Rounding.RoundUp","category":"constant","text":"RoundUp\n\nround using this rounding mode is an alias for ceil.\n\n\n\n\n\n"},{"title":"Base.Rounding.RoundDown","page":"Mathematics","location":"base/math.html#Base.Rounding.RoundDown","category":"constant","text":"RoundDown\n\nround using this rounding mode is an alias for floor.\n\n\n\n\n\n"},{"title":"Base.round","page":"Mathematics","location":"base/math.html#Base.round-Tuple{Complex{<:AbstractFloat}, RoundingMode, RoundingMode}","category":"method","text":"round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]])\nround(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; digits=0, base=10)\nround(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; sigdigits, base=10)\n\nReturn the nearest integral value of the same type as the complex-valued z to z,\nbreaking ties using the specified RoundingModes. The first\nRoundingMode is used for rounding the real components while the\nsecond is used for rounding the imaginary components.\n\nRoundingModeReal and RoundingModeImaginary default to RoundNearest,\nwhich rounds to the nearest integer, with ties (fractional values of 0.5)\nbeing rounded to the nearest even integer.\n\nExamples\n\njulia> round(3.14 + 4.5im)\n3.0 + 4.0im\n\njulia> round(3.14 + 4.5im, RoundUp, RoundNearestTiesUp)\n4.0 + 5.0im\n\njulia> round(3.14159 + 4.512im; digits = 1)\n3.1 + 4.5im\n\njulia> round(3.14159 + 4.512im; sigdigits = 3)\n3.14 + 4.51im\n\n\n\n\n\n"},{"title":"Base.ceil","page":"Mathematics","location":"base/math.html#Base.ceil","category":"function","text":"ceil([T,] x)\nceil(x; digits::Integer= [, base = 10])\nceil(x; sigdigits::Integer= [, base = 10])\n\nceil(x) returns the nearest integral value of the same type as x that is greater than or\nequal to x.\n\nceil(T, x) converts the result to type T, throwing an InexactError if the ceiled\nvalue is not representable as a T.\n\nKeywords digits, sigdigits and base work as for round.\n\nTo support ceil for a new type, define Base.round(x::NewType, ::RoundingMode{:Up}).\n\n\n\n\n\n"},{"title":"Base.floor","page":"Mathematics","location":"base/math.html#Base.floor","category":"function","text":"floor([T,] x)\nfloor(x; digits::Integer= [, base = 10])\nfloor(x; sigdigits::Integer= [, base = 10])\n\nfloor(x) returns the nearest integral value of the same type as x that is less than or\nequal to x.\n\nfloor(T, x) converts the result to type T, throwing an InexactError if the floored\nvalue is not representable a T.\n\nKeywords digits, sigdigits and base work as for round.\n\nTo support floor for a new type, define Base.round(x::NewType, ::RoundingMode{:Down}).\n\n\n\n\n\n"},{"title":"Base.trunc","page":"Mathematics","location":"base/math.html#Base.trunc","category":"function","text":"trunc([T,] x)\ntrunc(x; digits::Integer= [, base = 10])\ntrunc(x; sigdigits::Integer= [, base = 10])\n\ntrunc(x) returns the nearest integral value of the same type as x whose absolute value\nis less than or equal to the absolute value of x.\n\ntrunc(T, x) converts the result to type T, throwing an InexactError if the truncated\nvalue is not representable a T.\n\nKeywords digits, sigdigits and base work as for round.\n\nTo support trunc for a new type, define Base.round(x::NewType, ::RoundingMode{:ToZero}).\n\nSee also: %, floor, unsigned, unsafe_trunc.\n\nExamples\n\njulia> trunc(2.22)\n2.0\n\njulia> trunc(-2.22, digits=1)\n-2.2\n\njulia> trunc(Int, -2.22)\n-2\n\n\n\n\n\n"},{"title":"Base.unsafe_trunc","page":"Mathematics","location":"base/math.html#Base.unsafe_trunc","category":"function","text":"unsafe_trunc(T, x)\n\nReturn the nearest integral value of type T whose absolute value is\nless than or equal to the absolute value of x. If the value is not representable by T,\nan arbitrary value will be returned.\nSee also trunc.\n\nExamples\n\njulia> unsafe_trunc(Int, -2.2)\n-2\n\njulia> unsafe_trunc(Int, NaN) isa Int\ntrue\n\n\n\n\n\n"},{"title":"Base.Math.modf","page":"Mathematics","location":"base/math.html#Base.Math.modf","category":"function","text":"modf(x)\n\nReturn a tuple (fpart, ipart) of the fractional and integral parts of a number. Both parts\nhave the same sign as the argument.\n\nExamples\n\njulia> modf(3.5)\n(0.5, 3.0)\n\njulia> modf(-3.5)\n(-0.5, -3.0)\n\n\n\n\n\n"},{"title":"Base.min","page":"Mathematics","location":"base/math.html#Base.min","category":"function","text":"min(x, y, ...)\n\nReturn the minimum of the arguments, with respect to isless.\nIf any of the arguments is missing, return missing.\nSee also the minimum function to take the minimum element from a collection.\n\nExamples\n\njulia> min(2, 5, 1)\n1\n\njulia> min(4, missing, 6)\nmissing\n\n\n\n\n\n"},{"title":"Base.max","page":"Mathematics","location":"base/math.html#Base.max","category":"function","text":"max(x, y, ...)\n\nReturn the maximum of the arguments, with respect to isless.\nIf any of the arguments is missing, return missing.\nSee also the maximum function to take the maximum element from a collection.\n\nExamples\n\njulia> max(2, 5, 1)\n5\n\njulia> max(5, missing, 6)\nmissing\n\n\n\n\n\n"},{"title":"Base.minmax","page":"Mathematics","location":"base/math.html#Base.minmax","category":"function","text":"minmax(x, y)\n\nReturn (min(x,y), max(x,y)).\n\nSee also extrema that returns (minimum(x), maximum(x)).\n\nExamples\n\njulia> minmax('c','b')\n('b', 'c')\n\n\n\n\n\n"},{"title":"Base.clamp","page":"Mathematics","location":"base/math.html#Base.clamp","category":"function","text":"clamp(x::Integer, r::AbstractUnitRange)\n\nClamp x to lie within range r.\n\ncompat: Julia 1.6\nThis method requires at least Julia 1.6.\n\n\n\n\n\nclamp(x, T)::T\n\nClamp x between typemin(T) and typemax(T) and convert the result to type T.\n\nSee also trunc.\n\nExamples\n\njulia> clamp(200, Int8)\n127\n\njulia> clamp(-200, Int8)\n-128\n\njulia> trunc(Int, 4pi^2)\n39\n\n\n\n\n\nclamp(x, lo, hi)\n\nReturn x if lo <= x <= hi. If x > hi, return hi. If x < lo, return lo. Arguments\nare promoted to a common type.\n\nSee also clamp!, min, max.\n\ncompat: Julia 1.3\nmissing as the first argument requires at least Julia 1.3.\n\nExamples\n\njulia> clamp.([pi, 1.0, big(10)], 2.0, 9.0)\n3-element Vector{BigFloat}:\n 3.141592653589793238462643383279502884197169399375105820974944592307816406286198\n 2.0\n 9.0\n\njulia> clamp.([11, 8, 5], 10, 6)  # an example where lo > hi\n3-element Vector{Int64}:\n  6\n  6\n 10\n\n\n\n\n\n"},{"title":"Base.clamp!","page":"Mathematics","location":"base/math.html#Base.clamp!","category":"function","text":"clamp!(array::AbstractArray, lo, hi)\n\nRestrict values in array to the specified range, in-place.\nSee also clamp.\n\ncompat: Julia 1.3\nmissing entries in array require at least Julia 1.3.\n\nExamples\n\njulia> row = collect(-4:4)';\n\njulia> clamp!(row, 0, Inf)\n1×9 adjoint(::Vector{Int64}) with eltype Int64:\n 0  0  0  0  0  1  2  3  4\n\njulia> clamp.((-4:4)', 0, Inf)\n1×9 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0  1.0  2.0  3.0  4.0\n\n\n\n\n\n"},{"title":"Base.Checked","page":"Mathematics","location":"base/math.html#Base.Checked","category":"module","text":"Checked\n\nThe Checked module provides arithmetic functions for the built-in signed and unsigned\nInteger types which throw an error when an overflow occurs. They are named like checked_sub,\nchecked_div, etc. In addition, add_with_overflow, sub_with_overflow, mul_with_overflow\nreturn both the unchecked results and a boolean value denoting the presence of an overflow.\n\n\n\n\n\n"},{"title":"Base.Checked.checked_abs","page":"Mathematics","location":"base/math.html#Base.Checked.checked_abs","category":"function","text":"Base.checked_abs(x)\n\nCalculates abs(x), checking for overflow errors where applicable.\nFor example, standard two's complement signed integers (e.g. Int)\ncannot represent abs(typemin(Int)), thus leading to an overflow.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n"},{"title":"Base.Checked.checked_neg","page":"Mathematics","location":"base/math.html#Base.Checked.checked_neg","category":"function","text":"Base.checked_neg(x)\n\nCalculates -x, checking for overflow errors where applicable. For\nexample, standard two's complement signed integers (e.g. Int) cannot\nrepresent -typemin(Int), thus leading to an overflow.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n"},{"title":"Base.Checked.checked_add","page":"Mathematics","location":"base/math.html#Base.Checked.checked_add","category":"function","text":"Base.checked_add(x, y)\n\nCalculates x+y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n"},{"title":"Base.Checked.checked_sub","page":"Mathematics","location":"base/math.html#Base.Checked.checked_sub","category":"function","text":"Base.checked_sub(x, y)\n\nCalculates x-y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n"},{"title":"Base.Checked.checked_mul","page":"Mathematics","location":"base/math.html#Base.Checked.checked_mul","category":"function","text":"Base.checked_mul(x, y)\n\nCalculates x*y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n"},{"title":"Base.Checked.checked_div","page":"Mathematics","location":"base/math.html#Base.Checked.checked_div","category":"function","text":"Base.checked_div(x, y)\n\nCalculates div(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n"},{"title":"Base.Checked.checked_rem","page":"Mathematics","location":"base/math.html#Base.Checked.checked_rem","category":"function","text":"Base.checked_rem(x, y)\n\nCalculates x%y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n"},{"title":"Base.Checked.checked_fld","page":"Mathematics","location":"base/math.html#Base.Checked.checked_fld","category":"function","text":"Base.checked_fld(x, y)\n\nCalculates fld(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n"},{"title":"Base.Checked.checked_mod","page":"Mathematics","location":"base/math.html#Base.Checked.checked_mod","category":"function","text":"Base.checked_mod(x, y)\n\nCalculates mod(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n"},{"title":"Base.Checked.checked_cld","page":"Mathematics","location":"base/math.html#Base.Checked.checked_cld","category":"function","text":"Base.checked_cld(x, y)\n\nCalculates cld(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n"},{"title":"Base.Checked.checked_pow","page":"Mathematics","location":"base/math.html#Base.Checked.checked_pow","category":"function","text":"Base.checked_pow(x, y)\n\nCalculates ^(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n"},{"title":"Base.Checked.add_with_overflow","page":"Mathematics","location":"base/math.html#Base.Checked.add_with_overflow","category":"function","text":"Base.add_with_overflow(x, y) -> (r, f)\n\nCalculates r = x+y, with the flag f indicating whether overflow has occurred.\n\n\n\n\n\n"},{"title":"Base.Checked.sub_with_overflow","page":"Mathematics","location":"base/math.html#Base.Checked.sub_with_overflow","category":"function","text":"Base.sub_with_overflow(x, y) -> (r, f)\n\nCalculates r = x-y, with the flag f indicating whether overflow has occurred.\n\n\n\n\n\n"},{"title":"Base.Checked.mul_with_overflow","page":"Mathematics","location":"base/math.html#Base.Checked.mul_with_overflow","category":"function","text":"Base.mul_with_overflow(x, y) -> (r, f)\n\nCalculates r = x*y, with the flag f indicating whether overflow has occurred.\n\n\n\n\n\n"},{"title":"Base.abs","page":"Mathematics","location":"base/math.html#Base.abs","category":"function","text":"abs(x)\n\nThe absolute value of x.\n\nWhen abs is applied to signed integers, overflow may occur,\nresulting in the return of a negative value. This overflow occurs only\nwhen abs is applied to the minimum representable value of a signed\ninteger. That is, when x == typemin(typeof(x)), abs(x) == x < 0,\nnot -x as might be expected.\n\nSee also: abs2, unsigned, sign.\n\nExamples\n\njulia> abs(-3)\n3\n\njulia> abs(1 + im)\n1.4142135623730951\n\njulia> abs.(Int8[-128 -127 -126 0 126 127])  # overflow at typemin(Int8)\n1×6 Matrix{Int8}:\n -128  127  126  0  126  127\n\njulia> maximum(abs, [1, -2, 3, -4])\n4\n\n\n\n\n\n"},{"title":"Base.abs2","page":"Mathematics","location":"base/math.html#Base.abs2","category":"function","text":"abs2(x)\n\nSquared absolute value of x.\n\nThis can be faster than abs(x)^2, especially for complex\nnumbers where abs(x) requires a square root via hypot.\n\nSee also abs, conj, real.\n\nExamples\n\njulia> abs2(-3)\n9\n\njulia> abs2(3.0 + 4.0im)\n25.0\n\njulia> sum(abs2, [1+2im, 3+4im])  # LinearAlgebra.norm(x)^2\n30\n\n\n\n\n\n"},{"title":"Base.uabs","page":"Mathematics","location":"base/math.html#Base.uabs","category":"function","text":"Base.uabs(x::Integer)\n\nReturn the absolute value of x, possibly returning a different type should the\noperation be susceptible to overflow. This typically arises when x is a two's complement\nsigned integer, so that abs(typemin(x)) == typemin(x) < 0, in which case the result of\nuabs(x) will be an unsigned integer of the same size.\n\n\n\n\n\n"},{"title":"Base.copysign","page":"Mathematics","location":"base/math.html#Base.copysign","category":"function","text":"copysign(x, y) -> z\n\nReturn z which has the magnitude of x and the same sign as y.\n\nExamples\n\njulia> copysign(1, -2)\n-1\n\njulia> copysign(-1, 2)\n1\n\n\n\n\n\n"},{"title":"Base.sign","page":"Mathematics","location":"base/math.html#Base.sign","category":"function","text":"sign(x)\n\nReturn zero if x==0 and xx otherwise (i.e., ±1 for real x).\n\nSee also signbit, zero, copysign, flipsign.\n\nExamples\n\njulia> sign(-4.0)\n-1.0\n\njulia> sign(99)\n1\n\njulia> sign(-0.0)\n-0.0\n\njulia> sign(0 + im)\n0.0 + 1.0im\n\n\n\n\n\n"},{"title":"Base.signbit","page":"Mathematics","location":"base/math.html#Base.signbit","category":"function","text":"signbit(x)\n\nReturn true if the value of the sign of x is negative, otherwise false.\n\nSee also sign and copysign.\n\nExamples\n\njulia> signbit(-4)\ntrue\n\njulia> signbit(5)\nfalse\n\njulia> signbit(5.5)\nfalse\n\njulia> signbit(-4.1)\ntrue\n\n\n\n\n\n"},{"title":"Base.flipsign","page":"Mathematics","location":"base/math.html#Base.flipsign","category":"function","text":"flipsign(x, y)\n\nReturn x with its sign flipped if y is negative. For example abs(x) = flipsign(x,x).\n\nExamples\n\njulia> flipsign(5, 3)\n5\n\njulia> flipsign(5, -3)\n-5\n\n\n\n\n\n"},{"title":"Base.sqrt","page":"Mathematics","location":"base/math.html#Base.sqrt-Tuple{Number}","category":"method","text":"sqrt(x)\n\nReturn sqrtx.\n\nThrow a DomainError for negative Real arguments.\nUse Complex negative arguments instead to obtain a Complex result.\n\nThe prefix operator √ is equivalent to sqrt.\n\nnote: Branch cut\nsqrt has a branch cut along the negative real axis; -0.0im is taken\nto be below the axis.\n\nSee also: hypot.\n\nExamples\n\njulia> sqrt(big(81))\n9.0\n\njulia> sqrt(big(-81))\nERROR: DomainError with -81.0:\nNaN result for non-NaN input.\nStacktrace:\n [1] sqrt(::BigFloat) at ./mpfr.jl:501\n[...]\n\njulia> sqrt(big(complex(-81)))\n0.0 + 9.0im\n\njulia> sqrt(-81 - 0.0im)  # -0.0im is below the branch cut\n0.0 - 9.0im\n\njulia> .√(1:4)\n4-element Vector{Float64}:\n 1.0\n 1.4142135623730951\n 1.7320508075688772\n 2.0\n\n\n\n\n\n"},{"title":"Base.isqrt","page":"Mathematics","location":"base/math.html#Base.isqrt","category":"function","text":"isqrt(n::Integer)\n\nInteger square root: the largest integer m such that m*m <= n.\n\njulia> isqrt(5)\n2\n\n\n\n\n\n"},{"title":"Base.Math.cbrt","page":"Mathematics","location":"base/math.html#Base.Math.cbrt-Tuple{AbstractFloat}","category":"method","text":"cbrt(x::Real)\n\nReturn the cube root of x, i.e. x^13. Negative values are accepted\n(returning the negative real root when x  0).\n\nThe prefix operator ∛ is equivalent to cbrt.\n\nExamples\n\njulia> cbrt(big(27))\n3.0\n\njulia> cbrt(big(-27))\n-3.0\n\n\n\n\n\n"},{"title":"Base.Math.fourthroot","page":"Mathematics","location":"base/math.html#Base.Math.fourthroot-Tuple{Number}","category":"method","text":"fourthroot(x)\n\nReturn the fourth root of x by applying sqrt twice successively.\n\n\n\n\n\n"},{"title":"Base.real","page":"Mathematics","location":"base/math.html#Base.real","category":"function","text":"real(A::AbstractArray)\n\nReturn an array containing the real part of each entry in array A.\n\nEquivalent to real.(A), except that when eltype(A) <: Real\nA is returned without copying, and that when A has zero dimensions,\na 0-dimensional array is returned (rather than a scalar).\n\nExamples\n\njulia> real([1, 2im, 3 + 4im])\n3-element Vector{Int64}:\n 1\n 0\n 3\n\njulia> real(fill(2 - im))\n0-dimensional Array{Int64, 0}:\n2\n\n\n\n\n\nreal(T::Type)\n\nReturn the type that represents the real part of a value of type T.\ne.g: for T == Complex{R}, returns R.\nEquivalent to typeof(real(zero(T))).\n\nExamples\n\njulia> real(Complex{Int})\nInt64\n\njulia> real(Float64)\nFloat64\n\n\n\n\n\nreal(z)\n\nReturn the real part of the complex number z.\n\nSee also: imag, reim, complex, isreal, Real.\n\nExamples\n\njulia> real(1 + 3im)\n1\n\n\n\n\n\n"},{"title":"Base.imag","page":"Mathematics","location":"base/math.html#Base.imag","category":"function","text":"imag(A::AbstractArray)\n\nReturn an array containing the imaginary part of each entry in array A.\n\nEquivalent to imag.(A), except that when A has zero dimensions,\na 0-dimensional array is returned (rather than a scalar).\n\nExamples\n\njulia> imag([1, 2im, 3 + 4im])\n3-element Vector{Int64}:\n 0\n 2\n 4\n\njulia> imag(fill(2 - im))\n0-dimensional Array{Int64, 0}:\n-1\n\n\n\n\n\nimag(z)\n\nReturn the imaginary part of the complex number z.\n\nSee also: conj, reim, adjoint, angle.\n\nExamples\n\njulia> imag(1 + 3im)\n3\n\n\n\n\n\n"},{"title":"Base.reim","page":"Mathematics","location":"base/math.html#Base.reim","category":"function","text":"reim(A::AbstractArray)\n\nReturn a tuple of two arrays containing respectively the real and the imaginary\npart of each entry in A.\n\nEquivalent to (real.(A), imag.(A)), except that when eltype(A) <: Real\nA is returned without copying to represent the real part, and that when A has\nzero dimensions, a 0-dimensional array is returned (rather than a scalar).\n\nExamples\n\njulia> reim([1, 2im, 3 + 4im])\n([1, 0, 3], [0, 2, 4])\n\njulia> reim(fill(2 - im))\n(fill(2), fill(-1))\n\n\n\n\n\nreim(z)\n\nReturn a tuple of the real and imaginary parts of the complex number z.\n\nExamples\n\njulia> reim(1 + 3im)\n(1, 3)\n\n\n\n\n\n"},{"title":"Base.conj","page":"Mathematics","location":"base/math.html#Base.conj","category":"function","text":"conj(A::AbstractArray)\n\nReturn an array containing the complex conjugate of each entry in array A.\n\nEquivalent to conj.(A), except that when eltype(A) <: Real\nA is returned without copying, and that when A has zero dimensions,\na 0-dimensional array is returned (rather than a scalar).\n\nExamples\n\njulia> conj([1, 2im, 3 + 4im])\n3-element Vector{Complex{Int64}}:\n 1 + 0im\n 0 - 2im\n 3 - 4im\n\njulia> conj(fill(2 - im))\n0-dimensional Array{Complex{Int64}, 0}:\n2 + 1im\n\n\n\n\n\nconj(z)\n\nCompute the complex conjugate of a complex number z.\n\nSee also: angle, adjoint.\n\nExamples\n\njulia> conj(1 + 3im)\n1 - 3im\n\n\n\n\n\n"},{"title":"Base.angle","page":"Mathematics","location":"base/math.html#Base.angle","category":"function","text":"angle(z)\n\nCompute the phase angle in radians of a complex number z.\n\nReturns a number -pi ≤ angle(z) ≤ pi, and is thus discontinuous\nalong the negative real axis.\n\nSee also: atan, cis, rad2deg.\n\nExamples\n\njulia> rad2deg(angle(1 + im))\n45.0\n\njulia> rad2deg(angle(1 - im))\n-45.0\n\njulia> rad2deg(angle(-1 + 1e-20im))\n180.0\n\njulia> rad2deg(angle(-1 - 1e-20im))\n-180.0\n\n\n\n\n\n"},{"title":"Base.cis","page":"Mathematics","location":"base/math.html#Base.cis","category":"function","text":"cis(x)\n\nMore efficient method for exp(im*x) by using Euler's formula: cos(x) + i sin(x) = exp(i x).\n\nSee also cispi, sincos, exp, angle.\n\nExamples\n\njulia> cis(π) ≈ -1\ntrue\n\n\n\n\n\n"},{"title":"Base.cispi","page":"Mathematics","location":"base/math.html#Base.cispi","category":"function","text":"cispi(x)\n\nMore accurate method for cis(pi*x) (especially for large x).\n\nSee also cis, sincospi, exp, angle.\n\nExamples\n\njulia> cispi(10000)\n1.0 + 0.0im\n\njulia> cispi(0.25 + 1im)\n0.030556854645954562 + 0.03055685464595456im\n\ncompat: Julia 1.6\nThis function requires Julia 1.6 or later.\n\n\n\n\n\n"},{"title":"Base.binomial","page":"Mathematics","location":"base/math.html#Base.binomial","category":"function","text":"binomial(x::Number, k::Integer)\n\nThe generalized binomial coefficient, defined for k ≥ 0 by\nthe polynomial\n\nfrac1k prod_j=0^k-1 (x - j)\n\nWhen k < 0 it returns zero.\n\nFor the case of integer x, this is equivalent to the ordinary\ninteger binomial coefficient\n\nbinomnk = fracnk (n-k)\n\nFurther generalizations to non-integer k are mathematically possible, but\ninvolve the Gamma function and/or the beta function, which are\nnot provided by the Julia standard library but are available\nin external packages such as SpecialFunctions.jl.\n\nExternal links\n\nBinomial coefficient on Wikipedia.\n\n\n\n\n\nbinomial(n::Integer, k::Integer)\n\nThe binomial coefficient binomnk, being the coefficient of the kth term in\nthe polynomial expansion of (1+x)^n.\n\nIf n is non-negative, then it is the number of ways to choose k out of n items:\n\nbinomnk = fracnk (n-k)\n\nwhere n is the factorial function.\n\nIf n is negative, then it is defined in terms of the identity\n\nbinomnk = (-1)^k binomk-n-1k\n\nSee also factorial.\n\nExamples\n\njulia> binomial(5, 3)\n10\n\njulia> factorial(5) ÷ (factorial(5-3) * factorial(3))\n10\n\njulia> binomial(-5, 3)\n-35\n\nExternal links\n\nBinomial coefficient on Wikipedia.\n\n\n\n\n\n"},{"title":"Base.factorial","page":"Mathematics","location":"base/math.html#Base.factorial","category":"function","text":"factorial(n::Integer)\n\nFactorial of n. If n is an Integer, the factorial is computed as an\ninteger (promoted to at least 64 bits). Note that this may overflow if n is not small,\nbut you can use factorial(big(n)) to compute the result exactly in arbitrary precision.\n\nSee also binomial.\n\nExamples\n\njulia> factorial(6)\n720\n\njulia> factorial(21)\nERROR: OverflowError: 21 is too large to look up in the table; consider using `factorial(big(21))` instead\nStacktrace:\n[...]\n\njulia> factorial(big(21))\n51090942171709440000\n\nExternal links\n\nFactorial on Wikipedia.\n\n\n\n\n\n"},{"title":"Base.gcd","page":"Mathematics","location":"base/math.html#Base.gcd","category":"function","text":"gcd(x, y...)\n\nGreatest common (positive) divisor (or zero if all arguments are zero).\nThe arguments may be integer and rational numbers.\n\na is a divisor of b if there exists an integer m such\nthat ma=b.\n\ncompat: Julia 1.4\nRational arguments require Julia 1.4 or later.\n\nExamples\n\njulia> gcd(6, 9)\n3\n\njulia> gcd(6, -9)\n3\n\njulia> gcd(6, 0)\n6\n\njulia> gcd(0, 0)\n0\n\njulia> gcd(1//3, 2//3)\n1//3\n\njulia> gcd(1//3, -2//3)\n1//3\n\njulia> gcd(1//3, 2)\n1//3\n\njulia> gcd(0, 0, 10, 15)\n5\n\n\n\n\n\n"},{"title":"Base.lcm","page":"Mathematics","location":"base/math.html#Base.lcm","category":"function","text":"lcm(x, y...)\n\nLeast common (positive) multiple (or zero if any argument is zero).\nThe arguments may be integer and rational numbers.\n\na is a multiple of b if there exists an integer m such\nthat a=mb.\n\ncompat: Julia 1.4\nRational arguments require Julia 1.4 or later.\n\nExamples\n\njulia> lcm(2, 3)\n6\n\njulia> lcm(-2, 3)\n6\n\njulia> lcm(0, 3)\n0\n\njulia> lcm(0, 0)\n0\n\njulia> lcm(1//3, 2//3)\n2//3\n\njulia> lcm(1//3, -2//3)\n2//3\n\njulia> lcm(1//3, 2)\n2//1\n\njulia> lcm(1, 3, 5, 7)\n105\n\n\n\n\n\n"},{"title":"Base.gcdx","page":"Mathematics","location":"base/math.html#Base.gcdx","category":"function","text":"gcdx(a, b...)\n\nCompute the greatest common (positive) divisor of a and b and their Bézout\ncoefficients, i.e. the integer coefficients u and v that satisfy\nu*a + v*b = d = gcd(a b). gcdx(a b) returns (d u v).\n\nFor more arguments than two, i.e., gcdx(a, b, c, ...) the Bézout coefficients are computed\nrecursively, returning a solution (d, u, v, w, ...) to\nu*a + v*b + w*c +  = d = gcd(a b c ).\n\nThe arguments may be integer and rational numbers.\n\ncompat: Julia 1.4\nRational arguments require Julia 1.4 or later.\n\ncompat: Julia 1.12\nMore or fewer arguments than two require Julia 1.12 or later.\n\nExamples\n\njulia> gcdx(12, 42)\n(6, -3, 1)\n\njulia> gcdx(240, 46)\n(2, -9, 47)\n\njulia> gcdx(15, 12, 20)\n(1, 7, -7, -1)\n\nnote: Note\nBézout coefficients are not uniquely defined. gcdx returns the minimal\nBézout coefficients that are computed by the extended Euclidean algorithm.\n(Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.)\nFor signed integers, these coefficients u and v are minimal in\nthe sense that u  bd and v  ad. Furthermore,\nthe signs of u and v are chosen so that d is positive.\nFor unsigned integers, the coefficients u and v might be near\ntheir typemax, and the identity then holds only via the unsigned\nintegers' modulo arithmetic.\n\n\n\n\n\n"},{"title":"Base.ispow2","page":"Mathematics","location":"base/math.html#Base.ispow2","category":"function","text":"ispow2(n::Number)::Bool\n\nTest whether n is an integer power of two.\n\nSee also count_ones, prevpow, nextpow.\n\nExamples\n\njulia> ispow2(4)\ntrue\n\njulia> ispow2(5)\nfalse\n\njulia> ispow2(4.5)\nfalse\n\njulia> ispow2(0.25)\ntrue\n\njulia> ispow2(1//8)\ntrue\n\ncompat: Julia 1.6\nSupport for non-Integer arguments was added in Julia 1.6.\n\n\n\n\n\n"},{"title":"Base.nextpow","page":"Mathematics","location":"base/math.html#Base.nextpow","category":"function","text":"nextpow(a, x)\n\nThe smallest a^n not less than x, where n is a non-negative integer. a must be\ngreater than 1, and x must be greater than 0.\n\nSee also prevpow.\n\nExamples\n\njulia> nextpow(2, 7)\n8\n\njulia> nextpow(2, 9)\n16\n\njulia> nextpow(5, 20)\n25\n\njulia> nextpow(4, 16)\n16\n\n\n\n\n\n"},{"title":"Base.prevpow","page":"Mathematics","location":"base/math.html#Base.prevpow","category":"function","text":"prevpow(a, x)\n\nThe largest a^n not greater than x, where n is a non-negative integer.\na must be greater than 1, and x must not be less than 1.\n\nSee also nextpow, isqrt.\n\nExamples\n\njulia> prevpow(2, 7)\n4\n\njulia> prevpow(2, 9)\n8\n\njulia> prevpow(5, 20)\n5\n\njulia> prevpow(4, 16)\n16\n\n\n\n\n\n"},{"title":"Base.nextprod","page":"Mathematics","location":"base/math.html#Base.nextprod","category":"function","text":"nextprod(factors::Union{Tuple,AbstractVector}, n)\n\nNext integer greater than or equal to n that can be written as prod k_i^p_i for integers\np_1, p_2, etcetera, for factors k_i in factors.\n\nExamples\n\njulia> nextprod((2, 3), 105)\n108\n\njulia> 2^2 * 3^3\n108\n\ncompat: Julia 1.6\nThe method that accepts a tuple requires Julia 1.6 or later.\n\n\n\n\n\n"},{"title":"Base.invmod","page":"Mathematics","location":"base/math.html#Base.invmod","category":"function","text":"invmod(n::Integer, T) where {T <: Base.BitInteger}\ninvmod(n::T) where {T <: Base.BitInteger}\n\nCompute the modular inverse of n in the integer ring of type T, i.e. modulo\n2^N where N = 8*sizeof(T) (e.g. N = 32 for Int32). In other words, these\nmethods satisfy the following identities:\n\nn * invmod(n) == 1\n(n * invmod(n, T)) % T == 1\n(n % T) * invmod(n, T) == 1\n\nNote that * here is modular multiplication in the integer ring, T.  This will\nthrow an error if n is even, because then it is not relatively prime with 2^N\nand thus has no such inverse.\n\nSpecifying the modulus implied by an integer type as an explicit value is often\ninconvenient since the modulus is by definition too big to be represented by the\ntype.\n\nThe modular inverse is computed much more efficiently than the general case\nusing the algorithm described in [An Improved Integer Modular Multiplicative\nInverse (modulo 2^w) by Jeffrey Hurchalla](https://arxiv.org/abs/2204.04342).\n\ncompat: Julia 1.11\nThe invmod(n) and invmod(n, T) methods require Julia 1.11 or later.\n\n\n\n\n\ninvmod(n::Integer, m::Integer)\n\nTake the inverse of n modulo m: y such that n y = 1 pmod m,\nand div(ym) = 0. This will throw an error if m = 0, or if\ngcd(nm) neq 1.\n\nExamples\n\njulia> invmod(2, 5)\n3\n\njulia> invmod(2, 3)\n2\n\njulia> invmod(5, 6)\n5\n\n\n\n\n\n"},{"title":"Base.powermod","page":"Mathematics","location":"base/math.html#Base.powermod","category":"function","text":"powermod(x::Integer, p::Integer, m)\n\nCompute x^p pmod m.\n\nExamples\n\njulia> powermod(2, 6, 5)\n4\n\njulia> mod(2^6, 5)\n4\n\njulia> powermod(5, 2, 20)\n5\n\njulia> powermod(5, 2, 19)\n6\n\njulia> powermod(5, 3, 19)\n11\n\n\n\n\n\n"},{"title":"Base.add_sum","page":"Mathematics","location":"base/math.html#Base.add_sum","category":"function","text":"Base.add_sum(x, y)\n\nThe reduction operator used in sum. The main difference from + is that small\nintegers are promoted to Int/UInt.\n\n\n\n\n\n"},{"title":"Base.widemul","page":"Mathematics","location":"base/math.html#Base.widemul","category":"function","text":"widemul(x, y)\n\nMultiply x and y, giving the result as a larger type.\n\nSee also promote, Base.add_sum.\n\nExamples\n\njulia> widemul(Float32(3.0), 4.0) isa BigFloat\ntrue\n\njulia> typemax(Int8) * typemax(Int8)\n1\n\njulia> widemul(typemax(Int8), typemax(Int8))  # == 127^2\n16129\n\n\n\n\n\n"},{"title":"Base.Math.evalpoly","page":"Mathematics","location":"base/math.html#Base.Math.evalpoly","category":"function","text":"evalpoly(x, p)\n\nEvaluate the polynomial sum_k x^k-1 pk for the coefficients p[1], p[2], ...;\nthat is, the coefficients are given in ascending order by power of x.\nLoops are unrolled at compile time if the number of coefficients is statically known, i.e.\nwhen p is a Tuple.\nThis function generates efficient code using Horner's method if x is real, or using\na Goertzel-like [DK62] algorithm if x is complex.\n\n[DK62]: Donald Knuth, Art of Computer Programming, Volume 2: Seminumerical Algorithms, Sec. 4.6.4.\n\ncompat: Julia 1.4\nThis function requires Julia 1.4 or later.\n\nExamples\n\njulia> evalpoly(2, (1, 2, 3))\n17\n\n\n\n\n\n"},{"title":"Base.Math.@evalpoly","page":"Mathematics","location":"base/math.html#Base.Math.@evalpoly","category":"macro","text":"@evalpoly(z, c...)\n\nEvaluate the polynomial sum_k z^k-1 ck for the coefficients c[1], c[2], ...;\nthat is, the coefficients are given in ascending order by power of z.  This macro expands\nto efficient inline code that uses either Horner's method or, for complex z, a more\nefficient Goertzel-like algorithm.\n\nSee also evalpoly.\n\nExamples\n\njulia> @evalpoly(3, 1, 0, 1)\n10\n\njulia> @evalpoly(2, 1, 0, 1)\n5\n\njulia> @evalpoly(2, 1, 1, 1)\n7\n\n\n\n\n\n"},{"title":"Base.FastMath.@fastmath","page":"Mathematics","location":"base/math.html#Base.FastMath.@fastmath","category":"macro","text":"@fastmath expr\n\nExecute a transformed version of the expression, which calls functions that\nmay violate strict IEEE semantics. This allows the fastest possible operation,\nbut results are undefined – be careful when doing this, as it may change numerical\nresults.\n\nThis sets the LLVM Fast-Math flags,\nand corresponds to the -ffast-math option in clang. See [the notes on performance\nannotations](@ref man-performance-annotations) for more details.\n\nExamples\n\njulia> @fastmath 1+2\n3\n\njulia> @fastmath(sin(3))\n0.1411200080598672\n\n\n\n\n\n"},{"title":"External Profiler Support","page":"External Profiler Support","location":"devdocs/external_profilers.html#External-Profiler-Support","category":"section","text":"Julia provides explicit support for some external tracing profilers, enabling you to obtain a high-level overview of the runtime's execution behavior.\n\nThe currently supported profilers are:\n\nTracy\nIntel VTune (ITTAPI)"},{"title":"Adding New Zones","page":"External Profiler Support","location":"devdocs/external_profilers.html#Adding-New-Zones","category":"section","text":""},{"title":"From C/C++ code","page":"External Profiler Support","location":"devdocs/external_profilers.html#From-C/C-code","category":"section","text":"To add new zones, use the JL_TIMING macro. You can find numerous examples throughout the codebase by searching for JL_TIMING. To add a new type of zone\nyou add it to JL_TIMING_OWNERS (and possibly JL_TIMING_EVENTS)."},{"title":"From Julia code","page":"External Profiler Support","location":"devdocs/external_profilers.html#From-Julia-code","category":"section","text":"The Compiler.@zone macro can be used to add a zone from Julia code, it is used as:\n\nCompiler.@zone \"ZONE NAME\" begin\n    ...\nend"},{"title":"Dynamically Enabling and Disabling Zones","page":"External Profiler Support","location":"devdocs/external_profilers.html#Dynamically-Enabling-and-Disabling-Zones","category":"section","text":"The JULIA_TIMING_SUBSYSTEMS environment variable allows you to enable or disable zones for a specific Julia run. For instance, setting the variable to +GC,-INFERENCE will enable the GC zones and disable the INFERENCE\nzones."},{"title":"Tracy Profiler","page":"External Profiler Support","location":"devdocs/external_profilers.html#Tracy-Profiler","category":"section","text":"Tracy  is a flexible profiler that can be optionally integrated with Julia.\n\nA typical Tracy session might look like this:\n\n(Image: Typical Tracy usage)"},{"title":"Building Julia with Tracy","page":"External Profiler Support","location":"devdocs/external_profilers.html#Building-Julia-with-Tracy","category":"section","text":"To enable Tracy integration, build Julia with the extra option WITH_TRACY=1 in the Make.user file."},{"title":"Installing the Tracy Profile Viewer","page":"External Profiler Support","location":"devdocs/external_profilers.html#Installing-the-Tracy-Profile-Viewer","category":"section","text":"The easiest way to obtain the profile viewer is by adding the TracyProfiler_jll package and launching the profiler with:\n\nrun(TracyProfiler_jll.tracy())\n\nnote: Note\nOn macOS, you may want to set the TRACY_DPI_SCALE environment variable to 1.0 if the UI elements in the profiler appear excessively large.\n\nTo run a \"headless\" instance that saves the trace to disk, use\n\nrun(`$(TracyProfiler_jll.capture()) -o mytracefile.tracy`)\n\ninstead.\n\nFor information on using the Tracy UI, refer to the Tracy manual."},{"title":"Profiling Julia with Tracy","page":"External Profiler Support","location":"devdocs/external_profilers.html#Profiling-Julia-with-Tracy","category":"section","text":"A typical workflow for profiling Julia with Tracy involves starting Julia using:\n\nJULIA_WAIT_FOR_TRACY=1 ./julia -e '...'\n\nThe environment variable ensures that Julia waits until it has successfully connected to the Tracy profiler before continuing execution. Afterward, use the Tracy profiler UI, click Connect, and Julia execution should resume and profiling should start."},{"title":"Profiling package precompilation with Tracy","page":"External Profiler Support","location":"devdocs/external_profilers.html#Profiling-package-precompilation-with-Tracy","category":"section","text":"To profile a package precompilation process it is easiest to explicitly call into Base.compilecache with the package you want to precompile:\n\npkg = Base.identify_package(\"SparseArrays\")\nwithenv(\"JULIA_WAIT_FOR_TRACY\" => 1, \"TRACY_PORT\" => 9001) do\n    Base.compilecache(pkg)\nend\n\nHere, we use a custom port for tracy which makes it easier to find the correct client in the Tracy UI to connect to."},{"title":"Adding metadata to zones","page":"External Profiler Support","location":"devdocs/external_profilers.html#Adding-metadata-to-zones","category":"section","text":"The various jl_timing_show_* and jl_timing_printf functions can be used to attach a string (or strings) to a zone. For example, the trace zone for inference shows the method instance that is being inferred.\n\nThe TracyCZoneColor function can be used to set the color of a certain zone. Search through the codebase to see how it is used."},{"title":"Viewing Tracy files in your browser","page":"External Profiler Support","location":"devdocs/external_profilers.html#Viewing-Tracy-files-in-your-browser","category":"section","text":"Visit https://topolarity.github.io/trace-viewer/ for an (experimental) web viewer for Tracy traces.\n\nYou can open a local .tracy file or provide a URL from the web (e.g. a file in a Github repo). If you load a trace file from the web, you can also share the page URL directly with others, enabling them to view the same trace."},{"title":"Enabling stack trace samples","page":"External Profiler Support","location":"devdocs/external_profilers.html#Enabling-stack-trace-samples","category":"section","text":"To enable call stack sampling in Tracy, build Julia with these options in your Make.user file:\n\nWITH_TRACY := 1\nWITH_TRACY_CALLSTACKS := 1\nUSE_BINARYBUILDER_LIBTRACYCLIENT := 0\n\nYou may also need to run make -C deps clean-libtracyclient to force a re-build of Tracy.\n\nThis feature has a significant impact on trace size and profiling overhead, so it is recommended to leave call stack sampling off when possible, especially if you intend to share your trace files online.\n\nNote that the Julia JIT runtime does not yet have integration for Tracy's symbolification, so Julia functions will typically be unknown in these stack traces."},{"title":"Intel VTune (ITTAPI) Profiler","page":"External Profiler Support","location":"devdocs/external_profilers.html#Intel-VTune-(ITTAPI)-Profiler","category":"section","text":"This section is yet to be written."},{"title":"FreeBSD","page":"FreeBSD","location":"devdocs/build/freebsd.html#FreeBSD","category":"section","text":"Clang is the default compiler on FreeBSD 11.0-RELEASE and above.\nThe remaining build tools are available from the Ports Collection, and can be installed using\npkg install git gcc gmake cmake pkgconf.\nTo build Julia, simply run gmake.\n(Note that gmake must be used rather than make, since make on FreeBSD corresponds to the incompatible BSD Make rather than GNU Make.)\n\nAs mentioned above, it is important to note that the USE_SYSTEM_* flags should be used with caution on FreeBSD.\nThis is because many system libraries, and even libraries from the Ports Collection, link to the system's libgcc_s.so.1,\nor to another library which links to the system libgcc_s.\nThis library declares its GCC version to be 4.6, which is too old to build Julia, and conflicts with other libraries when linking.\nThus it is highly recommended to simply allow Julia to build all of its dependencies.\nIf you do choose to use the USE_SYSTEM_* flags, note that /usr/local is not on the compiler path by default, so you may need\nto add LDFLAGS=-L/usr/local/lib and CPPFLAGS=-I/usr/local/include to your Make.user, though doing so may interfere with\nother dependencies.\n\nNote that the x86 architecture does not support threading due to lack of compiler runtime library support, so you may need to\nset JULIA_THREADS=0 in your Make.user if you're on a 32-bit system."},{"title":"Julia ASTs","page":"Julia ASTs","location":"devdocs/ast.html#Julia-ASTs","category":"section","text":"Julia has two representations of code. First there is a surface syntax AST returned by the parser\n(e.g. the Meta.parse function), and manipulated by macros. It is a structured representation\nof code as it is written, constructed by julia-parser.scm from a character stream. Next there\nis a lowered form, or IR (intermediate representation), which is used by type inference and code\ngeneration. In the lowered form there are fewer types of nodes, all macros are expanded, and all\ncontrol flow is converted to explicit branches and sequences of statements. The lowered form is\nconstructed by julia-syntax.scm.\n\nFirst we will focus on the AST, since it is needed to write macros."},{"title":"Surface syntax AST","page":"Julia ASTs","location":"devdocs/ast.html#Surface-syntax-AST","category":"section","text":"Front end ASTs consist almost entirely of Exprs and atoms (e.g. symbols, numbers).\nThere is generally a different expression head for each visually distinct syntactic form.\nExamples will be given in s-expression syntax.\nEach parenthesized list corresponds to an Expr, where the first element is the head.\nFor example (call f x) corresponds to Expr(:call, :f, :x) in Julia."},{"title":"Calls","page":"Julia ASTs","location":"devdocs/ast.html#Calls","category":"section","text":"Input AST\nf(x) (call f x)\nf(x, y=1, z=2) (call f x (kw y 1) (kw z 2))\nf(x; y=1) (call f (parameters (kw y 1)) x)\nf(x...) (call f (... x))\n\ndo syntax:\n\nf(x) do a,b\n    body\nend\n\nparses as (do (call f x) (-> (tuple a b) (block body)))."},{"title":"Operators","page":"Julia ASTs","location":"devdocs/ast.html#Operators","category":"section","text":"Most uses of operators are just function calls, so they are parsed with the head call. However\nsome operators are special forms (not necessarily function calls), and in those cases the operator\nitself is the expression head. In julia-parser.scm these are referred to as \"syntactic operators\".\nSome operators (+ and *) use N-ary parsing; chained calls are parsed as a single N-argument\ncall. Finally, chains of comparisons have their own special expression structure.\n\nInput AST\nx+y (call + x y)\na+b+c+d (call + a b c d)\n2x (call * 2 x)\na&&b (&& a b)\nx += 1 (+= x 1)\na ? 1 : 2 (if a 1 2)\na,b (tuple a b)\na==b (call == a b)\n1<i<=n (comparison 1 < i <= n)\na.b (. a (quote b))\na.(b) (. a (tuple b))"},{"title":"Bracketed forms","page":"Julia ASTs","location":"devdocs/ast.html#Bracketed-forms","category":"section","text":"Input AST\na[i] (ref a i)\nt[i;j] (typed_vcat t i j)\nt[i j] (typed_hcat t i j)\nt[a b; c d] (typed_vcat t (row a b) (row c d))\nt[a b;;; c d] (typed_ncat t 3 (row a b) (row c d))\na{b} (curly a b)\na{b;c} (curly a (parameters c) b)\n[x] (vect x)\n[x,y] (vect x y)\n[x;y] (vcat x y)\n[x y] (hcat x y)\n[x y; z t] (vcat (row x y) (row z t))\n[x;y;; z;t;;;] (ncat 3 (nrow 2 (nrow 1 x y) (nrow 1 z t)))\n[x for y in z, a in b] (comprehension (generator x (= y z) (= a b)))\nT[x for y in z] (typed_comprehension T (generator x (= y z)))\n(a, b, c) (tuple a b c)\n(a; b; c) (block a b c)"},{"title":"Macros","page":"Julia ASTs","location":"devdocs/ast.html#Macros","category":"section","text":"Input AST\n@m x y (macrocall @m (line) x y)\nBase.@m x y (macrocall (. Base (quote @m)) (line) x y)\n@Base.m x y (macrocall (. Base (quote @m)) (line) x y)"},{"title":"Strings","page":"Julia ASTs","location":"devdocs/ast.html#Strings","category":"section","text":"Input AST\n\"a\" \"a\"\nx\"y\" (macrocall @x_str (line) \"y\")\nx\"y\"z (macrocall @x_str (line) \"y\" \"z\")\n\"x = $x\" (string \"x = \" x)\n`a b c` (macrocall @cmd (line) \"a b c\")\n\nDoc string syntax:\n\n\"some docs\"\nf(x) = x\n\nparses as (macrocall (|.| Core '@doc) (line) \"some docs\" (= (call f x) (block x)))."},{"title":"Imports and such","page":"Julia ASTs","location":"devdocs/ast.html#Imports-and-such","category":"section","text":"Input AST\nimport a (import (. a))\nimport a.b.c (import (. a b c))\nimport ...a (import (. . . . a))\nimport a.b, c.d (import (. a b) (. c d))\nimport Base: x (import (: (. Base) (. x)))\nimport Base: x, y (import (: (. Base) (. x) (. y)))\nexport a, b (export a b)\npublic a, b (public a b)\n\nusing has the same representation as import, but with expression head :using\ninstead of :import.\n\nTo programmatically create a public statement, you can use Expr(:public, :a, :b) or,\ncloser to regular code, Meta.parse(\"public a, b\"). This approach is necessary due to\ncurrent limitations on public. The public keyword is only\nrecognized at the syntactic top level within a file (parse_stmts) or module. This\nrestriction was implemented to prevent breaking existing code that used public as an\nidentifier when it was introduced in Julia 1.11."},{"title":"Numbers","page":"Julia ASTs","location":"devdocs/ast.html#Numbers","category":"section","text":"Julia supports more number types than many scheme implementations, so not all numbers are represented\ndirectly as scheme numbers in the AST.\n\nInput AST\n11111111111111111111 (macrocall @int128_str nothing \"11111111111111111111\")\n0xfffffffffffffffff (macrocall @uint128_str nothing \"0xfffffffffffffffff\")\n1111...many digits... (macrocall @big_str nothing \"1111....\")"},{"title":"Block forms","page":"Julia ASTs","location":"devdocs/ast.html#Block-forms","category":"section","text":"A block of statements is parsed as (block stmt1 stmt2 ...).\n\nIf statement:\n\nif a\n    b\nelseif c\n    d\nelse\n    e\nend\n\nparses as:\n\n(if a (block (line 2) b)\n    (elseif (block (line 3) c) (block (line 4) d)\n            (block (line 6) e)))\n\nA while loop parses as (while condition body).\n\nA for loop parses as (for (= var iter) body). If there is more than one iteration specification,\nthey are parsed as a block: (for (block (= v1 iter1) (= v2 iter2)) body).\n\nbreak and continue are parsed as 0-argument expressions (break) and (continue).\n\nlet is parsed as (let (= var val) body) or (let (block (= var1 val1) (= var2 val2) ...) body),\nlike for loops.\n\nA basic function definition is parsed as (function (call f x) body). A more complex example:\n\nfunction f(x::T; k = 1) where T\n    return x+1\nend\n\nparses as:\n\n(function (where (call f (parameters (kw k 1))\n                       (:: x T))\n                 T)\n          (block (line 2) (return (call + x 1))))\n\nType definition:\n\nmutable struct Foo{T<:S}\n    x::T\nend\n\nparses as:\n\n(struct true (curly Foo (<: T S))\n        (block (line 2) (:: x T)))\n\nThe first argument is a boolean telling whether the type is mutable.\n\ntry blocks parse as (try try_block var catch_block finally_block). If no variable is present\nafter catch, var is #f. If there is no finally clause, then the last argument is not present."},{"title":"Quote expressions","page":"Julia ASTs","location":"devdocs/ast.html#Quote-expressions","category":"section","text":"Julia source syntax forms for code quoting (quote and :( )) support interpolation with $.\nIn Lisp terminology, this means they are actually \"backquote\" or \"quasiquote\" forms.\nInternally, there is also a need for code quoting without interpolation.\nIn Julia's scheme code, non-interpolating quote is represented with the expression head inert.\n\ninert expressions are converted to Julia QuoteNode objects.\nThese objects wrap a single value of any type, and when evaluated simply return that value.\n\nA quote expression whose argument is an atom also gets converted to a QuoteNode."},{"title":"Line numbers","page":"Julia ASTs","location":"devdocs/ast.html#Line-numbers","category":"section","text":"Source location information is represented as (line line_num file_name) where the third\ncomponent is optional (and omitted when the current line number, but not file name,\nchanges).\n\nThese expressions are represented as LineNumberNodes in Julia."},{"title":"Macros","page":"Julia ASTs","location":"devdocs/ast.html#Macros-2","category":"section","text":"Macro hygiene is represented through the expression head pair escape and hygienic-scope.\nThe result of a macro expansion is automatically wrapped in (hygienic-scope block module [lno]),\nto represent the result of the new scope. The user can insert (escape block) inside\nto interpolate code from the caller. The lno is the __source__ argument of the macro, if included."},{"title":"Lowered form","page":"Julia ASTs","location":"devdocs/ast.html#Lowered-form","category":"section","text":"Lowered form (IR) is more important to the compiler, since it is used for type inference,\noptimizations like inlining, and code generation. It is also less obvious to the human,\nsince it results from a significant rearrangement of the input syntax.\n\nIn addition to Symbols and some number types, the following data\ntypes exist in lowered form:\n\nExpr\nHas a node type indicated by the head field, and an args field which is a Vector{Any} of\nsubexpressions.\nWhile almost every part of a surface AST is represented by an Expr, the IR uses only a\nlimited number of Exprs, mostly for calls and some top-level-only forms.\nSlotNumber\nIdentifies arguments and local variables by consecutive numbering. It has an\ninteger-valued id field giving the slot index.\nThe types of these slots can be found in the slottypes field of their CodeInfo object.\nArgument\nThe same as SlotNumber, but appears only post-optimization. Indicates that the\nreferenced slot is an argument of the enclosing function.\nCodeInfo\nWraps the IR of a group of statements. Its code field is an array of expressions to execute.\nGotoNode\nUnconditional branch. The argument is the branch target, represented as an index in\nthe code array to jump to.\nGotoIfNot\nConditional branch. If the cond field evaluates to false, goes to the index identified\nby the dest field.\nReturnNode\nReturns its argument (the val field) as the value of the enclosing function.\nIf the val field is undefined, then this represents an unreachable statement.\nQuoteNode\nWraps an arbitrary value to reference as data. For example, the function f() = :a contains a\nQuoteNode whose value field is the symbol a, in order to return the symbol itself instead\nof evaluating it.\nGlobalRef\nRefers to global variable name in module mod.\nSSAValue\nRefers to a consecutively-numbered (starting at 1) static single assignment (SSA) variable inserted\nby the compiler. The number (id) of an SSAValue is the code array index of the expression whose\nvalue it represents.\nNewvarNode\nMarks a point where a variable (slot) is created. This has the effect of resetting a variable to undefined."},{"title":"Expr types","page":"Julia ASTs","location":"devdocs/ast.html#Expr-types","category":"section","text":"These symbols appear in the head field of Exprs in lowered form.\n\ncall\nFunction call (dynamic dispatch). args[1] is the function to call, args[2:end] are the arguments.\ninvoke\nFunction call (static dispatch). args[1] is the MethodInstance to call, args[2:end] are the\narguments (including the function that is being called, at args[2]).\nstatic_parameter\nReference a static parameter by index.\n=\nAssignment. In the IR, the first argument is always a SlotNumber or a GlobalRef.\nmethod\nAdds a method to a generic function and assigns the result if necessary.\nHas a 1-argument form and a 3-argument form. The 1-argument form arises from the syntax function foo end.\nIn the 1-argument form, the argument is a symbol. If this symbol already names a function in the\ncurrent scope, nothing happens. If the symbol is undefined, a new function is created and assigned\nto the identifier specified by the symbol. If the symbol is defined but names a non-function,\nan error is raised. The definition of \"names a function\" is that the binding is constant, and\nrefers to an object of singleton type. The rationale for this is that an instance of a singleton\ntype uniquely identifies the type to add the method to. When the type has fields, it wouldn't\nbe clear whether the method was being added to the instance or its type.\nThe 3-argument form has the following arguments:\nargs[1]\nA function name, or nothing if unknown or unneeded. If a symbol, then the expression\nfirst behaves like the 1-argument form above. This argument is ignored from then on.\nIt can be nothing when methods are added strictly by type, (::T)(x) = x,\nor when a method is being added to an existing function, MyModule.f(x) = x.\nargs[2]\nA SimpleVector of argument type data. args[2][1] is a SimpleVector of the\nargument types, and args[2][2] is a SimpleVector of type variables corresponding\nto the method's static parameters.\nargs[3]\nA CodeInfo of the method itself. For \"out of scope\" method definitions (adding a\nmethod to a function that also has methods defined in different scopes) this is an\nexpression that evaluates to a :lambda expression.\nstruct_type\nA 7-argument expression that defines a new struct:\nargs[1]\nThe name of the struct\nargs[2]\nA call expression that creates a SimpleVector specifying its parameters\nargs[3]\nA call expression that creates a SimpleVector specifying its fieldnames\nargs[4]\nA Symbol, GlobalRef, or Expr specifying the supertype (e.g., :Integer,\nGlobalRef(Core, :Any), or :(Core.apply_type(AbstractArray, T, N)))\nargs[5]\nA call expression that creates a SimpleVector specifying its fieldtypes\nargs[6]\nA Bool, true if mutable\nargs[7]\nThe number of arguments to initialize. This will be the number\nof fields, or the minimum number of fields called by an inner\nconstructor's new statement.\nabstract_type\nA 3-argument expression that defines a new abstract type. The\narguments are the same as arguments 1, 2, and 4 of\nstruct_type expressions.\nprimitive_type\nA 4-argument expression that defines a new primitive type. Arguments 1, 2, and 4\nare the same as struct_type. Argument 3 is the number of bits.\ncompat: Julia 1.5\nstruct_type, abstract_type, and primitive_type were removed in Julia 1.5\nand replaced by calls to new builtins.\nglobal\nDeclares a global binding.\nconst\nDeclares a (global) variable as constant.\nnew\nAllocates a new struct-like object. First argument is the type. The new pseudo-function is lowered\nto this, and the type is always inserted by the compiler. This is very much an internal-only\nfeature, and does no checking. Evaluating arbitrary new expressions can easily segfault.\nsplatnew\nSimilar to new, except field values are passed as a single tuple. Works similarly to\nsplat(new) if new were a first-class function, hence the name.\nisdefined\nExpr(:isdefined, :x) returns a Bool indicating whether x has\nalready been defined in the current scope.\nthe_exception\nYields the caught exception inside a catch block, as returned by jl_current_exception(ct).\nenter\nEnters an exception handler (setjmp). args[1] is the label of the catch block to jump to on\nerror. Yields a token which is consumed by pop_exception.\nleave\nPop exception handlers. args[1] is the number of handlers to pop.\npop_exception\nPop the stack of current exceptions back to the state at the associated enter when leaving a\ncatch block. args[1] contains the token from the associated enter.\ncompat: Julia 1.1\npop_exception is new in Julia 1.1.\ninbounds\nControls turning bounds checks on or off. A stack is maintained; if the first argument of this\nexpression is true or false (true means bounds checks are disabled), it is pushed onto the stack.\nIf the first argument is :pop, the stack is popped.\nboundscheck\nHas the value false if inlined into a section of code marked with @inbounds,\notherwise has the value true.\nloopinfo\nMarks the end of the a loop. Contains metadata that is passed to LowerSimdLoop to either mark\nthe inner loop of @simd expression, or to propagate information to LLVM loop passes.\ncopyast\nPart of the implementation of quasi-quote. The argument is a surface syntax AST that is simply\ncopied recursively and returned at run time.\nmeta\nMetadata. args[1] is typically a symbol specifying the kind of metadata, and the rest of the\narguments are free-form. The following kinds of metadata are commonly used:\n:inline and :noinline: Inlining hints.\nforeigncall\nStatically-computed container for ccall information. The fields are:\nargs[1] : name\nThe expression that'll be parsed for the foreign function.\nargs[2]::Type : RT\nThe (literal) return type, computed statically when the containing method was defined.\nargs[3]::SimpleVector (of Types) : AT\nThe (literal) vector of argument types, computed statically when the containing method was defined.\nargs[4]::Int : nreq\nThe number of required arguments for a varargs function definition.\nargs[5]::QuoteNode{<:Union{Symbol,Tuple{Symbol,UInt16}, Tuple{Symbol,UInt16,Bool}}: calling convention\nThe calling convention for the call, optionally with effects, and gc_safe (safe to execute concurrently to GC.).\nargs[6:5+length(args[3])] : arguments\nThe values for all the arguments (with types of each given in args[3]).\nargs[6+length(args[3])+1:end] : gc-roots\nThe additional objects that may need to be gc-rooted for the duration of the call.\nSee Working with LLVM for where these are derived from and how they get handled.\nnew_opaque_closure\nConstructs a new opaque closure. The fields are:\nargs[1] : signature\nThe function signature of the opaque closure. Opaque closures don't participate in dispatch, but the input types can be restricted.\nargs[2] : lb\nLower bound on the output type. (Defaults to Union{})\nargs[3] : ub\nUpper bound on the output type. (Defaults to Any)\nargs[4] : constprop\nIndicates whether the opaque closure's identity may be used for constant\npropagation. The @opaque macro enables this by default, but this will\ncause additional inference which may be undesirable and prevents the\ncode from running during precompile.\nIf args[4] is a method, the argument is considered skipped.\nargs[5] : method\nThe actual method as an opaque_closure_method expression.\nargs[6:end] : captures\nThe values captured by the opaque closure.\ncompat: Julia 1.7\nOpaque closures were added in Julia 1.7"},{"title":"Method","page":"Julia ASTs","location":"devdocs/ast.html#ast-lowered-method","category":"section","text":"A unique'd container describing the shared metadata for a single method.\n\nname, module, file, line, sig\nMetadata to uniquely identify the method for the computer and the human.\nambig\nCache of other methods that may be ambiguous with this one.\nspecializations\nCache of all MethodInstance ever created for this Method, used to ensure uniqueness.\nUniqueness is required for efficiency, especially for incremental precompile and\ntracking of method invalidation.\nsource\nThe original source code (if available, usually compressed).\ngenerator\nA callable object which can be executed to get specialized source for a specific method signature.\nroots\nPointers to non-AST things that have been interpolated into the AST, required by\ncompression of the AST, type-inference, or the generation of native code.\nnargs, isva, called, is_for_opaque_closure,\nDescriptive bit-fields for the source code of this Method.\nprimary_world\nThe world age that \"owns\" this Method."},{"title":"MethodInstance","page":"Julia ASTs","location":"devdocs/ast.html#MethodInstance","category":"section","text":"A unique'd container describing a single callable signature for a Method.\nSee especially Proper maintenance and care of multi-threading locks\nfor important details on how to modify these fields safely.\n\nspecTypes\nThe primary key for this MethodInstance. Uniqueness is guaranteed through a\ndef.specializations lookup.\ndef\nThe Method that this function describes a specialization of. Or a Module,\nif this is a top-level Lambda expanded in Module, and which is not part of a Method.\nsparam_vals\nThe values of the static parameters in specTypes.\nFor the MethodInstance at Method.unspecialized, this is the empty SimpleVector.\nBut for a runtime MethodInstance from the MethodTable cache, this will always be defined and indexable.\nbackedges\nWe store the reverse-list of cache dependencies for efficient tracking of incremental reanalysis/recompilation work that may be needed after a new method definitions.\nThis works by keeping a list of the other MethodInstance that have been inferred or optimized to contain a possible call to this MethodInstance.\nThose optimization results might be stored somewhere in the cache, or it might have been the result of something we didn't want to cache, such as constant propagation.\nThus we merge all of those backedges to various cache entries here (there's almost always only the one applicable cache entry with a sentinel value for max_world anyways).\ncache\nCache of CodeInstance objects that share this template instantiation."},{"title":"CodeInstance","page":"Julia ASTs","location":"devdocs/ast.html#CodeInstance","category":"section","text":"def\nThe MethodInstance that this cache entry is derived from.\nowner\nA token that represents the owner of this CodeInstance. Will use jl_egal to match.\nrettype/rettype_const\nThe inferred return type for the specFunctionObject field, which (in most cases) is\nalso the computed return type for the function in general.\ninferred\nMay contain a cache of the inferred source for this function,\nor it could be set to nothing to just indicate rettype is inferred.\nftpr\nThe generic jlcall entry point.\njlcall_api\nThe ABI to use when calling fptr. Some significant ones include:\n0 - Not compiled yet\n1 - JL_CALLABLE jl_value_t *(*)(jl_value_t *f, jl_value_t *args[nargs], uint32_t nargs)\n2 - Constant (value stored in rettype_const)\n3 - With Static-parameters forwarded jl_value_t *(*)(jl_svec_t *sparams, jl_value_t *f, jl_value_t *args[nargs], uint32_t nargs)\n4 - Run in interpreter jl_value_t *(*)(jl_method_instance_t *meth, jl_value_t *f, jl_value_t *args[nargs], uint32_t nargs)\nmin_world / max_world\nThe range of world ages for which this method instance is valid to be called.\nIf max_world is the special token value -1, the value is not yet known.\nIt may continue to be used until we encounter a backedge that requires us to reconsider.\nTiming fields\ntime_infer_total: Total cost of computing inferred originally as wall-time from start to finish.\ntime_infer_cache_saved: The cost saved from time_infer_total by having caching.\nAdding this to time_infer_total should give a stable estimate for comparing the cost\nof two implementations or one implementation over time. This is generally an\nover-estimate of the time to infer something, since the cache is frequently effective\nat handling repeated work.\ntime_infer_self: Self cost of julia inference for inferred (a portion of\ntime_infer_total). This is simply the incremental cost of compiling this one method,\nif given a fully populated cache of all call targets, even including constant\ninference results and LimitedAccuracy results, which generally are not in a cache.\ntime_compile: Self cost of llvm JIT compilation (e.g. of computing invoke from\ninferred). A total cost estimate can be computed by walking all of the edges\ncontents and summing those, while accounting for cycles and duplicates. (This field\ncurrently does not include any measured AOT compile times.)"},{"title":"CodeInfo","page":"Julia ASTs","location":"devdocs/ast.html#CodeInfo","category":"section","text":"A (usually temporary) container for holding lowered (and possibly inferred) source code.\n\ncode\nAn Any array of statements\nslotnames\nAn array of symbols giving names for each slot (argument or local variable).\nslotflags\nA UInt8 array of slot properties, represented as bit flags:\n0x02 - assigned (only false if there are no assignment statements with this var on the left)\n0x08 - used (if there is any read or write of the slot)\n0x10 - statically assigned once\n0x20 - might be used before assigned. This flag is only valid after type inference.\nssavaluetypes\nEither an array or an Int.\nIf an Int, it gives the number of compiler-inserted temporary locations in the\nfunction (the length of code array). If an array, specifies a type for each location.\nssaflags\nStatement-level 32 bits flags for each expression in the function.\nSee the definition of jl_code_info_t in julia.h for more details.\n\nThese are only populated after inference (or by generated functions in some cases):\n\ndebuginfo\nAn object to retrieve source information for each statements, see\nHow to interpret line numbers in a CodeInfo object.\nrettype\nThe inferred return type of the lowered form (IR). Default value is Any. This is\nmostly present for convenience, as (due to the way OpaqueClosures work) it is not\nnecessarily the rettype used by codegen.\nparent\nThe MethodInstance that \"owns\" this object (if applicable).\nedges\nForward edges to method instances that must be invalidated.\nmin_world/max_world\nThe range of world ages for which this code was valid at the time when it had been inferred.\n\nOptional Fields:\n\nslottypes\nAn array of types for the slots.\nmethod_for_inference_limit_heuristics\nThe method_for_inference_heuristics will expand the given method's generator if\nnecessary during inference.\n\nBoolean properties:\n\npropagate_inbounds\nWhether this should propagate @inbounds when inlined for the purpose of eliding\n@boundscheck blocks.\n\nUInt8 settings:\n\nconstprop, inlineable\n0 = use heuristic\n1 = aggressive\n2 = none\npurity\nConstructed from 5 bit flags:\n0x01 << 0 = this method is guaranteed to return or terminate consistently (:consistent)\n0x01 << 1 = this method is free from externally semantically visible side effects (:effect_free)\n0x01 << 2 = this method is guaranteed to not throw an exception (:nothrow)\n0x01 << 3 = this method is guaranteed to terminate (:terminates_globally)\n0x01 << 4 = the syntactic control flow within this method is guaranteed to terminate (:terminates_locally)\nSee the documentation of Base.@assume_effects for more details."},{"title":"How to interpret line numbers in a CodeInfo object","page":"Julia ASTs","location":"devdocs/ast.html#How-to-interpret-line-numbers-in-a-CodeInfo-object","category":"section","text":"There are 2 common forms for this data: one used internally that compresses the data somewhat and one used in the compiler.\nThey contain the same basic info, but the compiler version is all mutable while the version used internally is not.\n\nMany consumers may be able to call Base.IRShow.buildLineInfoNode,\nBase.IRShow.append_scopes!, or Stacktraces.lookup(::InterpreterIP) to avoid needing to\n(re-)implement these details specifically.\n\nThe definitions of each of these are:\n\nstruct Core.DebugInfo\n    @noinline\n    def::Union{Method,MethodInstance,Symbol}\n    linetable::Union{Nothing,DebugInfo}\n    edges::SimpleVector{DebugInfo}\n    codelocs::String # compressed data\nend\nmutable struct Core.Compiler.DebugInfoStream\n    def::Union{Method,MethodInstance,Symbol}\n    linetable::Union{Nothing,DebugInfo}\n    edges::Vector{DebugInfo}\n    firstline::Int32 # the starting line for this block (specified by an index of 0)\n    codelocs::Vector{Int32} # for each statement:\n        # index into linetable (if defined), else a line number (in the file represented by def)\n        # then index into edges\n        # then index into edges[linetable]\nend\n\ndef : where this DebugInfo was defined (the Method, MethodInstance, or Symbol of file scope, for example)\nlinetable\nAnother DebugInfo that this was derived from, which contains the actual line numbers,\nsuch that this DebugInfo contains only the indexes into it. This avoids making copies,\nas well as makes it possible to track how each individual statement transformed from\nsource to optimized, not just the separate line numbers. If def is not a Symbol, then\nthat object replaces the current function object for the metadata on what function is\nconceptually being executed (e.g. think Cassette transforms here). The codelocs values\ndescribed below also are interpreted as an index into the codelocs in this object,\ninstead of being a line number itself.\nedges : Vector of the unique DebugInfo for every function inlined into this (which\nrecursively have the edges for everything inlined into them).\nfirstline (when uncompressed to DebugInfoStream)\nThe line number associated with the begin statement (or other keyword such as\nfunction or quote) that delineates where this code definition \"starts\".\ncodelocs (when uncompressed to DebugInfoStream)\nA vector of indices, with 3 values for each statement in the IR plus one for the\nstarting point of the block, that describe the stacktrace from that point:\nthe integer index into the linetable.codelocs field, giving the\noriginal location associated with each statement (including its syntactic edges),\nor zero indicating no change to the line number from the previously\nexecuted statement (which is not necessarily syntactic or lexical prior),\nor the line number itself if the linetable field is nothing.\nthe integer index into edges, giving the DebugInfo inlined there,\nor zero if there are no edges.\n(if entry 2 is non-zero) the integer index into edges[].codelocs,\nto interpret recursively for each function in the inlining stack,\nor zero indicating to use edges[].firstline as the line number.\nSpecial codes include:\n(zero, zero, *): no change to the line number or edges from the previous statement\n(you may choose to interpret this either syntactically or lexically). The inlining\ndepth also might have changed, though most callers should ignore that.\n(zero, non-zero, *) : no line number, just edges (usually because of\nmacro-expansion into top-level code)."},{"title":"Methods","page":"Methods","location":"manual/methods.html#Methods","category":"section","text":"Recall from Functions that a function is an object that maps a tuple of arguments to a\nreturn value, or throws an exception if no appropriate value can be returned. It is common for\nthe same conceptual function or operation to be implemented quite differently for different types\nof arguments: adding two integers is very different from adding two floating-point numbers, both\nof which are distinct from adding an integer to a floating-point number. Despite their implementation\ndifferences, these operations all fall under the general concept of \"addition\". Accordingly, in\nJulia, these behaviors all belong to a single object: the + function.\n\nTo facilitate using many different implementations of the same concept smoothly, functions need\nnot be defined all at once, but can rather be defined piecewise by providing specific behaviors\nfor certain combinations of argument types and counts. A definition of one possible behavior for\na function is called a method. Thus far, we have presented only examples of functions defined\nwith a single method, applicable to all types of arguments. However, the signatures of method\ndefinitions can be annotated to indicate the types of arguments in addition to their number, and\nmore than a single method definition may be provided. When a function is applied to a particular\ntuple of arguments, the most specific method applicable to those arguments is applied. Thus, the\noverall behavior of a function is a patchwork of the behaviors of its various method definitions.\nIf the patchwork is well designed, even though the implementations of the methods may be quite\ndifferent, the outward behavior of the function will appear seamless and consistent.\n\nThe choice of which method to execute when a function is applied is called dispatch. Julia allows\nthe dispatch process to choose which of a function's methods to call based on the number of arguments\ngiven, and on the types of all of the function's arguments. This is different than traditional\nobject-oriented languages, where dispatch occurs based only on the first argument, which often\nhas a special argument syntax, and is sometimes implied rather than explicitly written as an argument.\n[1] Using all of a function's arguments to choose which method should be invoked, rather than\njust the first, is known as multiple dispatch.\nMultiple dispatch is particularly useful for mathematical code, where it makes little sense to\nartificially deem the operations to \"belong\" to one argument more than any of the others: does\nthe addition operation in x + y belong to x any more than it does to y? The implementation\nof a mathematical operator generally depends on the types of all of its arguments. Even beyond\nmathematical operations, however, multiple dispatch ends up being a powerful and convenient paradigm\nfor structuring and organizing programs.\n\n[1]: In C++ or Java, for example, in a method call like obj.meth(arg1,arg2), the object obj \"receives\"\nthe method call and is implicitly passed to the method via the this keyword, rather than as\nan explicit method argument. When the current this object is the receiver of a method call,\nit can be omitted altogether, writing just meth(arg1,arg2), with this implied as the receiving\nobject.\n\nnote: Note\nAll the examples in this chapter assume that you are defining methods for a function in the same\nmodule. If you want to add methods to a function in another module, you have to import it or\nuse the name qualified with module names. See the section on [namespace management](@ref\nnamespace-management)."},{"title":"Defining Methods","page":"Methods","location":"manual/methods.html#Defining-Methods","category":"section","text":"Until now, we have, in our examples, defined only functions with a single method having unconstrained\nargument types. Such functions behave just like they would in traditional dynamically typed languages.\nNevertheless, we have used multiple dispatch and methods almost continually without being aware\nof it: all of Julia's standard functions and operators, like the aforementioned + function,\nhave many methods defining their behavior over various possible combinations of argument type\nand count.\n\nWhen defining a function, one can optionally constrain the types of parameters it is applicable\nto, using the :: type-assertion operator, introduced in the section on Composite Types:\n\njulia> f(x::Float64, y::Float64) = 2x + y\nf (generic function with 1 method)\n\nThis function definition applies only to calls where x and y are both values of type\nFloat64:\n\njulia> f(2.0, 3.0)\n7.0\n\nApplying it to any other types of arguments will result in a MethodError:\n\njulia> f(2.0, 3)\nERROR: MethodError: no method matching f(::Float64, ::Int64)\nThe function `f` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  f(::Float64, !Matched::Float64)\n   @ Main none:1\n\nStacktrace:\n[...]\n\njulia> f(Float32(2.0), 3.0)\nERROR: MethodError: no method matching f(::Float32, ::Float64)\nThe function `f` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  f(!Matched::Float64, ::Float64)\n   @ Main none:1\n\nStacktrace:\n[...]\n\njulia> f(2.0, \"3.0\")\nERROR: MethodError: no method matching f(::Float64, ::String)\nThe function `f` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  f(::Float64, !Matched::Float64)\n   @ Main none:1\n\nStacktrace:\n[...]\n\njulia> f(\"2.0\", \"3.0\")\nERROR: MethodError: no method matching f(::String, ::String)\nThe function `f` exists, but no method is defined for this combination of argument types.\n\nAs you can see, the arguments must be precisely of type Float64. Other numeric\ntypes, such as integers or 32-bit floating-point values, are not automatically converted\nto 64-bit floating-point, nor are strings parsed as numbers. Because Float64 is a concrete\ntype and concrete types cannot be subclassed in Julia, such a definition can only be applied\nto arguments that are exactly of type Float64. It may often be useful, however, to write\nmore general methods where the declared parameter types are abstract:\n\njulia> f(x::Number, y::Number) = 2x - y\nf (generic function with 2 methods)\n\njulia> f(2.0, 3)\n1.0\n\nThis method definition applies to any pair of arguments that are instances of Number.\nThey need not be of the same type, so long as they are each numeric values. The problem of\nhandling disparate numeric types is delegated to the arithmetic operations in the\nexpression 2x - y.\n\nTo define a function with multiple methods, one simply defines the function multiple times, with\ndifferent numbers and types of arguments. The first method definition for a function creates the\nfunction object, and subsequent method definitions add new methods to the existing function object.\nThe most specific method definition matching the number and types of the arguments will be executed\nwhen the function is applied. Thus, the two method definitions above, taken together, define the\nbehavior for f over all pairs of instances of the abstract type Number – but with a different\nbehavior specific to pairs of Float64 values. If one of the arguments is a 64-bit\nfloat but the other one is not, then the f(Float64,Float64) method cannot be called and\nthe more general f(Number,Number) method must be used:\n\njulia> f(2.0, 3.0)\n7.0\n\njulia> f(2, 3.0)\n1.0\n\njulia> f(2.0, 3)\n1.0\n\njulia> f(2, 3)\n1\n\nThe 2x + y definition is only used in the first case, while the 2x - y definition is used\nin the others. No automatic casting or conversion of function arguments is ever performed: all\nconversion in Julia is non-magical and completely explicit. Conversion and Promotion,\nhowever, shows how clever application of sufficiently advanced technology can be indistinguishable\nfrom magic. [Clarke61]\n\nFor non-numeric values, and for fewer or more than two arguments, the function f remains undefined,\nand applying it will still result in a MethodError:\n\njulia> f(\"foo\", 3)\nERROR: MethodError: no method matching f(::String, ::Int64)\nThe function `f` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  f(!Matched::Number, ::Number)\n   @ Main none:1\n  f(!Matched::Float64, !Matched::Float64)\n   @ Main none:1\n\nStacktrace:\n[...]\n\njulia> f()\nERROR: MethodError: no method matching f()\nThe function `f` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  f(!Matched::Float64, !Matched::Float64)\n   @ Main none:1\n  f(!Matched::Number, !Matched::Number)\n   @ Main none:1\n\nStacktrace:\n[...]\n\nYou can easily see which methods exist for a function by entering the function object itself in\nan interactive session:\n\njulia> f\nf (generic function with 2 methods)\n\nThis output tells us that f is a function object with two methods. To find out what the signatures\nof those methods are, use the methods function:\n\njulia> methods(f)\n# 2 methods for generic function \"f\" from Main:\n [1] f(x::Float64, y::Float64)\n     @ none:1\n [2] f(x::Number, y::Number)\n     @ none:1\n\nwhich shows that f has two methods, one taking two Float64 arguments and one taking arguments\nof type Number. It also indicates the file and line number where the methods were defined: because\nthese methods were defined at the REPL, we get the apparent line number none:1.\n\nIn the absence of a type declaration with ::, the type of a method parameter is Any by default,\nmeaning that it is unconstrained since all values in Julia are instances of the abstract type\nAny. Thus, we can define a catch-all method for f like so:\n\njulia> f(x,y) = println(\"Whoa there, Nelly.\")\nf (generic function with 3 methods)\n\njulia> methods(f)\n# 3 methods for generic function \"f\" from Main:\n [1] f(x::Float64, y::Float64)\n     @ none:1\n [2] f(x::Number, y::Number)\n     @ none:1\n [3] f(x, y)\n     @ none:1\n\njulia> f(\"foo\", 1)\nWhoa there, Nelly.\n\nThis catch-all is less specific than any other possible method definition for a pair of parameter\nvalues, so it will only be called on pairs of arguments to which no other method definition applies.\n\nNote that in the signature of the third method, there is no type specified for the arguments x and y.\nThis is a shortened way of expressing f(x::Any, y::Any).\n\nAlthough it seems a simple concept, multiple dispatch on the types of values is perhaps the single\nmost powerful and central feature of the Julia language. Core operations typically have dozens\nof methods:\n\njulia> methods(+)\n# 180 methods for generic function \"+\":\n[1] +(x::Bool, z::Complex{Bool}) in Base at complex.jl:227\n[2] +(x::Bool, y::Bool) in Base at bool.jl:89\n[3] +(x::Bool) in Base at bool.jl:86\n[4] +(x::Bool, y::T) where T<:AbstractFloat in Base at bool.jl:96\n[5] +(x::Bool, z::Complex) in Base at complex.jl:234\n[6] +(a::Float16, b::Float16) in Base at float.jl:373\n[7] +(x::Float32, y::Float32) in Base at float.jl:375\n[8] +(x::Float64, y::Float64) in Base at float.jl:376\n[9] +(z::Complex{Bool}, x::Bool) in Base at complex.jl:228\n[10] +(z::Complex{Bool}, x::Real) in Base at complex.jl:242\n[11] +(x::Char, y::Integer) in Base at char.jl:40\n[12] +(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:307\n[13] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:392\n[14] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:391\n[15] +(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:390\n[16] +(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:361\n[17] +(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:398\n...\n[180] +(a, b, c, xs...) in Base at operators.jl:424\n\nMultiple dispatch together with the flexible parametric type system give Julia its ability to\nabstractly express high-level algorithms decoupled from implementation details."},{"title":"Method specializations","page":"Methods","location":"manual/methods.html#man-method-specializations","category":"section","text":"When you create multiple methods of the same function, this is sometimes called\n\"specialization.\" In this case, you're specializing the function by adding additional\nmethods to it: each new method is a new specialization of the function.\nAs shown above, these specializations are returned by methods.\n\nThere's another kind of specialization that occurs without programmer intervention:\nJulia's compiler can automatically specialize the method for the specific argument types used.\nSuch specializations are not listed by methods, as this doesn't create new Methods, but tools like @code_typed allow you to inspect such specializations.\n\nFor example, if you create a method\n\nmysum(x::Real, y::Real) = x + y\n\nyou've given the function mysum one new method (possibly its only method), and that method takes any pair of Real number inputs. But if you then execute\n\njulia> mysum(1, 2)\n3\n\njulia> mysum(1.0, 2.0)\n3.0\n\nJulia will compile mysum twice, once for x::Int, y::Int and again for x::Float64, y::Float64.\nThe point of compiling twice is performance: the methods that get called for + (which mysum uses) vary depending on the specific types of x and y, and by compiling different specializations Julia can do all the method lookup ahead of time. This allows the program to run much more quickly, since it does not have to bother with method lookup while it is running.\nJulia's automatic specialization allows you to write generic algorithms and expect that the compiler will generate efficient, specialized code to handle each case you need.\n\nIn cases where the number of potential specializations might be effectively unlimited, Julia may avoid this default specialization. See Be aware of when Julia avoids specializing for more information."},{"title":"Method Ambiguities","page":"Methods","location":"manual/methods.html#man-ambiguities","category":"section","text":"It is possible to define a set of function methods such that there is no unique most specific\nmethod applicable to some combinations of arguments:\n\njulia> g(x::Float64, y) = 2x + y\ng (generic function with 1 method)\n\njulia> g(x, y::Float64) = x + 2y\ng (generic function with 2 methods)\n\njulia> g(2.0, 3)\n7.0\n\njulia> g(2, 3.0)\n8.0\n\njulia> g(2.0, 3.0)\nERROR: MethodError: g(::Float64, ::Float64) is ambiguous.\n\nCandidates:\n  g(x, y::Float64)\n    @ Main none:1\n  g(x::Float64, y)\n    @ Main none:1\n\nPossible fix, define\n  g(::Float64, ::Float64)\n\nStacktrace:\n[...]\n\nHere the call g(2.0, 3.0) could be handled by either the g(::Float64, ::Any) or the\ng(::Any, ::Float64) method. The order in which the methods are defined does not matter and\nneither is more specific than the other. In such cases, Julia raises a\nMethodError rather than arbitrarily picking a method. You can avoid method\nambiguities by specifying an appropriate method for the intersection case:\n\njulia> g(x::Float64, y::Float64) = 2x + 2y\ng (generic function with 3 methods)\n\njulia> g(2.0, 3)\n7.0\n\njulia> g(2, 3.0)\n8.0\n\njulia> g(2.0, 3.0)\n10.0\n\nIt is recommended that the disambiguating method be defined first, since otherwise the ambiguity\nexists, if transiently, until the more specific method is defined.\n\nIn more complex cases, resolving method ambiguities involves a certain\nelement of design; this topic is explored further below."},{"title":"Parametric Methods","page":"Methods","location":"manual/methods.html#Parametric-Methods","category":"section","text":"Method definitions can optionally have type parameters qualifying the signature:\n\njulia> same_type(x::T, y::T) where {T} = true\nsame_type (generic function with 1 method)\n\njulia> same_type(x,y) = false\nsame_type (generic function with 2 methods)\n\nThe first method applies whenever both arguments are of the same concrete type, regardless of\nwhat type that is, while the second method acts as a catch-all, covering all other cases. Thus,\noverall, this defines a boolean function that checks whether its two arguments are of the same\ntype:\n\njulia> same_type(1, 2)\ntrue\n\njulia> same_type(1, 2.0)\nfalse\n\njulia> same_type(1.0, 2.0)\ntrue\n\njulia> same_type(\"foo\", 2.0)\nfalse\n\njulia> same_type(\"foo\", \"bar\")\ntrue\n\njulia> same_type(Int32(1), Int64(2))\nfalse\n\nSuch definitions correspond to methods whose type signatures are UnionAll types\n(see UnionAll Types).\n\nThis kind of definition of function behavior by dispatch is quite common – idiomatic, even –\nin Julia. Method type parameters are not restricted to being used as the types of arguments:\nthey can be used anywhere a value would be in the signature of the function or body of the function.\nHere's an example where the method type parameter T is used as the type parameter to the parametric\ntype Vector{T} in the method signature:\n\njulia> function myappend(v::Vector{T}, x::T) where {T}\n           return [v..., x]\n       end\nmyappend (generic function with 1 method)\n\nThe type parameter T in this example ensures that the added element x is a subtype of the\nexisting eltype of the vector v.\nThe where keyword introduces a list of those constraints after the method signature definition.\nThis works the same for one-line definitions, as seen above, and must appear before the [return\ntype declaration](@ref man-functions-return-type), if present, as illustrated below:\n\njulia> (myappend(v::Vector{T}, x::T)::Vector) where {T} = [v..., x]\nmyappend (generic function with 1 method)\n\njulia> myappend([1,2,3],4)\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> myappend([1,2,3],2.5)\nERROR: MethodError: no method matching myappend(::Vector{Int64}, ::Float64)\nThe function `myappend` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  myappend(::Vector{T}, !Matched::T) where T\n   @ Main none:1\n\nStacktrace:\n[...]\n\njulia> myappend([1.0,2.0,3.0],4.0)\n4-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n\njulia> myappend([1.0,2.0,3.0],4)\nERROR: MethodError: no method matching myappend(::Vector{Float64}, ::Int64)\nThe function `myappend` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  myappend(::Vector{T}, !Matched::T) where T\n   @ Main none:1\n\nStacktrace:\n[...]\n\nIf the type of the appended element does not match the element type of the vector it is appended to,\na MethodError is raised.\nIn the following example, the method's type parameter T is used as the return value:\n\njulia> mytypeof(x::T) where {T} = T\nmytypeof (generic function with 1 method)\n\njulia> mytypeof(1)\nInt64\n\njulia> mytypeof(1.0)\nFloat64\n\nJust as you can put subtype constraints on type parameters in type declarations (see Parametric Types),\nyou can also constrain type parameters of methods:\n\njulia> same_type_numeric(x::T, y::T) where {T<:Number} = true\nsame_type_numeric (generic function with 1 method)\n\njulia> same_type_numeric(x::Number, y::Number) = false\nsame_type_numeric (generic function with 2 methods)\n\njulia> same_type_numeric(1, 2)\ntrue\n\njulia> same_type_numeric(1, 2.0)\nfalse\n\njulia> same_type_numeric(1.0, 2.0)\ntrue\n\njulia> same_type_numeric(\"foo\", 2.0)\nERROR: MethodError: no method matching same_type_numeric(::String, ::Float64)\nThe function `same_type_numeric` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  same_type_numeric(!Matched::T, ::T) where T<:Number\n   @ Main none:1\n  same_type_numeric(!Matched::Number, ::Number)\n   @ Main none:1\n\nStacktrace:\n[...]\n\njulia> same_type_numeric(\"foo\", \"bar\")\nERROR: MethodError: no method matching same_type_numeric(::String, ::String)\nThe function `same_type_numeric` exists, but no method is defined for this combination of argument types.\n\njulia> same_type_numeric(Int32(1), Int64(2))\nfalse\n\nThe same_type_numeric function behaves much like the same_type function defined above, but\nis only defined for pairs of numbers.\n\nParametric methods allow the same syntax as where expressions used to write types\n(see UnionAll Types).\nIf there is only a single parameter, the enclosing curly braces (in where {T}) can be omitted,\nbut are often preferred for clarity.\nMultiple parameters can be separated with commas, e.g. where {T, S<:Real}, or written using\nnested where, e.g. where S<:Real where T."},{"title":"Redefining Methods","page":"Methods","location":"manual/methods.html#Redefining-Methods","category":"section","text":"When redefining a method or adding new methods,\nit is important to realize that these changes don't take effect immediately.\nThis is key to Julia's ability to statically infer and compile code to run fast,\nwithout the usual JIT tricks and overhead.\nIndeed, any new method definition won't be visible to the current runtime environment,\nincluding Tasks and Threads (and any previously defined @generated functions).\nLet's start with an example to see what this means:\n\njulia> function tryeval()\n           @eval newfun() = 1\n           newfun()\n       end\ntryeval (generic function with 1 method)\n\njulia> tryeval()\nERROR: MethodError: no method matching newfun()\nThe applicable method may be too new: running in world age xxxx1, while current world is xxxx2.\nClosest candidates are:\n  newfun() at none:1 (method too new to be called from this world context.)\n in tryeval() at none:1\n ...\n\njulia> newfun()\n1\n\nIn this example, observe that the new definition for newfun has been created,\nbut can't be immediately called.\nThe new global is immediately visible to the tryeval function,\nso you could write return newfun (without parentheses).\nBut neither you, nor any of your callers, nor the functions they call, or etc.\ncan call this new method definition!\n\nBut there's an exception: future calls to newfun from the REPL work as expected,\nbeing able to both see and call the new definition of newfun.\n\nHowever, future calls to tryeval will continue to see the definition of newfun as it was\nat the previous statement at the REPL, and thus before that call to tryeval.\n\nYou may want to try this for yourself to see how it works.\n\nThe implementation of this behavior is a \"world age counter\", which is further described in the World Age\nmanual chapter."},{"title":"Design Patterns with Parametric Methods","page":"Methods","location":"manual/methods.html#Design-Patterns-with-Parametric-Methods","category":"section","text":"While complex dispatch logic is not required for performance or usability,\nsometimes it can be the best way to express some algorithm.\nHere are a few common design patterns that come up sometimes when using dispatch in this way."},{"title":"Extracting the type parameter from a super-type","page":"Methods","location":"manual/methods.html#Extracting-the-type-parameter-from-a-super-type","category":"section","text":"Here is a correct code template for returning the element-type T\nof any arbitrary subtype of AbstractArray that has well-defined\nelement type:\n\nabstract type AbstractArray{T, N} end\neltype(::Type{<:AbstractArray{T}}) where {T} = T\n\nusing so-called triangular dispatch. Note that UnionAll types, for\nexample eltype(AbstractArray{T} where T <: Integer), do not match the\nabove method. The implementation of eltype in Base adds a fallback\nmethod to Any for such cases.\n\nOne common mistake is to try and get the element-type by using introspection:\n\neltype_wrong(::Type{A}) where {A<:AbstractArray} = A.parameters[1]\n\nHowever, it is not hard to construct cases where this will fail:\n\nstruct BitVector <: AbstractArray{Bool, 1}; end\n\nHere we have created a type BitVector which has no parameters,\nbut where the element-type is still fully specified, with T equal to Bool!\n\nAnother mistake is to try to walk up the type hierarchy using\nsupertype:\n\neltype_wrong(::Type{AbstractArray{T}}) where {T} = T\neltype_wrong(::Type{AbstractArray{T, N}}) where {T, N} = T\neltype_wrong(::Type{A}) where {A<:AbstractArray} = eltype_wrong(supertype(A))\n\nWhile this works for declared types, it fails for types without\nsupertypes:\n\njulia> eltype_wrong(Union{Vector{Int}, Matrix{Int}})\nERROR: MethodError: no method matching supertype(::Type{VecOrMat{Int64}})\n\nClosest candidates are:\n  supertype(::UnionAll)\n   @ Base operators.jl:44\n  supertype(::DataType)\n   @ Base operators.jl:43"},{"title":"Building a similar type with a different type parameter","page":"Methods","location":"manual/methods.html#Building-a-similar-type-with-a-different-type-parameter","category":"section","text":"When building generic code, there is often a need for constructing a similar\nobject with some change made to the layout of the type, also\nnecessitating a change of the type parameters.\nFor instance, you might have some sort of abstract array with an arbitrary element type\nand want to write your computation on it with a specific element type.\nWe must implement a method for each AbstractArray{T} subtype that describes how to compute this type transform.\nThere is no general transform of one subtype into another subtype with a different parameter.\n\nThe subtypes of AbstractArray typically implement two methods to\nachieve this:\nA method to convert the input array to a subtype of a specific AbstractArray{T, N} abstract type;\nand a method to make a new uninitialized array with a specific element type.\nSample implementations of these can be found in Julia Base.\nHere is a basic example usage of them, guaranteeing that input and\noutput are of the same type:\n\ninput = convert(AbstractArray{Eltype}, input)\noutput = similar(input, Eltype)\n\nAs an extension of this, in cases where the algorithm needs a copy of\nthe input array,\nconvert is insufficient as the return value may alias the original input.\nCombining similar (to make the output array) and copyto! (to fill it with the input data)\nis a generic way to express the requirement for a mutable copy of the input argument:\n\ncopy_with_eltype(input, Eltype) = copyto!(similar(input, Eltype), input)"},{"title":"Iterated dispatch","page":"Methods","location":"manual/methods.html#Iterated-dispatch","category":"section","text":"In order to dispatch a multi-level parametric argument list,\noften it is best to separate each level of dispatch into distinct functions.\nThis may sound similar in approach to single-dispatch, but as we shall see below, it is still more flexible.\n\nFor example, trying to dispatch on the element-type of an array will often run into ambiguous situations.\nInstead, common code will dispatch first on the container type,\nthen recurse down to a more specific method based on eltype.\nIn most cases, the algorithms lend themselves conveniently to this hierarchical approach,\nwhile in other cases, this rigor must be resolved manually.\nThis dispatching branching can be observed, for example, in the logic to sum two matrices:\n\n# First dispatch selects the map algorithm for element-wise summation.\n+(a::Matrix, b::Matrix) = map(+, a, b)\n# Then dispatch handles each element and selects the appropriate\n# common element type for the computation.\n+(a, b) = +(promote(a, b)...)\n# Once the elements have the same type, they can be added.\n# For example, via primitive operations exposed by the processor.\n+(a::Float64, b::Float64) = Core.add(a, b)"},{"title":"Trait-based dispatch","page":"Methods","location":"manual/methods.html#Trait-based-dispatch","category":"section","text":"A natural extension to the iterated dispatch above is to add a layer to\nmethod selection that allows to dispatch on sets of types which are\nindependent from the sets defined by the type hierarchy.\nWe could construct such a set by writing out a Union of the types in question,\nbut then this set would not be extensible as Union-types cannot be\naltered after creation.\nHowever, such an extensible set can be programmed with a design pattern\noften referred to as a\n\"Holy-trait\".\n\nThis pattern is implemented by defining a generic function which\ncomputes a different singleton value (or type) for each trait-set to which the\nfunction arguments may belong to. If this function is pure there is\nno impact on performance compared to normal dispatch.\n\nThe example in the previous section glossed over the implementation details of\nmap and promote, which both operate in terms of these traits.\nWhen iterating over a matrix, such as in the implementation of map,\none important question is what order to use to traverse the data.\nWhen AbstractArray subtypes implement the Base.IndexStyle trait,\nother functions such as map can dispatch on this information to pick\nthe best algorithm (see Abstract Array Interface).\nThis means that each subtype does not need to implement a custom version of map,\nsince the generic definitions + trait classes will enable the system to select the fastest version.\nHere is a toy implementation of map illustrating the trait-based dispatch:\n\nmap(f, a::AbstractArray, b::AbstractArray) = map(Base.IndexStyle(a, b), f, a, b)\n# generic implementation:\nmap(::Base.IndexCartesian, f, a::AbstractArray, b::AbstractArray) = ...\n# linear-indexing implementation (faster)\nmap(::Base.IndexLinear, f, a::AbstractArray, b::AbstractArray) = ...\n\nThis trait-based approach is also present in the promote\nmechanism employed by the scalar +.\nIt uses promote_type, which returns the optimal common type to\ncompute the operation given the two types of the operands.\nThis makes it possible to reduce the problem of implementing every function for every pair of possible type arguments,\nto the much smaller problem of implementing a conversion operation from each type to a common type,\nplus a table of preferred pair-wise promotion rules."},{"title":"Output-type computation","page":"Methods","location":"manual/methods.html#Output-type-computation","category":"section","text":"The discussion of trait-based promotion provides a transition into our next design pattern:\ncomputing the output element type for a matrix operation.\n\nFor implementing primitive operations, such as addition,\nwe use the promote_type function to compute the desired output type.\n(As before, we saw this at work in the promote call in the call to +).\n\nFor more complex functions on matrices, it may be necessary to compute the expected return\ntype for a more complex sequence of operations.\nThis is often performed by the following steps:\n\nWrite a small function op that expresses the set of operations performed by the kernel of the algorithm.\nCompute the element type R of the result matrix as promote_op(op, argument_types...),\nwhere argument_types is computed from eltype applied to each input array.\nBuild the output matrix as similar(R, dims), where dims are the desired dimensions of the output array.\n\nFor a more specific example, a generic square-matrix multiply pseudo-code might look like:\n\nfunction matmul(a::AbstractMatrix, b::AbstractMatrix)\n    op = (ai, bi) -> ai * bi + ai * bi\n\n    ## this is insufficient because it assumes `one(eltype(a))` is constructable:\n    # R = typeof(op(one(eltype(a)), one(eltype(b))))\n\n    ## this fails because it assumes `a[1]` exists and is representative of all elements of the array\n    # R = typeof(op(a[1], b[1]))\n\n    ## this is incorrect because it assumes that `+` calls `promote_type`\n    ## but this is not true for some types, such as Bool:\n    # R = promote_type(ai, bi)\n\n    # this is wrong, since depending on the return value\n    # of type-inference is very brittle (as well as not being optimizable):\n    # R = Base.return_types(op, (eltype(a), eltype(b)))\n\n    ## but, finally, this works:\n    R = promote_op(op, eltype(a), eltype(b))\n    ## although sometimes it may give a larger type than desired\n    ## it will always give a correct type\n\n    output = similar(b, R, (size(a, 1), size(b, 2)))\n    if size(a, 2) > 0\n        for j in 1:size(b, 2)\n            for i in 1:size(a, 1)\n                ## here we don't use `ab = zero(R)`,\n                ## since `R` might be `Any` and `zero(Any)` is not defined\n                ## we also must declare `ab::R` to make the type of `ab` constant in the loop,\n                ## since it is possible that typeof(a * b) != typeof(a * b + a * b) == R\n                ab::R = a[i, 1] * b[1, j]\n                for k in 2:size(a, 2)\n                    ab += a[i, k] * b[k, j]\n                end\n                output[i, j] = ab\n            end\n        end\n    end\n    return output\nend"},{"title":"Separate convert and kernel logic","page":"Methods","location":"manual/methods.html#Separate-convert-and-kernel-logic","category":"section","text":"One way to significantly cut down on compile-times and testing complexity is to isolate\nthe logic for converting to the desired type and the computation.\nThis lets the compiler specialize and inline the conversion logic independent\nfrom the rest of the body of the larger kernel.\n\nThis is a common pattern seen when converting from a larger class of types\nto the one specific argument type that is actually supported by the algorithm:\n\ncomplexfunction(arg::Int) = ...\ncomplexfunction(arg::Any) = complexfunction(convert(Int, arg))\n\nmatmul(a::T, b::T) = ...\nmatmul(a, b) = matmul(promote(a, b)...)"},{"title":"Parametrically-constrained Varargs methods","page":"Methods","location":"manual/methods.html#Parametrically-constrained-Varargs-methods","category":"section","text":"Function parameters can also be used to constrain the number of arguments that may be supplied\nto a \"varargs\" function (Varargs Functions). The notation Vararg{T,N} is used to indicate\nsuch a constraint. For example:\n\njulia> bar(a,b,x::Vararg{Any,2}) = (a,b,x)\nbar (generic function with 1 method)\n\njulia> bar(1,2,3)\nERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)\nThe function `bar` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  bar(::Any, ::Any, ::Any, !Matched::Any)\n   @ Main none:1\n\nStacktrace:\n[...]\n\njulia> bar(1,2,3,4)\n(1, 2, (3, 4))\n\njulia> bar(1,2,3,4,5)\nERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)\nThe function `bar` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  bar(::Any, ::Any, ::Any, ::Any)\n   @ Main none:1\n\nStacktrace:\n[...]\n\nMore usefully, it is possible to constrain varargs methods by a parameter. For example:\n\nfunction getindex(A::AbstractArray{T,N}, indices::Vararg{Number,N}) where {T,N}\n\nwould be called only when the number of indices matches the dimensionality of the array.\n\nWhen only the type of supplied arguments needs to be constrained Vararg{T} can be equivalently\nwritten as T.... For instance f(x::Int...) = x is a shorthand for f(x::Vararg{Int}) = x."},{"title":"Note on Optional and keyword Arguments","page":"Methods","location":"manual/methods.html#Note-on-Optional-and-keyword-Arguments","category":"section","text":"As mentioned briefly in Functions, optional arguments are implemented as syntax for multiple\nmethod definitions. For example, this definition:\n\nf(a=1,b=2) = a+2b\n\ntranslates to the following three methods:\n\nf(a,b) = a+2b\nf(a) = f(a,2)\nf() = f(1,2)\n\nThis means that calling f() is equivalent to calling f(1,2). In this case the result is 5,\nbecause f(1,2) invokes the first method of f above. However, this need not always be the case.\nIf you define a fourth method that is more specialized for integers:\n\nf(a::Int,b::Int) = a-2b\n\nthen the result of both f() and f(1,2) is -3. In other words, optional arguments are tied\nto a function, not to any specific method of that function. It depends on the types of the optional\narguments which method is invoked. When optional arguments are defined in terms of a global variable,\nthe type of the optional argument may even change at run-time.\n\nKeyword arguments behave quite differently from ordinary positional arguments. In particular,\nthey do not participate in method dispatch. Methods are dispatched based only on positional arguments,\nwith keyword arguments processed after the matching method is identified."},{"title":"Function-like objects","page":"Methods","location":"manual/methods.html#Function-like-objects","category":"section","text":"Methods are associated with types, so it is possible to make any arbitrary Julia object \"callable\"\nby adding methods to its type.\n\nFor example, you can define a type that stores the coefficients of a polynomial, but behaves like\na function evaluating the polynomial:\n\njulia> struct Polynomial{R}\n           coeffs::Vector{R}\n       end\n\njulia> function (p::Polynomial)(x)\n           v = p.coeffs[end]\n           for i = (length(p.coeffs)-1):-1:1\n               v = v*x + p.coeffs[i]\n           end\n           return v\n       end\n\njulia> (p::Polynomial)() = p(5)\n\nNotice that the function is specified by type instead of by name. As with normal functions\nthere is a terse syntax form. In the function body, p will refer to the object that was\ncalled. A Polynomial can be used as follows:\n\njulia> poly = Polynomial([1,10,100])\nPolynomial{Int64}([1, 10, 100])\n\njulia> poly(3)\n931\n\njulia> poly()\n2551\n\nThis mechanism is also the key to how type constructors and closures (inner functions that refer\nto their surrounding environment) work in Julia."},{"title":"Empty generic functions","page":"Methods","location":"manual/methods.html#Empty-generic-functions","category":"section","text":"Occasionally it is useful to introduce a generic function without yet adding methods. This can\nbe used to separate interface definitions from implementations. It might also be done for the\npurpose of documentation or code readability. The syntax for this is an empty function block\nwithout a tuple of arguments:\n\nfunction emptyfunc end"},{"title":"Method design and the avoidance of ambiguities","page":"Methods","location":"manual/methods.html#man-method-design-ambiguities","category":"section","text":"Julia's method polymorphism is one of its most powerful features, yet\nexploiting this power can pose design challenges. In particular, in\nmore complex method hierarchies it is not uncommon for\nambiguities to arise.\n\nAbove, it was pointed out that one can resolve ambiguities like\n\nf(x, y::Int) = 1\nf(x::Int, y) = 2\n\nby defining a method\n\nf(x::Int, y::Int) = 3\n\nThis is often the right strategy; however, there are circumstances\nwhere following this advice mindlessly can be counterproductive. In\nparticular, the more methods a generic function has, the more\npossibilities there are for ambiguities. When your method hierarchies\nget more complicated than this simple example, it can be worth your\nwhile to think carefully about alternative strategies.\n\nBelow we discuss particular challenges and some alternative ways to resolve such issues."},{"title":"Tuple and NTuple arguments","page":"Methods","location":"manual/methods.html#Tuple-and-NTuple-arguments","category":"section","text":"Tuple (and NTuple) arguments present special challenges. For example,\n\nf(x::NTuple{N,Int}) where {N} = 1\nf(x::NTuple{N,Float64}) where {N} = 2\n\nare ambiguous because of the possibility that N == 0: there are no\nelements to determine whether the Int or Float64 variant should be\ncalled. To resolve the ambiguity, one approach is define a method for\nthe empty tuple:\n\nf(x::Tuple{}) = 3\n\nAlternatively, for all methods but one you can insist that there is at\nleast one element in the tuple:\n\nf(x::NTuple{N,Int}) where {N} = 1           # this is the fallback\nf(x::Tuple{Float64, Vararg{Float64}}) = 2   # this requires at least one Float64"},{"title":"Orthogonalize your design","page":"Methods","location":"manual/methods.html#man-methods-orthogonalize","category":"section","text":"When you might be tempted to dispatch on two or more arguments,\nconsider whether a \"wrapper\" function might make for a simpler\ndesign. For example, instead of writing multiple variants:\n\nf(x::A, y::A) = ...\nf(x::A, y::B) = ...\nf(x::B, y::A) = ...\nf(x::B, y::B) = ...\n\nyou might consider defining\n\nf(x::A, y::A) = ...\nf(x, y) = f(g(x), g(y))\n\nwhere g converts the argument to type A. This is a very specific\nexample of the more general principle of\northogonal design,\nin which separate concepts are assigned to separate methods. Here, g\nwill most likely need a fallback definition\n\ng(x::A) = x\n\nA related strategy exploits promote to bring x and y to a common\ntype:\n\nf(x::T, y::T) where {T} = ...\nf(x, y) = f(promote(x, y)...)\n\nOne risk with this design is the possibility that if there is no\nsuitable promotion method converting x and y to the same type, the\nsecond method will recurse on itself infinitely and trigger a stack\noverflow."},{"title":"Dispatch on one argument at a time","page":"Methods","location":"manual/methods.html#Dispatch-on-one-argument-at-a-time","category":"section","text":"If you need to dispatch on multiple arguments, and there are many\nfallbacks with too many combinations to make it practical to define\nall possible variants, then consider introducing a \"name cascade\"\nwhere (for example) you dispatch on the first argument and then call\nan internal method:\n\nf(x::A, y) = _fA(x, y)\nf(x::B, y) = _fB(x, y)\n\nThen the internal methods _fA and _fB can dispatch on y without\nconcern about ambiguities with each other with respect to x.\n\nBe aware that this strategy has at least one major disadvantage: in\nmany cases, it is not possible for users to further customize the\nbehavior of f by defining further specializations of your exported\nfunction f. Instead, they have to define specializations for your\ninternal methods _fA and _fB, and this blurs the lines between\nexported and internal methods."},{"title":"Abstract containers and element types","page":"Methods","location":"manual/methods.html#Abstract-containers-and-element-types","category":"section","text":"Where possible, try to avoid defining methods that dispatch on\nspecific element types of abstract containers. For example,\n\n-(A::AbstractArray{T}, b::Date) where {T<:Date}\n\ngenerates ambiguities for anyone who defines a method\n\n-(A::MyArrayType{T}, b::T) where {T}\n\nThe best approach is to avoid defining either of these methods:\ninstead, rely on a generic method -(A::AbstractArray, b) and make\nsure this method is implemented with generic calls (like similar and\n-) that do the right thing for each container type and element type\nseparately. This is just a more complex variant of the advice to\northogonalize your methods.\n\nWhen this approach is not possible, it may be worth starting a\ndiscussion with other developers about resolving the ambiguity; just\nbecause one method was defined first does not necessarily mean that it\ncan't be modified or eliminated. As a last resort, one developer can\ndefine the \"band-aid\" method\n\n-(A::MyArrayType{T}, b::Date) where {T<:Date} = ...\n\nthat resolves the ambiguity by brute force."},{"title":"Complex method \"cascades\" with default arguments","page":"Methods","location":"manual/methods.html#Complex-method-\"cascades\"-with-default-arguments","category":"section","text":"If you are defining a method \"cascade\" that supplies defaults, be\ncareful about dropping any arguments that correspond to potential\ndefaults. For example, suppose you're writing a digital filtering\nalgorithm and you have a method that handles the edges of the signal\nby applying padding:\n\nfunction myfilter(A, kernel, ::Replicate)\n    Apadded = replicate_edges(A, size(kernel))\n    myfilter(Apadded, kernel)  # now perform the \"real\" computation\nend\n\nThis will run afoul of a method that supplies default padding:\n\nmyfilter(A, kernel) = myfilter(A, kernel, Replicate()) # replicate the edge by default\n\nTogether, these two methods generate an infinite recursion with A constantly growing bigger.\n\nThe better design would be to define your call hierarchy like this:\n\nstruct NoPad end  # indicate that no padding is desired, or that it's already applied\n\nmyfilter(A, kernel) = myfilter(A, kernel, Replicate())  # default boundary conditions\n\nfunction myfilter(A, kernel, ::Replicate)\n    Apadded = replicate_edges(A, size(kernel))\n    myfilter(Apadded, kernel, NoPad())  # indicate the new boundary conditions\nend\n\n# other padding methods go here\n\nfunction myfilter(A, kernel, ::NoPad)\n    # Here's the \"real\" implementation of the core computation\nend\n\nNoPad is supplied in the same argument position as any other kind of\npadding, so it keeps the dispatch hierarchy well organized and with\nreduced likelihood of ambiguities. Moreover, it extends the \"public\"\nmyfilter interface: a user who wants to control the padding\nexplicitly can call the NoPad variant directly."},{"title":"Defining methods in local scope","page":"Methods","location":"manual/methods.html#Defining-methods-in-local-scope","category":"section","text":"You can define methods within a local scope, for example\n\njulia> function f(x)\n           g(y::Int) = y + x\n           g(y) = y - x\n           g\n       end\nf (generic function with 1 method)\n\njulia> h = f(3);\n\njulia> h(4)\n7\n\njulia> h(4.0)\n1.0\n\nHowever, you should not define local methods conditionally or subject to control flow, as in\n\nfunction f2(inc)\n    if inc\n        g(x) = x + 1\n    else\n        g(x) = x - 1\n    end\nend\n\nfunction f3()\n    function g end\n    return g\n    g() = 0\nend\n\nas it is not clear what function will end up getting defined. In the future, it might be an error to define local methods in this manner.\n\nFor cases like this use anonymous functions instead:\n\nfunction f2(inc)\n    g = if inc\n        x -> x + 1\n    else\n        x -> x - 1\n    end\nend\n\n[Clarke61]: Arthur C. Clarke, Profiles of the Future (1961): Clarke's Third Law."},{"title":"Multi-Threading","page":"Multi-Threading","location":"base/multi-threading.html#lib-multithreading","category":"section","text":"See also Multi-Threading."},{"title":"Atomic operations","page":"Multi-Threading","location":"base/multi-threading.html#Atomic-operations","category":"section","text":"There are also optional memory ordering parameters for the unsafe set of functions, that\nselect the C/C++-compatible versions of these atomic operations, if that parameter is specified to\nunsafe_load, unsafe_store!, unsafe_swap!, unsafe_replace!, and unsafe_modify!.\n\nwarning: Warning\nThe following APIs are deprecated, though support for them is likely to remain for several releases."},{"title":"ccall using a libuv threadpool (Experimental)","page":"Multi-Threading","location":"base/multi-threading.html#ccall-using-a-libuv-threadpool-(Experimental)","category":"section","text":""},{"title":"Low-level synchronization primitives","page":"Multi-Threading","location":"base/multi-threading.html#Low-level-synchronization-primitives","category":"section","text":"These building blocks are used to create the regular synchronization objects."},{"title":"Task metrics (Experimental)","page":"Multi-Threading","location":"base/multi-threading.html#Task-metrics-(Experimental)","category":"section","text":""},{"title":"Base.Threads.@threads","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.@threads","category":"macro","text":"Threads.@threads [schedule] for ... end\n\nA macro to execute a for loop in parallel. The iteration space is distributed to\ncoarse-grained tasks. This policy can be specified by the schedule argument. The\nexecution of the loop waits for the evaluation of all iterations.\n\nTasks spawned by @threads are scheduled on the :default threadpool. This means that\n@threads will not use threads from the :interactive threadpool, even if called from\nthe main thread or from a task in the interactive pool. The :default threadpool is\nintended for compute-intensive parallel workloads.\n\nSee also: @spawn and\npmap in Distributed.\nFor more information on threadpools, see the chapter on threadpools.\n\nExtended help\n\nSemantics\n\nUnless stronger guarantees are specified by the scheduling option, the loop executed by\n@threads macro have the following semantics.\n\nThe @threads macro executes the loop body in an unspecified order and potentially\nconcurrently. It does not specify the exact assignments of the tasks and the worker threads.\nThe assignments can be different for each execution. The loop body code (including any code\ntransitively called from it) must not make any assumptions about the distribution of\niterations to tasks or the worker thread in which they are executed. The loop body for each\niteration must be able to make forward progress independent of other iterations and be free\nfrom data races. As such, invalid synchronizations across iterations may deadlock while\nunsynchronized memory accesses may result in undefined behavior.\n\nFor example, the above conditions imply that:\n\nA lock taken in an iteration must be released within the same iteration.\nCommunicating between iterations using blocking primitives like Channels is incorrect.\nWrite only to locations not shared across iterations (unless a lock or atomic operation is\nused).\nUnless the :static schedule is used, the value of threadid()\nmay change even within a single iteration. See Task Migration.\n\nSchedulers\n\nWithout the scheduler argument, the exact scheduling is unspecified and varies across Julia\nreleases. Currently, :dynamic is used when the scheduler is not specified.\n\ncompat: Julia 1.5\nThe schedule argument is available as of Julia 1.5.\n\n:dynamic (default)\n\n:dynamic scheduler executes iterations dynamically to available worker threads. Current\nimplementation assumes that the workload for each iteration is uniform. However, this\nassumption may be removed in the future.\n\nThis scheduling option is merely a hint to the underlying execution mechanism. However, a\nfew properties can be expected. The number of Tasks used by :dynamic scheduler is\nbounded by a small constant multiple of the number of available worker threads\n(Threads.threadpoolsize()). Each task processes contiguous regions of the\niteration space. Thus, @threads :dynamic for x in xs; f(x); end is typically more\nefficient than @sync for x in xs; @spawn f(x); end if length(xs) is significantly\nlarger than the number of the worker threads and the run-time of f(x) is relatively\nsmaller than the cost of spawning and synchronizing a task (typically less than 10\nmicroseconds).\n\ncompat: Julia 1.8\nThe :dynamic option for the schedule argument is available and the default as of Julia 1.8.\n\n:greedy\n\n:greedy scheduler spawns up to Threads.threadpoolsize() tasks, each greedily working on\nthe given iterated values as they are produced. As soon as one task finishes its work, it takes\nthe next value from the iterator. Work done by any individual task is not necessarily on\ncontiguous values from the iterator. The given iterator may produce values forever, only the\niterator interface is required (no indexing).\n\nThis scheduling option is generally a good choice if the workload of individual iterations\nis not uniform/has a large spread.\n\ncompat: Julia 1.11\nThe :greedy option for the schedule argument is available as of Julia 1.11.\n\n:static\n\n:static scheduler creates one task per thread and divides the iterations equally among\nthem, assigning each task specifically to each thread. In particular, the value of\nthreadid() is guaranteed to be constant within one iteration.\nSpecifying :static is an error if used from inside another @threads loop or from a\nthread other than 1.\n\nnote: Note\n:static scheduling exists for supporting transition of code written before Julia 1.3.\nIn newly written library functions, :static scheduling is discouraged because the\nfunctions using this option cannot be called from arbitrary worker threads.\n\nExamples\n\nTo illustrate of the different scheduling strategies, consider the following function\nbusywait containing a non-yielding timed loop that runs for a given number of seconds.\n\njulia> function busywait(seconds)\n            tstart = time_ns()\n            while (time_ns() - tstart) / 1e9 < seconds\n            end\n        end\n\njulia> @time begin\n            Threads.@spawn busywait(5)\n            Threads.@threads :static for i in 1:Threads.threadpoolsize()\n                busywait(1)\n            end\n        end\n6.003001 seconds (16.33 k allocations: 899.255 KiB, 0.25% compilation time)\n\njulia> @time begin\n            Threads.@spawn busywait(5)\n            Threads.@threads :dynamic for i in 1:Threads.threadpoolsize()\n                busywait(1)\n            end\n        end\n2.012056 seconds (16.05 k allocations: 883.919 KiB, 0.66% compilation time)\n\nThe :dynamic example takes 2 seconds since one of the non-occupied threads is able\nto run two of the 1-second iterations to complete the for loop.\n\n\n\n\n\n"},{"title":"Base.Threads.foreach","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.foreach","category":"function","text":"Threads.foreach(f, channel::Channel;\n                schedule::Threads.AbstractSchedule=Threads.FairSchedule(),\n                ntasks=Threads.threadpoolsize())\n\nSimilar to foreach(f, channel), but iteration over channel and calls to\nf are split across ntasks tasks spawned by Threads.@spawn. This function\nwill wait for all internally spawned tasks to complete before returning.\n\nIf schedule isa FairSchedule, Threads.foreach will attempt to spawn tasks in a\nmanner that enables Julia's scheduler to more freely load-balance work items across\nthreads. This approach generally has higher per-item overhead, but may perform\nbetter than StaticSchedule in concurrence with other multithreaded workloads.\n\nIf schedule isa StaticSchedule, Threads.foreach will spawn tasks in a manner\nthat incurs lower per-item overhead than FairSchedule, but is less amenable\nto load-balancing. This approach thus may be more suitable for fine-grained,\nuniform workloads, but may perform worse than FairSchedule in concurrence\nwith other multithreaded workloads.\n\nExamples\n\njulia> n = 20\n\njulia> c = Channel{Int}(ch -> foreach(i -> put!(ch, i), 1:n), 1)\n\njulia> d = Channel{Int}(n) do ch\n           f = i -> put!(ch, i^2)\n           Threads.foreach(f, c)\n       end\n\njulia> collect(d)\ncollect(d) = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400]\n\ncompat: Julia 1.6\nThis function requires Julia 1.6 or later.\n\n\n\n\n\n"},{"title":"Base.Threads.@spawn","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.@spawn","category":"macro","text":"Threads.@spawn [:default|:interactive|:samepool] expr\n\nCreate a Task and schedule it to run on any available\nthread in the specified threadpool: :default, :interactive, or :samepool\nto use the same as the caller. :default is used if unspecified. The task is\nallocated to a thread once one becomes available. To wait for the task to\nfinish, call wait on the result of this macro, or call\nfetch to wait and then obtain its return value.\n\nValues can be interpolated into @spawn via $, which copies the value\ndirectly into the constructed underlying closure. This allows you to insert\nthe value of a variable, isolating the asynchronous code from changes to\nthe variable's value in the current task.\n\nnote: Note\nThe thread that the task runs on may change if the task yields, therefore threadid() should not\nbe treated as constant for a task. See Task Migration, and the broader\nmulti-threading manual for further important caveats.\nSee also the chapter on threadpools.\n\ncompat: Julia 1.3\nThis macro is available as of Julia 1.3.\n\ncompat: Julia 1.4\nInterpolating values via $ is available as of Julia 1.4.\n\ncompat: Julia 1.9\nA threadpool may be specified as of Julia 1.9.\n\ncompat: Julia 1.12\nThe same threadpool may be specified as of Julia 1.12.\n\nExamples\n\njulia> t() = println(\"Hello from \", Threads.threadid());\n\njulia> tasks = fetch.([Threads.@spawn t() for i in 1:4]);\nHello from 1\nHello from 1\nHello from 3\nHello from 4\n\n\n\n\n\n"},{"title":"Base.Threads.threadid","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.threadid","category":"function","text":"Threads.threadid([t::Task])::Int\n\nGet the ID number of the current thread of execution, or the thread of task\nt. The master thread has ID 1.\n\nExamples\n\njulia> Threads.threadid()\n1\n\njulia> Threads.@threads for i in 1:4\n          println(Threads.threadid())\n       end\n4\n2\n5\n4\n\njulia> Threads.threadid(Threads.@spawn \"foo\")\n2\n\nnote: Note\nThe thread that a task runs on may change if the task yields, which is known as Task Migration.\nFor this reason in most cases it is not safe to use threadid([task]) to index into, say, a vector of buffers or stateful\nobjects.\n\n\n\n\n\n"},{"title":"Base.Threads.maxthreadid","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.maxthreadid","category":"function","text":"Threads.maxthreadid()::Int\n\nGet a lower bound on the number of threads (across all thread pools) available\nto the Julia process, with atomic-acquire semantics. The result will always be\ngreater than or equal to threadid() as well as threadid(task) for\nany task you were able to observe before calling maxthreadid.\n\n\n\n\n\n"},{"title":"Base.Threads.nthreads","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.nthreads","category":"function","text":"Threads.nthreads(:default | :interactive)::Int\n\nGet the current number of threads within the specified thread pool. The threads in :interactive\nhave id numbers 1:nthreads(:interactive), and the threads in :default have id numbers in\nnthreads(:interactive) .+ (1:nthreads(:default)).\n\nSee also BLAS.get_num_threads and BLAS.set_num_threads in the [LinearAlgebra](@ref\nman-linalg) standard library, and nprocs() in the Distributed\nstandard library and Threads.maxthreadid().\n\n\n\n\n\n"},{"title":"Base.Threads.threadpool","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.threadpool","category":"function","text":"Threads.threadpool(tid = threadid())::Symbol\n\nReturn the specified thread's threadpool; either :default, :interactive, or :foreign.\n\n\n\n\n\n"},{"title":"Base.Threads.nthreadpools","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.nthreadpools","category":"function","text":"Threads.nthreadpools()::Int\n\nReturn the number of threadpools currently configured.\n\n\n\n\n\n"},{"title":"Base.Threads.threadpoolsize","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.threadpoolsize","category":"function","text":"Threads.threadpoolsize(pool::Symbol = :default)::Int\n\nGet the number of threads available to the default thread pool (or to the\nspecified thread pool).\n\nSee also: BLAS.get_num_threads and BLAS.set_num_threads in the\nLinearAlgebra standard library, and nprocs() in the\nDistributed standard library.\n\n\n\n\n\n"},{"title":"Base.Threads.ngcthreads","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.ngcthreads","category":"function","text":"Threads.ngcthreads()::Int\n\nReturn the number of GC threads currently configured.\nThis includes both mark threads and concurrent sweep threads.\n\n\n\n\n\n"},{"title":"atomic","page":"Multi-Threading","location":"base/multi-threading.html#atomic","category":"keyword","text":"Unsafe pointer operations are compatible with loading and storing pointers declared with\n_Atomic and std::atomic type in C11 and C++23 respectively. An error may be thrown if\nthere is not support for atomically loading the Julia type T.\n\nSee also: unsafe_load, unsafe_modify!, unsafe_replace!, unsafe_store!, unsafe_swap!\n\n\n\n\n\n"},{"title":"Base.@atomic","page":"Multi-Threading","location":"base/multi-threading.html#Base.@atomic","category":"macro","text":"@atomic var\n@atomic order ex\n\nMark var or ex as being performed atomically, if ex is a supported expression.\nIf no order is specified it defaults to :sequentially_consistent.\n\n@atomic a.b.x = new\n@atomic a.b.x += addend\n@atomic :release a.b.x = new\n@atomic :acquire_release a.b.x += addend\n@atomic m[idx] = new\n@atomic m[idx] += addend\n@atomic :release m[idx] = new\n@atomic :acquire_release m[idx] += addend\n\nPerform the store operation expressed on the right atomically and return the\nnew value.\n\nWith assignment (=), this operation translates to a setproperty!(a.b, :x, new)\nor, in case of reference, to a setindex_atomic!(m, order, new, idx) call,\nwith order defaulting to :sequentially_consistent.\n\nWith any modifying operator this operation translates to a\nmodifyproperty!(a.b, :x, op, addend)[2] or, in case of reference, to a\nmodifyindex_atomic!(m, order, op, addend, idx...)[2] call,\nwith order defaulting to :sequentially_consistent.\n\n@atomic a.b.x max arg2\n@atomic a.b.x + arg2\n@atomic max(a.b.x, arg2)\n@atomic :acquire_release max(a.b.x, arg2)\n@atomic :acquire_release a.b.x + arg2\n@atomic :acquire_release a.b.x max arg2\n@atomic m[idx] max arg2\n@atomic m[idx] + arg2\n@atomic max(m[idx], arg2)\n@atomic :acquire_release max(m[idx], arg2)\n@atomic :acquire_release m[idx] + arg2\n@atomic :acquire_release m[idx] max arg2\n\nPerform the binary operation expressed on the right atomically. Store the\nresult into the field or the reference in the first argument, and return the values\n(old, new).\n\nThis operation translates to a modifyproperty!(a.b, :x, func, arg2) or,\nin case of reference to a modifyindex_atomic!(m, order, func, arg2, idx) call,\nwith order defaulting to :sequentially_consistent.\n\nSee Per-field atomics section in the manual for more details.\n\nExamples\n\njulia> mutable struct Atomic{T}; @atomic x::T; end\n\njulia> a = Atomic(1)\nAtomic{Int64}(1)\n\njulia> @atomic a.x # fetch field x of a, with sequential consistency\n1\n\njulia> @atomic :sequentially_consistent a.x = 2 # set field x of a, with sequential consistency\n2\n\njulia> @atomic a.x += 1 # increment field x of a, with sequential consistency\n3\n\njulia> @atomic a.x + 1 # increment field x of a, with sequential consistency\n3 => 4\n\njulia> @atomic a.x # fetch field x of a, with sequential consistency\n4\n\njulia> @atomic max(a.x, 10) # change field x of a to the max value, with sequential consistency\n4 => 10\n\njulia> @atomic a.x max 5 # again change field x of a to the max value, with sequential consistency\n10 => 10\n\njulia> mem = AtomicMemory{Int}(undef, 2);\n\njulia> @atomic mem[1] = 2 # set mem[1] to value 2 with sequential consistency\n2\n\njulia> @atomic :monotonic mem[1] # fetch the first value of mem, with monotonic consistency\n2\n\njulia> @atomic mem[1] += 1 # increment the first value of mem, with sequential consistency\n3\n\njulia> @atomic mem[1] + 1 # increment the first value of mem, with sequential consistency\n3 => 4\n\njulia> @atomic mem[1] # fetch the first value of mem, with sequential consistency\n4\n\njulia> @atomic max(mem[1], 10) # change the first value of mem to the max value, with sequential consistency\n4 => 10\n\njulia> @atomic mem[1] max 5 # again change the first value of mem to the max value, with sequential consistency\n10 => 10\n\ncompat: Julia 1.7\nAtomic fields functionality requires at least Julia 1.7.\n\ncompat: Julia 1.12\nAtomic reference functionality requires at least Julia 1.12.\n\n\n\n\n\n"},{"title":"Base.@atomicswap","page":"Multi-Threading","location":"base/multi-threading.html#Base.@atomicswap","category":"macro","text":"@atomicswap a.b.x = new\n@atomicswap :sequentially_consistent a.b.x = new\n@atomicswap m[idx] = new\n@atomicswap :sequentially_consistent m[idx] = new\n\nStores new into a.b.x (m[idx] in case of reference) and returns the old\nvalue of a.b.x (the old value stored at m[idx], respectively).\n\nThis operation translates to a swapproperty!(a.b, :x, new) or,\nin case of reference, swapindex_atomic!(mem, order, new, idx) call,\nwith order defaulting to :sequentially_consistent.\n\nSee Per-field atomics section in the manual for more details.\n\nExamples\n\njulia> mutable struct Atomic{T}; @atomic x::T; end\n\njulia> a = Atomic(1)\nAtomic{Int64}(1)\n\njulia> @atomicswap a.x = 2+2 # replace field x of a with 4, with sequential consistency\n1\n\njulia> @atomic a.x # fetch field x of a, with sequential consistency\n4\n\njulia> mem = AtomicMemory{Int}(undef, 2);\n\njulia> @atomic mem[1] = 1;\n\njulia> @atomicswap mem[1] = 4 # replace the first value of `mem` with 4, with sequential consistency\n1\n\njulia> @atomic mem[1] # fetch the first value of mem, with sequential consistency\n4\n\ncompat: Julia 1.7\nAtomic fields functionality requires at least Julia 1.7.\n\ncompat: Julia 1.12\nAtomic reference functionality requires at least Julia 1.12.\n\n\n\n\n\n"},{"title":"Base.@atomicreplace","page":"Multi-Threading","location":"base/multi-threading.html#Base.@atomicreplace","category":"macro","text":"@atomicreplace a.b.x expected => desired\n@atomicreplace :sequentially_consistent a.b.x expected => desired\n@atomicreplace :sequentially_consistent :monotonic a.b.x expected => desired\n@atomicreplace m[idx] expected => desired\n@atomicreplace :sequentially_consistent m[idx] expected => desired\n@atomicreplace :sequentially_consistent :monotonic m[idx] expected => desired\n\nPerform the conditional replacement expressed by the pair atomically, returning\nthe values (old, success::Bool). Where success indicates whether the\nreplacement was completed.\n\nThis operation translates to a replaceproperty!(a.b, :x, expected, desired) or,\nin case of reference, to a\nreplaceindex_atomic!(mem, success_order, fail_order, expected, desired, idx) call,\nwith both orders defaulting to :sequentially_consistent.\n\nSee Per-field atomics section in the manual for more details.\n\nExamples\n\njulia> mutable struct Atomic{T}; @atomic x::T; end\n\njulia> a = Atomic(1)\nAtomic{Int64}(1)\n\njulia> @atomicreplace a.x 1 => 2 # replace field x of a with 2 if it was 1, with sequential consistency\n(old = 1, success = true)\n\njulia> @atomic a.x # fetch field x of a, with sequential consistency\n2\n\njulia> @atomicreplace a.x 1 => 3 # replace field x of a with 2 if it was 1, with sequential consistency\n(old = 2, success = false)\n\njulia> xchg = 2 => 0; # replace field x of a with 0 if it was 2, with sequential consistency\n\njulia> @atomicreplace a.x xchg\n(old = 2, success = true)\n\njulia> @atomic a.x # fetch field x of a, with sequential consistency\n0\n\njulia> mem = AtomicMemory{Int}(undef, 2);\n\njulia> @atomic mem[1] = 1;\n\njulia> @atomicreplace mem[1] 1 => 2 # replace the first value of mem with 2 if it was 1, with sequential consistency\n(old = 1, success = true)\n\njulia> @atomic mem[1] # fetch the first value of mem, with sequential consistency\n2\n\njulia> @atomicreplace mem[1] 1 => 3 # replace field x of a with 2 if it was 1, with sequential consistency\n(old = 2, success = false)\n\njulia> xchg = 2 => 0; # replace field x of a with 0 if it was 2, with sequential consistency\n\njulia> @atomicreplace mem[1] xchg\n(old = 2, success = true)\n\njulia> @atomic mem[1] # fetch the first value of mem, with sequential consistency\n0\n\ncompat: Julia 1.7\nAtomic fields functionality requires at least Julia 1.7.\n\ncompat: Julia 1.12\nAtomic reference functionality requires at least Julia 1.12.\n\n\n\n\n\n"},{"title":"Base.@atomiconce","page":"Multi-Threading","location":"base/multi-threading.html#Base.@atomiconce","category":"macro","text":"@atomiconce a.b.x = value\n@atomiconce :sequentially_consistent a.b.x = value\n@atomiconce :sequentially_consistent :monotonic a.b.x = value\n@atomiconce m[idx] = value\n@atomiconce :sequentially_consistent m[idx] = value\n@atomiconce :sequentially_consistent :monotonic m[idx] = value\n\nPerform the conditional assignment of value atomically if it was previously\nunset. Returned value success::Bool indicates whether the assignment was completed.\n\nThis operation translates to a setpropertyonce!(a.b, :x, value) or,\nin case of reference, to a setindexonce_atomic!(m, success_order, fail_order, value, idx) call,\nwith both orders defaulting to :sequentially_consistent.\n\nSee Per-field atomics section in the manual for more details.\n\nExamples\n\njulia> mutable struct AtomicOnce\n           @atomic x\n           AtomicOnce() = new()\n       end\n\njulia> a = AtomicOnce()\nAtomicOnce(#undef)\n\njulia> @atomiconce a.x = 1 # set field x of a to 1, if unset, with sequential consistency\ntrue\n\njulia> @atomic a.x # fetch field x of a, with sequential consistency\n1\n\njulia> @atomiconce :monotonic a.x = 2 # set field x of a to 1, if unset, with monotonic consistence\nfalse\n\njulia> mem = AtomicMemory{Vector{Int}}(undef, 1);\n\njulia> isassigned(mem, 1)\nfalse\n\njulia> @atomiconce mem[1] = [1] # set the first value of mem to [1], if unset, with sequential consistency\ntrue\n\njulia> isassigned(mem, 1)\ntrue\n\njulia> @atomic mem[1] # fetch the first value of mem, with sequential consistency\n1-element Vector{Int64}:\n 1\n\njulia> @atomiconce :monotonic mem[1] = [2] # set the first value of mem to [2], if unset, with monotonic\nfalse\n\njulia> @atomic mem[1]\n1-element Vector{Int64}:\n 1\n\ncompat: Julia 1.11\nAtomic fields functionality requires at least Julia 1.11.\n\ncompat: Julia 1.12\nAtomic reference functionality requires at least Julia 1.12.\n\n\n\n\n\n"},{"title":"Core.AtomicMemory","page":"Multi-Threading","location":"base/multi-threading.html#Core.AtomicMemory","category":"type","text":"AtomicMemory{T} == GenericMemory{:atomic, T, Core.CPU}\n\nFixed-size DenseVector{T}.\nFetching of any of its individual elements is performed atomically\n(with :monotonic ordering by default).\n\nwarning: Warning\nThe access to AtomicMemory must be done by either using the @atomic\nmacro or the lower level interface functions: Base.getindex_atomic,\nBase.setindex_atomic!, Base.setindexonce_atomic!,\nBase.swapindex_atomic!, Base.modifyindex_atomic!, and Base.replaceindex_atomic!.\n\nFor details, see Atomic Operations as well as macros\n@atomic, @atomiconce, @atomicswap, and @atomicreplace.\n\ncompat: Julia 1.11\nThis type requires Julia 1.11 or later.\n\ncompat: Julia 1.12\nLower level interface functions or @atomic macro requires Julia 1.12 or later.\n\n\n\n\n\n"},{"title":"Base.Threads.Atomic","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.Atomic","category":"type","text":"Threads.Atomic{T}\n\nHolds a reference to an object of type T, ensuring that it is only\naccessed atomically, i.e. in a thread-safe manner.\n\nNew atomic objects can be created from a non-atomic values; if none is\nspecified, the atomic object is initialized with zero.\n\nAtomic objects can be accessed using the [] notation:\n\nExamples\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> x[] = 1\n1\n\njulia> x[]\n1\n\nAtomic operations use an atomic_ prefix, such as atomic_add!,\natomic_xchg!, etc.\n\n\n\n\n\n"},{"title":"Base.Threads.atomic_cas!","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.atomic_cas!","category":"function","text":"Threads.atomic_cas!(x::Atomic{T}, cmp::T, newval::T) where T\n\nAtomically compare-and-set x\n\nAtomically compares the value in x with cmp. If equal, write\nnewval to x. Otherwise, leaves x unmodified. Returns the old\nvalue in x. By comparing the returned value to cmp (via ===) one\nknows whether x was modified and now holds the new value newval.\n\nFor further details, see LLVM's cmpxchg instruction.\n\nThis function can be used to implement transactional semantics. Before\nthe transaction, one records the value in x. After the transaction,\nthe new value is stored only if x has not been modified in the mean\ntime.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_cas!(x, 4, 2);\n\njulia> x\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_cas!(x, 3, 2);\n\njulia> x\nBase.Threads.Atomic{Int64}(2)\n\n\n\n\n\n"},{"title":"Base.Threads.atomic_xchg!","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.atomic_xchg!","category":"function","text":"Threads.atomic_xchg!(x::Atomic{T}, newval::T) where T\n\nAtomically exchange the value in x\n\nAtomically exchanges the value in x with newval. Returns the old\nvalue.\n\nFor further details, see LLVM's atomicrmw xchg instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_xchg!(x, 2)\n3\n\njulia> x[]\n2\n\n\n\n\n\n"},{"title":"Base.Threads.atomic_add!","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.atomic_add!","category":"function","text":"Threads.atomic_add!(x::Atomic{T}, val::T) where T <: ArithmeticTypes\n\nAtomically add val to x\n\nPerforms x[] += val atomically. Returns the old value. Not defined for\nAtomic{Bool}.\n\nFor further details, see LLVM's atomicrmw add instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_add!(x, 2)\n3\n\njulia> x[]\n5\n\n\n\n\n\n"},{"title":"Base.Threads.atomic_sub!","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.atomic_sub!","category":"function","text":"Threads.atomic_sub!(x::Atomic{T}, val::T) where T <: ArithmeticTypes\n\nAtomically subtract val from x\n\nPerforms x[] -= val atomically. Returns the old value. Not defined for\nAtomic{Bool}.\n\nFor further details, see LLVM's atomicrmw sub instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_sub!(x, 2)\n3\n\njulia> x[]\n1\n\n\n\n\n\n"},{"title":"Base.Threads.atomic_and!","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.atomic_and!","category":"function","text":"Threads.atomic_and!(x::Atomic{T}, val::T) where T\n\nAtomically bitwise-and x with val\n\nPerforms x[] &= val atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw and instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_and!(x, 2)\n3\n\njulia> x[]\n2\n\n\n\n\n\n"},{"title":"Base.Threads.atomic_nand!","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.atomic_nand!","category":"function","text":"Threads.atomic_nand!(x::Atomic{T}, val::T) where T\n\nAtomically bitwise-nand (not-and) x with val\n\nPerforms x[] = ~(x[] & val) atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw nand instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_nand!(x, 2)\n3\n\njulia> x[]\n-3\n\n\n\n\n\n"},{"title":"Base.Threads.atomic_or!","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.atomic_or!","category":"function","text":"Threads.atomic_or!(x::Atomic{T}, val::T) where T\n\nAtomically bitwise-or x with val\n\nPerforms x[] |= val atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw or instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(5)\nBase.Threads.Atomic{Int64}(5)\n\njulia> Threads.atomic_or!(x, 7)\n5\n\njulia> x[]\n7\n\n\n\n\n\n"},{"title":"Base.Threads.atomic_xor!","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.atomic_xor!","category":"function","text":"Threads.atomic_xor!(x::Atomic{T}, val::T) where T\n\nAtomically bitwise-xor (exclusive-or) x with val\n\nPerforms x[] $= val atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw xor instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(5)\nBase.Threads.Atomic{Int64}(5)\n\njulia> Threads.atomic_xor!(x, 7)\n5\n\njulia> x[]\n2\n\n\n\n\n\n"},{"title":"Base.Threads.atomic_max!","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.atomic_max!","category":"function","text":"Threads.atomic_max!(x::Atomic{T}, val::T) where T\n\nAtomically store the maximum of x and val in x\n\nPerforms x[] = max(x[], val) atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw max instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(5)\nBase.Threads.Atomic{Int64}(5)\n\njulia> Threads.atomic_max!(x, 7)\n5\n\njulia> x[]\n7\n\n\n\n\n\n"},{"title":"Base.Threads.atomic_min!","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.atomic_min!","category":"function","text":"Threads.atomic_min!(x::Atomic{T}, val::T) where T\n\nAtomically store the minimum of x and val in x\n\nPerforms x[] = min(x[], val) atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw min instruction.\n\nExamples\n\njulia> x = Threads.Atomic{Int}(7)\nBase.Threads.Atomic{Int64}(7)\n\njulia> Threads.atomic_min!(x, 5)\n7\n\njulia> x[]\n5\n\n\n\n\n\n"},{"title":"Base.Threads.atomic_fence","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.atomic_fence","category":"function","text":"Threads.atomic_fence()\n\nInsert a sequential-consistency memory fence\n\nInserts a memory fence with sequentially-consistent ordering\nsemantics. There are algorithms where this is needed, i.e. where an\nacquire/release ordering is insufficient.\n\nThis is likely a very expensive operation. Given that all other atomic\noperations in Julia already have acquire/release semantics, explicit\nfences should not be necessary in most cases.\n\nFor further details, see LLVM's fence instruction.\n\n\n\n\n\n"},{"title":"Base.Threads.atomic_fence_heavy","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.atomic_fence_heavy","category":"function","text":"Threads.atomic_fence_heavy()\n\nInsert the heavy side of an asymmetric sequential-consistency memory fence.\nUse this function on the side that runs rarely.\nSee atomic_fence_light for more details.\n\n\n\n\n\n"},{"title":"Base.Threads.atomic_fence_light","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.atomic_fence_light","category":"function","text":"Threads.atomic_fence_light()\n\nInsert the light side of an asymmetric sequential-consistency memory fence.\nAsymmetric memory fences are useful in scenarios where one side of the\nsynchronization runs significantly less often than the other side. Use this\nfunction on the side that runs often and atomic_fence_heavy on the\nside that runs rarely.\n\nOn supported operating systems and architectures this fence is cheaper than\nThreads.atomic_fence(), but synchronizes only with atomic_fence_heavy\ncalls from other threads.\n\n\n\n\n\n"},{"title":"Base.@threadcall","page":"Multi-Threading","location":"base/multi-threading.html#Base.@threadcall","category":"macro","text":"@threadcall((cfunc, clib), rettype, (argtypes...), argvals...)\n\nThe @threadcall macro is called in the same way as ccall but does the work\nin a different thread. This is useful when you want to call a blocking C\nfunction without causing the current julia thread to become blocked. Concurrency\nis limited by size of the libuv thread pool, which defaults to 4 threads but\ncan be increased by setting the UV_THREADPOOL_SIZE environment variable and\nrestarting the julia process.\n\nNote that the called function should never call back into Julia.\n\n\n\n\n\n"},{"title":"Base.Threads.AbstractSpinLock","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.AbstractSpinLock","category":"type","text":"abstract type AbstractSpinLock <: AbstractLock end\n\nA non-reentrant, test-and-test-and-set spin lock.\nRecursive use will result in a deadlock.\nThis kind of lock should only be used around code that takes little time\nto execute and does not block (e.g. perform I/O).\nIn general, ReentrantLock should be used instead.\n\nEach lock must be matched with an unlock.\nIf !islocked(lck::AbstractSpinLock) holds, trylock(lck)\nsucceeds unless there are other tasks attempting to hold the lock \"at the same time.\"\n\nTest-and-test-and-set spin locks are quickest up to about 30ish\ncontending threads. If you have more contention than that, different\nsynchronization approaches should be considered.\n\n\n\n\n\n"},{"title":"Base.Threads.SpinLock","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.SpinLock","category":"type","text":"SpinLock() <: AbstractSpinLock\n\nSpinlocks are not padded, and so may suffer from false sharing.\nSee also PaddedSpinLock.\n\nSee the documentation for AbstractSpinLock regarding correct usage.\n\n\n\n\n\n"},{"title":"Base.Threads.PaddedSpinLock","page":"Multi-Threading","location":"base/multi-threading.html#Base.Threads.PaddedSpinLock","category":"type","text":"PaddedSpinLock() <: AbstractSpinLock\n\nPaddedSpinLocks are padded so that each is guaranteed to be on its own cache line, to avoid\nfalse sharing.\nSee also SpinLock.\n\nSee the documentation for AbstractSpinLock regarding correct usage.\n\n\n\n\n\n"},{"title":"Base.Experimental.task_metrics","page":"Multi-Threading","location":"base/multi-threading.html#Base.Experimental.task_metrics","category":"function","text":"Base.Experimental.task_metrics(::Bool)\n\nEnable or disable the collection of per-task metrics.\nA Task created when Base.Experimental.task_metrics(true) is in effect will have\nBase.Experimental.task_running_time_ns and Base.Experimental.task_wall_time_ns\ntiming information available.\n\nnote: Note\nTask metrics can be enabled at start-up via the --task-metrics=yes command line option.\n\n\n\n\n\n"},{"title":"Base.Experimental.task_running_time_ns","page":"Multi-Threading","location":"base/multi-threading.html#Base.Experimental.task_running_time_ns","category":"function","text":"Base.Experimental.task_running_time_ns(t::Task)::Union{UInt64, Nothing}\n\nReturn the total nanoseconds that the task t has spent running.\nThis metric is only updated when t yields or completes unless t is the current task, in\nwhich it will be updated continuously.\nSee also Base.Experimental.task_wall_time_ns.\n\nReturn nothing if task timings are not enabled.\nSee Base.Experimental.task_metrics.\n\nnote: This metric is from the Julia scheduler\nA task may be running on an OS thread that is descheduled by the OS\nscheduler, this time still counts towards the metric.\n\ncompat: Julia 1.12\nThis method was added in Julia 1.12.\n\n\n\n\n\n"},{"title":"Base.Experimental.task_wall_time_ns","page":"Multi-Threading","location":"base/multi-threading.html#Base.Experimental.task_wall_time_ns","category":"function","text":"Base.Experimental.task_wall_time_ns(t::Task)::Union{UInt64, Nothing}\n\nReturn the total nanoseconds that the task t was runnable.\nThis is the time since the task first entered the run queue until the time at which it\ncompleted, or until the current time if the task has not yet completed.\nSee also Base.Experimental.task_running_time_ns.\n\nReturn nothing if task timings are not enabled.\nSee Base.Experimental.task_metrics.\n\ncompat: Julia 1.12\nThis method was added in Julia 1.12.\n\n\n\n\n\n"},{"title":"Metaprogramming","page":"Metaprogramming","location":"manual/metaprogramming.html#Metaprogramming","category":"section","text":"The strongest legacy of Lisp in the Julia language is its metaprogramming support. Like Lisp,\nJulia represents its own code as a data structure of the language itself. Since code is represented\nby objects that can be created and manipulated from within the language, it is possible for a\nprogram to transform and generate its own code. This allows sophisticated code generation without\nextra build steps, and also allows true Lisp-style macros operating at the level of abstract syntax trees.\nIn contrast, preprocessor \"macro\" systems, like that of C and C++, perform textual manipulation\nand substitution before any actual parsing or interpretation occurs. Because all data types and\ncode in Julia are represented by Julia data structures, powerful reflection\ncapabilities are available to explore the internals of a program and its types just like any other\ndata.\n\nwarning: Warning\nMetaprogramming is a powerful tool, but it introduces complexity that can make code more\ndifficult to understand. For example, it can be surprisingly hard to get scope rules\ncorrect. Metaprogramming should typically be used only when other approaches such as\nhigher order functions and\nclosures cannot be applied.eval and defining new macros should be typically used as a last resort. It is almost\nnever a good idea to use Meta.parse or convert an arbitrary string into Julia code. For\nmanipulating Julia code, use the Expr data structure directly to avoid the complexity\nof how Julia syntax is parsed.The best uses of metaprogramming often implement most of their functionality in runtime\nhelper functions, striving to minimize the amount of code they generate."},{"title":"Program representation","page":"Metaprogramming","location":"manual/metaprogramming.html#Program-representation","category":"section","text":"Every Julia program starts life as a string:\n\njulia> prog = \"1 + 1\"\n\"1 + 1\"\n\nWhat happens next?\n\nThe next step is to parse each string\ninto an object called an expression, represented by the Julia type Expr:\n\njulia> ex1 = Meta.parse(prog)\n:(1 + 1)\n\njulia> typeof(ex1)\nExpr\n\nExpr objects contain two parts:\n\na Symbol identifying the kind of expression. A symbol is an interned string\nidentifier (more discussion below).\n\njulia> ex1.head\n:call\n\nthe expression arguments, which may be symbols, other expressions, or literal values:\n\njulia> ex1.args\n3-element Vector{Any}:\n  :+\n 1\n 1\n\nExpressions may also be constructed directly in prefix notation:\n\njulia> ex2 = Expr(:call, :+, 1, 1)\n:(1 + 1)\n\nThe two expressions constructed above – by parsing and by direct construction – are equivalent:\n\njulia> ex1 == ex2\ntrue\n\nThe key point here is that Julia code is internally represented as a data structure that is accessible\nfrom the language itself.\n\nThe dump function provides indented and annotated display of Expr objects:\n\njulia> dump(ex2)\nExpr\n  head: Symbol call\n  args: Array{Any}((3,))\n    1: Symbol +\n    2: Int64 1\n    3: Int64 1\n\nExpr objects may also be nested:\n\njulia> ex3 = Meta.parse(\"(4 + 4) / 2\")\n:((4 + 4) / 2)\n\nAnother way to view expressions is with Meta.show_sexpr, which displays the S-expression\nform of a given Expr, which may look very familiar to users of Lisp. Here's an example illustrating\nthe display on a nested Expr:\n\njulia> Meta.show_sexpr(ex3)\n(:call, :/, (:call, :+, 4, 4), 2)"},{"title":"Symbols","page":"Metaprogramming","location":"manual/metaprogramming.html#Symbols","category":"section","text":"The : character has two syntactic purposes in Julia. The first form creates a Symbol,\nan interned string used as one building-block\nof expressions, from valid identifiers:\n\njulia> s = :foo\n:foo\n\njulia> typeof(s)\nSymbol\n\nThe Symbol constructor takes any number of arguments and creates a new symbol by concatenating\ntheir string representations together:\n\njulia> :foo === Symbol(\"foo\")\ntrue\n\njulia> Symbol(\"1foo\") # `:1foo` would not work, as `1foo` is not a valid identifier\nSymbol(\"1foo\")\n\njulia> Symbol(\"func\",10)\n:func10\n\njulia> Symbol(:var,'_',\"sym\")\n:var_sym\n\nIn the context of an expression, symbols are used to indicate access to variables; when an expression\nis evaluated, a symbol is replaced with the value bound to that symbol in the appropriate scope.\n\nSometimes extra parentheses around the argument to : are needed to avoid ambiguity in parsing:\n\njulia> :(:)\n:(:)\n\njulia> :(::)\n:(::)"},{"title":"Expressions and evaluation","page":"Metaprogramming","location":"manual/metaprogramming.html#Expressions-and-evaluation","category":"section","text":""},{"title":"Quoting","page":"Metaprogramming","location":"manual/metaprogramming.html#Quoting","category":"section","text":"The second syntactic purpose of the : character is to create expression objects without using\nthe explicit Expr constructor. This is referred to as quoting. The : character, followed\nby paired parentheses around a single statement of Julia code, produces an Expr object based\non the enclosed code. Here is an example of the short form used to quote an arithmetic expression:\n\njulia> ex = :(a+b*c+1)\n:(a + b * c + 1)\n\njulia> typeof(ex)\nExpr\n\n(to view the structure of this expression, try ex.head and ex.args, or use dump\nas above or Meta.@dump)\n\nNote that equivalent expressions may be constructed using Meta.parse or the direct Expr\nform:\n\njulia>      :(a + b*c + 1)       ==\n       Meta.parse(\"a + b*c + 1\") ==\n       Expr(:call, :+, :a, Expr(:call, :*, :b, :c), 1)\ntrue\n\nExpressions provided by the parser generally only have symbols, other expressions, and literal\nvalues as their args, whereas expressions constructed by Julia code can have arbitrary run-time\nvalues without literal forms as args. In this specific example, + and a are symbols, *(b,c)\nis a subexpression, and 1 is a literal 64-bit signed integer.\n\nThere is a second syntactic form of quoting for multiple expressions: blocks of code enclosed\nin quote ... end.\n\njulia> ex = quote\n           x = 1\n           y = 2\n           x + y\n       end\nquote\n    #= none:2 =#\n    x = 1\n    #= none:3 =#\n    y = 2\n    #= none:4 =#\n    x + y\nend\n\njulia> typeof(ex)\nExpr"},{"title":"Interpolation","page":"Metaprogramming","location":"manual/metaprogramming.html#man-expression-interpolation","category":"section","text":"Direct construction of Expr objects with value arguments is powerful, but Expr constructors\ncan be tedious compared to \"normal\" Julia syntax. As an alternative, Julia allows interpolation of\nliterals or expressions into quoted expressions. Interpolation is indicated by a prefix $.\n\nIn this example, the value of variable a is interpolated:\n\njulia> a = 1;\n\njulia> ex = :($a + b)\n:(1 + b)\n\nInterpolating into an unquoted expression is not supported and will cause a compile-time error:\n\njulia> $a + b\nERROR: syntax: \"$\" expression outside quote\n\nIn this example, the tuple (1,2,3) is interpolated as an expression into a conditional test:\n\njulia> ex = :(a in $:((1,2,3)) )\n:(a in (1, 2, 3))\n\nThe use of $ for expression interpolation is intentionally reminiscent of string interpolation\nand command interpolation. Expression interpolation allows convenient, readable programmatic\nconstruction of complex Julia expressions."},{"title":"Splatting interpolation","page":"Metaprogramming","location":"manual/metaprogramming.html#Splatting-interpolation","category":"section","text":"Notice that the $ interpolation syntax allows inserting only a single expression into an\nenclosing expression.\nOccasionally, you have an array of expressions and need them all to become arguments of\nthe surrounding expression.\nThis can be done with the syntax $(xs...).\nFor example, the following code generates a function call where the number of arguments is\ndetermined programmatically:\n\njulia> args = [:x, :y, :z];\n\njulia> :(f(1, $(args...)))\n:(f(1, x, y, z))"},{"title":"Nested quote","page":"Metaprogramming","location":"manual/metaprogramming.html#Nested-quote","category":"section","text":"Naturally, it is possible for quote expressions to contain other quote expressions.\nUnderstanding how interpolation works in these cases can be a bit tricky.\nConsider this example:\n\njulia> x = :(1 + 2);\n\njulia> e = quote quote $x end end\nquote\n    #= none:1 =#\n    $(Expr(:quote, quote\n    #= none:1 =#\n    $(Expr(:$, :x))\nend))\nend\n\nNotice that the result contains $x, which means that x has not been\nevaluated yet.\nIn other words, the $ expression \"belongs to\" the inner quote expression, and\nso its argument is only evaluated when the inner quote expression is:\n\njulia> eval(e)\nquote\n    #= none:1 =#\n    1 + 2\nend\n\nHowever, the outer quote expression is able to interpolate values inside the $\nin the inner quote.\nThis is done with multiple $s:\n\njulia> e = quote quote $$x end end\nquote\n    #= none:1 =#\n    $(Expr(:quote, quote\n    #= none:1 =#\n    $(Expr(:$, :(1 + 2)))\nend))\nend\n\nNotice that (1 + 2) now appears in the result instead of the symbol x.\nEvaluating this expression yields an interpolated 3:\n\njulia> eval(e)\nquote\n    #= none:1 =#\n    3\nend\n\nThe intuition behind this behavior is that x is evaluated once for each $:\none $ works similarly to eval(:x), giving x's value, while two $s do the\nequivalent of eval(eval(:x))."},{"title":"QuoteNode","page":"Metaprogramming","location":"manual/metaprogramming.html#man-quote-node","category":"section","text":"The usual representation of a quote form in an AST is an Expr with head :quote:\n\njulia> dump(Meta.parse(\":(1+2)\"))\nExpr\n  head: Symbol quote\n  args: Array{Any}((1,))\n    1: Expr\n      head: Symbol call\n      args: Array{Any}((3,))\n        1: Symbol +\n        2: Int64 1\n        3: Int64 2\n\nAs we have seen, such expressions support interpolation with $.\nHowever, in some situations it is necessary to quote code without performing interpolation.\nThis kind of quoting does not yet have syntax, but is represented internally\nas an object of type QuoteNode:\n\njulia> eval(Meta.quot(Expr(:$, :(1+2))))\n3\n\njulia> eval(QuoteNode(Expr(:$, :(1+2))))\n:($(Expr(:$, :(1 + 2))))\n\nThe parser yields QuoteNodes for simple quoted items like symbols:\n\njulia> dump(Meta.parse(\":x\"))\nQuoteNode\n  value: Symbol x\n\nQuoteNode can also be used for certain advanced metaprogramming tasks.\n\nNote that while it does not support $, it also does not prevent it, nor does\nit preserve the identity of the wrapped object:\n\njulia> b = 2; eval(Expr(:quote, QuoteNode(Expr(:$, :b))))\n:($(QuoteNode(2)))"},{"title":"Evaluating expressions","page":"Metaprogramming","location":"manual/metaprogramming.html#Evaluating-expressions","category":"section","text":"Given an expression object, one can cause Julia to evaluate (execute) it at global scope using\neval:\n\njulia> ex1 = :(1 + 2)\n:(1 + 2)\n\njulia> eval(ex1)\n3\n\njulia> ex = :(a + b)\n:(a + b)\n\njulia> eval(ex)\nERROR: UndefVarError: `b` not defined in `Main`\n[...]\n\njulia> a = 1; b = 2;\n\njulia> eval(ex)\n3\n\nEvery module has its own eval function that evaluates expressions in its global\nscope. Expressions passed to eval are not limited to returning values – they can\nalso have side-effects that alter the state of the enclosing module's environment:\n\njulia> ex = :(x = 1)\n:(x = 1)\n\njulia> x\nERROR: UndefVarError: `x` not defined in `Main`\n\njulia> eval(ex)\n1\n\njulia> x\n1\n\nHere, the evaluation of an expression object causes a value to be assigned to the global variable\nx.\n\nSince expressions are just Expr objects which can be constructed programmatically and then evaluated,\nit is possible to dynamically generate arbitrary code which can then be run using eval.\nHere is a simple example:\n\njulia> a = 1;\n\njulia> ex = Expr(:call, :+, a, :b)\n:(1 + b)\n\njulia> a = 0; b = 2;\n\njulia> eval(ex)\n3\n\nThe value of a is used to construct the expression ex which applies the + function to the\nvalue 1 and the variable b. Note the important distinction between the way a and b are used:\n\nThe value of the variable a at expression construction time is used as an immediate value in\nthe expression. Thus, the value of a when the expression is evaluated no longer matters: the\nvalue in the expression is already 1, independent of whatever the value of a might be.\nOn the other hand, the symbol :b is used in the expression construction, so the value of the\nvariable b at that time is irrelevant – :b is just a symbol and the variable b need not\neven be defined. At expression evaluation time, however, the value of the symbol :b is resolved\nby looking up the value of the variable b."},{"title":"Functions on Expressions","page":"Metaprogramming","location":"manual/metaprogramming.html#Functions-on-Expressions","category":"section","text":"As hinted above, one extremely useful feature of Julia is the capability to generate and manipulate\nJulia code within Julia itself. We have already seen one example of a function returning Expr\nobjects: the Meta.parse function, which takes a string of Julia code and returns the corresponding\nExpr. A function can also take one or more Expr objects as arguments, and return another\nExpr. Here is a simple, motivating example:\n\njulia> function math_expr(op, op1, op2)\n           expr = Expr(:call, op, op1, op2)\n           return expr\n       end\nmath_expr (generic function with 1 method)\n\njulia>  ex = math_expr(:+, 1, Expr(:call, :*, 4, 5))\n:(1 + 4 * 5)\n\njulia> eval(ex)\n21\n\nAs another example, here is a function that doubles any numeric argument, but leaves expressions\nalone:\n\njulia> function make_expr2(op, opr1, opr2)\n           opr1f, opr2f = map(x -> isa(x, Number) ? 2*x : x, (opr1, opr2))\n           retexpr = Expr(:call, op, opr1f, opr2f)\n           return retexpr\n       end\nmake_expr2 (generic function with 1 method)\n\njulia> make_expr2(:+, 1, 2)\n:(2 + 4)\n\njulia> ex = make_expr2(:+, 1, Expr(:call, :*, 5, 8))\n:(2 + 5 * 8)\n\njulia> eval(ex)\n42"},{"title":"Macros","page":"Metaprogramming","location":"manual/metaprogramming.html#man-macros","category":"section","text":"Macros provide a mechanism to include generated code in the final body of a program. A macro maps\na tuple of arguments to a returned expression, and the resulting expression is compiled directly\nrather than requiring a runtime eval call. Macro arguments may include expressions,\nliteral values, and symbols."},{"title":"Basics","page":"Metaprogramming","location":"manual/metaprogramming.html#Basics","category":"section","text":"Here is an extraordinarily simple macro:\n\njulia> macro sayhello()\n           return :( println(\"Hello, world!\") )\n       end\n@sayhello (macro with 1 method)\n\nMacros have a dedicated character in Julia's syntax: the @ (at-sign), followed by the unique\nname declared in a macro NAME ... end block. In this example, the compiler will replace all\ninstances of @sayhello with:\n\n:( println(\"Hello, world!\") )\n\nWhen @sayhello is entered in the REPL, the expression executes immediately, thus we only see the\nevaluation result:\n\njulia> @sayhello()\nHello, world!\n\nNow, consider a slightly more complex macro:\n\njulia> macro sayhello(name)\n           return :( println(\"Hello, \", $name) )\n       end\n@sayhello (macro with 1 method)\n\nThis macro takes one argument: name. When @sayhello is encountered, the quoted expression\nis expanded to interpolate the value of the argument into the final expression:\n\njulia> @sayhello(\"human\")\nHello, human\n\nWe can view the quoted return expression using the function macroexpand (important note:\nthis is an extremely useful tool for debugging macros):\n\njulia> ex = macroexpand(Main, :(@sayhello(\"human\")) )\n:(Main.println(\"Hello, \", \"human\"))\n\njulia> typeof(ex)\nExpr\n\nWe can see that the \"human\" literal has been interpolated into the expression.\n\nThere also exists a macro @macroexpand that is perhaps a bit more convenient than the macroexpand function:\n\njulia> @macroexpand @sayhello \"human\"\n:(println(\"Hello, \", \"human\"))"},{"title":"Hold up: why macros?","page":"Metaprogramming","location":"manual/metaprogramming.html#Hold-up:-why-macros?","category":"section","text":"We have already seen a function f(::Expr...) -> Expr in a previous section. In fact, macroexpand\nis also such a function. So, why do macros exist?\n\nMacros are necessary because they execute when code is parsed, therefore, macros allow the programmer\nto generate and include fragments of customized code before the full program is run. To illustrate\nthe difference, consider the following example:\n\njulia> macro twostep(arg)\n           println(\"I execute at parse time. The argument is: \", arg)\n           return :(println(\"I execute at runtime. The argument is: \", $arg))\n       end\n@twostep (macro with 1 method)\n\njulia> ex = macroexpand(Main, :(@twostep :(1, 2, 3)) );\nI execute at parse time. The argument is: :((1, 2, 3))\n\nThe first call to println is executed when macroexpand is called. The\nresulting expression contains only the second println:\n\njulia> typeof(ex)\nExpr\n\njulia> ex\n:(println(\"I execute at runtime. The argument is: \", $(Expr(:copyast, :($(QuoteNode(:((1, 2, 3)))))))))\n\njulia> eval(ex)\nI execute at runtime. The argument is: (1, 2, 3)"},{"title":"Macro invocation","page":"Metaprogramming","location":"manual/metaprogramming.html#Macro-invocation","category":"section","text":"Macros are invoked with the following general syntax:\n\n@name expr1 expr2 ...\n@name(expr1, expr2, ...)\n\nNote the distinguishing @ before the macro name and the lack of commas between the argument\nexpressions in the first form, and the lack of whitespace after @name in the second form. The\ntwo styles should not be mixed. For example, the following syntax is different from the examples\nabove; it passes the tuple (expr1, expr2, ...) as one argument to the macro:\n\n@name (expr1, expr2, ...)\n\nAn alternative way to invoke a macro over an array literal (or comprehension) is to juxtapose both without using parentheses. In this case, the array will be the only expression fed to the macro. The following syntax is equivalent (and different from @name [a b] * v):\n\n@name[a b] * v\n@name([a b]) * v\n\nIt is important to emphasize that macros receive their arguments as expressions, literals, or\nsymbols. One way to explore macro arguments is to call the show function within the\nmacro body:\n\njulia> macro showarg(x)\n           show(x)\n           # ... remainder of macro, returning an expression\n       end\n@showarg (macro with 1 method)\n\njulia> @showarg(a)\n:a\n\njulia> @showarg(1+1)\n:(1 + 1)\n\njulia> @showarg(println(\"Yo!\"))\n:(println(\"Yo!\"))\n\njulia> @showarg(1)        # Numeric literal\n1\n\njulia> @showarg(\"Yo!\")    # String literal\n\"Yo!\"\n\njulia> @showarg(\"Yo! $(\"hello\")\")    # String with interpolation is an Expr rather than a String\n:(\"Yo! $(\"hello\")\")\n\nIn addition to the given argument list, every macro is passed extra arguments named __source__ and __module__.\n\nThe argument __source__ provides information (in the form of a LineNumberNode object) about the parser location\nof the @ sign from the macro invocation.\nThis allows macros to include better error diagnostic information,\nand is commonly used by logging, string-parser macros, and docs, for example,\nas well as to implement the @__LINE__, @__FILE__, and @__DIR__ macros.\n\nThe location information can be accessed by referencing __source__.line and __source__.file:\n\njulia> macro __LOCATION__(); return QuoteNode(__source__); end\n@__LOCATION__ (macro with 1 method)\n\njulia> dump(\n            @__LOCATION__(\n       ))\nLineNumberNode\n  line: Int64 2\n  file: Symbol none\n\nThe argument __module__ provides information (in the form of a Module object)\nabout the expansion context of the macro invocation.\nThis allows macros to look up contextual information, such as existing bindings,\nor to insert the value as an extra argument to a runtime function call doing self-reflection\nin the current module."},{"title":"Building an advanced macro","page":"Metaprogramming","location":"manual/metaprogramming.html#Building-an-advanced-macro","category":"section","text":"Here is a simplified definition of Julia's @assert macro:\n\njulia> macro assert(ex)\n           return :( $ex ? nothing : throw(AssertionError($(string(ex)))) )\n       end\n@assert (macro with 1 method)\n\nThis macro can be used like this:\n\njulia> @assert 1 == 1.0\n\njulia> @assert 1 == 0\nERROR: AssertionError: 1 == 0\n\nIn place of the written syntax, the macro call is expanded at parse time to its returned result.\nThis is equivalent to writing:\n\n1 == 1.0 ? nothing : throw(AssertionError(\"1 == 1.0\"))\n1 == 0 ? nothing : throw(AssertionError(\"1 == 0\"))\n\nThat is, in the first call, the expression :(1 == 1.0) is spliced into the test condition slot,\nwhile the value of string(:(1 == 1.0)) is spliced into the assertion message slot. The entire\nexpression, thus constructed, is placed into the syntax tree where the @assert macro call occurs.\nThen at execution time, if the test expression evaluates to true, then nothing is returned,\nwhereas if the test is false, an error is raised indicating the asserted expression that was false.\nNotice that it would not be possible to write this as a function, since only the value of the\ncondition is available and it would be impossible to display the expression that computed it in\nthe error message.\n\nThe actual definition of @assert in Julia Base is more complicated. It allows the\nuser to optionally specify their own error message, instead of just printing the failed expression.\nJust like in functions with a variable number of arguments (Varargs Functions), this is specified with an ellipses\nfollowing the last argument:\n\njulia> macro assert(ex, msgs...)\n           msg_body = isempty(msgs) ? ex : msgs[1]\n           msg = string(msg_body)\n           return :($ex ? nothing : throw(AssertionError($msg)))\n       end\n@assert (macro with 1 method)\n\nNow @assert has two modes of operation, depending upon the number of arguments it receives!\nIf there's only one argument, the tuple of expressions captured by msgs will be empty and it\nwill behave the same as the simpler definition above. But now if the user specifies a second argument,\nit is printed in the message body instead of the failing expression. You can inspect the result\nof a macro expansion with the aptly named @macroexpand macro:\n\njulia> @macroexpand @assert a == b\n:(if Main.a == Main.b\n        Main.nothing\n    else\n        Main.throw(Main.AssertionError(\"a == b\"))\n    end)\n\njulia> @macroexpand @assert a==b \"a should equal b!\"\n:(if Main.a == Main.b\n        Main.nothing\n    else\n        Main.throw(Main.AssertionError(\"a should equal b!\"))\n    end)\n\nThere is yet another case that the actual @assert macro handles: what if, in addition to printing\n\"a should equal b,\" we wanted to print their values? One might naively try to use string interpolation\nin the custom message, e.g., @assert a==b \"a ($a) should equal b ($b)!\", but this won't work\nas expected with the above macro. Can you see why? Recall from string interpolation that\nan interpolated string is rewritten to a call to string. Compare:\n\njulia> typeof(:(\"a should equal b\"))\nString\n\njulia> typeof(:(\"a ($a) should equal b ($b)!\"))\nExpr\n\njulia> dump(:(\"a ($a) should equal b ($b)!\"))\nExpr\n  head: Symbol string\n  args: Array{Any}((5,))\n    1: String \"a (\"\n    2: Symbol a\n    3: String \") should equal b (\"\n    4: Symbol b\n    5: String \")!\"\n\nSo now instead of getting a plain string in msg_body, the macro is receiving a full expression\nthat will need to be evaluated in order to display as expected. This can be spliced directly into\nthe returned expression as an argument to the string call; see error.jl\nfor the complete implementation.\n\nThe @assert macro makes great use of splicing into quoted expressions to simplify the manipulation\nof expressions inside the macro body."},{"title":"Hygiene","page":"Metaprogramming","location":"manual/metaprogramming.html#Hygiene","category":"section","text":"An issue that arises in more complex macros is that of hygiene.\nIn short, macros must ensure that the variables they introduce in their returned expressions do\nnot accidentally clash with existing variables in the surrounding code they expand into. Conversely,\nthe expressions that are passed into a macro as arguments are often expected to evaluate in\nthe context of the surrounding code, interacting with and modifying the existing variables. Another\nconcern arises from the fact that a macro may be called in a different module from where it was\ndefined. In this case we need to ensure that all global variables are resolved to the correct\nmodule. Julia already has a major advantage over languages with textual macro expansion (like\nC) in that it only needs to consider the returned expression. All the other variables (such as\nmsg in @assert above) follow the normal scoping block behavior.\n\nTo demonstrate these issues, let us consider writing a @time macro that takes an expression\nas its argument, records the time, evaluates the expression, records the time again, prints the\ndifference between the before and after times, and then has the value of the expression as its\nfinal value. The macro might look like this:\n\nmacro time(ex)\n    return quote\n        local t0 = time_ns()\n        local val = $ex\n        local t1 = time_ns()\n        println(\"elapsed time: \", (t1-t0)/1e9, \" seconds\")\n        val\n    end\nend\n\nHere, we want t0, t1, and val to be private temporary variables, and we want time_ns to refer\nto the time_ns function in Julia Base, not to any time_ns variable the user\nmight have (the same applies to println). Imagine the problems that could occur if the user\nexpression ex also contained assignments to a variable called t0, or defined its own time_ns\nvariable. We might get errors, or mysteriously incorrect behavior.\n\nJulia's macro expander solves these problems in the following way. First, variables within a macro\nresult are classified as either local or global. A variable is considered local if it is assigned\nto (and not declared global), declared local, or used as a function argument name. Otherwise,\nit is considered global. Local variables are then renamed to be unique (using the gensym\nfunction, which generates new symbols), and global variables are resolved within the macro definition\nenvironment. Therefore both of the above concerns are handled; the macro's locals will not conflict\nwith any user variables, and time_ns and println will refer to the Julia Base definitions.\n\nOne problem remains however. Consider the following use of this macro:\n\nmodule MyModule\nimport Base.@time\n\ntime_ns() = ... # compute something\n\n@time time_ns()\nend\n\nHere the user expression ex is a call to time_ns, but not the same time_ns function that the macro\nuses. It clearly refers to MyModule.time_ns. Therefore we must arrange for the code in ex to\nbe resolved in the macro call environment. This is done by \"escaping\" the expression with esc:\n\nmacro time(ex)\n    ...\n    local val = $(esc(ex))\n    ...\nend\n\nAn expression wrapped in this manner is left alone by the macro expander and simply pasted into\nthe output verbatim. Therefore it will be resolved in the macro call environment.\n\nThis escaping mechanism can be used to \"violate\" hygiene when necessary, in order to introduce\nor manipulate user variables. For example, the following macro sets x to zero in the call environment:\n\njulia> macro zerox()\n           return esc(:(x = 0))\n       end\n@zerox (macro with 1 method)\n\njulia> function foo()\n           x = 1\n           @zerox\n           return x # is zero\n       end\nfoo (generic function with 1 method)\n\njulia> foo()\n0\n\nThis kind of manipulation of variables should be used judiciously, but is occasionally quite handy.\n\nGetting the hygiene rules correct can be a formidable challenge.\nBefore using a macro, you might want to consider whether a function closure\nwould be sufficient. Another useful strategy is to defer as much work as possible to runtime.\nFor example, many macros simply wrap their arguments in a QuoteNode or other similar Expr.\nSome examples of this include @task body which simply returns schedule(Task(() -> $body)),\nand @eval expr, which simply returns eval(QuoteNode(expr)).\n\nTo demonstrate, we might rewrite the @time example above as:\n\nmacro time(expr)\n    return :(timeit(() -> $(esc(expr))))\nend\nfunction timeit(f)\n    t0 = time_ns()\n    val = f()\n    t1 = time_ns()\n    println(\"elapsed time: \", (t1-t0)/1e9, \" seconds\")\n    return val\nend\n\nHowever, we don't do this for a good reason: wrapping the expr in a new scope block (the anonymous function)\nalso slightly changes the meaning of the expression (the scope of any variables in it),\nwhile we want @time to be usable with minimum impact on the wrapped code."},{"title":"Macros and dispatch","page":"Metaprogramming","location":"manual/metaprogramming.html#Macros-and-dispatch","category":"section","text":"Macros, just like Julia functions, are generic. This means they can also have multiple method definitions, thanks to multiple dispatch:\n\njulia> macro m end\n@m (macro with 0 methods)\n\njulia> macro m(args...)\n           println(\"$(length(args)) arguments\")\n       end\n@m (macro with 1 method)\n\njulia> macro m(x,y)\n           println(\"Two arguments\")\n       end\n@m (macro with 2 methods)\n\njulia> @m \"asd\"\n1 arguments\n\njulia> @m 1 2\nTwo arguments\n\nHowever one should keep in mind, that macro dispatch is based on the types of AST\nthat are handed to the macro, not the types that the AST evaluates to at runtime:\n\njulia> macro m(::Int)\n           println(\"An Integer\")\n       end\n@m (macro with 3 methods)\n\njulia> @m 2\nAn Integer\n\njulia> x = 2\n2\n\njulia> @m x\n1 arguments"},{"title":"Code Generation","page":"Metaprogramming","location":"manual/metaprogramming.html#Code-Generation","category":"section","text":"When a significant amount of repetitive boilerplate code is required, it is common to generate\nit programmatically to avoid redundancy. In most languages, this requires an extra build step,\nand a separate program to generate the repetitive code. In Julia, expression interpolation and\neval allow such code generation to take place in the normal course of program execution.\nFor example, consider the following custom type\n\nstruct MyNumber\n    x::Float64\nend\n# output\n\n\nfor which we want to add a number of methods to. We can do this programmatically in the\nfollowing loop:\n\nfor op = (:sin, :cos, :tan, :log, :exp)\n    eval(quote\n        Base.$op(a::MyNumber) = MyNumber($op(a.x))\n    end)\nend\n# output\n\n\nand we can now use those functions with our custom type:\n\njulia> x = MyNumber(π)\nMyNumber(3.141592653589793)\n\njulia> sin(x)\nMyNumber(1.2246467991473532e-16)\n\njulia> cos(x)\nMyNumber(-1.0)\n\nIn this manner, Julia acts as its own preprocessor,\nand allows code generation from inside the language. The above code could be written slightly\nmore tersely using the : prefix quoting form:\n\nfor op = (:sin, :cos, :tan, :log, :exp)\n    eval(:(Base.$op(a::MyNumber) = MyNumber($op(a.x))))\nend\n\nThis sort of in-language code generation, however, using the eval(quote(...)) pattern, is common\nenough that Julia comes with a macro to abbreviate this pattern:\n\nfor op = (:sin, :cos, :tan, :log, :exp)\n    @eval Base.$op(a::MyNumber) = MyNumber($op(a.x))\nend\n\nThe @eval macro rewrites this call to be precisely equivalent to the above longer versions.\nFor longer blocks of generated code, the expression argument given to @eval can be a\nblock:\n\n@eval begin\n    # multiple lines\nend"},{"title":"Non-Standard String Literals","page":"Metaprogramming","location":"manual/metaprogramming.html#meta-non-standard-string-literals","category":"section","text":"Recall from Strings that string literals prefixed by an identifier are called non-standard\nstring literals, and can have different semantics than un-prefixed string literals. For example:\n\nr\"^\\s*(?:#|$)\" produces a regular expression object rather than a string\nb\"DATA\\xff\\u2200\" is a byte array literal for [68,65,84,65,255,226,136,128].\n\nPerhaps surprisingly, these behaviors are not hard-coded into the Julia parser or compiler. Instead,\nthey are custom behaviors provided by a general mechanism that anyone can use: prefixed string\nliterals are parsed as calls to specially-named macros. For example, the regular expression macro\nis just the following:\n\nmacro r_str(p)\n    Regex(p)\nend\n\nThat's all. This macro says that the literal contents of the string literal r\"^\\s*(?:#|$)\" should\nbe passed to the @r_str macro and the result of that expansion should be placed in the syntax\ntree where the string literal occurs. In other words, the expression r\"^\\s*(?:#|$)\" is equivalent\nto placing the following object directly into the syntax tree:\n\nRegex(\"^\\\\s*(?:#|\\$)\")\n\nNot only is the string literal form shorter and far more convenient, but it is also more efficient:\nsince the regular expression is compiled and the Regex object is actually created when the code is compiled,\nthe compilation occurs only once, rather than every time the code is executed. Consider if the\nregular expression occurs in a loop:\n\nfor line = lines\n    m = match(r\"^\\s*(?:#|$)\", line)\n    if m === nothing\n        # non-comment\n    else\n        # comment\n    end\nend\n\nSince the regular expression r\"^\\s*(?:#|$)\" is compiled and inserted into the syntax tree when\nthis code is parsed, the expression is only compiled once instead of each time the loop is executed.\nIn order to accomplish this without macros, one would have to write this loop like this:\n\nre = Regex(\"^\\\\s*(?:#|\\$)\")\nfor line = lines\n    m = match(re, line)\n    if m === nothing\n        # non-comment\n    else\n        # comment\n    end\nend\n\nMoreover, if the compiler could not determine that the regex object was constant over all loops,\ncertain optimizations might not be possible, making this version still less efficient than the\nmore convenient literal form above. Of course, there are still situations where the non-literal\nform is more convenient: if one needs to interpolate a variable into the regular expression, one\nmust take this more verbose approach; in cases where the regular expression pattern itself is\ndynamic, potentially changing upon each loop iteration, a new regular expression object must be\nconstructed on each iteration. In the vast majority of use cases, however, regular expressions\nare not constructed based on run-time data. In this majority of cases, the ability to write regular\nexpressions as compile-time values is invaluable.\n\nThe mechanism for user-defined string literals is deeply, profoundly powerful. Not only are Julia's\nnon-standard literals implemented using it, but the command literal syntax (`echo \"Hello, $person\"`)\nis also implemented using the following innocuous-looking macro:\n\nmacro cmd(str)\n    :(cmd_gen($(shell_parse(str)[1])))\nend\n\nOf course, a large amount of complexity is hidden in the functions used in this macro definition,\nbut they are just functions, written entirely in Julia. You can read their source and see precisely\nwhat they do – and all they do is construct expression objects to be inserted into your program's\nsyntax tree.\n\nLike string literals, command literals can also be prefixed by an identifier\nto form what are called non-standard command literals. These command literals are parsed\nas calls to specially-named macros. For example, the syntax custom`literal` is parsed\nas @custom_cmd \"literal\".\nJulia itself does not contain any non-standard command literals, but packages can make use of\nthis syntax. Aside from the different syntax and the _cmd suffix instead of the _str suffix,\nnon-standard command literals behave exactly like non-standard string literals.\n\nIn the event that two modules provide non-standard string or command literals with the same name,\nit is possible to qualify the string or command literal with a module name. For instance, if both\nFoo and Bar provide non-standard string literal @x_str, then one can write Foo.x\"literal\"\nor Bar.x\"literal\" to disambiguate between the two.\n\nAnother way to define a macro would be like this:\n\nmacro foo_str(str, flag)\n    # do stuff\nend\n\nThis macro can then be called with the following syntax:\n\nfoo\"str\"flag\n\nThe type of flag in the above mentioned syntax would be a String with contents of whatever trails after the string literal."},{"title":"Generated functions","page":"Metaprogramming","location":"manual/metaprogramming.html#Generated-functions","category":"section","text":"A very special macro is @generated, which allows you to define so-called generated functions.\nThese have the capability to generate specialized code depending on the types of their arguments\nwith more flexibility and/or less code than what can be achieved with multiple dispatch. While\nmacros work with expressions at parse time and cannot access the types of their inputs, a generated\nfunction gets expanded at a time when the types of the arguments are known, but the function is\nnot yet compiled.\n\nInstead of performing some calculation or action, a generated function declaration returns a quoted\nexpression which then forms the body for the method corresponding to the types of the arguments.\nWhen a generated function is called, the expression it returns is compiled and then run.\nTo make this efficient, the result is usually cached. And to make this inferable, only a limited\nsubset of the language is usable. Thus, generated functions provide a flexible way to move work from\nrun time to compile time, at the expense of greater restrictions on allowed constructs.\n\nWhen defining generated functions, there are five main differences to ordinary functions:\n\nYou annotate the function declaration with the @generated macro. This adds some information\nto the AST that lets the compiler know that this is a generated function.\nIn the body of the generated function you only have access to the types of the arguments –\nnot their values.\nInstead of calculating something or performing some action, you return a quoted expression which,\nwhen evaluated, does what you want.\nGenerated functions are only permitted to call functions that were defined before the definition of the generated\nfunction. (Failure to follow this may result in getting MethodErrors referring to functions from a future world-age.)\nGenerated functions must not mutate or observe any non-constant global state (including,\nfor example, IO, locks, non-local dictionaries, or using hasmethod).\nThis means they can only read global constants, and cannot have any side effects.\nIn other words, they must be completely pure.\nDue to an implementation limitation, this also means that they currently cannot define a closure\nor generator.\n\nIt's easiest to illustrate this with an example. We can declare a generated function foo as\n\njulia> @generated function foo(x)\n           Core.println(x)\n           return :(x * x)\n       end\nfoo (generic function with 1 method)\n\nNote that the body returns a quoted expression, namely :(x * x), rather than just the value\nof x * x.\n\nFrom the caller's perspective, this is identical to a regular function; in fact, you don't\nhave to know whether you're calling a regular or generated function. Let's see how foo behaves:\n\njulia> x = foo(2); # note: output is from println() statement in the body\nInt64\n\njulia> x           # now we print x\n4\n\njulia> y = foo(\"bar\");\nString\n\njulia> y\n\"barbar\"\n\nSo, we see that in the body of the generated function, x is the type of the passed argument,\nand the value returned by the generated function, is the result of evaluating the quoted expression\nwe returned from the definition, now with the value of x.\n\nWhat happens if we evaluate foo again with a type that we have already used?\n\njulia> foo(4)\n16\n\nNote that there is no printout of Int64. We can see that the body of the generated function\nwas only executed once here, for the specific set of argument types, and the result was cached.\nAfter that, for this example, the expression returned from the generated function on the first\ninvocation was re-used as the method body. However, the actual caching behavior is an implementation-defined\nperformance optimization, so it is invalid to depend too closely on this behavior.\n\nThe number of times a generated function is generated might be only once, but it might also\nbe more often, or appear to not happen at all. As a consequence, you should never write a generated\nfunction with side effects - when, and how often, the side effects occur is undefined. (This is\ntrue for macros too - and just like for macros, the use of eval in a generated function\nis a sign that you're doing something the wrong way.) However, unlike macros, the runtime system\ncannot correctly handle a call to eval, so it is disallowed.\n\nIt is also important to see how @generated functions interact with method redefinition.\nFollowing the principle that a correct @generated function must not observe any\nmutable state or cause any mutation of global state, we see the following behavior.\nObserve that the generated function cannot call any method that was not defined\nprior to the definition of the generated function itself.\n\nInitially f(x) has one definition\n\njulia> f(x) = \"original definition\";\n\nDefine other operations that use f(x):\n\njulia> g(x) = f(x);\n\njulia> @generated gen1(x) = f(x);\n\njulia> @generated gen2(x) = :(f(x));\n\nWe now add some new definitions for f(x):\n\njulia> f(x::Int) = \"definition for Int\";\n\njulia> f(x::Type{Int}) = \"definition for Type{Int}\";\n\nand compare how these results differ:\n\njulia> f(1)\n\"definition for Int\"\n\njulia> g(1)\n\"definition for Int\"\n\njulia> gen1(1)\n\"original definition\"\n\njulia> gen2(1)\n\"definition for Int\"\n\nEach method of a generated function has its own view of defined functions:\n\njulia> @generated gen1(x::Real) = f(x);\n\njulia> gen1(1)\n\"definition for Type{Int}\"\n\nThe example generated function foo above did not do anything a normal function foo(x) = x * x\ncould not do (except printing the type on the first invocation, and incurring higher overhead).\nHowever, the power of a generated function lies in its ability to compute different quoted expressions\ndepending on the types passed to it:\n\njulia> @generated function bar(x)\n           if x <: Integer\n               return :(x ^ 2)\n           else\n               return :(x)\n           end\n       end\nbar (generic function with 1 method)\n\njulia> bar(4)\n16\n\njulia> bar(\"baz\")\n\"baz\"\n\n(although of course this contrived example would be more easily implemented using multiple dispatch...)\n\nAbusing this will corrupt the runtime system and cause undefined behavior:\n\njulia> @generated function baz(x)\n           if rand() < .9\n               return :(x^2)\n           else\n               return :(\"boo!\")\n           end\n       end\nbaz (generic function with 1 method)\n\nSince the body of the generated function is non-deterministic, its behavior, and the behavior of all subsequent code\nis undefined.\n\nDon't copy these examples!\n\nThese examples are hopefully helpful to illustrate how generated functions work, both in the definition\nend and at the call site; however, don't copy them, for the following reasons:\n\nthe foo function has side-effects (the call to Core.println), and it is undefined exactly\nwhen, how often or how many times these side-effects will occur\nthe bar function solves a problem that is better solved with multiple dispatch - defining bar(x) = x\nand bar(x::Integer) = x ^ 2 will do the same thing, but it is both simpler and faster.\nthe baz function is pathological\n\nNote that the set of operations that should not be attempted in a generated function is unbounded,\nand the runtime system can currently only detect a subset of the invalid operations. There are\nmany other operations that will simply corrupt the runtime system without notification, usually\nin subtle ways not obviously connected to the bad definition. Because the function generator is\nrun during inference, it must respect all of the limitations of that code.\n\nSome operations that should not be attempted include:\n\nCaching of native pointers.\nInteracting with the contents or methods of Core.Compiler in any way.\nObserving any mutable state.\nInference on the generated function may be run at any time, including while your code is attempting\nto observe or mutate this state.\nTaking any locks: C code you call out to may use locks internally, (for example, it is not problematic\nto call malloc, even though most implementations require locks internally) but don't attempt\nto hold or acquire any while executing Julia code.\nCalling any function that is defined after the body of the generated function. This condition\nis relaxed for incrementally-loaded precompiled modules to allow calling any function in the module.\n\nAlright, now that we have a better understanding of how generated functions work, let's use them\nto build some more advanced (and valid) functionality..."},{"title":"An advanced example","page":"Metaprogramming","location":"manual/metaprogramming.html#An-advanced-example","category":"section","text":"Julia's base library has an internal sub2ind function to calculate a linear index into an n-dimensional\narray, based on a set of n multilinear indices - in other words, to calculate the index i that\ncan be used to index into an array A using A[i], instead of A[x,y,z,...]. One possible implementation\nis the following:\n\njulia> function sub2ind_loop(dims::NTuple{N}, I::Integer...) where N\n           ind = I[N] - 1\n           for i = N-1:-1:1\n               ind = I[i]-1 + dims[i]*ind\n           end\n           return ind + 1\n       end;\n\njulia> sub2ind_loop((3, 5), 1, 2)\n4\n\nThe same thing can be done using recursion:\n\njulia> sub2ind_rec(dims::Tuple{}) = 1;\n\njulia> sub2ind_rec(dims::Tuple{}, i1::Integer, I::Integer...) =\n           i1 == 1 ? sub2ind_rec(dims, I...) : throw(BoundsError());\n\njulia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer) = i1;\n\njulia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer, I::Integer...) =\n           i1 + dims[1] * (sub2ind_rec(Base.tail(dims), I...) - 1);\n\njulia> sub2ind_rec((3, 5), 1, 2)\n4\n\nBoth these implementations, although different, do essentially the same thing: a runtime loop\nover the dimensions of the array, collecting the offset in each dimension into the final index.\n\nHowever, all the information we need for the loop is embedded in the type information of the arguments.\nThis allows the compiler to move the iteration to compile time and eliminate the runtime loops\naltogether. We can utilize generated functions to achieve a similar effect; in compiler parlance,\nwe use generated functions to manually unroll the loop. The body becomes almost identical, but\ninstead of calculating the linear index, we build up an expression that calculates the index:\n\njulia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N\n           ex = :(I[$N] - 1)\n           for i = (N - 1):-1:1\n               ex = :(I[$i] - 1 + dims[$i] * $ex)\n           end\n           return :($ex + 1)\n       end;\n\njulia> sub2ind_gen((3, 5), 1, 2)\n4\n\nWhat code will this generate?\n\nAn easy way to find out is to extract the body into another (regular) function:\n\njulia> function sub2ind_gen_impl(dims::Type{T}, I...) where T <: NTuple{N,Any} where N\n           length(I) == N || return :(error(\"partial indexing is unsupported\"))\n           ex = :(I[$N] - 1)\n           for i = (N - 1):-1:1\n               ex = :(I[$i] - 1 + dims[$i] * $ex)\n           end\n           return :($ex + 1)\n       end;\n\njulia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N\n           return sub2ind_gen_impl(dims, I...)\n       end;\n\njulia> sub2ind_gen((3, 5), 1, 2)\n4\n\nWe can now execute sub2ind_gen_impl and examine the expression it returns:\n\njulia> sub2ind_gen_impl(Tuple{Int,Int}, Int, Int)\n:(((I[1] - 1) + dims[1] * (I[2] - 1)) + 1)\n\nSo, the method body that will be used here doesn't include a loop at all - just indexing into\nthe two tuples, multiplication and addition/subtraction. All the looping is performed compile-time,\nand we avoid looping during execution entirely. Thus, we only loop once per type, in this case\nonce per N (except in edge cases where the function is generated more than once - see disclaimer\nabove)."},{"title":"Optionally-generated functions","page":"Metaprogramming","location":"manual/metaprogramming.html#Optionally-generated-functions","category":"section","text":"Generated functions can achieve high efficiency at run time, but come with a compile time cost:\na new function body must be generated for every combination of concrete argument types.\nTypically, Julia is able to compile \"generic\" versions of functions that will work for any\narguments, but with generated functions this is impossible.\nThis means that programs making heavy use of generated functions might be impossible to\nstatically compile.\n\nTo solve this problem, the language provides syntax for writing normal, non-generated\nalternative implementations of generated functions.\nApplied to the sub2ind example above, it would look like this:\n\njulia> function sub2ind_gen_impl(dims::Type{T}, I...) where T <: NTuple{N,Any} where N\n           ex = :(I[$N] - 1)\n           for i = (N - 1):-1:1\n               ex = :(I[$i] - 1 + dims[$i] * $ex)\n           end\n           return :($ex + 1)\n       end;\n\njulia> function sub2ind_gen_fallback(dims::NTuple{N}, I) where N\n           ind = I[N] - 1\n           for i = (N - 1):-1:1\n               ind = I[i] - 1 + dims[i]*ind\n           end\n           return ind + 1\n       end;\n\njulia> function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N\n           length(I) == N || error(\"partial indexing is unsupported\")\n           if @generated\n               return sub2ind_gen_impl(dims, I...)\n           else\n               return sub2ind_gen_fallback(dims, I)\n           end\n       end;\n\njulia> sub2ind_gen((3, 5), 1, 2)\n4\n\nInternally, this code creates two implementations of the function: a generated one where\nthe first block in if @generated is used, and a normal one where the else block is used.\nInside the then part of the if @generated block, code has the same semantics as other\ngenerated functions: argument names refer to types, and the code should return an expression.\nMultiple if @generated blocks may occur, in which case the generated implementation uses\nall of the then blocks and the alternate implementation uses all of the else blocks.\n\nNotice that we added an error check to the top of the function.\nThis code will be common to both versions, and is run-time code in both versions\n(it will be quoted and returned as an expression from the generated version).\nThat means that the values and types of local variables are not available at code generation\ntime — the code-generation code can only see the types of arguments.\n\nIn this style of definition, the code generation feature is essentially an optional\noptimization.\nThe compiler will use it if convenient, but otherwise may choose to use the normal\nimplementation instead.\nThis style is preferred, since it allows the compiler to make more decisions and compile\nprograms in more ways, and since normal code is more readable than code-generating code.\nHowever, which implementation is used depends on compiler implementation details, so it\nis essential for the two implementations to behave identically."},{"title":"Git workflow recommendations","page":"Git workflow recommendations","location":"devdocs/contributing/git-workflow.html#Git-workflow-recommendations","category":"section","text":""},{"title":"Git Recommendations For Pull Requests","page":"Git workflow recommendations","location":"devdocs/contributing/git-workflow.html#Git-Recommendations-For-Pull-Requests","category":"section","text":"Avoid working from the master branch of your fork. Create a new branch as it will make it easier to update your pull request if Julia's master changes.\nTry to squash together small commits that make repeated changes to the same section of code, so your pull request is easier to review. A reasonable number of separate well-factored commits is fine, especially for larger changes.\nIf any conflicts arise due to changes in Julia's master, prefer updating your pull request branch with git rebase versus git merge or git pull, since the latter will introduce merge commits that clutter the git history with noise that makes your changes more difficult to review.\nDescriptive commit messages are good.\nUsing git add -p or git add -i can be useful to avoid accidentally committing unrelated changes.\nWhen linking to specific lines of code in discussion of an issue or pull request, hit the y key while viewing code on GitHub to reload the page with a URL that includes the specific version that you're viewing. That way any lines of code that you refer to will still make sense in the future, even if the content of the file changes.\nWhitespace can be automatically removed from existing commits with git rebase.\nTo remove whitespace for the previous commit, run\ngit rebase --whitespace=fix HEAD~1.\nTo remove whitespace relative to the master branch, run\ngit rebase --whitespace=fix master."},{"title":"Git Recommendations For Pull Request Reviewers","page":"Git workflow recommendations","location":"devdocs/contributing/git-workflow.html#Git-Recommendations-For-Pull-Request-Reviewers","category":"section","text":"When merging, we generally like squash+merge. Unless it is the rare case of a PR with carefully staged individual commits that you want in the history separately, in which case merge is acceptable, but usually prefer squash+merge."},{"title":"Punctuation","page":"Punctuation","location":"base/punctuation.html#man-punctuation","category":"section","text":"See also the extended documentation for mathematical symbols & functions.\n\nsymbol meaning\n@ the at-sign marks a macro invocation; optionally followed by an argument list\n! an exclamation mark is a prefix operator for logical negation (\"not\")\na! function names that end with an exclamation mark modify one or more of their arguments by convention\n# the number sign (or hash or pound) character begins single line comments\n#= when followed by an equals sign, it begins a multi-line comment (these are nestable)\n=# end a multi-line comment by immediately preceding the number sign with an equals sign\n$ the dollar sign is used for string and expression interpolation\n% the percent symbol is the remainder operator\n^ the caret is the exponentiation operator\n& single ampersand is bitwise and\n&& double ampersands is short-circuiting boolean and\n| single pipe character is bitwise or\n|| double pipe characters is short-circuiting boolean or\n⊻ the unicode xor character is bitwise exclusive or\n~ the tilde is an operator for bitwise not\n' a trailing apostrophe is the adjoint (that is, the complex transpose) operator Aᴴ\n* the asterisk is used for multiplication, including matrix multiplication and string concatenation\n/ forward slash divides the argument on its left by the one on its right\n// double forward slash performs exact, rational division\n\\ backslash operator divides the argument on its right by the one on its left, commonly used to solve matrix equations\n() parentheses with no arguments constructs an empty Tuple\n(a,...) parentheses with comma-separated arguments constructs a tuple containing its arguments\n(a=1,...) parentheses with comma-separated assignments constructs a NamedTuple\n(x;y) parentheses can also be used to group one or more semicolon separated expressions\na[] array indexing (calling getindex or setindex!)\n[,] vector literal constructor (calling vect)\n[;] vertical concatenation (calling vcat or hvcat)\n[    ] with space-separated expressions, horizontal concatenation (calling hcat or hvcat)\nT{ } curly braces following a type list that type's parameters\n{} curly braces can also be used to group multiple where expressions in function declarations\n; semicolons separate statements, begin a list of keyword arguments in function declarations or calls, or are used to separate array literals for vertical concatenation\n, commas separate function arguments or tuple or array components\n? the question mark delimits the ternary conditional operator (used like: conditional ? if_true : if_false)\n\" \" the single double-quote character delimits String literals\n\"\"\" \"\"\" three double-quote characters delimits string literals that may contain \" and ignore leading indentation\n' ' the single-quote character delimits Char (that is, character) literals\n` ` the backtick character delimits external process (Cmd) literals\nA... triple periods are a postfix operator that \"splat\" their arguments' contents into many arguments of a function call or declare a varargs function that \"slurps\" up many arguments into a single tuple\na.b single periods access named fields in objects/modules (calling getproperty or setproperty!)\nf.() periods may also prefix parentheses (like f.(...)) or infix operators (like .+) to perform the function element-wise (calling broadcast)\na:b colons (:) used as a binary infix operator construct a range from a to b (inclusive) with fixed step size 1\na:s:b colons (:) used as a ternary infix operator construct a range from a to b (inclusive) with step size s\n: when used by themselves, Colons represent all indices within a dimension, frequently combined with indexing\n:: double-colons represent a type annotation or typeassert, depending on context, frequently used when declaring function arguments\n:( ) quoted expression\n:a Symbol a\n<: subtype operator\n>: supertype operator (reverse of subtype operator)\n= single equals sign is assignment\n== double equals sign is value equality comparison\n=== triple equals sign is programmatically identical equality comparison\n=> right arrow using an equals sign defines a Pair typically used to populate dictionaries\n-> right arrow using a hyphen defines an anonymous function on a single line\n|> pipe operator passes output from the left argument to input of the right argument, usually a function\n∘ function composition operator (typed with \\circ{tab}) combines two functions as though they are a single larger function\n_ underscores may be assigned values which will not be saved, often used to ignore multiple return values or create repetitive comprehensions"},{"title":"Talking to the compiler (the :meta mechanism)","page":"Talking to the compiler (the :meta mechanism)","location":"devdocs/meta.html#Talking-to-the-compiler-(the-:meta-mechanism)","category":"section","text":"In some circumstances, one might wish to provide hints or instructions that a given block of code\nhas special properties: you might always want to inline it, or you might want to turn on special\ncompiler optimization passes. Starting with version 0.4, Julia has a convention that these instructions\ncan be placed inside a :meta expression, which is typically (but not necessarily) the first\nexpression in the body of a function.\n\n:meta expressions are created with macros. As an example, consider the implementation of the\n@inline macro:\n\nmacro inline(ex)\n    esc(isa(ex, Expr) ? pushmeta!(ex, :inline) : ex)\nend\n\nHere, ex is expected to be an expression defining a function. A statement like this:\n\n@inline function myfunction(x)\n    x*(x+3)\nend\n\ngets turned into an expression like this:\n\nquote\n    function myfunction(x)\n        Expr(:meta, :inline)\n        x*(x+3)\n    end\nend\n\nBase.pushmeta!(ex, tag::Union{Symbol,Expr}) appends :tag to the end of the :meta expression,\ncreating a new :meta expression if necessary.\n\nTo use the metadata, you have to parse these :meta expressions. If your implementation can be\nperformed within Julia, Base.popmeta! is very handy: Base.popmeta!(body, :symbol) will scan\na function body expression (one without the function signature) for the first :meta expression\ncontaining :symbol, extract any arguments, and return a tuple (found::Bool, args::Array{Any}).\nIf the metadata did not have any arguments, or :symbol was not found, the args array will\nbe empty.\n\nNot yet provided is a convenient infrastructure for parsing :meta expressions from C++."},{"title":"Conversion and Promotion","page":"Conversion and Promotion","location":"manual/conversion-and-promotion.html#conversion-and-promotion","category":"section","text":"Julia has a system for promoting arguments of mathematical operators to a common type, which has\nbeen mentioned in various other sections, including Integers and Floating-Point Numbers,\nMathematical Operations and Elementary Functions, Types, and Methods.\nIn this section, we explain how this promotion system works, as well as how to extend it to new\ntypes and apply it to functions besides built-in mathematical operators. Traditionally, programming\nlanguages fall into two camps with respect to promotion of arithmetic arguments:\n\nAutomatic promotion for built-in arithmetic types and operators. In most languages, built-in\nnumeric types, when used as operands to arithmetic operators with infix syntax, such as +,\n-, *, and /, are automatically promoted to a common type to produce the expected results.\nC, Java, Perl, and Python, to name a few, all correctly compute the sum 1 + 1.5 as the floating-point\nvalue 2.5, even though one of the operands to + is an integer. These systems are convenient\nand designed carefully enough that they are generally all-but-invisible to the programmer: hardly\nanyone consciously thinks of this promotion taking place when writing such an expression, but\ncompilers and interpreters must perform conversion before addition since integers and floating-point\nvalues cannot be added as-is. Complex rules for such automatic conversions are thus inevitably\npart of specifications and implementations for such languages.\nNo automatic promotion. This camp includes Ada and ML – very \"strict\" statically typed languages.\nIn these languages, every conversion must be explicitly specified by the programmer. Thus, the\nexample expression 1 + 1.5 would be a compilation error in both Ada and ML. Instead one must\nwrite real(1) + 1.5, explicitly converting the integer 1 to a floating-point value before\nperforming addition. Explicit conversion everywhere is so inconvenient, however, that even Ada\nhas some degree of automatic conversion: integer literals are promoted to the expected integer\ntype automatically, and floating-point literals are similarly promoted to appropriate floating-point\ntypes.\n\nIn a sense, Julia falls into the \"no automatic promotion\" category: mathematical operators are\njust functions with special syntax, and the arguments of functions are never automatically converted.\nHowever, one may observe that applying mathematical operations to a wide variety of mixed argument\ntypes is just an extreme case of polymorphic multiple dispatch – something which Julia's dispatch\nand type systems are particularly well-suited to handle. \"Automatic\" promotion of mathematical\noperands simply emerges as a special application: Julia comes with pre-defined catch-all dispatch\nrules for mathematical operators, invoked when no specific implementation exists for some combination\nof operand types. These catch-all rules first promote all operands to a common type using user-definable\npromotion rules, and then invoke a specialized implementation of the operator in question for\nthe resulting values, now of the same type. User-defined types can easily participate in this\npromotion system by defining methods for conversion to and from other types, and providing a handful\nof promotion rules defining what types they should promote to when mixed with other types."},{"title":"Conversion","page":"Conversion and Promotion","location":"manual/conversion-and-promotion.html#Conversion","category":"section","text":"The standard way to obtain a value of a certain type T is to call the type's constructor, T(x).\nHowever, there are cases where it's convenient to convert a value from one type to another\nwithout the programmer asking for it explicitly.\nOne example is assigning a value into an array: if A is a Vector{Float64}, the expression\nA[1] = 2 should work by automatically converting the 2 from Int to Float64, and\nstoring the result in the array.\nThis is done via the convert function.\n\nThe convert function generally takes two arguments: the first is a type object and the second is\na value to convert to that type. The returned value is the value converted to an instance of given type.\nThe simplest way to understand this function is to see it in action:\n\njulia> x = 12\n12\n\njulia> typeof(x)\nInt64\n\njulia> xu = convert(UInt8, x)\n0x0c\n\njulia> typeof(xu)\nUInt8\n\njulia> xf = convert(AbstractFloat, x)\n12.0\n\njulia> typeof(xf)\nFloat64\n\njulia> a = Any[1 2 3; 4 5 6]\n2×3 Matrix{Any}:\n 1  2  3\n 4  5  6\n\njulia> convert(Array{Float64}, a)\n2×3 Matrix{Float64}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n\nConversion isn't always possible, in which case a MethodError is thrown indicating that convert\ndoesn't know how to perform the requested conversion:\n\njulia> convert(AbstractFloat, \"foo\")\nERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat\n[...]\n\nSome languages consider parsing strings as numbers or formatting numbers as strings to be conversions\n(many dynamic languages will even perform conversion for you automatically). This is not the case in Julia.\nEven though some strings can be parsed as numbers, most strings are not valid representations\nof numbers, and only a very limited subset of them are. Therefore in Julia the dedicated parse\nfunction must be used to perform this operation, making it more explicit."},{"title":"When is convert called?","page":"Conversion and Promotion","location":"manual/conversion-and-promotion.html#When-is-convert-called?","category":"section","text":"The following language constructs call convert:\n\nAssigning to an array converts to the array's element type.\nAssigning to a field of an object converts to the declared type of the field.\nConstructing an object with new converts to the object's declared field types.\nAssigning to a variable with a declared type (e.g. local x::T) converts to that type.\nA function with a declared return type converts its return value to that type.\nPassing a value to ccall converts it to the corresponding argument type."},{"title":"Conversion vs. Construction","page":"Conversion and Promotion","location":"manual/conversion-and-promotion.html#Conversion-vs.-Construction","category":"section","text":"Note that the behavior of convert(T, x) appears to be nearly identical to T(x).\nIndeed, it usually is.\nHowever, there is a key semantic difference: since convert can be called implicitly,\nits methods are restricted to cases that are considered \"safe\" or \"unsurprising\".\nconvert will only convert between types that represent the same basic kind of thing\n(e.g. different representations of numbers, or different string encodings).\nIt is also usually lossless; converting a value to a different type and back again\nshould result in the exact same value.\n\nThere are four general kinds of cases where constructors differ from convert:"},{"title":"Constructors for types unrelated to their arguments","page":"Conversion and Promotion","location":"manual/conversion-and-promotion.html#Constructors-for-types-unrelated-to-their-arguments","category":"section","text":"Some constructors don't implement the concept of \"conversion\".\nFor example, Timer(2) creates a 2-second timer, which is not really a\n\"conversion\" from an integer to a timer."},{"title":"Mutable collections","page":"Conversion and Promotion","location":"manual/conversion-and-promotion.html#Mutable-collections","category":"section","text":"convert(T, x) is expected to return the original x if x is already of type T.\nIn contrast, if T is a mutable collection type then T(x) should always make a new\ncollection (copying elements from x)."},{"title":"Wrapper types","page":"Conversion and Promotion","location":"manual/conversion-and-promotion.html#Wrapper-types","category":"section","text":"For some types which \"wrap\" other values, the constructor may wrap its argument inside\na new object even if it is already of the requested type.\nFor example Some(x) wraps x to indicate that a value is present (in a context\nwhere the result might be a Some or nothing).\nHowever, x itself might be the object Some(y), in which case the result is\nSome(Some(y)), with two levels of wrapping.\nconvert(Some, x), on the other hand, would just return x since it is already\na Some."},{"title":"Constructors that don't return instances of their own type","page":"Conversion and Promotion","location":"manual/conversion-and-promotion.html#Constructors-that-don't-return-instances-of-their-own-type","category":"section","text":"In very rare cases it might make sense for the constructor T(x) to return\nan object not of type T.\nThis could happen if a wrapper type is its own inverse (e.g. Flip(Flip(x)) === x),\nor to support an old calling syntax for backwards compatibility when a library is\nrestructured.\nBut convert(T, x) should always return a value of type T."},{"title":"Defining New Conversions","page":"Conversion and Promotion","location":"manual/conversion-and-promotion.html#Defining-New-Conversions","category":"section","text":"When defining a new type, initially all ways of creating it should be defined as\nconstructors.\nIf it becomes clear that implicit conversion would be useful, and that some\nconstructors meet the above \"safety\" criteria, then convert methods can be added.\nThese methods are typically quite simple, as they only need to call the appropriate\nconstructor.\nSuch a definition might look like this:\n\nimport Base: convert\nconvert(::Type{MyType}, x) = MyType(x)\n\nThe type of the first argument of this method is Type{MyType},\nthe only instance of which is MyType. Thus, this method is only invoked\nwhen the first argument is the type value MyType. Notice the syntax used for the first\nargument: the argument name is omitted prior to the :: symbol, and only the type is given.\nThis is the syntax in Julia for a function argument whose type is specified but whose value\ndoes not need to be referenced by name.\n\nAll instances of some abstract types are by default considered \"sufficiently similar\"\nthat a universal convert definition is provided in Julia Base.\nFor example, this definition states that it's valid to convert any Number type to\nany other by calling a 1-argument constructor:\n\nconvert(::Type{T}, x::Number) where {T<:Number} = T(x)::T\n\nThis means that new Number types only need to define constructors, since this\ndefinition will handle convert for them.\nAn identity conversion is also provided to handle the case where the argument is\nalready of the requested type:\n\nconvert(::Type{T}, x::T) where {T<:Number} = x\n\nSimilar definitions exist for AbstractString, AbstractArray, and AbstractDict."},{"title":"Promotion","page":"Conversion and Promotion","location":"manual/conversion-and-promotion.html#Promotion","category":"section","text":"Promotion refers to converting values of mixed types to a single common type. Although it is not\nstrictly necessary, it is generally implied that the common type to which the values are converted\ncan faithfully represent all of the original values. In this sense, the term \"promotion\" is appropriate\nsince the values are converted to a \"greater\" type – i.e. one which can represent all of the\ninput values in a single common type. It is important, however, not to confuse this with object-oriented\n(structural) super-typing, or Julia's notion of abstract super-types: promotion has nothing to\ndo with the type hierarchy, and everything to do with converting between alternate representations.\nFor instance, although every Int32 value can also be represented as a Float64 value,\nInt32 is not a subtype of Float64.\n\nPromotion to a common \"greater\" type is performed in Julia by the promote function, which takes\nany number of arguments, and returns a tuple of the same number of values, converted to a common\ntype, or throws an exception if promotion is not possible. The most common use case for promotion\nis to convert numeric arguments to a common type:\n\njulia> promote(1, 2.5)\n(1.0, 2.5)\n\njulia> promote(1, 2.5, 3)\n(1.0, 2.5, 3.0)\n\njulia> promote(2, 3//4)\n(2//1, 3//4)\n\njulia> promote(1, 2.5, 3, 3//4)\n(1.0, 2.5, 3.0, 0.75)\n\njulia> promote(1.5, im)\n(1.5 + 0.0im, 0.0 + 1.0im)\n\njulia> promote(1 + 2im, 3//4)\n(1//1 + 2//1*im, 3//4 + 0//1*im)\n\nFloating-point values are promoted to the largest of the floating-point argument types. Integer\nvalues are promoted to the largest of the integer argument types. If the types are the same size\nbut differ in signedness, the unsigned type is chosen. Mixtures of integers and floating-point\nvalues are promoted to a floating-point type big enough to hold all the values. Integers mixed\nwith rationals are promoted to rationals. Rationals mixed with floats are promoted to floats.\nComplex values mixed with real values are promoted to the appropriate kind of complex value.\n\nThat is really all there is to using promotions. The rest is just a matter of clever application,\nthe most typical \"clever\" application being the definition of catch-all methods for numeric operations\nlike the arithmetic operators +, -, * and /. Here are some of the catch-all method definitions\ngiven in promotion.jl:\n\n+(x::Number, y::Number) = +(promote(x,y)...)\n-(x::Number, y::Number) = -(promote(x,y)...)\n*(x::Number, y::Number) = *(promote(x,y)...)\n/(x::Number, y::Number) = /(promote(x,y)...)\n\nThese method definitions say that in the absence of more specific rules for adding, subtracting,\nmultiplying and dividing pairs of numeric values, promote the values to a common type and then\ntry again. That's all there is to it: nowhere else does one ever need to worry about promotion\nto a common numeric type for arithmetic operations – it just happens automatically. There are\ndefinitions of catch-all promotion methods for a number of other arithmetic and mathematical functions\nin promotion.jl, but beyond\nthat, there are hardly any calls to promote required in Julia Base. The most\ncommon usages of promote occur in outer constructors methods, provided for convenience, to allow\nconstructor calls with mixed types to delegate to an inner type with fields promoted to an appropriate\ncommon type. For example, recall that rational.jl\nprovides the following outer constructor method:\n\nRational(n::Integer, d::Integer) = Rational(promote(n,d)...)\n\nThis allows calls like the following to work:\n\njulia> x = Rational(Int8(15),Int32(-5))\n-3//1\n\njulia> typeof(x)\nRational{Int32}\n\nFor most user-defined types, it is better practice to require programmers to supply the expected\ntypes to constructor functions explicitly, but sometimes, especially for numeric problems, it\ncan be convenient to do promotion automatically."},{"title":"Defining Promotion Rules","page":"Conversion and Promotion","location":"manual/conversion-and-promotion.html#Defining-Promotion-Rules","category":"section","text":"Although one could, in principle, define methods for the promote function directly, this would\nrequire many redundant definitions for all possible permutations of argument types. Instead, the\nbehavior of promote is defined in terms of an auxiliary function called promote_rule, which\none can provide methods for. The promote_rule function takes a pair of type objects and returns\nanother type object, such that instances of the argument types will be promoted to the returned\ntype. Thus, by defining the rule:\n\nimport Base: promote_rule\npromote_rule(::Type{Float64}, ::Type{Float32}) = Float64\n\none declares that when 64-bit and 32-bit floating-point values are promoted together, they should\nbe promoted to 64-bit floating-point. The promotion type does not need to be one of the argument\ntypes. For example, the following promotion rules both occur in Julia Base:\n\npromote_rule(::Type{BigInt}, ::Type{Float64}) = BigFloat\npromote_rule(::Type{BigInt}, ::Type{Int8}) = BigInt\n\nIn the latter case, the result type is BigInt since BigInt is the only type\nlarge enough to hold integers for arbitrary-precision integer arithmetic. Also note that\none does not need to define both promote_rule(::Type{A}, ::Type{B}) and\npromote_rule(::Type{B}, ::Type{A}) – the symmetry is implied by the way promote_rule\nis used in the promotion process.\n\nThe promote_rule function is used as a building block to define a second function called promote_type,\nwhich, given any number of type objects, returns the common type to which those values, as arguments\nto promote should be promoted. Thus, if one wants to know, in absence of actual values, what\ntype a collection of values of certain types would promote to, one can use promote_type:\n\njulia> promote_type(Int8, Int64)\nInt64\n\nNote that we do not overload promote_type directly: we overload promote_rule instead.\npromote_type uses promote_rule, and adds the symmetry.\nOverloading it directly can cause ambiguity errors.\nWe overload promote_rule to define how things should be promoted, and we use promote_type\nto query that.\n\nInternally, promote_type is used inside of promote to determine what type argument values\nshould be converted to for promotion. The curious reader can read the code in\npromotion.jl,\nwhich defines the complete promotion mechanism in about 35 lines."},{"title":"Case Study: Rational Promotions","page":"Conversion and Promotion","location":"manual/conversion-and-promotion.html#Case-Study:-Rational-Promotions","category":"section","text":"Finally, we finish off our ongoing case study of Julia's rational number type, which makes relatively\nsophisticated use of the promotion mechanism with the following promotion rules:\n\nimport Base: promote_rule\npromote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}\npromote_rule(::Type{Rational{T}}, ::Type{Rational{S}}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}\npromote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:AbstractFloat} = promote_type(T,S)\n\nThe first rule says that promoting a rational number with any other integer type promotes to a\nrational type whose numerator/denominator type is the result of promotion of its numerator/denominator\ntype with the other integer type. The second rule applies the same logic to two different types\nof rational numbers, resulting in a rational of the promotion of their respective numerator/denominator\ntypes. The third and final rule dictates that promoting a rational with a float results in the\nsame type as promoting the numerator/denominator type with the float.\n\nThis small handful of promotion rules, together with the type's constructors and the default\nconvert method for numbers, are sufficient to make rational numbers interoperate completely\nnaturally with all of Julia's other numeric types – integers, floating-point numbers, and complex\nnumbers. By providing appropriate conversion methods and promotion rules in the same manner, any\nuser-defined numeric type can interoperate just as naturally with Julia's predefined numerics."},{"title":"Strings","page":"Strings","location":"manual/strings.html#man-strings","category":"section","text":"Strings are finite sequences of characters. Of course, the real trouble comes when one asks what\na character is. The characters that English speakers are familiar with are the letters A, B,\nC, etc., together with numerals and common punctuation symbols. These characters are standardized\ntogether with a mapping to integer values between 0 and 127 by the ASCII\nstandard. There are, of course, many other characters used in non-English languages, including\nvariants of the ASCII characters with accents and other modifications, related scripts such as\nCyrillic and Greek, and scripts completely unrelated to ASCII and English, including Arabic, Chinese,\nHebrew, Hindi, Japanese, and Korean. The Unicode standard\ntackles the complexities of what exactly a character is, and is generally accepted as the definitive\nstandard addressing this problem. Depending on your needs, you can either ignore these complexities\nentirely and just pretend that only ASCII characters exist, or you can write code that can handle\nany of the characters or encodings that one may encounter when handling non-ASCII text. Julia\nmakes dealing with plain ASCII text simple and efficient, and handling Unicode is as simple and\nefficient as possible. In particular, you can write C-style string code to process ASCII strings,\nand they will work as expected, both in terms of performance and semantics. If such code encounters\nnon-ASCII text, it will gracefully fail with a clear error message, rather than silently introducing\ncorrupt results. When this happens, modifying the code to handle non-ASCII data is straightforward.\n\nThere are a few noteworthy high-level features about Julia's strings:\n\nThe built-in concrete type used for strings (and string literals) in Julia is String.\nThis supports the full range of Unicode characters via\nthe UTF-8 encoding. (A transcode function is\nprovided to convert to/from other Unicode encodings.)\nAll string types are subtypes of the abstract type AbstractString, and external packages define\nadditional AbstractString subtypes (e.g. for other encodings). If you define a function expecting\na string argument, you should declare the type as AbstractString in order to accept any string\ntype.\nLike C and Java, but unlike most dynamic languages, Julia has a first-class type for representing\na single character, called AbstractChar. The built-in Char subtype of AbstractChar\nis a 32-bit primitive type that can represent any Unicode character (and which is based\non the UTF-8 encoding).\nAs in Java, strings are immutable: the value of an AbstractString object cannot be changed.\nTo construct a different string value, you construct a new string from parts of other strings.\nConceptually, a string is a partial function from indices to characters: for some index values,\nno character value is returned, and instead an exception is thrown. This allows for efficient\nindexing into strings by the byte index of an encoded representation rather than by a character\nindex, which cannot be implemented both efficiently and simply for variable-width encodings of\nUnicode strings."},{"title":"Characters","page":"Strings","location":"manual/strings.html#man-characters","category":"section","text":"A Char value represents a single character: it is just a 32-bit primitive type with a special literal\nrepresentation and appropriate arithmetic behaviors, and which can be converted\nto a numeric value representing a\nUnicode code point.  (Julia packages may define\nother subtypes of AbstractChar, e.g. to optimize operations for other\ntext encodings.) Here is how Char values are\ninput and shown (note that character literals are delimited with single quotes, not double quotes):\n\njulia> c = 'x'\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\njulia> typeof(c)\nChar\n\nYou can easily convert a Char to its integer value, i.e. code point:\n\njulia> c = Int('x')\n120\n\njulia> typeof(c)\nInt64\n\nOn 32-bit architectures, typeof(c) will be Int32. You can convert an\ninteger value back to a Char just as easily:\n\njulia> Char(120)\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\nNot all integer values are valid Unicode code points, but for performance, the Char conversion\ndoes not check that every character value is valid. If you want to check that each converted value\nis a valid code point, use the isvalid function:\n\njulia> Char(0x110000)\n'\\U110000': Unicode U+110000 (category In: Invalid, too high)\n\njulia> isvalid(Char, 0x110000)\nfalse\n\nAs of this writing, the valid Unicode code points are U+0000 through U+D7FF and U+E000 through\nU+10FFFF. These have not all been assigned intelligible meanings yet, nor are they necessarily\ninterpretable by applications, but all of these values are considered to be valid Unicode characters.\n\nYou can input any Unicode character in single quotes using \\u followed by up to four hexadecimal\ndigits or \\U followed by up to eight hexadecimal digits (the longest valid value only requires\nsix):\n\njulia> '\\u0'\n'\\0': ASCII/Unicode U+0000 (category Cc: Other, control)\n\njulia> '\\u78'\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\njulia> '\\u2200'\n'∀': Unicode U+2200 (category Sm: Symbol, math)\n\njulia> '\\U10ffff'\n'\\U10ffff': Unicode U+10FFFF (category Cn: Other, not assigned)\n\nJulia uses your system's locale and language settings to determine which characters can be printed\nas-is and which must be output using the generic, escaped \\u or \\U input forms. In addition\nto these Unicode escape forms, all of C's traditional escaped input forms\ncan also be used:\n\njulia> Int('\\0')\n0\n\njulia> Int('\\t')\n9\n\njulia> Int('\\n')\n10\n\njulia> Int('\\e')\n27\n\njulia> Int('\\x7f')\n127\n\njulia> Int('\\177')\n127\n\nYou can do comparisons and a limited amount of arithmetic with Char values:\n\njulia> 'A' < 'a'\ntrue\n\njulia> 'A' <= 'a' <= 'Z'\nfalse\n\njulia> 'A' <= 'X' <= 'Z'\ntrue\n\njulia> 'x' - 'a'\n23\n\njulia> 'A' + 1\n'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)"},{"title":"String Basics","page":"Strings","location":"manual/strings.html#String-Basics","category":"section","text":"String literals are delimited by double quotes or triple double quotes (not single quotes):\n\njulia> str = \"Hello, world.\\n\"\n\"Hello, world.\\n\"\n\njulia> \"\"\"Contains \"quote\" characters\"\"\"\n\"Contains \\\"quote\\\" characters\"\n\nLong lines in strings can be broken up by preceding the newline with a backslash (\\):\n\njulia> \"This is a long \\\n       line\"\n\"This is a long line\"\n\nIf you want to extract a character from a string, you index into it:\n\njulia> str[begin]\n'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n\njulia> str[1]\n'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n\njulia> str[6]\n',': ASCII/Unicode U+002C (category Po: Punctuation, other)\n\njulia> str[end]\n'\\n': ASCII/Unicode U+000A (category Cc: Other, control)\n\nMany Julia objects, including strings, can be indexed with integers. The index of the\nfirst element (the first character of a string) is returned by firstindex(str),\nand the index of the last element (character) with lastindex(str). The keywords\nbegin and end can be used inside an indexing operation as shorthand for the first and\nlast indices, respectively, along the given dimension. String indexing, like most indexing\nin Julia, is 1-based: firstindex always returns 1 for any AbstractString. As we will\nsee below, however, lastindex(str) is not in general the same as length(str) for a\nstring, because some Unicode characters can occupy multiple \"code units\".\n\nYou can perform arithmetic and other operations with end, just like\na normal value:\n\njulia> str[end-1]\n'.': ASCII/Unicode U+002E (category Po: Punctuation, other)\n\njulia> str[end÷2]\n' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n\nUsing an index less than begin (1) or greater than end raises an error:\n\njulia> str[begin-1]\nERROR: BoundsError: attempt to access 14-codeunit String at index [0]\n[...]\n\njulia> str[end+1]\nERROR: BoundsError: attempt to access 14-codeunit String at index [15]\n[...]\n\nYou can also extract a substring using range indexing:\n\njulia> str[4:9]\n\"lo, wo\"\n\nNotice that the expressions str[k] and str[k:k] do not give the same result:\n\njulia> str[6]\n',': ASCII/Unicode U+002C (category Po: Punctuation, other)\n\njulia> str[6:6]\n\",\"\n\nThe former is a single character value of type Char, while the latter is a string value that\nhappens to contain only a single character. In Julia these are very different things.\n\nRange indexing makes a copy of the selected part of the original string.\nAlternatively, it is possible to create a view into a string using the type SubString.\nMore simply, using the @views macro on a block of code converts all string slices\ninto substrings. For example:\n\njulia> str = \"long string\"\n\"long string\"\n\njulia> substr = SubString(str, 1, 4)\n\"long\"\n\njulia> typeof(substr)\nSubString{String}\n\njulia> @views typeof(str[1:4]) # @views converts slices to SubStrings\nSubString{String}\n\nSeveral standard functions like chop, chomp or strip\nreturn a SubString."},{"title":"Unicode and UTF-8","page":"Strings","location":"manual/strings.html#Unicode-and-UTF-8","category":"section","text":"Julia fully supports Unicode characters and strings. As discussed above, in character\nliterals, Unicode code points can be represented using Unicode \\u and \\U escape sequences,\nas well as all the standard C escape sequences. These can likewise be used to write string literals:\n\njulia> s = \"\\u2200 x \\u2203 y\"\n\"∀ x ∃ y\"\n\nWhether these Unicode characters are displayed as escapes or shown as special characters depends\non your terminal's locale settings and its support for Unicode. String literals are encoded using\nthe UTF-8 encoding. UTF-8 is a variable-width encoding, meaning that not all characters are encoded\nin the same number of bytes (\"code units\"). In UTF-8, ASCII characters — i.e. those with code points\nless than 0x80 (128) – are encoded as they are in ASCII, using a single byte, while code points\n0x80 and above are encoded using multiple bytes — up to four per character.\n\nString indices in Julia refer to code units (= bytes for UTF-8), the fixed-width building blocks that\nare used to encode arbitrary characters (code points). This means that not every\nindex into a String is necessarily a valid index for a character. If you index into\na string at such an invalid byte index, an error is thrown:\n\njulia> s[1]\n'∀': Unicode U+2200 (category Sm: Symbol, math)\n\njulia> s[2]\nERROR: StringIndexError: invalid index [2], valid nearby indices [1]=>'∀', [4]=>' '\nStacktrace:\n[...]\n\njulia> s[3]\nERROR: StringIndexError: invalid index [3], valid nearby indices [1]=>'∀', [4]=>' '\nStacktrace:\n[...]\n\njulia> s[4]\n' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n\nIn this case, the character ∀ is a three-byte character, so the indices 2 and 3 are invalid\nand the next character's index is 4; this next valid index can be computed by nextind(s,1),\nand the next index after that by nextind(s,4) and so on.\n\nSince end is always the last valid index into a collection, end-1 references an invalid\nbyte index if the second-to-last character is multibyte.\n\njulia> s[end-1]\n' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n\njulia> s[end-2]\nERROR: StringIndexError: invalid index [9], valid nearby indices [7]=>'∃', [10]=>' '\nStacktrace:\n[...]\n\njulia> s[prevind(s, end, 2)]\n'∃': Unicode U+2203 (category Sm: Symbol, math)\n\nThe first case works, because the last character y and the space are one-byte characters,\nwhereas end-2 indexes into the middle of the ∃ multibyte representation. The correct\nway for this case is using prevind(s, lastindex(s), 2) or, if you're using that value to index\ninto s you can write s[prevind(s, end, 2)] and end expands to lastindex(s).\n\nExtraction of a substring using range indexing also expects valid byte indices or an error is thrown:\n\njulia> s[1:1]\n\"∀\"\n\njulia> s[1:2]\nERROR: StringIndexError: invalid index [2], valid nearby indices [1]=>'∀', [4]=>' '\nStacktrace:\n[...]\n\njulia> s[1:4]\n\"∀ \"\n\nBecause of variable-length encodings, the number of characters in a string (given by length(s))\nis not always the same as the last index. If you iterate through the indices 1 through lastindex(s)\nand index into s, the sequence of characters returned when errors aren't thrown is the sequence\nof characters comprising the string s. Thus length(s) <= lastindex(s),\nsince each character in a string must have its own index. The following is an inefficient and\nverbose way to iterate through the characters of s:\n\njulia> for i = firstindex(s):lastindex(s)\n           try\n               println(s[i])\n           catch\n               # ignore the index error\n           end\n       end\n∀\n\nx\n\n∃\n\ny\n\nThe blank lines actually have spaces on them. Fortunately, the above awkward idiom is unnecessary\nfor iterating through the characters in a string, since you can just use the string as an iterable\nobject, no exception handling required:\n\njulia> for c in s\n           println(c)\n       end\n∀\n\nx\n\n∃\n\ny\n\nIf you need to obtain valid indices for a string, you can use the nextind and\nprevind functions to increment/decrement to the next/previous valid index, as mentioned above.\nYou can also use the eachindex function to iterate over the valid character indices:\n\njulia> collect(eachindex(s))\n7-element Vector{Int64}:\n  1\n  4\n  5\n  6\n  7\n 10\n 11\n\nTo access the raw code units (bytes for UTF-8) of the encoding, you can use the codeunit(s,i)\nfunction, where the index i runs consecutively from 1 to ncodeunits(s). The\ncodeunits(s) function returns an AbstractVector{UInt8} wrapper that lets you\naccess these raw codeunits (bytes) as an array.\n\nStrings in Julia can contain invalid UTF-8 code unit sequences. This convention allows to\ntreat any byte sequence as a String. In such situations a rule is that when parsing\na sequence of code units from left to right characters are formed by the longest sequence of\n8-bit code units that matches the start of one of the following bit patterns\n(each x can be 0 or 1):\n\n0xxxxxxx;\n110xxxxx 10xxxxxx;\n1110xxxx 10xxxxxx 10xxxxxx;\n11110xxx 10xxxxxx 10xxxxxx 10xxxxxx;\n10xxxxxx;\n11111xxx.\n\nIn particular this means that overlong and too-high code unit sequences and prefixes thereof are treated\nas a single invalid character rather than multiple invalid characters.\nThis rule may be best explained with an example:\n\njulia> s = \"\\xc0\\xa0\\xe2\\x88\\xe2|\"\n\"\\xc0\\xa0\\xe2\\x88\\xe2|\"\n\njulia> foreach(display, s)\n'\\xc0\\xa0': [overlong] ASCII/Unicode U+0020 (category Zs: Separator, space)\n'\\xe2\\x88': Malformed UTF-8 (category Ma: Malformed, bad data)\n'\\xe2': Malformed UTF-8 (category Ma: Malformed, bad data)\n'|': ASCII/Unicode U+007C (category Sm: Symbol, math)\n\njulia> isvalid.(collect(s))\n4-element BitArray{1}:\n 0\n 0\n 0\n 1\n\njulia> s2 = \"\\xf7\\xbf\\xbf\\xbf\"\n\"\\U1fffff\"\n\njulia> foreach(display, s2)\n'\\U1fffff': Unicode U+1FFFFF (category In: Invalid, too high)\n\nWe can see that the first two code units in the string s form an overlong encoding of\nspace character. It is invalid, but is accepted in a string as a single character.\nThe next two code units form a valid start of a three-byte UTF-8 sequence. However, the fifth\ncode unit \\xe2 is not its valid continuation. Therefore code units 3 and 4 are also\ninterpreted as malformed characters in this string. Similarly code unit 5 forms a malformed\ncharacter because | is not a valid continuation to it. Finally the string s2 contains\none too high code point.\n\nJulia uses the UTF-8 encoding by default, and support for new encodings can be added by packages.\nFor example, the LegacyStrings.jl package\nimplements UTF16String and UTF32String types. Additional discussion of other encodings and\nhow to implement support for them is beyond the scope of this document for the time being. For\nfurther discussion of UTF-8 encoding issues, see the section below on byte array literals.\nThe transcode function is provided to convert data between the various UTF-xx encodings,\nprimarily for working with external data and libraries."},{"title":"Concatenation","page":"Strings","location":"manual/strings.html#man-concatenation","category":"section","text":"One of the most common and useful string operations is concatenation:\n\njulia> greet = \"Hello\"\n\"Hello\"\n\njulia> whom = \"world\"\n\"world\"\n\njulia> string(greet, \", \", whom, \".\\n\")\n\"Hello, world.\\n\"\n\nIt is important to be aware of potentially dangerous situations such as concatenation of\ninvalid UTF-8 strings. The resulting string may contain different characters than the\ninput strings, and its number of characters may be lower than sum of numbers of characters\nof the concatenated strings, e.g.:\n\njulia> a, b = \"\\xe2\\x88\", \"\\x80\"\n(\"\\xe2\\x88\", \"\\x80\")\n\njulia> c = string(a, b)\n\"∀\"\n\njulia> collect.([a, b, c])\n3-element Vector{Vector{Char}}:\n ['\\xe2\\x88']\n ['\\x80']\n ['∀']\n\njulia> length.([a, b, c])\n3-element Vector{Int64}:\n 1\n 1\n 1\n\nThis situation can happen only for invalid UTF-8 strings. For valid UTF-8 strings\nconcatenation preserves all characters in strings and additivity of string lengths.\n\nJulia also provides * for string concatenation:\n\njulia> greet * \", \" * whom * \".\\n\"\n\"Hello, world.\\n\"\n\nWhile * may seem like a surprising choice to users of languages that provide + for string\nconcatenation, this use of * has precedent in mathematics, particularly in abstract algebra.\n\nIn mathematics, + usually denotes a commutative operation, where the order of the operands does\nnot matter. An example of this is matrix addition, where A + B == B + A for any matrices A and B\nthat have the same shape. In contrast, * typically denotes a noncommutative operation, where the\norder of the operands does matter. An example of this is matrix multiplication, where in general\nA * B != B * A. As with matrix multiplication, string concatenation is noncommutative:\ngreet * whom != whom * greet. As such, * is a more natural choice for an infix string concatenation\noperator, consistent with common mathematical use.\n\nMore precisely, the set of all finite-length strings S together with the string concatenation operator\n* forms a free monoid (S, *). The identity element\nof this set is the empty string, \"\". Whenever a free monoid is not commutative, the operation is\ntypically represented as \\cdot, *, or a similar symbol, rather than +, which as stated usually\nimplies commutativity."},{"title":"Interpolation","page":"Strings","location":"manual/strings.html#string-interpolation","category":"section","text":"Constructing strings using concatenation can become a bit cumbersome, however. To reduce\nthe need for these verbose calls to string or repeated multiplications, Julia\nallows interpolation into string literals using $, as in Perl:\n\njulia> greet = \"Hello\"; whom = \"world\";\n\njulia> \"$greet, $whom.\\n\"\n\"Hello, world.\\n\"\n\nThis is more readable and convenient and equivalent to the above string concatenation – the system\nrewrites this apparent single string literal into the call string(greet, \", \", whom, \".\\n\").\n\nThe shortest complete expression after the $ is taken as the expression whose value is to be\ninterpolated into the string. Thus, you can interpolate any expression into a string using parentheses:\n\njulia> \"1 + 2 = $(1 + 2)\"\n\"1 + 2 = 3\"\n\nBoth concatenation and string interpolation call string to convert objects into string\nform. However, string actually just returns the output of print, so new types\nshould add methods to print or show instead of string.\n\nMost non-AbstractString objects are converted to strings closely corresponding to how\nthey are entered as literal expressions:\n\njulia> v = [1,2,3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> \"v: $v\"\n\"v: [1, 2, 3]\"\n\nstring is the identity for AbstractString and AbstractChar values, so these are interpolated\ninto strings as themselves, unquoted and unescaped:\n\njulia> c = 'x'\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\njulia> \"hi, $c\"\n\"hi, x\"\n\nTo include a literal $ in a string literal, escape it with a backslash:\n\njulia> print(\"I have \\$100 in my account.\\n\")\nI have $100 in my account."},{"title":"Triple-Quoted String Literals","page":"Strings","location":"manual/strings.html#Triple-Quoted-String-Literals","category":"section","text":"When strings are created using triple-quotes (\"\"\"...\"\"\") they have some special behavior that\ncan be useful for creating longer blocks of text.\n\nFirst, triple-quoted strings are also dedented to the level of the least-indented line.\nThis is useful for defining strings within code that is indented. For example:\n\njulia> str = \"\"\"\n           Hello,\n           world.\n         \"\"\"\n\"  Hello,\\n  world.\\n\"\n\nIn this case the final (empty) line before the closing \"\"\" sets the indentation level.\n\nThe dedentation level is determined as the longest common starting sequence of spaces or\ntabs in all lines, excluding the line following the opening \"\"\" and lines containing\nonly spaces or tabs (the line containing the closing \"\"\" is always included).\nThen for all lines, excluding the text following the opening \"\"\", the common starting\nsequence is removed (including lines containing only spaces and tabs if they start with\nthis sequence), e.g.:\n\njulia> \"\"\"    This\n         is\n           a test\"\"\"\n\"    This\\nis\\n  a test\"\n\nNext, if the opening \"\"\" is followed by a newline,\nthe newline is stripped from the resulting string.\n\n\"\"\"hello\"\"\"\n\nis equivalent to\n\n\"\"\"\nhello\"\"\"\n\nbut\n\n\"\"\"\n\nhello\"\"\"\n\nwill contain a literal newline at the beginning.\n\nStripping of the newline is performed after the dedentation. For example:\n\njulia> \"\"\"\n         Hello,\n         world.\"\"\"\n\"Hello,\\nworld.\"\n\nIf the newline is removed using a backslash, dedentation will be respected as well:\n\njulia> \"\"\"\n         Averylong\\\n         word\"\"\"\n\"Averylongword\"\n\nTrailing whitespace is left unaltered.\n\nTriple-quoted string literals can contain \" characters without escaping.\n\nNote that line breaks in literal strings, whether single- or triple-quoted, result in a newline\n(LF) character \\n in the string, even if your editor uses a carriage return \\r (CR) or CRLF\ncombination to end lines. To include a CR in a string, use an explicit escape \\r; for example,\nyou can enter the literal string \"a CRLF line ending\\r\\n\"."},{"title":"Common Operations","page":"Strings","location":"manual/strings.html#Common-Operations","category":"section","text":"You can lexicographically compare strings using the standard comparison operators:\n\njulia> \"abracadabra\" < \"xylophone\"\ntrue\n\njulia> \"abracadabra\" == \"xylophone\"\nfalse\n\njulia> \"Hello, world.\" != \"Goodbye, world.\"\ntrue\n\njulia> \"1 + 2 = 3\" == \"1 + 2 = $(1 + 2)\"\ntrue\n\nYou can search for the index of a particular character using the\nfindfirst and findlast functions:\n\njulia> findfirst('o', \"xylophone\")\n4\n\njulia> findlast('o', \"xylophone\")\n7\n\njulia> findfirst('z', \"xylophone\")\n\nYou can start the search for a character at a given offset by using\nthe functions findnext and findprev:\n\njulia> findnext('o', \"xylophone\", 1)\n4\n\njulia> findnext('o', \"xylophone\", 5)\n7\n\njulia> findprev('o', \"xylophone\", 5)\n4\n\njulia> findnext('o', \"xylophone\", 8)\n\nYou can use the occursin function to check if a substring is found within a string:\n\njulia> occursin(\"world\", \"Hello, world.\")\ntrue\n\njulia> occursin(\"o\", \"Xylophon\")\ntrue\n\njulia> occursin(\"a\", \"Xylophon\")\nfalse\n\njulia> occursin('o', \"Xylophon\")\ntrue\n\nThe last example shows that occursin can also look for a character literal.\n\nTwo other handy string functions are repeat and join:\n\njulia> repeat(\".:Z:.\", 10)\n\".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:.\"\n\njulia> join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")\n\"apples, bananas and pineapples\"\n\nSome other useful functions include:\n\nfirstindex(str) gives the minimal (byte) index that can be used to index into str\n(always 1 for strings, not necessarily true for other containers).\nlastindex(str) gives the maximal (byte) index that can be used to index into str.\nlength(str) the number of characters in str.\nlength(str, i, j) the number of valid character indices in str from i to j.\nncodeunits(str) number of code units in a string.\ncodeunit(str, i) gives the code unit value in the string str at index i.\nthisind(str, i) given an arbitrary index into a string find the first index of the character into which the index points.\nnextind(str, i, n=1) find the start of the nth character starting after index i.\nprevind(str, i, n=1) find the start of the nth character starting before index i."},{"title":"Non-Standard String Literals","page":"Strings","location":"manual/strings.html#non-standard-string-literals","category":"section","text":"There are situations when you want to construct a string or use string semantics, but the behavior\nof the standard string construct is not quite what is needed. For these kinds of situations, Julia\nprovides non-standard string literals. A non-standard string literal looks like a regular\ndouble-quoted string literal,\nbut is immediately prefixed by an identifier, and may behave differently from a normal string literal.\n\nRegular expressions, byte array literals,\nand version number literals, as described below,\nare some examples of non-standard string literals. Users and packages may also define new non-standard string literals.\nFurther documentation is given in the Metaprogramming section."},{"title":"Regular Expressions","page":"Strings","location":"manual/strings.html#man-regex-literals","category":"section","text":"Sometimes you are not looking for an exact string, but a particular pattern. For\nexample, suppose you are trying to extract a single date from a large text file. You don’t\nknow what that date is (that’s why you are searching for it), but you do know it will look\nsomething like YYYY-MM-DD. Regular expressions allow you to specify these patterns and\nsearch for them.\n\nJulia uses version 2 of Perl-compatible regular expressions (regexes), as provided by the PCRE\nlibrary (see the PCRE2 syntax description\nfor more details). Regular expressions are related to strings in two ways: the obvious connection\nis that regular expressions are used to find regular patterns in strings; the other connection is\nthat regular expressions are themselves input as strings, which are parsed into a state machine that\ncan be used to efficiently search for patterns in strings. In Julia, regular expressions are input\nusing non-standard string literals prefixed with various identifiers beginning with r. The most\nbasic regular expression literal without any options turned on just uses r\"...\":\n\njulia> re = r\"^\\s*(?:#|$)\"\nr\"^\\s*(?:#|$)\"\n\njulia> typeof(re)\nRegex\n\nTo check if a regex matches a string, use occursin:\n\njulia> occursin(r\"^\\s*(?:#|$)\", \"not a comment\")\nfalse\n\njulia> occursin(r\"^\\s*(?:#|$)\", \"# a comment\")\ntrue\n\nAs one can see here, occursin simply returns true or false, indicating whether a\nmatch for the given regex occurs in the string. Commonly, however, one wants to know not\njust whether a string matched, but also how it matched. To capture this information about\na match, use the match function instead:\n\njulia> match(r\"^\\s*(?:#|$)\", \"not a comment\")\n\njulia> match(r\"^\\s*(?:#|$)\", \"# a comment\")\nRegexMatch(\"#\")\n\nIf the regular expression does not match the given string, match returns nothing\n– a special value that does not print anything at the interactive prompt. Other than not printing,\nit is a completely normal value and you can test for it programmatically:\n\nm = match(r\"^\\s*(?:#|$)\", line)\nif m === nothing\n    println(\"not a comment\")\nelse\n    println(\"blank or comment\")\nend\n\nIf a regular expression does match, the value returned by match is a RegexMatch\nobject. These objects record how the expression matches, including the substring that the pattern\nmatches and any captured substrings, if there are any. This example only captures the portion\nof the substring that matches, but perhaps we want to capture any non-blank text after the comment\ncharacter. We could do the following:\n\njulia> m = match(r\"^\\s*(?:#\\s*(.*?)\\s*$)\", \"# a comment \")\nRegexMatch(\"# a comment \", 1=\"a comment\")\n\nWhen calling match, you have the option to specify an index at which to start the\nsearch. For example:\n\njulia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",1)\nRegexMatch(\"1\")\n\njulia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",6)\nRegexMatch(\"2\")\n\njulia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",11)\nRegexMatch(\"3\")\n\nYou can extract the following info from a RegexMatch object:\n\nthe entire substring matched: m.match\nthe captured substrings as an array of strings: m.captures\nthe offset at which the whole match begins: m.offset\nthe offsets of the captured substrings as a vector: m.offsets\n\nFor when a capture doesn't match, instead of a substring, m.captures contains nothing in that\nposition, and m.offsets has a zero offset (recall that indices in Julia are 1-based, so a zero\noffset into a string is invalid). Here is a pair of somewhat contrived examples:\n\njulia> m = match(r\"(a|b)(c)?(d)\", \"acd\")\nRegexMatch(\"acd\", 1=\"a\", 2=\"c\", 3=\"d\")\n\njulia> m.match\n\"acd\"\n\njulia> m.captures\n3-element Vector{Union{Nothing, SubString{String}}}:\n \"a\"\n \"c\"\n \"d\"\n\njulia> m.offset\n1\n\njulia> m.offsets\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> m = match(r\"(a|b)(c)?(d)\", \"ad\")\nRegexMatch(\"ad\", 1=\"a\", 2=nothing, 3=\"d\")\n\njulia> m.match\n\"ad\"\n\njulia> m.captures\n3-element Vector{Union{Nothing, SubString{String}}}:\n \"a\"\n nothing\n \"d\"\n\njulia> m.offset\n1\n\njulia> m.offsets\n3-element Vector{Int64}:\n 1\n 0\n 2\n\nIt is convenient to have captures returned as an array so that one can use destructuring\nsyntax to bind them to local variables. As a convenience, the RegexMatch object\nimplements iterator methods that pass through to the captures field, so you can\ndestructure the match object directly:\n\njulia> first, second, third = m; first\n\"a\"\n\nCaptures can also be accessed by indexing the RegexMatch object with the number or name of the\ncapture group:\n\njulia> m=match(r\"(?<hour>\\d+):(?<minute>\\d+)\",\"12:45\")\nRegexMatch(\"12:45\", hour=\"12\", minute=\"45\")\n\njulia> m[:minute]\n\"45\"\n\njulia> m[2]\n\"45\"\n\nCaptures can be referenced in a substitution string when using replace by using \\n\nto refer to the nth capture group and prefixing the substitution string with s. Capture group\n0 refers to the entire match object. Named capture groups can be referenced in the substitution\nwith \\g<groupname>. For example:\n\njulia> replace(\"first second\", r\"(\\w+) (?<agroup>\\w+)\" => s\"\\g<agroup> \\1\")\n\"second first\"\n\nNumbered capture groups can also be referenced as \\g<n> for disambiguation, as in:\n\njulia> replace(\"a\", r\".\" => s\"\\g<0>1\")\n\"a1\"\n\nYou can modify the behavior of regular expressions by some combination of the flags i, m,\ns, and x after the closing double quote mark. These flags have the same meaning as they do\nin Perl, as explained in this excerpt from the perlre manpage:\n\ni   Do case-insensitive pattern matching.\n\n    If locale matching rules are in effect, the case map is taken\n    from the current locale for code points less than 255, and\n    from Unicode rules for larger code points. However, matches\n    that would cross the Unicode rules/non-Unicode rules boundary\n    (ords 255/256) will not succeed.\n\nm   Treat string as multiple lines. That is, change \"^\" and \"$\"\n    from matching the start or end of the string to matching the\n    start or end of any line anywhere within the string.\n\ns   Treat string as single line. That is, change \".\" to match any\n    character whatsoever, even a newline, which normally it would\n    not match.\n\n    Used together, as r\"\"ms, they let the \".\" match any character\n    whatsoever, while still allowing \"^\" and \"$\" to match,\n    respectively, just after and just before newlines within the\n    string.\n\nx   Tells the regular expression parser to ignore most whitespace\n    that is neither backslashed nor within a character class. You\n    can use this to break up your regular expression into\n    (slightly) more readable parts. The '#' character is also\n    treated as a metacharacter introducing a comment, just as in\n    ordinary code.\n\nFor example, the following regex has all three flags turned on:\n\njulia> r\"a+.*b+.*d$\"ism\nr\"a+.*b+.*d$\"ims\n\njulia> match(r\"a+.*b+.*d$\"ism, \"Goodbye,\\nOh, angry,\\nBad world\\n\")\nRegexMatch(\"angry,\\nBad world\")\n\nThe r\"...\" literal is constructed without interpolation and unescaping (except for\nquotation mark \" which still has to be escaped). Here is an example\nshowing the difference from standard string literals:\n\njulia> x = 10\n10\n\njulia> r\"$x\"\nr\"$x\"\n\njulia> \"$x\"\n\"10\"\n\njulia> r\"\\x\"\nr\"\\x\"\n\njulia> \"\\x\"\nERROR: ParseError:\n# Error @ none:1:2\n\"\\x\"\n#└┘ ── invalid hex escape sequence\n\nTriple-quoted regex strings, of the form r\"\"\"...\"\"\", are also supported (and may be convenient\nfor regular expressions containing quotation marks or newlines).\n\nThe Regex() constructor may be used to create a valid regex string programmatically.\nThis permits using the contents of string variables and other string operations when\nconstructing the regex string. Any of the regex codes above can be used within the single\nstring argument to Regex(). Here are some examples:\n\njulia> using Dates\n\njulia> d = Date(1962,7,10)\n1962-07-10\n\njulia> regex_d = Regex(\"Day \" * string(day(d)))\nr\"Day 10\"\n\njulia> match(regex_d, \"It happened on Day 10\")\nRegexMatch(\"Day 10\")\n\njulia> name = \"Jon\"\n\"Jon\"\n\njulia> regex_name = Regex(\"[\\\"( ]\\\\Q$name\\\\E[\\\") ]\")  # interpolate value of name\nr\"[\\\"( ]\\QJon\\E[\\\") ]\"\n\njulia> match(regex_name, \" Jon \")\nRegexMatch(\" Jon \")\n\njulia> match(regex_name, \"[Jon]\") === nothing\ntrue\n\nNote the use of the \\Q...\\E escape sequence. All characters between the \\Q and the \\E\nare interpreted as literal characters. This is convenient for matching characters that\nwould otherwise be regex metacharacters. However, caution is needed when using this feature\ntogether with string interpolation, since the interpolated string might itself contain\nthe \\E sequence, unexpectedly terminating literal matching. User inputs need to be sanitized\nbefore inclusion in a regex."},{"title":"Byte Array Literals","page":"Strings","location":"manual/strings.html#man-byte-array-literals","category":"section","text":"Another useful non-standard string literal is the byte-array string literal: b\"...\". This\nform lets you use string notation to express read only literal byte arrays – i.e. arrays of\nUInt8 values. The type of those objects is CodeUnits{UInt8, String}.\nThe rules for byte array literals are the following:\n\nASCII characters and ASCII escapes produce a single byte.\n\\x and octal escape sequences produce the byte corresponding to the escape value.\nUnicode escape sequences produce a sequence of bytes encoding that code point in UTF-8.\n\nThere is some overlap between these rules since the behavior of \\x and octal escapes less than\n0x80 (128) are covered by both of the first two rules, but here these rules agree. Together, these\nrules allow one to easily use ASCII characters, arbitrary byte values, and UTF-8 sequences to\nproduce arrays of bytes. Here is an example using all three:\n\njulia> b\"DATA\\xff\\u2200\"\n8-element Base.CodeUnits{UInt8, String}:\n 0x44\n 0x41\n 0x54\n 0x41\n 0xff\n 0xe2\n 0x88\n 0x80\n\nThe ASCII string \"DATA\" corresponds to the bytes 68, 65, 84, 65. \\xff produces the single byte 255.\nThe Unicode escape \\u2200 is encoded in UTF-8 as the three bytes 226, 136, 128. Note that the\nresulting byte array does not correspond to a valid UTF-8 string:\n\njulia> isvalid(\"DATA\\xff\\u2200\")\nfalse\n\nAs it was mentioned CodeUnits{UInt8, String} type behaves like read only array of UInt8 and\nif you need a standard vector you can convert it using Vector{UInt8}:\n\njulia> x = b\"123\"\n3-element Base.CodeUnits{UInt8, String}:\n 0x31\n 0x32\n 0x33\n\njulia> x[1]\n0x31\n\njulia> x[1] = 0x32\nERROR: CanonicalIndexError: setindex! not defined for Base.CodeUnits{UInt8, String}\n[...]\n\njulia> Vector{UInt8}(x)\n3-element Vector{UInt8}:\n 0x31\n 0x32\n 0x33\n\nAlso observe the significant distinction between \\xff and \\uff: the former escape sequence\nencodes the byte 255, whereas the latter escape sequence represents the code point 255, which\nis encoded as two bytes in UTF-8:\n\njulia> b\"\\xff\"\n1-element Base.CodeUnits{UInt8, String}:\n 0xff\n\njulia> b\"\\uff\"\n2-element Base.CodeUnits{UInt8, String}:\n 0xc3\n 0xbf\n\nCharacter literals use the same behavior.\n\nFor code points less than \\u80, it happens that the\nUTF-8 encoding of each code point is just the single byte produced by the corresponding \\x escape,\nso the distinction can safely be ignored. For the escapes \\x80 through \\xff as compared to\n\\u80 through \\uff, however, there is a major difference: the former escapes all encode single\nbytes, which – unless followed by very specific continuation bytes – do not form valid UTF-8\ndata, whereas the latter escapes all represent Unicode code points with two-byte encodings.\n\nIf this is all extremely confusing, try reading [\"The Absolute Minimum Every\nSoftware Developer Absolutely, Positively Must Know About Unicode and Character\nSets\"](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/).\nIt is an excellent introduction to Unicode and UTF-8, and may help alleviate\nsome confusion regarding the matter."},{"title":"Version Number Literals","page":"Strings","location":"manual/strings.html#man-version-number-literals","category":"section","text":"Version numbers can easily be expressed with non-standard string literals of the form v\"...\".\nVersion number literals create VersionNumber objects which follow the\nspecifications of semantic versioning 2.0.0-rc2,\nand therefore are composed of major, minor and patch numeric values, followed by pre-release and\nbuild alphanumeric annotations. For example, v\"0.2.1-rc1+win64\" is broken into major version\n0, minor version 2, patch version 1, pre-release rc1 and build win64. When entering\na version literal, everything except the major version number is optional, therefore e.g.  v\"0.2\"\nis equivalent to v\"0.2.0\" (with empty pre-release/build annotations), v\"2\" is equivalent to\nv\"2.0.0\", and so on.\n\nVersionNumber objects are mostly useful to easily and correctly compare two (or more) versions.\nFor example, the constant VERSION holds Julia version number as a VersionNumber object, and\ntherefore one can define some version-specific behavior using simple statements as:\n\nif v\"0.2\" <= VERSION < v\"0.3-\"\n    # do something specific to 0.2 release series\nend\n\nNote that in the above example the non-standard version number v\"0.3-\" is used, with a trailing\n-: this notation is a Julia extension of the standard, and it is used to indicate a version which\nis lower than any 0.3 release, including all of its pre-releases. So in the above example the\ncode would only run with stable 0.2 versions, and exclude such versions as v\"0.3.0-rc1\". In\norder to also allow for unstable (i.e. pre-release) 0.2 versions, the lower bound check should\nbe modified like this: v\"0.2-\" <= VERSION.\n\nAnother non-standard version specification extension allows one to use a trailing + to express\nan upper limit on build versions, e.g.  VERSION > v\"0.2-rc1+\" can be used to mean any version\nabove 0.2-rc1 and any of its builds: it will return false for version v\"0.2-rc1+win64\" and\ntrue for v\"0.2-rc2\".\n\nIt is good practice to use such special versions in comparisons (particularly, the trailing -\nshould always be used on upper bounds unless there's a good reason not to), but they must not\nbe used as the actual version number of anything, as they are invalid in the semantic versioning\nscheme.\n\nBesides being used for the VERSION constant, VersionNumber objects are widely used\nin the Pkg module, to specify packages versions and their dependencies."},{"title":"Raw String Literals","page":"Strings","location":"manual/strings.html#man-raw-string-literals","category":"section","text":"Raw strings without interpolation or unescaping can be expressed with\nnon-standard string literals of the form raw\"...\". Raw string literals create\nordinary String objects which contain the enclosed contents exactly as\nentered with no interpolation or unescaping. This is useful for strings which\ncontain code or markup in other languages which use $ or \\ as special\ncharacters.\n\nThe exception is that quotation marks still must be escaped, e.g. raw\"\\\"\" is equivalent\nto \"\\\"\".\nTo make it possible to express all strings, backslashes then also must be escaped, but\nonly when appearing right before a quote character:\n\njulia> println(raw\"\\\\ \\\\\\\"\")\n\\\\ \\\"\n\nNotice that the first two backslashes appear verbatim in the output, since they do not\nprecede a quote character.\nHowever, the next backslash character escapes the backslash that follows it, and the\nlast backslash escapes a quote, since these backslashes appear before a quote."},{"title":"Annotated Strings","page":"Strings","location":"manual/strings.html#man-annotated-strings","category":"section","text":"note: Note\nThe API for AnnotatedStrings is considered experimental and is subject to change between\nJulia versions.\n\nIt is sometimes useful to be able to hold metadata relating to regions of a\nstring. A AnnotatedString wraps another string and\nallows for regions of it to be annotated with labelled values (:label => value).\nAll generic string operations are applied to the underlying string. However,\nwhen possible, styling information is preserved. This means you can manipulate a\nAnnotatedString —taking substrings, padding them,\nconcatenating them with other strings— and the metadata annotations will \"come\nalong for the ride\".\n\nThis string type is fundamental to the [StyledStrings stdlib](@ref\nstdlib-styledstrings), which uses :face-labelled annotations to hold styling\ninformation.\n\nWhen concatenating a AnnotatedString, take care to use\nannotatedstring instead of string if you want\nto keep the string annotations.\n\njulia> str = Base.AnnotatedString(\"hello there\",\n               [(1:5, :word, :greeting), (7:11, :label, 1)])\n\"hello there\"\n\njulia> length(str)\n11\n\njulia> lpad(str, 14)\n\"   hello there\"\n\njulia> typeof(lpad(str, 7))\nBase.AnnotatedString{String}\n\njulia> str2 = Base.AnnotatedString(\" julia\", [(2:6, :face, :magenta)])\n\" julia\"\n\njulia> Base.annotatedstring(str, str2)\n\"hello there julia\"\n\njulia> str * str2 == Base.annotatedstring(str, str2) # *-concatenation still works\ntrue\n\nThe annotations of a AnnotatedString can be accessed\nand modified via the annotations and\nannotate! functions."},{"title":"Unicode Input","page":"Unicode Input","location":"manual/unicode-input.html#Unicode-Input","category":"section","text":"The following table lists Unicode characters that can be entered via\ntab completion of LaTeX-like abbreviations in the Julia REPL (and\nin various other editing environments). You can also get information on how to\ntype a symbol by entering it in the REPL help, i.e. by typing ? and then\nentering the symbol in the REPL (e.g., by copy-paste from somewhere you saw\nthe symbol).\n\nwarning: Warning\nThis table may appear to contain missing characters in the second column, or even\nshow characters that are inconsistent with the characters as they are rendered in\nthe Julia REPL. In these cases, users are strongly advised to check their choice\nof fonts in their browser and REPL environment, as there are known issues with\nglyphs in many fonts.\n\n#\n# Generate a table containing all LaTeX and Emoji tab completions available in the REPL.\n#\nimport REPL, Markdown\nconst NBSP = '\\u00A0'\n\nfunction tab_completions(symbols...)\n    completions = Dict{String, Vector{String}}()\n    for each in symbols, (k, v) in each\n        completions[v] = push!(get!(completions, v, String[]), k)\n    end\n    return completions\nend\n\nfunction unicode_data()\n    file = normpath(@__DIR__, \"..\", \"..\", \"..\", \"..\", \"..\", \"doc\", \"UnicodeData.txt\")\n    names = Dict{UInt32, String}()\n    open(file) do unidata\n        for line in readlines(unidata)\n            id, name, desc = split(line, \";\")[[1, 2, 11]]\n            codepoint = parse(UInt32, \"0x$id\")\n            names[codepoint] = titlecase(lowercase(\n                name == \"\" ? desc : desc == \"\" ? name : \"$name / $desc\"))\n        end\n    end\n    return names\nend\n\n# Surround combining characters with no-break spaces (i.e '\\u00A0'). Follows the same format\n# for how unicode is displayed on the unicode.org website:\n# https://util.unicode.org/UnicodeJsps/character.jsp?a=0300\nfunction fix_combining_chars(char)\n    cat = Base.Unicode.category_code(char)\n    return cat == 6 || cat == 8 ? \"$NBSP$char$NBSP\" : \"$char\"\nend\n\nfunction table_entries(completions, unicode_dict)\n    entries = Any[Any[\n        [\"Code point(s)\"],\n        [\"Character(s)\"],\n        [\"Tab completion sequence(s)\"],\n        [\"Unicode name(s)\"],\n    ]]\n    for (chars, inputs) in sort!(collect(completions), by = first)\n        code_points, unicode_names, characters = String[], String[], String[]\n        for char in chars\n            push!(code_points, \"U+$(uppercase(string(UInt32(char), base = 16, pad = 5)))\")\n            push!(unicode_names, get(unicode_dict, UInt32(char), \"(No Unicode name)\"))\n            push!(characters, isempty(characters) ? fix_combining_chars(char) : \"$char\")\n        end\n        inputs_md = []\n        for (i, input) in enumerate(inputs)\n            i > 1 && push!(inputs_md, \", \")\n            push!(inputs_md, Markdown.Code(\"\", input))\n        end\n        push!(entries, [\n            [join(code_points, \" + \")],\n            [join(characters)],\n            inputs_md,\n            [join(unicode_names, \" + \")],\n        ])\n    end\n    table = Markdown.Table(entries, [:l, :c, :l, :l])\n    # We also need to wrap the Table in a Markdown.MD \"document\"\n    return Markdown.MD([table])\nend\n\ntable_entries(\n    tab_completions(\n        REPL.REPLCompletions.latex_symbols,\n        REPL.REPLCompletions.emoji_symbols\n    ),\n    unicode_data()\n)"},{"title":"Contributing to patch releases","page":"Contributing to patch releases","location":"devdocs/contributing/patch-releases.html#Contributing-to-patch-releases","category":"section","text":"The process of creating a patch release is roughly as follows:\n\nCreate a new branch (e.g. backports-release-1.10) against the relevant minor release\nbranch (e.g. release-1.10). Usually a corresponding pull request is created as well.\nAdd commits, nominally from master (hence \"backports\"), to that branch.\nSee below for more information on this process.\nRun the BaseBenchmarks.jl benchmark\nsuite and PkgEval.jl package ecosystem\nexerciser against that branch. Nominally BaseBenchmarks.jl and PkgEval.jl are\ninvoked via Nanosoldier.jl from\nthe pull request associated with the backports branch. Fix any issues.\nOnce all test and benchmark reports look good, merge the backports branch into\nthe corresponding release branch (e.g. merge backports-release-1.10 into\nrelease-1.10).\nOpen a pull request that bumps the version of the relevant minor release to the\nnext patch version, e.g. as in this pull request.\nPing @JuliaLang/releases to tag the patch release and update the website.\nOpen a pull request that bumps the version of the relevant minor release to the\nnext prerelease patch version, e.g. as in this pull request.\n\nStep 2 above, i.e. backporting commits to the backports-release-X.Y branch, has largely\nbeen automated via Backporter: Backporter\nsearches for merged pull requests with the relevant backport-X.Y tag, and attempts to\ncherry-pick the commits from those pull requests onto the backports-release-X.Y branch.\nSome commits apply successfully without intervention, others not so much. The latter\ncommits require \"manual\" backporting, with which help is generally much appreciated.\nBackporter generates a report identifying those commits it managed to backport automatically\nand those that require manual backporting; this report is usually copied into the first\npost of the pull request associated with backports-release-X.Y and maintained as\nadditional commits are automatically and/or manually backported.\n\nWhen contributing a manual backport, if you have the necessary permissions, please push the\nbackport directly to the backports-release-X.Y branch. If you lack the relevant\npermissions, please open a pull request against the backports-release-X.Y branch with the\nmanual backport. Once the manual backport is live on the backports-release-X.Y branch,\nplease remove the backport-X.Y tag from the originating pull request for the commits."},{"title":"Memory-mapped I/O","page":"Memory-mapped I/O","location":"stdlib/Mmap.html#Memory-mapped-I/O","category":"section","text":"Low level module for mmap (memory mapping of files)."},{"title":"Mmap.Anonymous","page":"Memory-mapped I/O","location":"stdlib/Mmap.html#Mmap.Anonymous","category":"type","text":"Mmap.Anonymous(name::AbstractString=\"\", readonly::Bool=false, create::Bool=true)\n\nCreate an IO-like object for creating zeroed-out mmapped-memory that is not tied to a file\nfor use in mmap. Used by SharedArray for creating shared memory arrays.\n\nExamples\n\njulia> using Mmap\n\njulia> anon = Mmap.Anonymous();\n\njulia> isreadable(anon)\ntrue\n\njulia> iswritable(anon)\ntrue\n\njulia> isopen(anon)\ntrue\n\n\n\n\n\n"},{"title":"Mmap.mmap","page":"Memory-mapped I/O","location":"stdlib/Mmap.html#Mmap.mmap","category":"function","text":"mmap(io::Union{IOStream,AbstractString,Mmap.AnonymousMmap}[, type::Type{Array{T,N}}, dims, offset]; grow::Bool=true, shared::Bool=true)\nmmap(type::Type{Array{T,N}}, dims)\n\nCreate an Array whose values are linked to a file, using memory-mapping. This provides a\nconvenient way of working with data too large to fit in the computer's memory.\n\nThe type is an Array{T,N} with a bits-type element of T and dimension N that\ndetermines how the bytes of the array are interpreted. Note that the file must be stored in\nbinary format, and no format conversions are possible (this is a limitation of operating\nsystems, not Julia).\n\ndims is a tuple or single Integer specifying the size or length of the array.\n\nThe file is passed via the stream argument, either as an open IOStream or filename string.\nWhen you initialize the stream, use \"r\" for a \"read-only\" array, and \"w+\" to create a\nnew array used to write values to disk.\n\nIf no type argument is specified, the default is Vector{UInt8}.\n\nOptionally, you can specify an offset (in bytes) if, for example, you want to skip over a\nheader in the file. The default value for the offset is the current stream position for an\nIOStream.\n\nThe grow keyword argument specifies whether the disk file should be grown to accommodate\nthe requested size of array (if the total file size is < requested array size). Write\nprivileges are required to grow the file.\n\nThe shared keyword argument specifies whether the resulting Array and changes made to it\nwill be visible to other processes mapping the same file.\n\nFor example, the following code\n\n# Create a file for mmapping\n# (you could alternatively use mmap to do this step, too)\nusing Mmap\nA = rand(1:20, 5, 30)\ns = open(\"/tmp/mmap.bin\", \"w+\")\n# We'll write the dimensions of the array as the first two Ints in the file\nwrite(s, size(A,1))\nwrite(s, size(A,2))\n# Now write the data\nwrite(s, A)\nclose(s)\n\n# Test by reading it back in\ns = open(\"/tmp/mmap.bin\")   # default is read-only\nm = read(s, Int)\nn = read(s, Int)\nA2 = mmap(s, Matrix{Int}, (m,n))\n\ncreates a m-by-n Matrix{Int}, linked to the file associated with stream s.\n\nA more portable file would need to encode the word size – 32 bit or 64 bit – and endianness\ninformation in the header. In practice, consider encoding binary data using standard formats\nlike HDF5 (which can be used with memory-mapping).\n\n\n\n\n\nmmap(io, BitArray, [dims, offset])\n\nCreate a BitArray whose values are linked to a file, using memory-mapping; it has the same\npurpose, works in the same way, and has the same arguments, as mmap, but\nthe byte representation is different.\n\nExamples\n\njulia> using Mmap\n\njulia> io = open(\"mmap.bin\", \"w+\");\n\njulia> B = mmap(io, BitArray, (25,30000));\n\njulia> B[3, 4000] = true;\n\njulia> Mmap.sync!(B);\n\njulia> close(io);\n\njulia> io = open(\"mmap.bin\", \"r+\");\n\njulia> C = mmap(io, BitArray, (25,30000));\n\njulia> C[3, 4000]\ntrue\n\njulia> C[2, 4000]\nfalse\n\njulia> close(io)\n\njulia> rm(\"mmap.bin\")\n\nThis creates a 25-by-30000 BitArray, linked to the file associated with stream io.\n\n\n\n\n\n"},{"title":"Mmap.sync!","page":"Memory-mapped I/O","location":"stdlib/Mmap.html#Mmap.sync!","category":"function","text":"Mmap.sync!(array)\n\nForces synchronization between the in-memory version of a memory-mapped Array or\nBitArray and the on-disk version.\n\n\n\n\n\n"},{"title":"macOS","page":"macOS","location":"devdocs/build/macos.html#macOS","category":"section","text":"You need to have the current Xcode command line utilities installed: run xcode-select --install in the terminal. You will need to rerun this terminal command after each macOS update, otherwise you may run into errors involving missing libraries or headers.\n\nThe dependent libraries are now built with BinaryBuilder and will be automatically downloaded. This is the preferred way to build Julia source. In case you want to build them all on your own, you will need a 64-bit gfortran to compile Julia dependencies.\n\nbrew install gcc\n\nIf you have set LD_LIBRARY_PATH or DYLD_LIBRARY_PATH in your .bashrc or equivalent, Julia may be unable to find various libraries that come bundled with it. These environment variables need to be unset for Julia to work."},{"title":"Serialization","page":"Serialization","location":"stdlib/Serialization.html#Serialization","category":"section","text":"Provides serialization of Julia objects."},{"title":"Recommended File Extension","page":"Serialization","location":"stdlib/Serialization.html#Recommended-File-Extension","category":"section","text":"While the Serialization module does not mandate a specific file extension, the Julia community commonly uses the .jls extension for serialized Julia files.\n\nExample:\n\nopen(\"model.jls\", \"w\") do io\n    serialize(io, my_model)\nend"},{"title":"Serialization.serialize","page":"Serialization","location":"stdlib/Serialization.html#Serialization.serialize","category":"function","text":"serialize(stream::IO, value)\n\nWrite an arbitrary value to a stream in an opaque format, such that it can be read back by\ndeserialize. The read-back value will be as identical as possible to the original,\nbut note that Ptr values are serialized as all-zero bit patterns (NULL).\n\nAn 8-byte identifying header is written to the stream first. To avoid writing the header,\nconstruct a Serializer and use it as the first argument to serialize instead.\nSee also Serialization.writeheader.\n\nThe data format can change in minor (1.x) Julia releases, but files written by prior 1.x\nversions will remain readable. The main exception to this is when the definition of a\ntype in an external package changes. If that occurs, it may be necessary to specify\nan explicit compatible version of the affected package in your environment.\nRenaming functions, even private functions, inside packages can also put existing files\nout of sync. Anonymous functions require special care: because their names are automatically\ngenerated, minor code changes can cause them to be renamed.\nSerializing anonymous functions should be avoided in files intended for long-term storage.\n\nIn some cases, the word size (32- or 64-bit) of the reading and writing machines must match.\nIn rarer cases the OS or architecture must also match, for example when using packages\nthat contain platform-dependent code.\n\n\n\n\n\nserialize(filename::AbstractString, value)\n\nOpen a file and serialize the given value to it.\n\ncompat: Julia 1.1\nThis method is available as of Julia 1.1.\n\n\n\n\n\n"},{"title":"Serialization.deserialize","page":"Serialization","location":"stdlib/Serialization.html#Serialization.deserialize","category":"function","text":"deserialize(stream)\n\nRead a value written by serialize. deserialize assumes the binary data read from\nstream is correct and has been serialized by a compatible implementation of serialize.\ndeserialize is designed for simplicity and performance, and so does not validate\nthe data read. Malformed data can result in process termination. The caller must ensure\nthe integrity and correctness of data read from stream.\n\n\n\n\n\ndeserialize(filename::AbstractString)\n\nOpen a file and deserialize its contents.\n\ncompat: Julia 1.1\nThis method is available as of Julia 1.1.\n\n\n\n\n\n"},{"title":"Serialization.writeheader","page":"Serialization","location":"stdlib/Serialization.html#Serialization.writeheader","category":"function","text":"Serialization.writeheader(s::AbstractSerializer)\n\nWrite an identifying header to the specified serializer. The header consists of\n8 bytes as follows:\n\nOffset Description\n0 tag byte (0x37)\n1-2 signature bytes \"JL\"\n3 protocol version\n4 bits 0-1: endianness: 0 = little, 1 = big\n4 bits 2-3: platform: 0 = 32-bit, 1 = 64-bit\n5-7 reserved\n\n\n\n\n\n"},{"title":"Binary distributions","page":"Binary distributions","location":"devdocs/build/distributing.html#Binary-distributions","category":"section","text":"These notes are for those wishing to compile a binary distribution of Julia\nfor distribution on various platforms. We love users spreading Julia as\nfar and wide as they can, trying it out on as wide an array of\noperating systems and hardware configurations as possible. As each\nplatform has specific gotchas and processes that must be followed in\norder to create a portable, working Julia distribution, we have\nseparated most of the notes by OS.\n\nNote that while the code for Julia is\nMIT-licensed, with a few exceptions,\nthe distribution created by the techniques described herein will be\nGPL licensed, as various dependent libraries such as SuiteSparse are\nGPL licensed. We do hope to have a non-GPL distribution of Julia in the future."},{"title":"Versioning and Git","page":"Binary distributions","location":"devdocs/build/distributing.html#Versioning-and-Git","category":"section","text":"The Makefile uses both the VERSION file and commit hashes and tags from the\ngit repository to generate the base/version_git.jl with information we use to\nfill the splash screen and the versioninfo() output. If you for some reason\ndon't want to have the git repository available when building you should\npregenerate the base/version_git.jl file with:\n\nmake -C base version_git.jl.phony\n\nJulia has lots of build dependencies where we use patched versions that has not\nyet been included by the popular package managers. These dependencies will usually\nbe automatically downloaded when you build, but if you want to be able to build\nJulia on a computer without internet access you should create a full-source-dist\narchive with the special make target\n\nmake full-source-dist\n\nthat creates a julia-version-commit.tar.gz archive with all required dependencies.\n\nWhen compiling a tagged release in the git repository, we don't display the\nbranch/commit hash info in the splash screen. You can use this line to show\na release description of up to 45 characters. To set this line you have\nto create a Make.user file containing:\n\noverride TAGGED_RELEASE_BANNER = \"my-package-repository build\""},{"title":"Target Architectures","page":"Binary distributions","location":"devdocs/build/distributing.html#Target-Architectures","category":"section","text":"By default, Julia optimizes its system image to the native architecture of\nthe build machine. This is usually not what you want when building packages,\nas it will make Julia fail at startup on any machine with incompatible CPUs\n(in particular older ones with more restricted instruction sets).\n\nWe therefore recommend that you pass the MARCH variable when calling make,\nsetting it to the baseline target you intend to support. This will determine\nthe target CPU for both the Julia executable and libraries, and the system\nimage (the latter can also be set using JULIA_CPU_TARGET). Typically useful\nvalues for x86 CPUs are x86-64 and core2 (for 64-bit builds) and\npentium4 (for 32-bit builds). Unfortunately, CPUs older than Pentium 4\nare currently not supported (see\nthis issue).\n\nThe full list of CPU targets supported by LLVM can be obtained by running\nllc -mattr=help."},{"title":"Linux","page":"Binary distributions","location":"devdocs/build/distributing.html#Linux","category":"section","text":"On Linux, make binary-dist creates a tarball that contains a fully\nfunctional Julia installation. If you wish to create a distribution\npackage such as a .deb, or .rpm, some extra effort is needed. See the\njulia-debian repository\nfor an example of what metadata is needed for creating .deb packages\nfor Debian and Ubuntu-based systems. See the\nFedora package\nfor RPM-based distributions. Although we have not yet experimented\nwith it, Alien could be used to\ngenerate Julia packages for various Linux distributions.\n\nJulia supports overriding standard installation directories via prefix\nand other environment variables you can pass when calling make and\nmake install. See Make.inc for their list. DESTDIR can also be used\nto force the installation into a temporary directory.\n\nBy default, Julia loads $prefix/etc/julia/startup.jl as an\ninstallation-wide initialization file. This file can be used by\ndistribution managers to set up custom paths or initialization code.\nFor Linux distribution packages, if $prefix is\nset to /usr, there is no /usr/etc to look into. This requires\nthe path to Julia's private etc directory to be changed. This can\nbe done via the sysconfdir make variable when building. Simply\npass sysconfdir=/etc to make when building and Julia will first\ncheck /etc/julia/startup.jl before trying\n$prefix/etc/julia/startup.jl."},{"title":"OS X","page":"Binary distributions","location":"devdocs/build/distributing.html#OS-X","category":"section","text":"To create a binary distribution on OSX, build Julia first, then cd to\ncontrib/mac/app, and run make with the same makevars that were used\nwith make when building Julia proper. This will then\ncreate a .dmg file in the contrib/mac/app directory holding a\ncompletely self-contained Julia.app.\n\nAlternatively, Julia may be built as a framework by invoking make with the\ndarwinframework target and DARWIN_FRAMEWORK=1 set. For example,\nmake DARWIN_FRAMEWORK=1 darwinframework."},{"title":"Windows","page":"Binary distributions","location":"devdocs/build/distributing.html#Windows","category":"section","text":"Instructions for creating a Julia distribution on Windows are described in the\nbuild devdocs for Windows."},{"title":"Notes on BLAS and LAPACK","page":"Binary distributions","location":"devdocs/build/distributing.html#Notes-on-BLAS-and-LAPACK","category":"section","text":"Julia builds OpenBLAS by default, which includes the BLAS and LAPACK\nlibraries. On 32-bit architectures, Julia builds OpenBLAS to use\n32-bit integers, while on 64-bit architectures, Julia builds OpenBLAS\nto use 64-bit integers (ILP64). It is essential that all Julia functions\nthat call BLAS and LAPACK API routines use integers of the correct width.\n\nMost BLAS and LAPACK distributions provided on linux distributions,\nand even commercial implementations ship libraries that use 32-bit\nAPIs. In many cases, a 64-bit API is provided as a separate library.\n\nWhen using vendor provided or OS provided libraries, a make option\ncalled USE_BLAS64 is available as part of the Julia build. When doing\nmake USE_BLAS64=0, Julia will call BLAS and LAPACK assuming a 32-bit\nAPI, where all integers are 32-bit wide, even on a 64-bit architecture.\n\nOther libraries that Julia uses, such as SuiteSparse also\nuse BLAS and LAPACK internally. The APIs need to be consistent across\nall libraries that depend on BLAS and LAPACK. The Julia build process\nwill build all these libraries correctly, but when overriding defaults\nand using system provided libraries, this consistency must be ensured.\n\nAlso note that Linux distributions sometimes ship several versions of\nOpenBLAS, some of which enable multithreading, and others only working\nin a serial fashion. For example, in Fedora, libopenblasp.so is threaded,\nbut libopenblas.so is not. We recommend using the former for optimal\nperformance. To choose an OpenBLAS library whose name is different from\nthe default libopenblas.so, pass LIBBLAS=-l$(YOURBLAS) and\nLIBBLASNAME=lib$(YOURBLAS) to make, replacing $(YOURBLAS) with the\nname of your library. You can also add .so.0 to the name of the library\nif you want your package to work without requiring the unversioned .so\nsymlink.\n\nFinally, OpenBLAS includes its own optimized version of LAPACK. If you\nset USE_SYSTEM_BLAS=1 and USE_SYSTEM_LAPACK=1, you should also set\nLIBLAPACK=-l$(YOURBLAS) and LIBLAPACKNAME=lib$(YOURBLAS). Else, the\nreference LAPACK will be used and performance will typically be much lower.\n\nStarting with Julia 1.7, Julia uses libblastrampoline\nto pick a different BLAS at runtime."},{"title":"Point releasing 101","page":"Binary distributions","location":"devdocs/build/distributing.html#Point-releasing-101","category":"section","text":"Creating a point/patch release consists of several distinct steps."},{"title":"Backporting commits","page":"Binary distributions","location":"devdocs/build/distributing.html#Backporting-commits","category":"section","text":"Some pull requests are labeled \"backport pending x.y\", e.g. \"backport pending 0.6\".\nThis designates that the next subsequent release tagged from the release-x.y branch\nshould include the commit(s) in that pull request.\nOnce the pull request is merged into master, each of the commits should be [cherry\npicked](https://git-scm.com/docs/git-cherry-pick) to a dedicated branch that will\nultimately be merged into release-x.y."},{"title":"Creating a backports branch","page":"Binary distributions","location":"devdocs/build/distributing.html#Creating-a-backports-branch","category":"section","text":"First, create a new branch based on release-x.y.\nThe typical convention for Julia branches is to prefix the branch name with your\ninitials if it's intended to be a personal branch.\nFor the sake of example, we'll say that the author of the branch is Jane Smith.\n\ngit fetch origin\ngit checkout release-x.y\ngit rebase origin/release-x.y\ngit checkout -b js/backport-x.y\n\nThis ensures that your local copy of release-x.y is up to date with origin before\nyou create a new branch from it."},{"title":"Cherry picking commits","page":"Binary distributions","location":"devdocs/build/distributing.html#Cherry-picking-commits","category":"section","text":"Now we do the actual backporting.\nFind all merged pull requests labeled \"backport pending x.y\" in the GitHub web UI.\nFor each of these, scroll to the bottom where it says \"someperson merged commit\n123abc into master XX minutes ago\".\nNote that the commit name is a link; if you click it, you'll be shown the contents\nof the commit.\nIf this page shows that 123abc is a merge commit, go back to the PR page—we\ndon't want merge commits, we want the actual commits.\nHowever, if this does not show a merge commit, it means that the PR was squash-merged.\nIn that case, use the git SHA of the commit, listed next to commit on this page.\n\nOnce you have the SHA of the commit, cherry-pick it onto the backporting branch:\n\ngit cherry-pick -x -e <sha>\n\nThere may be conflicts which need to be resolved manually.\nOnce conflicts are resolved (if applicable), add a reference to the GitHub pull\nrequest that introduced the commit in the body of the commit message.\n\nAfter all of the relevant commits are on the backports branch, push the branch to\nGitHub."},{"title":"Checking for performance regressions","page":"Binary distributions","location":"devdocs/build/distributing.html#Checking-for-performance-regressions","category":"section","text":"Point releases should never introduce performance regressions.\nLuckily the Julia benchmarking bot, Nanosoldier, can run benchmarks against any\nbranch, not just master.\nIn this case we want to check the benchmark results of js/backport-x.y against\nrelease-x.y.\nTo do this, awaken the Nanosoldier from his robotic slumber using a comment on\nyour backporting pull request:\n\n@nanosoldier `runbenchmarks(ALL, vs=\":release-x.y\")`\n\nThis will run all registered benchmarks on release-x.y and js/backport-x.y and\nproduce a summary of results, marking all improvements and regressions.\n\nIf Nanosoldier finds any regressions, try verifying locally and rerun Nanosoldier\nif necessary.\nIf the regressions are deemed to be real rather than just noise, you'll have to\nfind a commit on master to backport that fixes it if one exists, otherwise you\nshould determine what caused the regression and submit a patch (or get someone who\nknows the code to submit a patch) to master, then backport the commit once that's\nmerged.\n(Or submit a patch directly to the backport branch if appropriate.)"},{"title":"Building test binaries","page":"Binary distributions","location":"devdocs/build/distributing.html#Building-test-binaries","category":"section","text":"After the backport PR has been merged into the release-x.y branch, update your local\nclone of Julia, then get the SHA of the branch using\n\ngit rev-parse origin/release-x.y\n\nKeep that handy, as it's what you'll enter in the \"Revision\" field in the buildbot UI.\n\nFor now, all you need are binaries for Linux x86-64, since this is what's used for\nrunning PackageEvaluator.\nGo to https://buildog.julialang.org, submit a job for nuke_linux64, then queue up a\njob for package_linux64, providing the SHA as the revision.\nWhen the packaging job completes, it will upload the binary to the julialang2 bucket\non AWS.\nRetrieve the URL, as it will be used for PackageEvaluator."},{"title":"Checking for package breakages","page":"Binary distributions","location":"devdocs/build/distributing.html#Checking-for-package-breakages","category":"section","text":"Point releases should never break packages, with the possible exception of packages\nthat are doing some seriously questionable hacks using Base internals that are\nnot intended to be user-facing.\n(In those cases, maybe have a word with the package author.)\n\nChecking whether changes made in the forthcoming new version will break packages can\nbe accomplished using PackageEvaluator,\noften called \"PkgEval\" for short.\nPkgEval is what populates the status badges on GitHub repos and on pkg.julialang.org.\nIt typically runs on one of the non-benchmarking nodes of Nanosoldier and uses Vagrant\nto perform its duties in separate, parallel VirtualBox virtual machines."},{"title":"Setting up PackageEvaluator","page":"Binary distributions","location":"devdocs/build/distributing.html#Setting-up-PackageEvaluator","category":"section","text":"Clone PackageEvaluator and create a branch called backport-x.y.z, and check it out.\nNote that the required changes are a little hacky and confusing, and hopefully that will\nbe addressed in a future version of PackageEvaluator.\nThe changes to make will be modeled off of\nthis commit.\n\nThe setup script takes its first argument as the version of Julia to run and the second\nas the range of package names (AK for packages named A-K, LZ for L-Z).\nThe basic idea is that we're going to tweak that a bit to run only two versions of Julia,\nthe current x.y release and our backport version, each with three ranges of packages.\n\nIn the linked diff, we're saying that if the second argument is LZ, use the binaries\nbuilt from our backport branch, otherwise (AK) use the release binaries.\nThen we're using the first argument to run a section of the package list: A-F for input\n0.4, G-N for 0.5, and O-Z for 0.6."},{"title":"Running PackageEvaluator","page":"Binary distributions","location":"devdocs/build/distributing.html#Running-PackageEvaluator","category":"section","text":"To run PkgEval, find a hefty enough machine (such as Nanosoldier node 1), then run\n\ngit clone https://github.com/JuliaCI/PackageEvaluator.jl.git\ncd PackageEvaluator.jl/scripts\ngit checkout backport-x.y.z\n./runvagrant.sh\n\nThis produces some folders in the scripts/ directory.\nThe folder names and their contents are decoded below:\n\nFolder name Julia version Package range\n0.4AK Release A-F\n0.4LZ Backport A-F\n0.5AK Release G-N\n0.5LZ Backport G-N\n0.6AK Release O-Z\n0.6LZ Backport O-Z"},{"title":"Investigating results","page":"Binary distributions","location":"devdocs/build/distributing.html#Investigating-results","category":"section","text":"Once that's done, you can use ./summary.sh from that same directory to produce\na summary report of the findings.\nWe'll do so for each of the folders to aggregate overall results by version.\n\n./summary.sh 0.4AK/*.json > summary_release.txt\n./summary.sh 0.5AK/*.json >> summary_release.txt\n./summary.sh 0.6AK/*.json >> summary_release.txt\n./summary.sh 0.4LZ/*.json > summary_backport.txt\n./summary.sh 0.5LZ/*.json >> summary_backport.txt\n./summary.sh 0.6LZ/*.json >> summary_backport.txt\n\nNow we have two files, summary_release.txt and summary_backport.txt, containing\nthe PackageEvaluator test results (pass/fail) for each package for the two versions.\n\nTo make these easier to ingest into a Julia, we'll convert them into CSV files then\nuse the DataFrames package to process the results.\nTo convert to CSV, copy each .txt file to a corresponding .csv file, then enter Vim\nand execute ggVGI\"<esc> then :%s/\\.json /\",/g.\n(You don't have to use Vim; this just is one way to do it.)\nNow process the results with Julia code similar to the following.\n\nusing DataFrames\n\nrelease = readtable(\"summary_release.csv\", header=false, names=[:package, :release])\nbackport = readtable(\"summary_backport.csv\", header=false, names=[:package, :backport])\n\nresults = join(release, backport, on=:package, kind=:outer)\n\nfor result in eachrow(results)\n    a = result[:release]\n    b = result[:backport]\n    if (isna(a) && !isna(b)) || (isna(b) && !isna(a))\n        color = :yellow\n    elseif a != b && occursin(\"pass\", b)\n        color = :green\n    elseif a != b\n        color = :red\n    else\n        continue\n    end\n    printstyled(result[:package], \": Release \", a, \" -> Backport \", b, \"\\n\", color=color)\nend\n\nThis will write color-coded lines to stdout.\nAll lines in red must be investigated as they signify potential breakages caused by the\nbackport version.\nLines in yellow should be looked into since it means a package ran on one version but\nnot on the other for some reason.\nIf you find that your backported branch is causing breakages, use git bisect to\nidentify the problematic commits, git revert those commits, and repeat the process."},{"title":"Merging backports into the release branch","page":"Binary distributions","location":"devdocs/build/distributing.html#Merging-backports-into-the-release-branch","category":"section","text":"After you have ensured that\n\nthe backported commits pass all of Julia's unit tests,\nthere are no performance regressions introduced by the backported commits as compared\nto the release branch, and\nthe backported commits do not break any registered packages,\n\nthen the backport branch is ready to be merged into release-x.y.\nOnce it's merged, go through and remove the \"backport pending x.y\" label from all pull\nrequests containing the commits that have been backported.\nDo not remove the label from PRs that have not been backported.\n\nThe release-x.y branch should now contain all of the new commits.\nThe last thing we want to do to the branch is to adjust the version number.\nTo do this, submit a PR against release-x.y that edits the VERSION file to remove -pre\nfrom the version number.\nOnce that's merged, we're ready to tag."},{"title":"Tagging the release","page":"Binary distributions","location":"devdocs/build/distributing.html#Tagging-the-release","category":"section","text":"It's time!\nCheck out the release-x.y branch and make sure that your local copy of the branch is\nup to date with the remote branch.\nAt the command line, run\n\ngit tag v$(cat VERSION)\ngit push --tags\n\nThis creates the tag locally and pushes it to GitHub.\n\nAfter tagging the release, submit another PR to release-x.y to bump the patch number\nand add -pre back to the end.\nThis denotes that the branch state reflects a prerelease version of the next point\nrelease in the x.y series.\n\nFollow the remaining directions in the Makefile."},{"title":"Signing binaries","page":"Binary distributions","location":"devdocs/build/distributing.html#Signing-binaries","category":"section","text":"Some of these steps will require secure passwords.\nTo obtain the appropriate passwords, contact Elliot Saba (staticfloat) or Alex Arslan\n(ararslan).\nNote that code signing for each platform must be performed on that platform (e.g. Windows\nsigning must be done on Windows, etc.)."},{"title":"Linux","page":"Binary distributions","location":"devdocs/build/distributing.html#Linux-2","category":"section","text":"Code signing must be done manually on Linux, but it's quite simple.\nFirst obtain the file julia.key from the CodeSigning folder in the juliasecure AWS\nbucket.\nAdd this to your GnuPG keyring using\n\ngpg --import julia.key\n\nThis will require entering a password that you must obtain from Elliot or Alex.\nNext, set the trust level for the key to maximum.\nStart by entering a gpg session:\n\ngpg --edit-key julia\n\nAt the prompt, type trust, then when asked for a trust level, provide the maximum\navailable (likely 5).\nExit GnuPG.\n\nNow, for each of the Linux tarballs that were built on the buildbots, enter\n\ngpg -u julia --armor --detach-sig julia-x.y.z-linux-<arch>.tar.gz\n\nThis will produce a corresponding .asc file for each tarball.\nAnd that's it!"},{"title":"macOS","page":"Binary distributions","location":"devdocs/build/distributing.html#macOS","category":"section","text":"Code signing should happen automatically on the macOS buildbots.\nHowever, it's important to verify that it was successful.\nOn a system or virtual machine running macOS, download the .dmg file that was built on\nthe buildbots.\nFor the sake of example, say that the .dmg file is called julia-x.y.z-osx.dmg.\nRun\n\nmkdir ./jlmnt\nhdiutil mount -readonly -mountpoint ./jlmnt julia-x.y.z-osx.dmg\ncodesign -v jlmnt/Julia-x.y.app\n\nBe sure to note the name of the mounted disk listed when mounting!\nFor the sake of example, we'll assume this is disk3.\nIf the code signing verification exited successfully, there will be no output from the\ncodesign step.\nIf it was indeed successful, you can detach the .dmg now:\n\nhdiutil eject /dev/disk3\nrm -rf ./jlmnt\n\nIf you get a message like\n\nJulia-x.y.app: code object is not signed at all\n\nthen you'll need to sign manually.\n\nTo sign manually, first retrieve the OS X certificates from the CodeSigning folder\nin the juliasecure bucket on AWS.\nAdd the .p12 file to your keychain using Keychain.app.\nAsk Elliot Saba (staticfloat) or Alex Arslan (ararslan) for the password for the key.\nNow run\n\nhdiutil convert julia-x.y.z-osx.dmg -format UDRW -o julia-x.y.z-osx_writable.dmg\nmkdir ./jlmnt\nhdiutil mount -mountpoint julia-x.y.z-osx_writable.dmg\ncodesign -s \"AFB379C0B4CBD9DB9A762797FC2AB5460A2B0DBE\" --deep jlmnt/Julia-x.y.app\n\nThis may fail with a message like\n\nJulia-x.y.app: resource fork, Finder information, or similar detritus not allowed\n\nIf that's the case, you'll need to remove extraneous attributes:\n\nxattr -cr jlmnt/Julia-x.y.app\n\nThen retry code signing.\nIf that produces no errors, retry verification.\nIf all is now well, unmount the writable .dmg and convert it back to read-only:\n\nhdiutil eject /dev/disk3\nrm -rf ./jlmnt\nhdiutil convert julia-x.y.z-osx_writable.dmg -format UDZO -o julia-x.y.z-osx_fixed.dmg\n\nVerify that the resulting .dmg is in fact fixed by double clicking it.\nIf everything looks good, eject it then drop the _fixed suffix from the name.\nAnd that's it!"},{"title":"Windows","page":"Binary distributions","location":"devdocs/build/distributing.html#Windows-2","category":"section","text":"Signing must be performed manually on Windows.\nFirst obtain the Windows 10 SDK, which contains the necessary signing utilities, from\nthe Microsoft website.\nWe need the SignTool utility which should have been installed somewhere like\nC:\\Program Files (x86)\\Windows Kits\\10\\App Certification Kit.\nGrab the Windows certificate files from CodeSigning on juliasecure and put them\nin the same directory as the executables.\nOpen a Windows CMD window, cd to where all the files are, and run\n\nset PATH=%PATH%;C:\\Program Files (x86)\\Windows Kits\\10\\App Certification Kit;\nsigntool sign /f julia-windows-code-sign_2017.p12 /p \"PASSWORD\" ^\n   /t http://timestamp.verisign.com/scripts/timstamp.dll ^\n   /v julia-x.y.z-win32.exe\n\nNote that ^ is a line continuation character in Windows CMD and PASSWORD is a\nplaceholder for the password for this certificate.\nAs usual, contact Elliot or Alex for passwords.\nIf there are no errors, we're all good!"},{"title":"Uploading binaries","page":"Binary distributions","location":"devdocs/build/distributing.html#Uploading-binaries","category":"section","text":"Now that everything is signed, we need to upload the binaries to AWS.\nYou can use a program like Cyberduck or the aws command line utility.\nThe binaries should go in the julialang2 bucket in the appropriate folders.\nFor example, Linux x86-64 goes in julialang2/bin/linux/x.y.\nBe sure to delete the current julia-x.y-latest-linux-<arch>.tar.gz file and replace\nit with a duplicate of julia-x.y.z-linux-<arch>.tar.gz.\n\nWe also need to upload the checksums for everything we've built, including the source\ntarballs and all release binaries.\nThis is simple:\n\nshasum -a 256 julia-x.y.z* | grep -v -e sha256 -e md5 -e asc > julia-x.y.z.sha256\nmd5sum julia-x.y.z* | grep -v -e sha256 -e md5 -e asc > julia-x.y.z.md5\n\nNote that if you're running those commands on macOS, you'll get very slightly different\noutput, which can be reformatted by looking at an existing file.\nMac users will also need to use md5 -r instead of md5sum.\nUpload the .md5 and .sha256 files to julialang2/bin/checksums on AWS.\n\nEnsure that the permissions on AWS for all uploaded files are set to \"Everyone: READ.\"\n\nFor each file we've uploaded, we need to purge the Fastly cache so that the links on\nthe website point to the updated files.\nAs an example:\n\ncurl -X PURGE https://julialang-s3.julialang.org/bin/checksums/julia-x.y.z.sha256\n\nSometimes this isn't necessary but it's good to do anyway."},{"title":"Iteration utilities","page":"Iteration utilities","location":"base/iterators.html#Iteration-utilities","category":"section","text":""},{"title":"Base.Iterators.Stateful","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.Stateful","category":"type","text":"Stateful(itr)\n\nThere are several different ways to think about this iterator wrapper:\n\nIt provides a mutable wrapper around an iterator and\nits iteration state.\nIt turns an iterator-like abstraction into a Channel-like\nabstraction.\nIt's an iterator that mutates to become its own rest iterator\nwhenever an item is produced.\n\nStateful provides the regular iterator interface. Like other mutable iterators\n(e.g. Base.Channel), if iteration is stopped early (e.g. by a break in a for loop),\niteration can be resumed from the same spot by continuing to iterate over the\nsame iterator object (in contrast, an immutable iterator would restart from the\nbeginning).\n\nExamples\n\njulia> a = Iterators.Stateful(\"abcdef\");\n\njulia> isempty(a)\nfalse\n\njulia> popfirst!(a)\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> collect(Iterators.take(a, 3))\n3-element Vector{Char}:\n 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n 'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n 'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n\njulia> collect(a)\n2-element Vector{Char}:\n 'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n 'f': ASCII/Unicode U+0066 (category Ll: Letter, lowercase)\n\njulia> Iterators.reset!(a); popfirst!(a)\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> Iterators.reset!(a, \"hello\"); popfirst!(a)\n'h': ASCII/Unicode U+0068 (category Ll: Letter, lowercase)\n\njulia> a = Iterators.Stateful([1,1,1,2,3,4]);\n\njulia> for x in a; x == 1 || break; end\n\njulia> peek(a)\n3\n\njulia> sum(a) # Sum the remaining elements\n7\n\n\n\n\n\n"},{"title":"Base.Iterators.zip","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.zip","category":"function","text":"zip(iters...)\n\nRun multiple iterators at the same time, until any of them is exhausted. The value type of\nthe zip iterator is a tuple of values of its subiterators.\n\nnote: Note\nzip orders the calls to its subiterators in such a way that stateful iterators will\nnot advance when another iterator finishes in the current iteration.\n\nnote: Note\nzip() with no arguments yields an infinite iterator of empty tuples.\n\nSee also: enumerate, Base.splat.\n\nExamples\n\njulia> a = 1:5\n1:5\n\njulia> b = [\"e\",\"d\",\"b\",\"c\",\"a\"]\n5-element Vector{String}:\n \"e\"\n \"d\"\n \"b\"\n \"c\"\n \"a\"\n\njulia> c = zip(a,b)\nzip(1:5, [\"e\", \"d\", \"b\", \"c\", \"a\"])\n\njulia> length(c)\n5\n\njulia> first(c)\n(1, \"e\")\n\n\n\n\n\n"},{"title":"Base.Iterators.enumerate","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.enumerate","category":"function","text":"enumerate(iter)\n\nAn iterator that yields (i, x) where i is a counter starting at 1,\nand x is the ith value from the given iterator. It's useful when\nyou need not only the values x over which you are iterating, but\nalso the number of iterations so far.\n\nNote that i may not be valid for indexing iter, or may index a\ndifferent element. This will happen if iter has indices that do not\nstart at 1, and may happen for strings, dictionaries, etc.\nSee the pairs(IndexLinear(), iter) method if you want to ensure that i is an index.\n\nExamples\n\njulia> a = [\"a\", \"b\", \"c\"];\n\njulia> for (index, value) in enumerate(a)\n           println(\"$index $value\")\n       end\n1 a\n2 b\n3 c\n\njulia> str = \"naïve\";\n\njulia> for (i, val) in enumerate(str)\n           print(\"i = \", i, \", val = \", val, \", \")\n           try @show(str[i]) catch e println(e) end\n       end\ni = 1, val = n, str[i] = 'n'\ni = 2, val = a, str[i] = 'a'\ni = 3, val = ï, str[i] = 'ï'\ni = 4, val = v, StringIndexError(\"naïve\", 4)\ni = 5, val = e, str[i] = 'v'\n\n\n\n\n\n"},{"title":"Base.Iterators.rest","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.rest","category":"function","text":"rest(iter, state)\n\nAn iterator that yields the same elements as iter, but starting at the given state, which\nmust be a state obtainable via a sequence of one or more calls to iterate(iter[, state])\n\nSee also: Iterators.drop, Iterators.peel, Base.rest.\n\nExamples\n\njulia> iter = [1,2,3,4];\n\njulia> val, state = iterate(iter)\n(1, 2)\n\njulia> collect(Iterators.rest(iter, state))\n3-element Vector{Int64}:\n 2\n 3\n 4\n\n\n\n\n\n"},{"title":"Base.Iterators.countfrom","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.countfrom","category":"function","text":"countfrom(start=1, step=1)\n\nAn iterator that counts forever, starting at start and incrementing by step.\n\nExamples\n\njulia> for v in Iterators.countfrom(5, 2)\n           v > 10 && break\n           println(v)\n       end\n5\n7\n9\n\n\n\n\n\n"},{"title":"Base.Iterators.take","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.take","category":"function","text":"take(iter, n)\n\nAn iterator that generates at most the first n elements of iter.\n\nSee also: drop, peel, first, Base.take!.\n\nExamples\n\njulia> a = 1:2:11\n1:2:11\n\njulia> collect(a)\n6-element Vector{Int64}:\n  1\n  3\n  5\n  7\n  9\n 11\n\njulia> collect(Iterators.take(a,3))\n3-element Vector{Int64}:\n 1\n 3\n 5\n\n\n\n\n\n"},{"title":"Base.Iterators.takewhile","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.takewhile","category":"function","text":"takewhile(pred, iter)\n\nAn iterator that generates element from iter as long as predicate pred is true,\nafterwards, drops every element.\n\ncompat: Julia 1.4\nThis function requires at least Julia 1.4.\n\nExamples\n\njulia> s = collect(1:5)\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\njulia> collect(Iterators.takewhile(<(3),s))\n2-element Vector{Int64}:\n 1\n 2\n\n\n\n\n\n"},{"title":"Base.Iterators.drop","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.drop","category":"function","text":"drop(iter, n)\n\nAn iterator that generates all but the first n elements of iter.\n\nExamples\n\njulia> a = 1:2:11\n1:2:11\n\njulia> collect(a)\n6-element Vector{Int64}:\n  1\n  3\n  5\n  7\n  9\n 11\n\njulia> collect(Iterators.drop(a,4))\n2-element Vector{Int64}:\n  9\n 11\n\n\n\n\n\n"},{"title":"Base.Iterators.dropwhile","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.dropwhile","category":"function","text":"dropwhile(pred, iter)\n\nAn iterator that drops element from iter as long as predicate pred is true,\nafterwards, returns every element.\n\ncompat: Julia 1.4\nThis function requires at least Julia 1.4.\n\nExamples\n\njulia> s = collect(1:5)\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\njulia> collect(Iterators.dropwhile(<(3),s))\n3-element Vector{Int64}:\n 3\n 4\n 5\n\n\n\n\n\n"},{"title":"Base.Iterators.findeach","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.findeach","category":"function","text":"findeach(f, it)\nfindeach(it)\n\nAn iterator that generates every key from the key/value pairs of pairs(it),\nwhere f(value) returns true.\n\nIf f is not specified, default to identity.\n\nIterators.findeach is the lazy equivalent of findall.\n\ncompat: Julia 1.13\nfindeach requires at least Julia 1.13.\n\nExamples\n\njulia> collect(Iterators.findeach(isodd, Dict(2 => 3, 3 => 2)))\n1-element Vector{Int64}:\n 2\n\njulia> only(Iterators.findeach(==(1), [3,6,2,1]))\n4\n\n\n\n\n\n"},{"title":"Base.Iterators.cycle","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.cycle","category":"function","text":"cycle(iter[, n::Int])\n\nAn iterator that cycles through iter forever.\nIf n is specified, then it cycles through iter that many times.\nWhen iter is empty, so are cycle(iter) and cycle(iter, n).\n\nIterators.cycle(iter, n) is the lazy equivalent of Base.repeat(vector, n),\nwhile Iterators.repeated(iter, n) is the lazy Base.fill(item, n).\n\ncompat: Julia 1.11\nThe method cycle(iter, n) was added in Julia 1.11.\n\nExamples\n\njulia> for (i, v) in enumerate(Iterators.cycle(\"hello\"))\n           print(v)\n           i > 10 && break\n       end\nhellohelloh\n\njulia> foreach(print, Iterators.cycle(['j', 'u', 'l', 'i', 'a'], 3))\njuliajuliajulia\n\njulia> repeat([1,2,3], 4) == collect(Iterators.cycle([1,2,3], 4))\ntrue\n\njulia> fill([1,2,3], 4) == collect(Iterators.repeated([1,2,3], 4))\ntrue\n\n\n\n\n\n"},{"title":"Base.Iterators.repeated","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.repeated","category":"function","text":"repeated(x[, n::Int])\n\nAn iterator that generates the value x forever. If n is specified, generates x that\nmany times (equivalent to take(repeated(x), n)).\n\nSee also fill, and compare Iterators.cycle.\n\nExamples\n\njulia> a = Iterators.repeated([1 2], 4);\n\njulia> collect(a)\n4-element Vector{Matrix{Int64}}:\n [1 2]\n [1 2]\n [1 2]\n [1 2]\n\njulia> ans == fill([1 2], 4)\ntrue\n\njulia> Iterators.cycle([1 2], 4) |> collect |> println\n[1, 2, 1, 2, 1, 2, 1, 2]\n\n\n\n\n\n"},{"title":"Base.Iterators.product","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.product","category":"function","text":"product(iters...)\n\nReturn an iterator over the product of several iterators. Each generated element is\na tuple whose ith element comes from the ith argument iterator. The first iterator\nchanges the fastest.\n\nSee also: zip, Iterators.flatten.\n\nExamples\n\njulia> collect(Iterators.product(1:2, 3:5))\n2×3 Matrix{Tuple{Int64, Int64}}:\n (1, 3)  (1, 4)  (1, 5)\n (2, 3)  (2, 4)  (2, 5)\n\njulia> ans == [(x,y) for x in 1:2, y in 3:5]  # collects a generator involving Iterators.product\ntrue\n\n\n\n\n\n"},{"title":"Base.Iterators.flatten","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.flatten","category":"function","text":"flatten(iter)\n\nGiven an iterator that yields iterators, return an iterator that yields the\nelements of those iterators.\nPut differently, the elements of the argument iterator are concatenated.\n\nExamples\n\njulia> collect(Iterators.flatten((1:2, 8:9)))\n4-element Vector{Int64}:\n 1\n 2\n 8\n 9\n\njulia> [(x,y) for x in 0:1 for y in 'a':'c']  # collects generators involving Iterators.flatten\n6-element Vector{Tuple{Int64, Char}}:\n (0, 'a')\n (0, 'b')\n (0, 'c')\n (1, 'a')\n (1, 'b')\n (1, 'c')\n\n\n\n\n\n"},{"title":"Base.Iterators.flatmap","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.flatmap","category":"function","text":"Iterators.flatmap(f, iterators...)\n\nEquivalent to flatten(map(f, iterators...)).\n\nSee also Iterators.flatten, Iterators.map.\n\ncompat: Julia 1.9\nThis function was added in Julia 1.9.\n\nExamples\n\njulia> Iterators.flatmap(n -> -n:2:n, 1:3) |> collect\n9-element Vector{Int64}:\n -1\n  1\n -2\n  0\n  2\n -3\n -1\n  1\n  3\n\njulia> stack(n -> -n:2:n, 1:3)\nERROR: DimensionMismatch: stack expects uniform slices, got axes(x) == (1:3,) while first had (1:2,)\n[...]\n\njulia> Iterators.flatmap(n -> (-n, 10n), 1:2) |> collect\n4-element Vector{Int64}:\n -1\n 10\n -2\n 20\n\njulia> ans == vec(stack(n -> (-n, 10n), 1:2))\ntrue\n\n\n\n\n\n"},{"title":"Base.Iterators.partition","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.partition","category":"function","text":"partition(collection, n)\n\nIterate over a collection n elements at a time.\n\nExamples\n\njulia> collect(Iterators.partition([1,2,3,4,5], 2))\n3-element Vector{SubArray{Int64, 1, Vector{Int64}, Tuple{UnitRange{Int64}}, true}}:\n [1, 2]\n [3, 4]\n [5]\n\n\n\n\n\n"},{"title":"Base.Iterators.map","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.map","category":"function","text":"Iterators.map(f, iterators...)\n\nCreate a lazy mapping.  This is another syntax for writing\n(f(args...) for args in zip(iterators...)).\n\ncompat: Julia 1.6\nThis function requires at least Julia 1.6.\n\nExamples\n\njulia> collect(Iterators.map(x -> x^2, 1:3))\n3-element Vector{Int64}:\n 1\n 4\n 9\n\n\n\n\n\n"},{"title":"Base.Iterators.filter","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.filter","category":"function","text":"Iterators.filter(flt, itr)\n\nGiven a predicate function flt and an iterable object itr, return an\niterable object which upon iteration yields the elements x of itr that\nsatisfy flt(x). The order of the original iterator is preserved.\n\nThis function is lazy; that is, it is guaranteed to return in Θ(1) time\nand use Θ(1) additional space, and flt will not be called by an\ninvocation of filter. Calls to flt will be made when iterating over the\nreturned iterable object. These calls are not cached and repeated calls will be\nmade when reiterating.\n\nwarning: Warning\nSubsequent lazy transformations on the iterator returned from filter, such\nas those performed by Iterators.reverse or cycle, will also delay calls to flt\nuntil collecting or iterating over the returned iterable object. If the filter\npredicate is nondeterministic or its return values depend on the order of iteration\nover the elements of itr, composition with lazy transformations may result in\nsurprising behavior. If this is undesirable, either ensure that flt is a pure\nfunction or collect intermediate filter iterators before further transformations.\n\nSee Base.filter for an eager implementation of filtering for arrays.\n\nExamples\n\njulia> f = Iterators.filter(isodd, [1, 2, 3, 4, 5])\nBase.Iterators.Filter{typeof(isodd), Vector{Int64}}(isodd, [1, 2, 3, 4, 5])\n\njulia> foreach(println, f)\n1\n3\n5\n\njulia> [x for x in [1, 2, 3, 4, 5] if isodd(x)]  # collects a generator over Iterators.filter\n3-element Vector{Int64}:\n 1\n 3\n 5\n\n\n\n\n\n"},{"title":"Base.Iterators.accumulate","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.accumulate","category":"function","text":"Iterators.accumulate(f, itr; [init])\n\nGiven a 2-argument function f and an iterator itr, return a new\niterator that successively applies f to the previous value and the\nnext element of itr.\n\nThis is effectively a lazy version of Base.accumulate.\n\ncompat: Julia 1.5\nKeyword argument init is added in Julia 1.5.\n\nExamples\n\njulia> a = Iterators.accumulate(+, [1,2,3,4]);\n\njulia> foreach(println, a)\n1\n3\n6\n10\n\njulia> b = Iterators.accumulate(/, (2, 5, 2, 5); init = 100);\n\njulia> collect(b)\n4-element Vector{Float64}:\n 50.0\n 10.0\n  5.0\n  1.0\n\n\n\n\n\n"},{"title":"Base.Iterators.reverse","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.reverse","category":"function","text":"Iterators.reverse(itr)\n\nGiven an iterator itr, then reverse(itr) is an iterator over the\nsame collection but in the reverse order.\nThis iterator is \"lazy\" in that it does not make a copy of the collection in\norder to reverse it; see Base.reverse for an eager implementation.\n\n(By default, this returns\nan Iterators.Reverse object wrapping itr, which is iterable\nif the corresponding iterate methods are defined, but some itr types\nmay implement more specialized Iterators.reverse behaviors.)\n\nNot all iterator types T support reverse-order iteration.  If T\ndoesn't, then iterating over Iterators.reverse(itr::T) will throw a MethodError\nbecause of the missing iterate methods for Iterators.Reverse{T}.\n(To implement these methods, the original iterator\nitr::T can be obtained from an r::Iterators.Reverse{T} object by r.itr;\nmore generally, one can use Iterators.reverse(r).)\n\nExamples\n\njulia> foreach(println, Iterators.reverse(1:5))\n5\n4\n3\n2\n1\n\n\n\n\n\n"},{"title":"Base.Iterators.only","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.only","category":"function","text":"only(x)\n\nReturn the one and only element of collection x, or throw an ArgumentError if the\ncollection has zero or multiple elements.\n\nSee also first, last.\n\ncompat: Julia 1.4\nThis method requires at least Julia 1.4.\n\nExamples\n\njulia> only([\"a\"])\n\"a\"\n\njulia> only(\"a\")\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> only(())\nERROR: ArgumentError: Tuple contains 0 elements, must contain exactly 1 element\nStacktrace:\n[...]\n\njulia> only(('a', 'b'))\nERROR: ArgumentError: Tuple contains 2 elements, must contain exactly 1 element\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"Base.Iterators.peel","page":"Iteration utilities","location":"base/iterators.html#Base.Iterators.peel","category":"function","text":"peel(iter)\n\nReturns the first element and an iterator over the remaining elements.\n\nIf the iterator is empty return nothing (like iterate).\n\ncompat: Julia 1.7\nPrior versions throw a BoundsError if the iterator is empty.\n\nSee also: Iterators.drop, Iterators.take.\n\nExamples\n\njulia> (a, rest) = Iterators.peel(\"abc\");\n\njulia> a\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> collect(rest)\n2-element Vector{Char}:\n 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n 'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n\n\n\n\n\n"},{"title":"Environment Variables","page":"Environment Variables","location":"manual/environment-variables.html#Environment-Variables","category":"section","text":"Julia can be configured with a number of environment variables, set either in\nthe usual way for each operating system, or in a portable way from within Julia.\nSupposing that you want to set the environment variable JULIA_EDITOR to vim,\nyou can type ENV[\"JULIA_EDITOR\"] = \"vim\" (for instance, in the REPL) to make\nthis change on a case by case basis, or add the same to the user configuration\nfile ~/.julia/config/startup.jl in the user's home directory to have a\npermanent effect. The current value of the same environment variable can be\ndetermined by evaluating ENV[\"JULIA_EDITOR\"].\n\nThe environment variables that Julia uses generally start with JULIA. If\nInteractiveUtils.versioninfo is called with the keyword verbose=true, then the\noutput will list any defined environment variables relevant for Julia,\nincluding those which include JULIA in their names.\n\nnote: Note\nIt is recommended to avoid changing environment variables during runtime,\nsuch as within a ~/.julia/config/startup.jl.One reason is that some julia language variables, such as JULIA_NUM_THREADS\nand JULIA_PROJECT, need to be set before Julia starts.Similarly, __init__() functions of user modules in the sysimage (via PackageCompiler) are\nrun before startup.jl, so setting environment variables in a startup.jl may be too late for\nuser code.Further, changing environment variables during runtime can introduce data races into\notherwise benign code.In Bash, environment variables can either be set manually by running, e.g.,\nexport JULIA_NUM_THREADS=4 before starting Julia, or by adding the same command to\n~/.bashrc or ~/.bash_profile to set the variable each time Bash is started."},{"title":"File locations","page":"Environment Variables","location":"manual/environment-variables.html#File-locations","category":"section","text":""},{"title":"JULIA_BINDIR","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_BINDIR","category":"section","text":"The absolute path of the directory containing the Julia executable, which sets\nthe global variable Sys.BINDIR. If $JULIA_BINDIR is not set, then\nJulia determines the value Sys.BINDIR at run-time.\n\nThe executable itself is one of\n\n$JULIA_BINDIR/julia\n$JULIA_BINDIR/julia-debug\n\nby default.\n\nThe global variable Base.DATAROOTDIR determines a relative path from\nSys.BINDIR to the data directory associated with Julia. Then the path\n\n$JULIA_BINDIR/$DATAROOTDIR/julia/base\n\ndetermines the directory in which Julia initially searches for source files (via\nBase.find_source_file()).\n\nLikewise, the global variable Base.SYSCONFDIR determines a relative path to the\nconfiguration file directory. Then Julia searches for a startup.jl file at\n\n$JULIA_BINDIR/$SYSCONFDIR/julia/startup.jl\n$JULIA_BINDIR/../etc/julia/startup.jl\n\nby default (via Base.load_julia_startup()).\n\nFor example, a Linux installation with a Julia executable located at\n/bin/julia, a DATAROOTDIR of ../share, and a SYSCONFDIR of ../etc will\nhave JULIA_BINDIR set to /bin, a source-file search path of\n\n/share/julia/base\n\nand a global configuration search path of\n\n/etc/julia/startup.jl"},{"title":"JULIA_PROJECT","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_PROJECT","category":"section","text":"A directory path that indicates which project should be the initial active project.\nSetting this environment variable has the same effect as specifying the --project\nstart-up option, but --project has higher precedence. If the variable is set to @.\n(note the trailing dot)\nthen Julia tries to find a project directory that contains Project.toml or\nJuliaProject.toml file from the current directory and its parents. See also\nthe chapter on Code Loading.\n\nnote: Note\nJULIA_PROJECT must be defined before starting julia; defining it in startup.jl\nis too late in the startup process."},{"title":"JULIA_LOAD_PATH","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_LOAD_PATH","category":"section","text":"The JULIA_LOAD_PATH environment variable is used to populate the global Julia\nLOAD_PATH variable, which determines which packages can be loaded via\nimport and using (see Code Loading).\n\nUnlike the shell PATH variable, empty entries in JULIA_LOAD_PATH are expanded to\nthe default value of LOAD_PATH, [\"@\", \"@v#.#\", \"@stdlib\"] when populating\nLOAD_PATH. This allows easy appending, prepending, etc. of the load path value in\nshell scripts regardless of whether JULIA_LOAD_PATH is already set or not. For\nexample, to prepend the directory /foo/bar to LOAD_PATH just do\n\nexport JULIA_LOAD_PATH=\"/foo/bar:$JULIA_LOAD_PATH\"\n\nIf the JULIA_LOAD_PATH environment variable is already set, its old value will be\nprepended with /foo/bar. On the other hand, if JULIA_LOAD_PATH is not set, then\nit will be set to /foo/bar: which will expand to a LOAD_PATH value of\n[\"/foo/bar\", \"@\", \"@v#.#\", \"@stdlib\"]. If JULIA_LOAD_PATH is set to the empty\nstring, it expands to an empty LOAD_PATH array. In other words, the empty string\nis interpreted as a zero-element array, not a one-element array of the empty string.\nThis behavior was chosen so that it would be possible to set an empty load path via\nthe environment variable. If you want the default load path, either unset the\nenvironment variable or if it must have a value, set it to the string :.\n\nnote: Note\nOn Windows, path elements are separated by the ; character, as is the case with\nmost path lists on Windows. Replace : with ; in the above paragraph."},{"title":"JULIA_DEPOT_PATH","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_DEPOT_PATH","category":"section","text":"The JULIA_DEPOT_PATH environment variable is used to populate the\nglobal Julia DEPOT_PATH variable, which controls where the package manager, as well\nas Julia's code loading mechanisms, look for package registries, installed packages, named\nenvironments, repo clones, cached compiled package images, configuration files, and the default\nlocation of the REPL's history file.\n\nUnlike the shell PATH variable but similar to JULIA_LOAD_PATH,\nempty entries in JULIA_DEPOT_PATH have special behavior:\n\nAt the end, it is expanded to the default value of DEPOT_PATH, excluding the user depot.\nAt the start, it is expanded to the default value of DEPOT_PATH, including the user depot.\n\nThis allows easy overriding of the user depot, while still retaining access to resources that\nare bundled with Julia, like cache files, artifacts, etc. For example, to switch the user depot\nto /foo/bar use a trailing :\n\nexport JULIA_DEPOT_PATH=\"/foo/bar:\"\n\nAll package operations, like cloning registries or installing packages, will now write to\n/foo/bar, but since the empty entry is expanded to the default system depot, any bundled\nresources will still be available. If you really only want to use the depot at /foo/bar,\nand not load any bundled resources, simply set the environment variable to /foo/bar\nwithout the trailing colon.\n\nTo append a depot at the end of the full default list, including the default user depot, use a\nleading :\n\nexport JULIA_DEPOT_PATH=\":/foo/bar\"\n\nThere are two exceptions to the above rule. First, if [JULIA_DEPOT_PATH](@ref\nJULIADEPOTPATH) is set to the empty string, it expands to an empty DEPOT_PATH array. In\nother words, the empty string is interpreted as a zero-element array, not a one-element\narray of the empty string. This behavior was chosen so that it would be possible to set an\nempty depot path via the environment variable.\n\nSecond, if no user depot is specified in JULIA_DEPOT_PATH, then\nthe empty entry is expanded to the default depot including the user depot. This makes\nit possible to use the default depot, as if the environment variable was unset, by setting\nit to the string :.\n\nnote: Note\nOn Windows, path elements are separated by the ; character, as is the case with\nmost path lists on Windows. Replace : with ; in the above paragraph.\n\nnote: Note\nJULIA_DEPOT_PATH must be defined before starting julia; defining it in\nstartup.jl is too late in the startup process; at that point you can instead\ndirectly modify the DEPOT_PATH array, which is populated from the environment\nvariable."},{"title":"JULIA_HISTORY","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_HISTORY","category":"section","text":"The absolute path REPL.find_hist_file() of the REPL's history file. If\n$JULIA_HISTORY is not set, then REPL.find_hist_file() defaults to\n\n$(DEPOT_PATH[1])/logs/repl_history.jl"},{"title":"JULIA_MAX_NUM_PRECOMPILE_FILES","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_MAX_NUM_PRECOMPILE_FILES","category":"section","text":"Sets the maximum number of different instances of a single package that are to be stored in the precompile cache (default = 10)."},{"title":"JULIA_VERBOSE_LINKING","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_VERBOSE_LINKING","category":"section","text":"If set to true, linker commands will be displayed during precompilation."},{"title":"Pkg.jl","page":"Environment Variables","location":"manual/environment-variables.html#Pkg.jl","category":"section","text":""},{"title":"JULIA_CI","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_CI","category":"section","text":"If set to true, this indicates to the package server that any package operations are part of a continuous integration (CI) system for the purposes of gathering package usage statistics."},{"title":"JULIA_NUM_PRECOMPILE_TASKS","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_NUM_PRECOMPILE_TASKS","category":"section","text":"The number of parallel tasks to use when precompiling packages. See Pkg.precompile."},{"title":"JULIA_PKG_DEVDIR","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_PKG_DEVDIR","category":"section","text":"The default directory used by Pkg.develop for downloading packages."},{"title":"JULIA_PKG_IGNORE_HASHES","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_PKG_IGNORE_HASHES","category":"section","text":"If set to 1, this will ignore incorrect hashes in artifacts. This should be used carefully, as it disables verification of downloads, but can resolve issues when moving files across different types of file systems. See Pkg.jl issue #2317 for more details.\n\ncompat: Julia 1.6\nThis is only supported in Julia 1.6 and above."},{"title":"JULIA_PKG_OFFLINE","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_PKG_OFFLINE","category":"section","text":"If set to true, this will enable offline mode: see Pkg.offline.\n\ncompat: Julia 1.5\nPkg's offline mode requires Julia 1.5 or later."},{"title":"JULIA_PKG_PRECOMPILE_AUTO","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_PKG_PRECOMPILE_AUTO","category":"section","text":"If set to 0, this will disable automatic precompilation by package actions which change the manifest. See Pkg.precompile."},{"title":"JULIA_PKG_SERVER","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_PKG_SERVER","category":"section","text":"Specifies the URL of the package registry to use. By default, Pkg uses\nhttps://pkg.julialang.org to fetch Julia packages. In addition, you can disable the use of the PkgServer\nprotocol, and instead access the packages directly from their hosts (GitHub, GitLab, etc.)\nby setting: export JULIA_PKG_SERVER=\"\""},{"title":"JULIA_PKG_SERVER_REGISTRY_PREFERENCE","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_PKG_SERVER_REGISTRY_PREFERENCE","category":"section","text":"Specifies the preferred registry flavor. Currently supported values are conservative\n(the default), which will only publish resources that have been processed by the storage\nserver (and thereby have a higher probability of being available from the PkgServers),\nwhereas eager will publish registries whose resources have not necessarily been\nprocessed by the storage servers. Users behind restrictive firewalls that do not allow\ndownloading from arbitrary servers should not use the eager flavor.\n\ncompat: Julia 1.7\nThis only affects Julia 1.7 and above."},{"title":"JULIA_PKG_UNPACK_REGISTRY","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_PKG_UNPACK_REGISTRY","category":"section","text":"If set to true, this will unpack the registry instead of storing it as a compressed tarball.\n\ncompat: Julia 1.7\nThis only affects Julia 1.7 and above. Earlier versions will always unpack the registry."},{"title":"JULIA_PKG_USE_CLI_GIT","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_PKG_USE_CLI_GIT","category":"section","text":"If set to true, Pkg operations which use the git protocol will use an external git executable instead of the default libgit2 library.\n\ncompat: Julia 1.7\nUse of the git executable is only supported on Julia 1.7 and above."},{"title":"JULIA_PKGRESOLVE_ACCURACY","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_PKGRESOLVE_ACCURACY","category":"section","text":"The accuracy of the package resolver. This should be a positive integer, the default is 1."},{"title":"JULIA_PKG_PRESERVE_TIERED_INSTALLED","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_PKG_PRESERVE_TIERED_INSTALLED","category":"section","text":"Change the default package installation strategy to Pkg.PRESERVE_TIERED_INSTALLED\nto let the package manager try to install versions of packages while keeping as many\nversions of packages already installed as possible.\n\ncompat: Julia 1.9\nThis only affects Julia 1.9 and above."},{"title":"JULIA_PKG_GC_AUTO","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_PKG_GC_AUTO","category":"section","text":"If set to false, automatic garbage collection of packages and artifacts will be disabled;\nsee Pkg.gc for more details.\n\ncompat: Julia 1.12\nThis environment variable is only supported on Julia 1.12 and above."},{"title":"Network transport","page":"Environment Variables","location":"manual/environment-variables.html#Network-transport","category":"section","text":""},{"title":"JULIA_NO_VERIFY_HOSTS","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_NO_VERIFY_HOSTS","category":"section","text":""},{"title":"JULIA_SSL_NO_VERIFY_HOSTS","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_SSL_NO_VERIFY_HOSTS","category":"section","text":""},{"title":"JULIA_SSH_NO_VERIFY_HOSTS","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_SSH_NO_VERIFY_HOSTS","category":"section","text":""},{"title":"JULIA_ALWAYS_VERIFY_HOSTS","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_ALWAYS_VERIFY_HOSTS","category":"section","text":"Specify hosts whose identity should or should not be verified for specific transport layers. See NetworkOptions.verify_host"},{"title":"JULIA_SSL_CA_ROOTS_PATH","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_SSL_CA_ROOTS_PATH","category":"section","text":"Specify the file or directory containing the certificate authority roots. See NetworkOptions.ca_roots"},{"title":"External applications","page":"Environment Variables","location":"manual/environment-variables.html#External-applications","category":"section","text":""},{"title":"JULIA_SHELL","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_SHELL","category":"section","text":"The absolute path of the shell with which Julia should execute external commands\n(via Base.repl_cmd()). Defaults to the environment variable $SHELL, and\nfalls back to /bin/sh if $SHELL is unset.\n\nnote: Note\nOn Windows, this environment variable is ignored, and external commands are\nexecuted directly."},{"title":"JULIA_EDITOR","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_EDITOR","category":"section","text":"The editor returned by InteractiveUtils.editor() and used in, e.g., InteractiveUtils.edit,\nreferring to the command of the preferred editor, for instance vim.\n\n$JULIA_EDITOR takes precedence over $VISUAL, which in turn takes precedence\nover $EDITOR. If none of these environment variables is set, then the editor\nis taken to be open on Windows and OS X, or /etc/alternatives/editor if it\nexists, or emacs otherwise.\n\nTo use Visual Studio Code on Windows, set $JULIA_EDITOR to code.cmd."},{"title":"Parallelization","page":"Environment Variables","location":"manual/environment-variables.html#Parallelization","category":"section","text":""},{"title":"JULIA_CPU_THREADS","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_CPU_THREADS","category":"section","text":"Overrides the global variable Base.Sys.CPU_THREADS, the number of\nlogical CPU cores available."},{"title":"JULIA_WORKER_TIMEOUT","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_WORKER_TIMEOUT","category":"section","text":"A Float64 that sets the value of Distributed.worker_timeout() (default: 60.0).\nThis function gives the number of seconds a worker process will wait for\na master process to establish a connection before dying."},{"title":"JULIA_NUM_THREADS","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_NUM_THREADS","category":"section","text":"An unsigned 64-bit integer (uint64_t) or string that sets the maximum number\nof threads available to Julia. If $JULIA_NUM_THREADS is not set or is a\nnon-positive integer, or if the number of CPU threads cannot be determined\nthrough system calls, then the number of threads is set to 1.\n\nIf $JULIA_NUM_THREADS is set to auto, then the number of threads will be set\nto the number of CPU threads. It can also be set to a comma-separated string to\nspecify the size of the :default and :interactive [threadpools](@ref\nman-threadpools), respectively:\n\n# 5 threads in the :default pool and 2 in the :interactive pool\nexport JULIA_NUM_THREADS=5,2\n\n# `auto` threads in the :default pool and 1 in the :interactive pool\nexport JULIA_NUM_THREADS=auto,1\n\nnote: Note\nJULIA_NUM_THREADS must be defined before starting Julia; defining it in\nstartup.jl is too late in the startup process.\n\ncompat: Julia 1.5\nIn Julia 1.5 and above the number of threads can also be specified on startup\nusing the -t/--threads command line argument.\n\ncompat: Julia 1.7\nThe auto value for $JULIA_NUM_THREADS requires Julia 1.7 or above.\n\ncompat: Julia 1.9\nThe x,y format for threadpools requires Julia 1.9 or above."},{"title":"JULIA_THREAD_SLEEP_THRESHOLD","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_THREAD_SLEEP_THRESHOLD","category":"section","text":"If set to a string that starts with the case-insensitive substring \"infinite\",\nthen spinning threads never sleep. Otherwise, $JULIA_THREAD_SLEEP_THRESHOLD is\ninterpreted as an unsigned 64-bit integer (uint64_t) and gives, in\nnanoseconds, the amount of time after which spinning threads should sleep."},{"title":"JULIA_NUM_GC_THREADS","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_NUM_GC_THREADS","category":"section","text":"Sets the number of threads used by Garbage Collection. If unspecified is set to the number of worker threads.\n\ncompat: Julia 1.10\nThe environment variable was added in 1.10"},{"title":"JULIA_IMAGE_THREADS","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_IMAGE_THREADS","category":"section","text":"An unsigned 32-bit integer that sets the number of threads used by image\ncompilation in this Julia process. The value of this variable may be\nignored if the module is a small module. If left unspecified, the smaller\nof the value of JULIA_CPU_THREADS or half the\nnumber of logical CPU cores is used in its place."},{"title":"JULIA_IMAGE_TIMINGS","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_IMAGE_TIMINGS","category":"section","text":"A boolean value that determines if detailed timing information is printed during\nduring image compilation. Defaults to 0."},{"title":"JULIA_EXCLUSIVE","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_EXCLUSIVE","category":"section","text":"If set to anything besides 0, then Julia's thread policy is consistent with\nrunning on a dedicated machine: each thread in the default threadpool is\naffinitized.  Interactive threads remain under the\ncontrol of the operating system scheduler.\n\nOtherwise, Julia lets the operating system handle thread policy."},{"title":"Garbage Collection","page":"Environment Variables","location":"manual/environment-variables.html#Garbage-Collection","category":"section","text":""},{"title":"JULIA_HEAP_SIZE_HINT","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_HEAP_SIZE_HINT","category":"section","text":"Environment variable equivalent to the --heap-size-hint=<size>[<unit>] command line option.\n\nForces garbage collection if memory usage is higher than the given value. The value may be specified as a number of bytes, optionally in units of:\n\n- B  (bytes)\n- K  (kibibytes)\n- M  (mebibytes)\n- G  (gibibytes)\n- T  (tebibytes)\n- %  (percentage of physical memory)\n\nFor example, JULIA_HEAP_SIZE_HINT=1G would provide a 1 GB heap size hint to the garbage collector."},{"title":"REPL formatting","page":"Environment Variables","location":"manual/environment-variables.html#REPL-formatting","category":"section","text":"Environment variables that determine how REPL output should be formatted at the\nterminal. The JULIA_*_COLOR variables should be set to [ANSI terminal escape\nsequences](https://en.wikipedia.org/wiki/ANSIescapecode). Julia provides\na high-level interface with much of the same functionality; see the section on\nThe Julia REPL."},{"title":"JULIA_ERROR_COLOR","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_ERROR_COLOR","category":"section","text":"The formatting Base.error_color() (default: light red, \"\\033[91m\") that\nerrors should have at the terminal."},{"title":"JULIA_WARN_COLOR","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_WARN_COLOR","category":"section","text":"The formatting Base.warn_color() (default: yellow, \"\\033[93m\") that warnings\nshould have at the terminal."},{"title":"JULIA_INFO_COLOR","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_INFO_COLOR","category":"section","text":"The formatting Base.info_color() (default: cyan, \"\\033[36m\") that info\nshould have at the terminal."},{"title":"JULIA_INPUT_COLOR","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_INPUT_COLOR","category":"section","text":"The formatting Base.input_color() (default: normal, \"\\033[0m\") that input\nshould have at the terminal."},{"title":"JULIA_ANSWER_COLOR","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_ANSWER_COLOR","category":"section","text":"The formatting Base.answer_color() (default: normal, \"\\033[0m\") that output\nshould have at the terminal."},{"title":"NO_COLOR","page":"Environment Variables","location":"manual/environment-variables.html#NO_COLOR","category":"section","text":"When this variable is present and not an empty string (regardless of its value) then colored\ntext will be disabled on the REPL. Can be overridden with the flag --color=yes or with the\nenvironment variable FORCE_COLOR. This environment variable is\ncommonly recognized by command-line applications."},{"title":"FORCE_COLOR","page":"Environment Variables","location":"manual/environment-variables.html#FORCE_COLOR","category":"section","text":"When this variable is present and not an empty string (regardless of its value) then\ncolored text will be enabled on the REPL. Can be overridden with the flag --color=no. This\nenvironment variable is commonly recognized by command-line applications."},{"title":"System and Package Image Building","page":"Environment Variables","location":"manual/environment-variables.html#System-and-Package-Image-Building","category":"section","text":""},{"title":"JULIA_CPU_TARGET","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_CPU_TARGET","category":"section","text":"Modify the target machine architecture for (pre)compiling\nsystem and package images.\nJULIA_CPU_TARGET only affects machine code image generation being output to a disk cache.\nUnlike the --cpu-target, or -C, command line option, it does not influence\njust-in-time (JIT) code generation within a Julia session where machine code is only\nstored in memory.\n\nValid values for JULIA_CPU_TARGET can be obtained by executing julia -C help.\n\nTo get the CPU target string that was used to build the current system image,\nuse Sys.sysimage_target(). This can be useful for reproducing\nthe same system image or understanding what CPU features were enabled during compilation.\n\nSetting JULIA_CPU_TARGET is important for heterogeneous compute systems where processors of\ndistinct types or features may be present. This is commonly encountered in high performance\ncomputing (HPC) clusters since the component nodes may be using distinct processors. In this case,\nyou may want to use the sysimage CPU target to maintain the same configuration as the sysimage.\nSee below for more details.\n\nThe CPU target string is a list of strings separated by ; each string starts with a CPU\nor architecture name and followed by an optional list of features separated by ,.\nA generic or empty CPU name means the basic required feature set of the target ISA\nwhich is at least the architecture the C/C++ runtime is compiled with. Each string\nis interpreted by LLVM.\n\nnote: Note\nPackage images can only target the same or more specific CPU features than\ntheir base system image.\n\nA few special features are supported:\n\nsysimage\nA special keyword that can be used as a CPU target name, which will be replaced\n  with the CPU target string that was used to build the current system image. This allows\n  you to specify CPU targets that build upon or extend the current sysimage's target, which\n  is particularly helpful for creating package images that are as flexible as the sysimage.\nclone_all\nThis forces the target to have all functions in sysimg cloned.\n  When used in negative form (i.e. -clone_all), this disables full clone that's\n  enabled by default for certain targets.\nbase([0-9]*)\nThis specifies the (0-based) base target index. The base target is the target\n  that the current target is based on, i.e. the functions that are not being cloned\n  will use the version in the base target. This option causes the base target to be\n  fully cloned (as if clone_all is specified for it) if it is not the default target (0).\n  The index can only be smaller than the current index.\nopt_size\nOptimize for size with minimum performance impact. Clang/GCC's -Os.\nmin_size\nOptimize only for size. Clang's -Oz."},{"title":"Debugging and profiling","page":"Environment Variables","location":"manual/environment-variables.html#Debugging-and-profiling","category":"section","text":""},{"title":"JULIA_DEBUG","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_DEBUG","category":"section","text":"Enable debug logging for a file or module, see Logging for more information."},{"title":"CI Debug Environment Variables","page":"Environment Variables","location":"manual/environment-variables.html#CI-Debug-Environment-Variables","category":"section","text":"Julia automatically enables verbose debugging options when certain continuous integration (CI) debug environment variables are set. This improves the debugging experience when CI jobs are re-run with debug logging enabled, by automatically:\n\nEnabling --trace-eval (location mode) to show expressions being evaluated\nSetting JULIA_TEST_VERBOSE=true to enable verbose test output\n\nThis allows developers to get detailed debugging information from CI runs without modifying their scripts or workflow files."},{"title":"JULIA_PROFILE_PEEK_HEAP_SNAPSHOT","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_PROFILE_PEEK_HEAP_SNAPSHOT","category":"section","text":"Enable collecting of a heap snapshot during execution via the profiling peek mechanism.\nSee Triggered During Execution."},{"title":"JULIA_TIMING_SUBSYSTEMS","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_TIMING_SUBSYSTEMS","category":"section","text":"Allows you to enable or disable zones for a specific Julia run.\nFor instance, setting the variable to +GC,-INFERENCE will enable the GC zones and disable\nthe INFERENCE zones. See Dynamically Enabling and Disabling Zones."},{"title":"JULIA_GC_WAIT_FOR_DEBUGGER","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_GC_WAIT_FOR_DEBUGGER","category":"section","text":"If set to anything besides 0, then the Julia garbage collector will wait for\na debugger to attach instead of aborting whenever there's a critical error.\n\nnote: Note\nThis environment variable only has an effect if Julia was compiled with\ngarbage-collection debugging (that is, if WITH_GC_DEBUG_ENV is set to 1\nin the build configuration)."},{"title":"ENABLE_JITPROFILING","page":"Environment Variables","location":"manual/environment-variables.html#ENABLE_JITPROFILING","category":"section","text":"If set to anything besides 0, then the compiler will create and register an\nevent listener for just-in-time (JIT) profiling.\n\nnote: Note\nThis environment variable only has an effect if Julia was compiled with JIT\nprofiling support, using eitherIntel's VTune™ Amplifier\n(USE_INTEL_JITEVENTS set to 1 in the build configuration), or\nOProfile (USE_OPROFILE_JITEVENTS set to 1\nin the build configuration).\nPerf (USE_PERF_JITEVENTS set to 1\nin the build configuration). This integration is enabled by default."},{"title":"ENABLE_GDBLISTENER","page":"Environment Variables","location":"manual/environment-variables.html#ENABLE_GDBLISTENER","category":"section","text":"If set to anything besides 0 enables GDB registration of Julia code on release builds.\nOn debug builds of Julia this is always enabled. Recommended to use with -g 2."},{"title":"JULIA_LLVM_ARGS","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_LLVM_ARGS","category":"section","text":"Arguments to be passed to the LLVM backend."},{"title":"JULIA_FALLBACK_REPL","page":"Environment Variables","location":"manual/environment-variables.html#JULIA_FALLBACK_REPL","category":"section","text":"Forces the fallback repl instead of REPL.jl."},{"title":"Writing tests","page":"Writing tests","location":"devdocs/contributing/tests.html#Writing-tests","category":"section","text":"There are never enough tests. Track code coverage at Codecov, and help improve it.\n\nGo visit https://codecov.io/github/JuliaLang/julia.\nBrowse through the source files and find some untested functionality (highlighted in red) that you think you might be able to write a test for.\nWrite a test that exercises this functionality—you can add your test to one of the existing files, or start a new one, whichever seems most appropriate to you. If you're adding a new test file, make sure you include it in the list of tests in test/choosetests.jl. https://docs.julialang.org/en/v1/stdlib/Test/ may be helpful in explaining how the testing infrastructure works.\nRun make test-all to rebuild Julia and run your new test(s). If you had to fix a bug or add functionality in base, this will ensure that your test passes and that you have not introduced extraneous whitespace.\nSubmit the test as a pull request (PR).\n\nCode for the buildbot configuration is maintained at: https://github.com/staticfloat/julia-buildbot\nYou can see the current buildbot setup at: https://build.julialang.org/builders\nIssue 9493 and issue 11885 have more detailed discussion on code coverage.\n\nCode coverage shows functionality that still needs \"proof of concept\" tests. These are important, as are tests for tricky edge cases, such as converting between integer types when the number to convert is near the maximum of the range of one of the integer types. Even if a function already has some coverage on Codecov, it may still benefit from tests for edge cases."},{"title":"Base.Cartesian","page":"Base.Cartesian","location":"devdocs/cartesian.html#Base.Cartesian","category":"section","text":"The (non-exported) Cartesian module provides macros that facilitate writing multidimensional algorithms.\nMost often you can write such algorithms with straightforward techniques; however, there are a few cases where Base.Cartesian is still useful or necessary."},{"title":"Principles of usage","page":"Base.Cartesian","location":"devdocs/cartesian.html#Principles-of-usage","category":"section","text":"A simple example of usage is:\n\n@nloops 3 i A begin\n    s += @nref 3 A i\nend\n\nwhich generates the following code:\n\nfor i_3 = axes(A, 3)\n    for i_2 = axes(A, 2)\n        for i_1 = axes(A, 1)\n            s += A[i_1, i_2, i_3]\n        end\n    end\nend\n\nIn general, Cartesian allows you to write generic code that contains repetitive elements, like\nthe nested loops in this example. Other applications include repeated expressions (e.g., loop\nunwinding) or creating function calls with variable numbers of arguments without using the \"splat\"\nconstruct (i...)."},{"title":"Basic syntax","page":"Base.Cartesian","location":"devdocs/cartesian.html#Basic-syntax","category":"section","text":"The (basic) syntax of @nloops is as follows:\n\nThe first argument must be an integer (not a variable) specifying the number of loops.\nThe second argument is the symbol-prefix used for the iterator variable. Here we used i, and\nvariables i_1, i_2, i_3 were generated.\nThe third argument specifies the range for each iterator variable. If you use a variable (symbol)\nhere, it's taken as axes(A, dim). More flexibly, you can use the anonymous-function expression\nsyntax described below.\nThe last argument is the body of the loop. Here, that's what appears between the begin...end.\n\nThere are some additional features of @nloops described in the reference section.\n\n@nref follows a similar pattern, generating A[i_1,i_2,i_3] from @nref 3 A i. The general\npractice is to read from left to right, which is why @nloops is @nloops 3 i A expr (as in\nfor i_2 = axes(A, 2), where i_2 is to the left and the range is to the right) whereas @nref\nis @nref 3 A i (as in A[i_1,i_2,i_3], where the array comes first).\n\nIf you're developing code with Cartesian, you may find that debugging is easier when you examine\nthe generated code, using @macroexpand:\n\njulia> @macroexpand @nref 2 A i\n:(A[i_1, i_2])"},{"title":"Supplying the number of expressions","page":"Base.Cartesian","location":"devdocs/cartesian.html#Supplying-the-number-of-expressions","category":"section","text":"The first argument to both of these macros is the number of expressions, which must be an integer.\nWhen you're writing a function that you intend to work in multiple dimensions, this may not be\nsomething you want to hard-code. The recommended approach is to use a @generated function. Here's\nan example:\n\n@generated function mysum(A::Array{T,N}) where {T,N}\n    quote\n        s = zero(T)\n        @nloops $N i A begin\n            s += @nref $N A i\n        end\n        s\n    end\nend\n\nNaturally, you can also prepare expressions or perform calculations before the quote block."},{"title":"Anonymous-function expressions as macro arguments","page":"Base.Cartesian","location":"devdocs/cartesian.html#Anonymous-function-expressions-as-macro-arguments","category":"section","text":"Perhaps the single most powerful feature in Cartesian is the ability to supply anonymous-function\nexpressions that get evaluated at parsing time. Let's consider a simple example:\n\n@nexprs 2 j->(i_j = 1)\n\n@nexprs generates n expressions that follow a pattern. This code would generate the following\nstatements:\n\ni_1 = 1\ni_2 = 1\n\nIn each generated statement, an \"isolated\" j (the variable of the anonymous function) gets replaced\nby values in the range 1:2. Generally speaking, Cartesian employs a LaTeX-like syntax. This\nallows you to do math on the index j. Here's an example computing the strides of an array:\n\ns_1 = 1\n@nexprs 3 j->(s_{j+1} = s_j * size(A, j))\n\nwould generate expressions\n\ns_1 = 1\ns_2 = s_1 * size(A, 1)\ns_3 = s_2 * size(A, 2)\ns_4 = s_3 * size(A, 3)\n\nAnonymous-function expressions have many uses in practice."},{"title":"Macro reference","page":"Base.Cartesian","location":"devdocs/cartesian.html#dev-cartesian-reference","category":"section","text":""},{"title":"Base.Cartesian.@nloops","page":"Base.Cartesian","location":"devdocs/cartesian.html#Base.Cartesian.@nloops","category":"macro","text":"@nloops N itersym rangeexpr bodyexpr\n@nloops N itersym rangeexpr preexpr bodyexpr\n@nloops N itersym rangeexpr preexpr postexpr bodyexpr\n\nGenerate N nested loops, using itersym as the prefix for the iteration variables.\nrangeexpr may be an anonymous-function expression, or a simple symbol var in which case\nthe range is axes(var, d) for dimension d.\n\nOptionally, you can provide \"pre\" and \"post\" expressions. These get executed first and last,\nrespectively, in the body of each loop. For example:\n\n@nloops 2 i A d -> j_d = min(i_d, 5) begin\n    s += @nref 2 A j\nend\n\nwould generate:\n\nfor i_2 = axes(A, 2)\n    j_2 = min(i_2, 5)\n    for i_1 = axes(A, 1)\n        j_1 = min(i_1, 5)\n        s += A[j_1, j_2]\n    end\nend\n\nIf you want just a post-expression, supply nothing for the pre-expression. Using\nparentheses and semicolons, you can supply multi-statement expressions.\n\n\n\n\n\n"},{"title":"Base.Cartesian.@nref","page":"Base.Cartesian","location":"devdocs/cartesian.html#Base.Cartesian.@nref","category":"macro","text":"@nref N A indexexpr\n\nGenerate expressions like A[i_1, i_2, ...]. indexexpr can either be an iteration-symbol\nprefix, or an anonymous-function expression.\n\nExamples\n\njulia> @macroexpand Base.Cartesian.@nref 3 A i\n:(A[i_1, i_2, i_3])\n\n\n\n\n\n"},{"title":"Base.Cartesian.@nextract","page":"Base.Cartesian","location":"devdocs/cartesian.html#Base.Cartesian.@nextract","category":"macro","text":"@nextract N esym isym\n\nGenerate N variables esym_1, esym_2, ..., esym_N to extract values from isym.\nisym can be either a Symbol or anonymous-function expression.\n\n@nextract 2 x y would generate\n\nx_1 = y[1]\nx_2 = y[2]\n\nwhile @nextract 3 x d->y[2d-1] yields\n\nx_1 = y[1]\nx_2 = y[3]\nx_3 = y[5]\n\n\n\n\n\n"},{"title":"Base.Cartesian.@nexprs","page":"Base.Cartesian","location":"devdocs/cartesian.html#Base.Cartesian.@nexprs","category":"macro","text":"@nexprs N expr\n\nGenerate N expressions. expr should be an anonymous-function expression.\n\nExamples\n\njulia> @macroexpand Base.Cartesian.@nexprs 4 i -> y[i] = A[i+j]\nquote\n    y[1] = A[1 + j]\n    y[2] = A[2 + j]\n    y[3] = A[3 + j]\n    y[4] = A[4 + j]\nend\n\n\n\n\n\n"},{"title":"Base.Cartesian.@ncall","page":"Base.Cartesian","location":"devdocs/cartesian.html#Base.Cartesian.@ncall","category":"macro","text":"@ncall N f sym...\n\nGenerate a function call expression. sym represents any number of function arguments, the\nlast of which may be an anonymous-function expression and is expanded into N arguments.\n\nFor example, @ncall 3 func a generates\n\nfunc(a_1, a_2, a_3)\n\nwhile @ncall 2 func a b i->c[i] yields\n\nfunc(a, b, c[1], c[2])\n\n\n\n\n\n"},{"title":"Base.Cartesian.@ncallkw","page":"Base.Cartesian","location":"devdocs/cartesian.html#Base.Cartesian.@ncallkw","category":"macro","text":"@ncallkw N f kw sym...\n\nGenerate a function call expression with keyword arguments kw.... As\nin the case of @ncall, sym represents any number of function arguments, the\nlast of which may be an anonymous-function expression and is expanded into N arguments.\n\nExamples\n\njulia> using Base.Cartesian\n\njulia> f(x...; a, b = 1, c = 2, d = 3) = +(x..., a, b, c, d);\n\njulia> x_1, x_2 = (-1, -2); b = 0; kw = (c = 0, d = 0);\n\njulia> @ncallkw 2 f (; a = 0, b, kw...) x\n-3\n\n\n\n\n\n\n"},{"title":"Base.Cartesian.@ntuple","page":"Base.Cartesian","location":"devdocs/cartesian.html#Base.Cartesian.@ntuple","category":"macro","text":"@ntuple N expr\n\nGenerates an N-tuple. @ntuple 2 i would generate (i_1, i_2), and @ntuple 2 k->k+1\nwould generate (2,3).\n\n\n\n\n\n"},{"title":"Base.Cartesian.@nall","page":"Base.Cartesian","location":"devdocs/cartesian.html#Base.Cartesian.@nall","category":"macro","text":"@nall N expr\n\nCheck whether all of the expressions generated by the anonymous-function expression expr\nevaluate to true.\n\n@nall 3 d->(i_d > 1) would generate the expression (i_1 > 1 && i_2 > 1 && i_3 > 1). This\ncan be convenient for bounds-checking.\n\n\n\n\n\n"},{"title":"Base.Cartesian.@nany","page":"Base.Cartesian","location":"devdocs/cartesian.html#Base.Cartesian.@nany","category":"macro","text":"@nany N expr\n\nCheck whether any of the expressions generated by the anonymous-function expression expr\nevaluate to true.\n\n@nany 3 d->(i_d > 1) would generate the expression (i_1 > 1 || i_2 > 1 || i_3 > 1).\n\n\n\n\n\n"},{"title":"Base.Cartesian.@nif","page":"Base.Cartesian","location":"devdocs/cartesian.html#Base.Cartesian.@nif","category":"macro","text":"@nif N conditionexpr expr\n@nif N conditionexpr expr elseexpr\n\nGenerates a sequence of if ... elseif ... else ... end statements. For example:\n\n@nif 3 d->(i_d >= size(A,d)) d->(error(\"Dimension \", d, \" too big\")) d->println(\"All OK\")\n\nwould generate:\n\nif i_1 > size(A, 1)\n    error(\"Dimension \", 1, \" too big\")\nelseif i_2 > size(A, 2)\n    error(\"Dimension \", 2, \" too big\")\nelse\n    println(\"All OK\")\nend\n\n\n\n\n\n"},{"title":"Pkg","page":"Pkg","location":"stdlib/Pkg.html#Pkg","category":"section","text":"Pkg is Julia's built-in package manager, and handles operations\nsuch as installing, updating and removing packages.\n\nnote: Note\nWhat follows is a very brief introduction to Pkg. For more\ninformation on Project.toml files, Manifest.toml files, package\nversion compatibility ([compat]), environments, registries, etc.,\nit is highly recommended to read the full manual, which is available here:\nhttps://pkgdocs.julialang.org.\n\nimport Markdown\nfile = joinpath(Sys.STDLIB, \"Pkg\", \"docs\", \"src\", \"getting-started.md\")\nstr = read(file, String)\nstr = replace(str, r\"^#.*$\"m => \"\")\nstr = replace(str, \"[API Reference](@ref)\" => \"[API Reference](https://pkgdocs.julialang.org/v1/api/)\")\nstr = replace(str, \"(@ref Working-with-Environments)\" => \"(https://pkgdocs.julialang.org/v1/environments/)\")\nstr = replace(str, \"(@ref Managing-Packages)\" => \"(https://pkgdocs.julialang.org/v1/managing-packages/)\")\nMarkdown.parse(str)"},{"title":"Using AI agents to work on Julia","page":"Using AI agents to work on Julia","location":"devdocs/contributing/aiagents.html#Using-AI-agents-to-work-on-Julia","category":"section","text":"![WARNING]\nYou are responsible for the code you submit in PRs. Do not submit PRs\ncontaining AI-generated code that you do not understand or that does not\nmeet the ordinary quality bar for PRs to julia.\n\nThis page documents best practices for setting up AI agents to work with Julia.\nIf you find additional prompt instructions that work well for common tasks,\nconsider submitting a PR to add these to AGENTS.md."},{"title":"Google Jules","page":"Using AI agents to work on Julia","location":"devdocs/contributing/aiagents.html#Google-Jules","category":"section","text":"Use the following for your Initial Setup configuration.\n\ncurl -fsSL https://install.julialang.org | sh -s -- -y --default-channel nightly\n. /home/swebot/.profile\n\nJules has access to the internet, so you can give it links to issues or additional\ndocumentation in your prompting."},{"title":"OpenAI Codex","page":"Using AI agents to work on Julia","location":"devdocs/contributing/aiagents.html#OpenAI-Codex","category":"section","text":"Configure the following:\n\nSetup Script\n\napt update\napt install less\ncurl -fsSL https://install.julialang.org | sh -s -- -y --default-channel nightly\nsource /root/.bashrc\nmake -C /workspace/julia/doc alldeps JULIA_EXECUTABLE=\"/root/.juliaup/bin/julia\"\nmake -C /workspace/julia/test install-revise-deps JULIA_EXECUTABLE=\"/root/.juliaup/bin/julia\"\n\nEnvironment Variables\n\nJULIA_PKG_OFFLINE=true\n\nCodex does not have internet access after initial setup, so you cannot give it\nadditional information as links - you will need to copy any relevant text into\nthe prompt.\n\nNote that Codex rebuilds the environment after every invocation. This can\nadd significant latency. Codex work best for well-defined tasks that can\nbe solved in a single shot."},{"title":"SIMD Support","page":"SIMD Support","location":"base/simd-types.html#SIMD-Support","category":"section","text":"Type VecElement{T} is intended for building libraries of SIMD operations. Practical use of it\nrequires using llvmcall. The type is defined as:\n\nstruct VecElement{T}\n    value::T\nend\n\nIt has a special compilation rule: a homogeneous tuple of VecElement{T} maps to an LLVM vector\ntype when T is a primitive bits type.\n\nAt -O3, the compiler might automatically vectorize operations on such tuples. For example,\nthe following program, when compiled with julia -O3 generates two SIMD addition instructions\n(addps) on x86 systems:\n\nconst m128 = NTuple{4,VecElement{Float32}}\n\nfunction add(a::m128, b::m128)\n    (VecElement(a[1].value+b[1].value),\n     VecElement(a[2].value+b[2].value),\n     VecElement(a[3].value+b[3].value),\n     VecElement(a[4].value+b[4].value))\nend\n\ntriple(c::m128) = add(add(c,c),c)\n\ncode_native(triple,(m128,))\n\nHowever, since the automatic vectorization cannot be relied upon, future use will mostly be via\nlibraries that use llvmcall."},{"title":"Julia Syntax Highlighting","page":"Julia Syntax Highlighting","location":"stdlib/JuliaSyntaxHighlighting.html#Julia-Syntax-Highlighting","category":"section","text":"The JuliaSyntaxHighlighting library serves as a small convenience package to\nsyntax highlight Julia code using JuliaSyntax and StyledStrings.\n\nIt is intended for use across the standard library, and the wider ecosystem."},{"title":"Functions","page":"Julia Syntax Highlighting","location":"stdlib/JuliaSyntaxHighlighting.html#stdlib-jsh-api","category":"section","text":""},{"title":"Faces","page":"Julia Syntax Highlighting","location":"stdlib/JuliaSyntaxHighlighting.html#stdlib-jsh-faces","category":"section","text":"The highlight/highlight! methods work by applying custom faces to Julia\ncode. As part of the standard library, these faces use privileged face names, of\nthe form julia_*. These can be re-used in other packages, and customised with\nfaces.toml configuration.\n\nwarning: Unstable faces\nThe particular faces used by JuliaSyntaxHighlighting are liable to change\nwithout warning in point releases. As the syntax highlighting rules are refined\nover time, changes should become less and less frequent though.\n\nThe current set of faces, and their default values are as follows:\n\njulia_macro: magenta\njulia_symbol: magenta\njulia_singleton_identifier: inherits from julia_symbol\njulia_type: yellow\njulia_typedec: bright blue\njulia_comment: grey\njulia_string: green\njulia_regex: inherits from julia_string\njulia_backslash_literal: magenta, inherits from julia_string\njulia_string_delim: bright green\njulia_cmdstring: inherits from julia_string\njulia_char: inherits from julia_string\njulia_char_delim: inherits from julia_string_delim\njulia_number: bright magenta\njulia_bool: inherits from julia_number\njulia_funcall: cyan\njulia_funcdef: cyan\njulia_broadcast: bright blue, bold\njulia_builtin: bright blue\njulia_operator: blue\njulia_comparator: inherits from julia_operator\njulia_assignment: bright red\njulia_keyword: red\njulia_parentheses: unstyled\njulia_unpaired_parentheses: inherit from julia_error and julia_parentheses\njulia_error: red background\njulia_rainbow_paren_1: bright green, inherits from julia_parentheses\njulia_rainbow_paren_2: bright blue, inherits from julia_parentheses\njulia_rainbow_paren_3: bright red, inherits from julia_parentheses\njulia_rainbow_paren_4: inherits from julia_rainbow_paren_1\njulia_rainbow_paren_5: inherits from julia_rainbow_paren_2\njulia_rainbow_paren_6: inherits from julia_rainbow_paren_3\njulia_rainbow_bracket_1: blue, inherits from julia_parentheses\njulia_rainbow_bracket_2: brightmagenta, inherits from `juliaparentheses`\njulia_rainbow_bracket_3: inherits from julia_rainbow_bracket_1\njulia_rainbow_bracket_4: inherits from julia_rainbow_bracket_2\njulia_rainbow_bracket_5: inherits from julia_rainbow_bracket_1\njulia_rainbow_bracket_6: inherits from julia_rainbow_bracket_2\njulia_rainbow_curly_1: bright yellow, inherits from julia_parentheses\njulia_rainbow_curly_2: yellow, inherits from julia_parentheses\njulia_rainbow_curly_3: inherits from julia_rainbow_curly_1\njulia_rainbow_curly_4: inherits from julia_rainbow_curly_2\njulia_rainbow_curly_5: inherits from julia_rainbow_curly_1\njulia_rainbow_curly_6: inherits from julia_rainbow_curly_2"},{"title":"JuliaSyntaxHighlighting.highlight","page":"Julia Syntax Highlighting","location":"stdlib/JuliaSyntaxHighlighting.html#JuliaSyntaxHighlighting.highlight","category":"function","text":"highlight(content::Union{AbstractString, IO},\n          ast::JuliaSyntax.GreenNode = <parsed content>;\n          syntax_errors::Bool = false) -> AnnotatedString{String}\n\nApply syntax highlighting to content using JuliaSyntax.\n\nBy default, JuliaSyntax.parseall is used to generate to ast with the\nignore_errors keyword argument set to true. Alternatively, one may provide a\npre-generated ast.\n\nWhen syntax_errors is set, the julia_error face is applied to detected syntax errors.\n\nwarning: Warning\nNote that the particular faces used by JuliaSyntax, and the way they\nare applied, is subject to change.\n\nExamples\n\njulia> JuliaSyntaxHighlighting.highlight(\"sum(1:8)\")\n\"sum(1:8)\"\n\njulia> JuliaSyntaxHighlighting.highlight(\"sum(1:8)\") |> Base.annotations\n6-element Vector{@NamedTuple{region::UnitRange{Int64}, label::Symbol, value}}:\n @NamedTuple{region::UnitRange{Int64}, label::Symbol, value}((1:3, :face, :julia_funcall))\n @NamedTuple{region::UnitRange{Int64}, label::Symbol, value}((4:4, :face, :julia_rainbow_paren_1))\n @NamedTuple{region::UnitRange{Int64}, label::Symbol, value}((5:5, :face, :julia_number))\n @NamedTuple{region::UnitRange{Int64}, label::Symbol, value}((6:6, :face, :julia_operator))\n @NamedTuple{region::UnitRange{Int64}, label::Symbol, value}((7:7, :face, :julia_number))\n @NamedTuple{region::UnitRange{Int64}, label::Symbol, value}((8:8, :face, :julia_rainbow_paren_1))\n\n\n\n\n\n"},{"title":"JuliaSyntaxHighlighting.highlight!","page":"Julia Syntax Highlighting","location":"stdlib/JuliaSyntaxHighlighting.html#JuliaSyntaxHighlighting.highlight!","category":"function","text":"highlight!(content::Union{AnnotatedString, SubString{AnnotatedString}},\n           ast::JuliaSyntax.GreenNode = <parsed content>;\n           syntax_errors::Bool = false) -> content\n\nModify content by applying syntax highlighting using JuliaSyntax.\n\nBy default, JuliaSyntax.parseall is used to generate to ast with the\nignore_errors keyword argument set to true. Alternatively, one may provide a\npre-generated ast.\n\nWhen syntax_errors is set, the julia_error face is applied to detected syntax errors.\n\nwarning: Warning\nNote that the particular faces used by JuliaSyntax, and the way they\nare applied, is subject to change.\n\nExamples\n\njulia> str = Base.AnnotatedString(\"sum(1:8)\")\n\"sum(1:8)\"\n\njulia> JuliaSyntaxHighlighting.highlight!(str)\n\"sum(1:8)\"\n\njulia> Base.annotations(str)\n6-element Vector{@NamedTuple{region::UnitRange{Int64}, label::Symbol, value}}:\n @NamedTuple{region::UnitRange{Int64}, label::Symbol, value}((1:3, :face, :julia_funcall))\n @NamedTuple{region::UnitRange{Int64}, label::Symbol, value}((4:4, :face, :julia_rainbow_paren_1))\n @NamedTuple{region::UnitRange{Int64}, label::Symbol, value}((5:5, :face, :julia_number))\n @NamedTuple{region::UnitRange{Int64}, label::Symbol, value}((6:6, :face, :julia_operator))\n @NamedTuple{region::UnitRange{Int64}, label::Symbol, value}((7:7, :face, :julia_number))\n @NamedTuple{region::UnitRange{Int64}, label::Symbol, value}((8:8, :face, :julia_rainbow_paren_1))\n\n\n\n\n\n"},{"title":"Tasks","page":"Tasks","location":"base/parallel.html#Tasks","category":"section","text":""},{"title":"Scheduling","page":"Tasks","location":"base/parallel.html#Scheduling","category":"section","text":""},{"title":"Synchronization","page":"Tasks","location":"base/parallel.html#lib-task-sync","category":"section","text":""},{"title":"Channels","page":"Tasks","location":"base/parallel.html#Channels","category":"section","text":""},{"title":"Low-level synchronization using schedule and wait","page":"Tasks","location":"base/parallel.html#low-level-schedule-wait","category":"section","text":"The easiest correct use of schedule is on a Task that is not started (scheduled)\nyet. However, it is possible to use schedule and wait as a very\nlow-level building block for constructing synchronization interfaces. A crucial\npre-condition of calling schedule(task) is that the caller must \"own\" the task; i.e., it\nmust know that the call to wait in the given task is happening at the locations known to\nthe code calling schedule(task). One strategy for ensuring such pre-condition is to use\natomics, as demonstrated in the following example:\n\n@enum OWEState begin\n    OWE_EMPTY\n    OWE_WAITING\n    OWE_NOTIFYING\nend\n\nmutable struct OneWayEvent\n    @atomic state::OWEState\n    task::Task\n    OneWayEvent() = new(OWE_EMPTY)\nend\n\nfunction Base.notify(ev::OneWayEvent)\n    state = @atomic ev.state\n    while state !== OWE_NOTIFYING\n        # Spin until we successfully update the state to OWE_NOTIFYING:\n        state, ok = @atomicreplace(ev.state, state => OWE_NOTIFYING)\n        if ok\n            if state == OWE_WAITING\n                # OWE_WAITING -> OWE_NOTIFYING transition means that the waiter task is\n                # already waiting or about to call `wait`. The notifier task must wake up\n                # the waiter task.\n                schedule(ev.task)\n            else\n                @assert state == OWE_EMPTY\n                # Since we are assuming that there is only one notifier task (for\n                # simplicity), we know that the other possible case here is OWE_EMPTY.\n                # We do not need to do anything because we know that the waiter task has\n                # not called `wait(ev::OneWayEvent)` yet.\n            end\n            break\n        end\n    end\n    return\nend\n\nfunction Base.wait(ev::OneWayEvent)\n    ev.task = current_task()\n    state, ok = @atomicreplace(ev.state, OWE_EMPTY => OWE_WAITING)\n    if ok\n        # OWE_EMPTY -> OWE_WAITING transition means that the notifier task is guaranteed to\n        # invoke OWE_WAITING -> OWE_NOTIFYING transition. The waiter task must call\n        # `wait()` immediately. In particular, it MUST NOT invoke any function that may\n        # yield to the scheduler at this point in code.\n        wait()\n    else\n        @assert state == OWE_NOTIFYING\n        # Otherwise, the `state` must have already been moved to OWE_NOTIFYING by the\n        # notifier task.\n    end\n    return\nend\n\nev = OneWayEvent()\n@sync begin\n    Threads.@spawn begin\n        wait(ev)\n        println(\"done\")\n    end\n    println(\"notifying...\")\n    notify(ev)\nend\n\n# output\nnotifying...\ndone\n\nOneWayEvent lets one task to wait for another task's notify. It is a limited\ncommunication interface since wait can only be used once from a single task (note the\nnon-atomic assignment of ev.task)\n\nIn this example, notify(ev::OneWayEvent) is allowed to call schedule(ev.task) if and\nonly if it modifies the state from OWE_WAITING to OWE_NOTIFYING. This lets us know that\nthe task executing wait(ev::OneWayEvent) is now in the ok branch and that there cannot be\nother tasks that try to schedule(ev.task) since their\n@atomicreplace(ev.state, state => OWE_NOTIFYING) will fail."},{"title":"Core.Task","page":"Tasks","location":"base/parallel.html#Core.Task","category":"type","text":"Task(func[, reserved_stack::Int])\n\nCreate a Task (i.e. coroutine) to execute the given function func (which\nmust be callable with no arguments). The task exits when this function returns.\nThe task will run in the \"world age\" from the parent at construction when scheduled.\n\nThe optional reserved_stack argument specifies the size of the stack available\nfor this task, in bytes. The default, 0, uses the system-dependent stack size default.\n\nwarning: Warning\nBy default tasks will have the sticky bit set to true t.sticky. This models the\nhistoric default for @async. Sticky tasks can only be run on the worker thread\nthey are first scheduled on, and when scheduled will make the task that they were scheduled\nfrom sticky. To obtain the behavior of Threads.@spawn set the sticky\nbit manually to false.\n\nExamples\n\njulia> a() = sum(i for i in 1:1000);\n\njulia> b = Task(a);\n\nIn this example, b is a runnable Task that hasn't started yet.\n\n\n\n\n\n"},{"title":"Base.@task","page":"Tasks","location":"base/parallel.html#Base.@task","category":"macro","text":"@task\n\nWrap an expression in a Task without executing it, and return the Task. This only\ncreates a task, and does not run it.\n\nwarning: Warning\nBy default tasks will have the sticky bit set to true t.sticky. This models the\nhistoric default for @async. Sticky tasks can only be run on the worker thread\nthey are first scheduled on, and when scheduled will make the task that they were scheduled\nfrom sticky. To obtain the behavior of Threads.@spawn set the sticky\nbit manually to false.\n\nExamples\n\njulia> a1() = sum(i for i in 1:1000);\n\njulia> b = @task a1();\n\njulia> istaskstarted(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskdone(b)\ntrue\n\n\n\n\n\n"},{"title":"Base.@async","page":"Tasks","location":"base/parallel.html#Base.@async","category":"macro","text":"@async\n\nWrap an expression in a Task and add it to the local machine's scheduler queue.\n\nValues can be interpolated into @async via $, which copies the value directly into the\nconstructed underlying closure. This allows you to insert the value of a variable,\nisolating the asynchronous code from changes to the variable's value in the current task.\n\nwarning: Warning\nIt is strongly encouraged to favor Threads.@spawn over @async always even when no\nparallelism is required especially in publicly distributed libraries.  This is\nbecause a use of @async disables the migration of the parent task across worker\nthreads in the current implementation of Julia.  Thus, seemingly innocent use of\n@async in a library function can have a large impact on the performance of very\ndifferent parts of user applications.\n\ncompat: Julia 1.4\nInterpolating values via $ is available as of Julia 1.4.\n\n\n\n\n\n"},{"title":"Base.asyncmap","page":"Tasks","location":"base/parallel.html#Base.asyncmap","category":"function","text":"asyncmap(f, c...; ntasks=0, batch_size=nothing)\n\nUses multiple concurrent tasks to map f over a collection (or multiple\nequal length collections). For multiple collection arguments, f is\napplied elementwise.\n\nThe output is guaranteed to be the same order as the elements of the collection(s) c.\n\nntasks specifies the number of tasks to run concurrently.\nDepending on the length of the collections, if ntasks is unspecified,\nup to 100 tasks will be used for concurrent mapping.\n\nntasks can also be specified as a zero-arg function. In this case, the\nnumber of tasks to run in parallel is checked before processing every element and a new\ntask started if the value of ntasks_func is greater than the current number\nof tasks.\n\nIf batch_size is specified, the collection is processed in batch mode. f must\nthen be a function that must accept a Vector of argument tuples and must\nreturn a vector of results. The input vector will have a length of batch_size or less.\n\nThe following examples highlight execution in different tasks by returning\nthe objectid of the tasks in which the mapping function is executed.\n\nFirst, with ntasks undefined, each element is processed in a different task.\n\njulia> tskoid() = objectid(current_task());\n\njulia> asyncmap(x->tskoid(), 1:5)\n5-element Vector{UInt64}:\n 0x6e15e66c75c75853\n 0x440f8819a1baa682\n 0x9fb3eeadd0c83985\n 0xebd3e35fe90d4050\n 0x29efc93edce2b961\n\njulia> length(unique(asyncmap(x->tskoid(), 1:5)))\n5\n\nWith ntasks=2 all elements are processed in 2 tasks.\n\njulia> asyncmap(x->tskoid(), 1:5; ntasks=2)\n5-element Vector{UInt64}:\n 0x027ab1680df7ae94\n 0xa23d2f80cd7cf157\n 0x027ab1680df7ae94\n 0xa23d2f80cd7cf157\n 0x027ab1680df7ae94\n\njulia> length(unique(asyncmap(x->tskoid(), 1:5; ntasks=2)))\n2\n\nWith batch_size defined, the mapping function needs to be changed to accept an array\nof argument tuples and return an array of results. map is used in the modified mapping\nfunction to achieve this.\n\njulia> batch_func(input) = map(x->string(\"args_tuple: \", x, \", element_val: \", x[1], \", task: \", tskoid()), input)\nbatch_func (generic function with 1 method)\n\njulia> asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)\n5-element Vector{String}:\n \"args_tuple: (1,), element_val: 1, task: 9118321258196414413\"\n \"args_tuple: (2,), element_val: 2, task: 4904288162898683522\"\n \"args_tuple: (3,), element_val: 3, task: 9118321258196414413\"\n \"args_tuple: (4,), element_val: 4, task: 4904288162898683522\"\n \"args_tuple: (5,), element_val: 5, task: 9118321258196414413\"\n\n\n\n\n\n"},{"title":"Base.asyncmap!","page":"Tasks","location":"base/parallel.html#Base.asyncmap!","category":"function","text":"asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)\n\nLike asyncmap, but stores output in results rather than\nreturning a collection.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\n\n\n\n\n"},{"title":"Base.current_task","page":"Tasks","location":"base/parallel.html#Base.current_task","category":"function","text":"current_task()\n\nGet the currently running Task.\n\n\n\n\n\n"},{"title":"Base.istaskdone","page":"Tasks","location":"base/parallel.html#Base.istaskdone","category":"function","text":"istaskdone(t::Task)::Bool\n\nDetermine whether a task has exited.\n\nExamples\n\njulia> a2() = sum(i for i in 1:1000);\n\njulia> b = Task(a2);\n\njulia> istaskdone(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskdone(b)\ntrue\n\n\n\n\n\n"},{"title":"Base.istaskstarted","page":"Tasks","location":"base/parallel.html#Base.istaskstarted","category":"function","text":"istaskstarted(t::Task)::Bool\n\nDetermine whether a task has started executing.\n\nExamples\n\njulia> a3() = sum(i for i in 1:1000);\n\njulia> b = Task(a3);\n\njulia> istaskstarted(b)\nfalse\n\n\n\n\n\n"},{"title":"Base.istaskfailed","page":"Tasks","location":"base/parallel.html#Base.istaskfailed","category":"function","text":"istaskfailed(t::Task)::Bool\n\nDetermine whether a task has exited because an exception was thrown.\n\nExamples\n\njulia> a4() = error(\"task failed\");\n\njulia> b = Task(a4);\n\njulia> istaskfailed(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskfailed(b)\ntrue\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n"},{"title":"Base.task_local_storage","page":"Tasks","location":"base/parallel.html#Base.task_local_storage-Tuple{Any}","category":"method","text":"task_local_storage(key)\n\nLook up the value of a key in the current task's task-local storage.\n\n\n\n\n\n"},{"title":"Base.task_local_storage","page":"Tasks","location":"base/parallel.html#Base.task_local_storage-Tuple{Any, Any}","category":"method","text":"task_local_storage(key, value)\n\nAssign a value to a key in the current task's task-local storage.\n\n\n\n\n\n"},{"title":"Base.task_local_storage","page":"Tasks","location":"base/parallel.html#Base.task_local_storage-Tuple{Function, Any, Any}","category":"method","text":"task_local_storage(body, key, value)\n\nCall the function body with a modified task-local storage, in which value is assigned to\nkey; the previous value of key, or lack thereof, is restored afterwards. Useful\nfor emulating dynamic scoping.\n\n\n\n\n\n"},{"title":"Core.ConcurrencyViolationError","page":"Tasks","location":"base/parallel.html#Core.ConcurrencyViolationError","category":"type","text":"ConcurrencyViolationError(msg) <: Exception\n\nAn error thrown when a detectable violation of concurrent semantics has occurred.\n\nA non-exhaustive list of examples of when this is used include:\n\nThrowing when a deadlock has been detected (e.g. wait(current_task()))\nKnown-unsafe behavior is attempted (e.g. yield(current_task))\nA known non-threadsafe datastructure is attempted to be modified from multiple concurrent tasks\nA lock is being unlocked that wasn't locked by this task\n\n\n\n\n\n"},{"title":"Base.yield","page":"Tasks","location":"base/parallel.html#Base.yield","category":"function","text":"yield(t::Task, arg = nothing)\n\nA fast, unfair-scheduling version of schedule(t, arg); yield() which\nimmediately yields to t before calling the scheduler.\n\nThrows a ConcurrencyViolationError if t is the currently running task.\n\n\n\n\n\nyield()\n\nSwitch to the scheduler to allow another scheduled task to run. A task that calls this\nfunction is still runnable, and will be restarted immediately if there are no other runnable\ntasks.\n\n\n\n\n\n"},{"title":"Base.yieldto","page":"Tasks","location":"base/parallel.html#Base.yieldto","category":"function","text":"yieldto(t::Task, arg = nothing)\n\nSwitch to the given task. The first time a task is switched to, the task's function is\ncalled with no arguments. On subsequent switches, arg is returned from the task's last\ncall to yieldto. This is a low-level call that only switches tasks, not considering states\nor scheduling in any way. Its use is discouraged.\n\n\n\n\n\n"},{"title":"Base.sleep","page":"Tasks","location":"base/parallel.html#Base.sleep","category":"function","text":"sleep(seconds)\n\nBlock the current task for a specified number of seconds. The minimum sleep time is 1\nmillisecond or input of 0.001.\n\n\n\n\n\n"},{"title":"Base.schedule","page":"Tasks","location":"base/parallel.html#Base.schedule","category":"function","text":"schedule(t::Task, [val]; error=false)\n\nAdd a Task to the scheduler's queue. This causes the task to run constantly when the system\nis otherwise idle, unless the task performs a blocking operation such as wait.\n\nIf a second argument val is provided, it will be passed to the task (via the return value of\nyieldto) when it runs again. If error is true, the value is raised as an exception in\nthe woken task.\n\nwarning: Warning\nIt is incorrect to use schedule on an arbitrary Task that has already been started.\nSee the API reference for more information.\n\nwarning: Warning\nBy default tasks will have the sticky bit set to true t.sticky. This models the\nhistoric default for @async. Sticky tasks can only be run on the worker thread\nthey are first scheduled on, and when scheduled will make the task that they were scheduled\nfrom sticky. To obtain the behavior of Threads.@spawn set the sticky\nbit manually to false.\n\nExamples\n\njulia> a5() = sum(i for i in 1:1000);\n\njulia> b = Task(a5);\n\njulia> istaskstarted(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskstarted(b)\ntrue\n\njulia> istaskdone(b)\ntrue\n\n\n\n\n\n"},{"title":"Base.errormonitor","page":"Tasks","location":"base/parallel.html#Base.errormonitor","category":"function","text":"errormonitor(t::Task)\n\nPrint an error log to stderr if task t fails.\n\nExamples\n\njulia> wait(errormonitor(Threads.@spawn error(\"task failed\")); throw = false)\nUnhandled Task ERROR: task failed\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"Base.@sync","page":"Tasks","location":"base/parallel.html#Base.@sync","category":"macro","text":"@sync\n\nWait until all lexically-enclosed uses of @async, @spawn,\nDistributed.@spawnat and Distributed.@distributed\nare complete. All exceptions thrown by enclosed async operations are collected and thrown as\na CompositeException.\n\nExamples\n\njulia> Threads.nthreads()\n4\n\njulia> @sync begin\n           Threads.@spawn println(\"Thread-id $(Threads.threadid()), task 1\")\n           Threads.@spawn println(\"Thread-id $(Threads.threadid()), task 2\")\n       end;\nThread-id 3, task 1\nThread-id 1, task 2\n\n\n\n\n\n"},{"title":"Base.wait","page":"Tasks","location":"base/parallel.html#Base.wait","category":"function","text":"wait([x])\n\nBlock the current task until some event occurs.\n\nChannel: Wait for a value to be appended to the channel.\nCondition: Wait for notify on a condition and return the val\nparameter passed to notify. See the Condition-specific docstring of wait for\nthe exact behavior.\nProcess: Wait for a process or process chain to exit. The exitcode field of a process\ncan be used to determine success or failure.\nTask: Wait for a Task to finish. See the Task-specific docstring of wait for\nthe exact behavior.\nRawFD: Wait for changes on a file descriptor (see the FileWatching package).\n\nIf no argument is passed, the task blocks for an undefined period. A task can only be\nrestarted by an explicit call to schedule or yieldto.\n\nOften wait is called within a while loop to ensure a waited-for condition is met before\nproceeding.\n\n\n\n\n\n"},{"title":"Base.waitany","page":"Tasks","location":"base/parallel.html#Base.waitany","category":"function","text":"waitany(tasks; throw=true) -> (done_tasks, remaining_tasks)\n\nWait until at least one of the given tasks have been completed.\n\nIf throw is true, throw CompositeException when one of the\ncompleted tasks completes with an exception.\n\nThe return value consists of two task vectors. The first one consists of\ncompleted tasks, and the other consists of uncompleted tasks.\n\nwarning: Warning\nThis may scale poorly compared to writing code that uses multiple individual tasks that\neach runs serially, since this needs to scan the list of tasks each time and\nsynchronize with each one every time this is called. Or consider using\nwaitall(tasks; failfast=true) instead.\n\ncompat: Julia 1.12\nThis function requires at least Julia 1.12.\n\n\n\n\n\n"},{"title":"Base.waitall","page":"Tasks","location":"base/parallel.html#Base.waitall","category":"function","text":"waitall(tasks; failfast=true, throw=true) -> (done_tasks, remaining_tasks)\n\nWait until all the given tasks have been completed.\n\nIf failfast is true, the function will return when at least one of the\ngiven tasks is finished by exception. If throw is true, throw\nCompositeException when one of the completed tasks has failed.\n\nfailfast and throw keyword arguments work independently; when only\nthrow=true is specified, this function waits for all the tasks to complete.\n\nThe return value consists of two task vectors. The first one consists of\ncompleted tasks, and the other consists of uncompleted tasks.\n\ncompat: Julia 1.12\nThis function requires at least Julia 1.12.\n\n\n\n\n\n"},{"title":"Base.fetch","page":"Tasks","location":"base/parallel.html#Base.fetch-Tuple{Task}","category":"method","text":"fetch(t::Task)\n\nWait for a Task to finish, then return its result value.\nIf the task fails with an exception, a TaskFailedException (which wraps the failed task)\nis thrown.\n\n\n\n\n\n"},{"title":"Base.fetch","page":"Tasks","location":"base/parallel.html#Base.fetch-Tuple{Any}","category":"method","text":"fetch(x::Any)\n\nReturn x.\n\n\n\n\n\n"},{"title":"Base.timedwait","page":"Tasks","location":"base/parallel.html#Base.timedwait","category":"function","text":"timedwait(testcb, timeout::Real; pollint::Real=0.1)\n\nWait until testcb() returns true or timeout seconds have passed, whichever is earlier.\nThe test function is polled every pollint seconds. The minimum value for pollint is 0.001 seconds,\nthat is, 1 millisecond.\n\nReturn :ok or :timed_out.\n\nExamples\n\njulia> cb() = (sleep(5); return);\n\njulia> t = @async cb();\n\njulia> timedwait(()->istaskdone(t), 1)\n:timed_out\n\njulia> timedwait(()->istaskdone(t), 6.5)\n:ok\n\n\n\n\n\n"},{"title":"Base.Condition","page":"Tasks","location":"base/parallel.html#Base.Condition","category":"type","text":"Condition()\n\nCreate an edge-triggered event source that tasks can wait for. Tasks that call wait on a\nCondition are suspended and queued. Tasks are woken up when notify is later called on\nthe Condition. Waiting on a condition can return a value or raise an error if the optional arguments\nof notify are used. Edge triggering means that only tasks waiting at the time notify\nis called can be woken up. For level-triggered notifications, you must keep extra state to keep\ntrack of whether a notification has happened. The Channel and Threads.Event types do\nthis, and can be used for level-triggered events.\n\nThis object is NOT thread-safe. See Threads.Condition for a thread-safe version.\n\n\n\n\n\n"},{"title":"Base.Threads.Condition","page":"Tasks","location":"base/parallel.html#Base.Threads.Condition","category":"type","text":"Threads.Condition([lock])\n\nA thread-safe version of Base.Condition.\n\nTo call wait or notify on a Threads.Condition, you must first call\nlock on it. When wait is called, the lock is atomically released during\nblocking, and will be reacquired before wait returns. Therefore idiomatic use\nof a Threads.Condition c looks like the following:\n\nlock(c)\ntry\n    while !thing_we_are_waiting_for\n        wait(c)\n    end\nfinally\n    unlock(c)\nend\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n"},{"title":"Base.Event","page":"Tasks","location":"base/parallel.html#Base.Event","category":"type","text":"Event([autoreset=false])\n\nCreate a level-triggered event source. Tasks that call wait on an\nEvent are suspended and queued until notify is called on the Event.\nAfter notify is called, the Event remains in a signaled state and\ntasks will no longer block when waiting for it, until reset is called.\n\nIf autoreset is true, at most one task will be released from wait for\neach call to notify.\n\nThis provides an acquire & release memory ordering on notify/wait.\n\ncompat: Julia 1.1\nThis functionality requires at least Julia 1.1.\n\ncompat: Julia 1.8\nThe autoreset functionality and memory ordering guarantee requires at least Julia 1.8.\n\n\n\n\n\n"},{"title":"Base.notify","page":"Tasks","location":"base/parallel.html#Base.notify","category":"function","text":"notify(condition, val=nothing; all=true, error=false)\n\nWake up tasks waiting for a condition, passing them val. If all is true (the default),\nall waiting tasks are woken, otherwise only one is. If error is true, the passed value\nis raised as an exception in the woken tasks.\n\nReturn the count of tasks woken up. Return 0 if no tasks are waiting on condition.\n\n\n\n\n\n"},{"title":"Base.reset","page":"Tasks","location":"base/parallel.html#Base.reset-Tuple{Base.Event}","category":"method","text":"reset(::Event)\n\nReset an Event back into an un-set state. Then any future calls to wait will\nblock until notify is called again.\n\n\n\n\n\n"},{"title":"Base.Semaphore","page":"Tasks","location":"base/parallel.html#Base.Semaphore","category":"type","text":"Semaphore(sem_size)\n\nCreate a counting semaphore that allows at most sem_size\nacquires to be in use at any time.\nEach acquire must be matched with a release.\n\nThis provides a acquire & release memory ordering on acquire/release calls.\n\n\n\n\n\n"},{"title":"Base.acquire","page":"Tasks","location":"base/parallel.html#Base.acquire","category":"function","text":"acquire(f, s::Semaphore)\n\nExecute f after acquiring from Semaphore s,\nand release on completion or error.\n\nFor example, a do-block form that ensures only 2\ncalls of foo will be active at the same time:\n\ns = Base.Semaphore(2)\n@sync for _ in 1:100\n    Threads.@spawn begin\n        Base.acquire(s) do\n            foo()\n        end\n    end\nend\n\ncompat: Julia 1.8\nThis method requires at least Julia 1.8.\n\n\n\n\n\nacquire(s::Semaphore)\n\nWait for one of the sem_size permits to be available,\nblocking until one can be acquired.\n\n\n\n\n\n"},{"title":"Base.release","page":"Tasks","location":"base/parallel.html#Base.release","category":"function","text":"release(s::Semaphore)\n\nReturn one permit to the pool,\npossibly allowing another task to acquire it\nand resume execution.\n\n\n\n\n\n"},{"title":"Base.AbstractLock","page":"Tasks","location":"base/parallel.html#Base.AbstractLock","category":"type","text":"AbstractLock\n\nAbstract supertype describing types that\nimplement the synchronization primitives:\nlock, trylock, unlock, and islocked.\n\n\n\n\n\n"},{"title":"Base.lock","page":"Tasks","location":"base/parallel.html#Base.lock","category":"function","text":"lock(f::Function, l::Lockable)\n\nAcquire the lock associated with l, execute f with the lock held,\nand release the lock when f returns. f will receive one positional\nargument: the value wrapped by l. If the lock is already locked by a\ndifferent task/thread, wait for it to become available.\nWhen this function returns, the lock has been released, so the caller should\nnot attempt to unlock it.\n\ncompat: Julia 1.11\nRequires at least Julia 1.11.\n\n\n\n\n\nlock(f::Function, lock)\n\nAcquire the lock, execute f with the lock held, and release the lock when f\nreturns. If the lock is already locked by a different task/thread, wait for it to become\navailable.\n\nWhen this function returns, the lock has been released, so the caller should\nnot attempt to unlock it.\n\nSee also: @lock.\n\ncompat: Julia 1.7\nUsing a Channel as the second argument requires Julia 1.7 or later.\n\n\n\n\n\nlock(lock)\n\nAcquire the lock when it becomes available.\nIf the lock is already locked by a different task/thread,\nwait for it to become available.\n\nEach lock must be matched by an unlock.\n\n\n\n\n\n"},{"title":"Base.unlock","page":"Tasks","location":"base/parallel.html#Base.unlock","category":"function","text":"unlock(lock)\n\nReleases ownership of the lock.\n\nIf this is a recursive lock which has been acquired before, decrement an\ninternal counter and return immediately.\n\n\n\n\n\n"},{"title":"Base.trylock","page":"Tasks","location":"base/parallel.html#Base.trylock","category":"function","text":"trylock(lock) -> Success (Boolean)\n\nAcquire the lock if it is available,\nand return true if successful.\nIf the lock is already locked by a different task/thread,\nreturn false.\n\nEach successful trylock must be matched by an unlock.\n\nFunction trylock combined with islocked can be used for writing the\ntest-and-test-and-set or exponential backoff algorithms if it is supported by the\ntypeof(lock) (read its documentation).\n\n\n\n\n\n"},{"title":"Base.islocked","page":"Tasks","location":"base/parallel.html#Base.islocked","category":"function","text":"islocked(lock) -> Status (Boolean)\n\nCheck whether the lock is held by any task/thread.\nThis function alone should not be used for synchronization. However, islocked combined\nwith trylock can be used for writing the test-and-test-and-set or exponential\nbackoff algorithms if it is supported by the typeof(lock) (read its documentation).\n\nExtended help\n\nFor example, an exponential backoff can be implemented as follows if the lock\nimplementation satisfied the properties documented below.\n\nnspins = 0\nwhile true\n    while islocked(lock)\n        GC.safepoint()\n        nspins += 1\n        nspins > LIMIT && error(\"timeout\")\n    end\n    trylock(lock) && break\n    backoff()\nend\n\nImplementation\n\nA lock implementation is advised to define islocked with the following properties and note\nit in its docstring.\n\nislocked(lock) is data-race-free.\nIf islocked(lock) returns false, an immediate invocation of trylock(lock) must\nsucceed (returns true) if there is no interference from other tasks.\n\n\n\n\n\n"},{"title":"Base.ReentrantLock","page":"Tasks","location":"base/parallel.html#Base.ReentrantLock","category":"type","text":"ReentrantLock()\n\nCreate a re-entrant lock for synchronizing Tasks. The same task can\nacquire the lock as many times as required (this is what the \"Reentrant\" part\nof the name means). Each lock must be matched with an unlock.\n\nCalling lock will also inhibit running of finalizers on that thread until the\ncorresponding unlock. Use of the standard lock pattern illustrated below\nshould naturally be supported, but beware of inverting the try/lock order or\nmissing the try block entirely (e.g. attempting to return with the lock still\nheld):\n\nThis provides a acquire/release memory ordering on lock/unlock calls.\n\nlock(l)\ntry\n    <atomic work>\nfinally\n    unlock(l)\nend\n\nIf !islocked(lck::ReentrantLock) holds, trylock(lck)\nsucceeds unless there are other tasks attempting to hold the lock \"at the same time.\"\n\n\n\n\n\n"},{"title":"Base.@lock","page":"Tasks","location":"base/parallel.html#Base.@lock","category":"macro","text":"@lock l expr\n\nMacro version of lock(f, l::AbstractLock) but with expr instead of f function.\nExpands to:\n\nlock(l)\ntry\n    expr\nfinally\n    unlock(l)\nend\n\nThis is similar to using lock with a do block, but avoids creating a closure\nand thus can improve the performance.\n\ncompat: Compat\n@lock was added in Julia 1.3, and exported in Julia 1.7.\n\n\n\n\n\n"},{"title":"Base.Lockable","page":"Tasks","location":"base/parallel.html#Base.Lockable","category":"type","text":"Lockable(value, lock = ReentrantLock())\n\nCreate a Lockable object that wraps value and\nassociates it with the provided lock. This object\nsupports @lock, lock, trylock,\nunlock. To access the value, index the lockable object while\nholding the lock.\n\ncompat: Julia 1.11\nRequires at least Julia 1.11.\n\nExample\n\njulia> locked_list = Base.Lockable(Int[]);\n\njulia> @lock(locked_list, push!(locked_list[], 1)) # must hold the lock to access the value\n1-element Vector{Int64}:\n 1\n\njulia> lock(summary, locked_list)\n\"1-element Vector{Int64}\"\n\n\n\n\n\n"},{"title":"Base.AbstractChannel","page":"Tasks","location":"base/parallel.html#Base.AbstractChannel","category":"type","text":"AbstractChannel{T}\n\nRepresentation of a channel passing objects of type T.\n\n\n\n\n\n"},{"title":"Base.Channel","page":"Tasks","location":"base/parallel.html#Base.Channel","category":"type","text":"Channel{T=Any}(size::Int=0)\n\nConstruct a Channel with an internal buffer that can hold a maximum of size objects\nof type T.\nput! calls on a full channel block until an object is removed with take!.\n\nChannel(0) constructs an unbuffered channel. put! blocks until a matching take! is called.\nAnd vice-versa.\n\nOther constructors:\n\nChannel(): default constructor, equivalent to Channel{Any}(0)\nChannel(Inf): equivalent to Channel{Any}(typemax(Int))\nChannel(sz): equivalent to Channel{Any}(sz)\n\ncompat: Julia 1.3\nThe default constructor Channel() and default size=0 were added in Julia 1.3.\n\n\n\n\n\n"},{"title":"Base.Channel","page":"Tasks","location":"base/parallel.html#Base.Channel-Tuple{Function}","category":"method","text":"Channel{T=Any}(func::Function, size=0; taskref=nothing, spawn=false, threadpool=nothing)\n\nCreate a new task from func, bind it to a new channel of type\nT and size size, and schedule the task, all in a single call.\nThe channel is automatically closed when the task terminates.\n\nfunc must accept the bound channel as its only argument.\n\nIf you need a reference to the created task, pass a Ref{Task} object via\nthe keyword argument taskref.\n\nIf spawn=true, the Task created for func may be scheduled on another thread\nin parallel, equivalent to creating a task via Threads.@spawn.\n\nIf spawn=true and the threadpool argument is not set, it defaults to :default.\n\nIf the threadpool argument is set (to :default or :interactive), this implies\nthat spawn=true and the new Task is spawned to the specified threadpool.\n\nReturn a Channel.\n\nExamples\n\njulia> chnl = Channel() do ch\n           foreach(i -> put!(ch, i), 1:4)\n       end;\n\njulia> typeof(chnl)\nChannel{Any}\n\njulia> for i in chnl\n           @show i\n       end;\ni = 1\ni = 2\ni = 3\ni = 4\n\nReferencing the created task:\n\njulia> taskref = Ref{Task}();\n\njulia> chnl = Channel(taskref=taskref) do ch\n           println(take!(ch))\n       end;\n\njulia> istaskdone(taskref[])\nfalse\n\njulia> put!(chnl, \"Hello\");\nHello\n\njulia> istaskdone(taskref[])\ntrue\n\ncompat: Julia 1.3\nThe spawn= parameter was added in Julia 1.3. This constructor was added in Julia 1.3.\nIn earlier versions of Julia, Channel used keyword arguments to set size and T, but\nthose constructors are deprecated.\n\ncompat: Julia 1.9\nThe threadpool= argument was added in Julia 1.9.\n\njulia> chnl = Channel{Char}(1, spawn=true) do ch\n           for c in \"hello world\"\n               put!(ch, c)\n           end\n       end;\n\njulia> String(collect(chnl))\n\"hello world\"\n\n\n\n\n\n"},{"title":"Base.put!","page":"Tasks","location":"base/parallel.html#Base.put!-Tuple{Channel, Any}","category":"method","text":"put!(c::Channel, v)\n\nAppend an item v to the channel c. Blocks if the channel is full.\n\nFor unbuffered channels, blocks until a take! is performed by a different\ntask.\n\ncompat: Julia 1.1\nv now gets converted to the channel's type with convert as put! is called.\n\n\n\n\n\n"},{"title":"Base.take!","page":"Tasks","location":"base/parallel.html#Base.take!-Tuple{Channel}","category":"method","text":"take!(c::Channel)\n\nRemoves and returns a value from a Channel in order. Blocks until data is available.\nFor unbuffered channels, blocks until a put! is performed by a different task.\n\nExamples\n\nBuffered channel\n\njulia> c = Channel(1);\n\njulia> put!(c, 1);\n\njulia> take!(c)\n1\n\nUnbuffered channel\n\njulia> c = Channel(0);\n\njulia> task = Task(() -> put!(c, 1));\n\njulia> schedule(task);\n\njulia> take!(c)\n1\n\n\n\n\n\n"},{"title":"Base.isfull","page":"Tasks","location":"base/parallel.html#Base.isfull-Tuple{Channel}","category":"method","text":"isfull(c::Channel)\n\nDetermine if a Channel is full, in the sense\nthat calling put!(c, some_value) would have blocked.\nReturns immediately, does not block.\n\nNote that it may frequently be the case that put! will\nnot block after this returns true. Users must take\nprecautions not to accidentally create live-lock bugs\nin their code by calling this method, as these are\ngenerally harder to debug than deadlocks. It is also\npossible that put! will block after this call\nreturns false, if there are multiple producer\ntasks calling put! in parallel.\n\nExamples\n\nBuffered channel\n\njulia> c = Channel(1); # capacity = 1\n\njulia> isfull(c)\nfalse\n\njulia> put!(c, 1);\n\njulia> isfull(c)\ntrue\n\nUnbuffered channel\n\njulia> c = Channel(); # capacity = 0\n\njulia> isfull(c) # unbuffered channel is always full\ntrue\n\n\n\n\n\n"},{"title":"Base.isready","page":"Tasks","location":"base/parallel.html#Base.isready-Tuple{Channel}","category":"method","text":"isready(c::Channel)\n\nDetermine whether a Channel has a value stored in it.\nReturns immediately, does not block.\n\nFor unbuffered channels, return true if there are tasks waiting on a put!.\n\nExamples\n\nBuffered channel\n\njulia> c = Channel(1);\n\njulia> isready(c)\nfalse\n\njulia> put!(c, 1);\n\njulia> isready(c)\ntrue\n\nUnbuffered channel\n\njulia> c = Channel();\n\njulia> isready(c)  # no tasks waiting to put!\nfalse\n\njulia> task = Task(() -> put!(c, 1));\n\njulia> schedule(task);  # schedule a put! task\n\njulia> isready(c)\ntrue\n\n\n\n\n\n"},{"title":"Base.isopen","page":"Tasks","location":"base/parallel.html#Base.isopen-Tuple{Channel}","category":"method","text":"isopen(c::Channel)\n\nDetermine whether a Channel is open for new put! operations.\nNotice that a Channel can be closed and still have buffered elements which can be\nconsumed with take!.\n\nExamples\n\nBuffered channel with task\n\njulia> c = Channel(ch -> put!(ch, 1), 1);\n\njulia> isopen(c) # The channel is closed to new `put!`s\nfalse\n\njulia> isready(c) # The channel is closed but still contains elements\ntrue\n\njulia> take!(c)\n1\n\njulia> isready(c)\nfalse\n\nUnbuffered channel\n\njulia> c = Channel{Int}();\n\njulia> isopen(c)\ntrue\n\njulia> close(c)\n\njulia> isopen(c)\nfalse\n\n\n\n\n\n"},{"title":"Base.fetch","page":"Tasks","location":"base/parallel.html#Base.fetch-Tuple{Channel}","category":"method","text":"fetch(c::Channel)\n\nWaits for and returns (without removing) the first available item from the Channel.\nNote: fetch is unsupported on an unbuffered (0-size) Channel.\n\nExamples\n\nBuffered channel\n\njulia> c = Channel(3) do ch\n           foreach(i -> put!(ch, i), 1:3)\n       end;\n\njulia> fetch(c)\n1\n\njulia> collect(c)  # item is not removed\n3-element Vector{Any}:\n 1\n 2\n 3\n\n\n\n\n\n"},{"title":"Base.close","page":"Tasks","location":"base/parallel.html#Base.close-Tuple{Channel}","category":"method","text":"close(c::Channel[, excp::Exception])\n\nClose a channel. An exception (optionally given by excp), is thrown by:\n\nput! on a closed channel.\ntake! and fetch on an empty, closed channel.\n\n\n\n\n\n"},{"title":"Base.bind","page":"Tasks","location":"base/parallel.html#Base.bind-Tuple{Channel, Task}","category":"method","text":"bind(chnl::Channel, task::Task)\n\nAssociate the lifetime of chnl with a task.\nChannel chnl is automatically closed when the task terminates.\nAny uncaught exception in the task is propagated to all waiters on chnl.\n\nThe chnl object can be explicitly closed independent of task termination.\nTerminating tasks have no effect on already closed Channel objects.\n\nWhen a channel is bound to multiple tasks, the first task to terminate will\nclose the channel. When multiple channels are bound to the same task,\ntermination of the task will close all of the bound channels.\n\nExamples\n\njulia> c = Channel(0);\n\njulia> task = @async foreach(i->put!(c, i), 1:4);\n\njulia> bind(c,task);\n\njulia> for i in c\n           @show i\n       end;\ni = 1\ni = 2\ni = 3\ni = 4\n\njulia> isopen(c)\nfalse\n\njulia> c = Channel(0);\n\njulia> task = @async (put!(c, 1); error(\"foo\"));\n\njulia> bind(c, task);\n\njulia> take!(c)\n1\n\njulia> put!(c, 1);\nERROR: TaskFailedException\nStacktrace:\n[...]\n    nested task error: foo\n[...]\n\n\n\n\n\n"},{"title":"Scope of Variables","page":"Scope of Variables","location":"manual/variables-and-scoping.html#scope-of-variables","category":"section","text":"The scope of a variable is the region of code within which a variable is accessible. Variable\nscoping helps avoid variable naming conflicts. The concept is intuitive: two functions can both have\narguments called x without the two x's referring to the same thing. Similarly, there are many\nother cases where different blocks of code can use the same name without referring to the same\nthing. The rules for when the same variable name does or doesn't refer to the same thing are called\nscope rules; this section spells them out in detail.\n\nCertain constructs in the language introduce scope blocks, which are regions of code that are\neligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary\nset of source lines; instead, it will always line up with one of these blocks. There are two main\ntypes of scopes in Julia, global scope and local scope. The latter can be nested. There is also\na distinction in Julia between constructs which introduce a \"hard scope\" and those which only\nintroduce a \"soft scope\", which affects whether\nshadowing\na global variable by the same name is allowed or not.\n\ninfo: Summary\nVariables defined in global scope may be undefined in inner local scopes,\ndepending on where the code is run, in order to balance safety and convenience.\nThe hard and soft local scoping rules define the interplay between global and local variables.However, variables defined only in local scope behave consistently in all contexts.\nIf the variable is already defined, it will be reused. If the variable is not defined,\nit will be made available to the current and inner scopes (but not outer scopes).\n\ntip: A Common Confusion\nIf you run into an unexpectedly undefined variable,# Print the numbers 1 through 5\ni = 0\nwhile i < 5\n    i += 1     # ERROR: UndefVarError: `i` not defined\n    println(i)\nenda simple fix is to change all global variable definitions into local definitions\nby wrapping the code in a let block or function.# Print the numbers 1 through 5\nlet i = 0\n    while i < 5\n        i += 1     # Now outer `i` is defined in the inner scope of the while loop\n        println(i)\n    end\nendThis is a common source of confusion when writing procedural scripts,\nbut it becomes a non-issue if code is moved inside functions\nor executed interactively in the REPL.See also the global and local keywords\nto explicitly achieve any desired scoping behavior."},{"title":"Scope Constructs","page":"Scope of Variables","location":"manual/variables-and-scoping.html#man-scope-table","category":"section","text":"The constructs introducing scope blocks are:\n\nConstruct Scope Type Introduced Scope Types Able to Contain Construct\nmodule, baremodule global global\nstruct local (hard) global\nmacro local (hard) global\nfor, while, try local (soft) global, local\nfunction, do, let, comprehensions, generators local (hard) global, local\n\nNotably missing from this table are\nbegin blocks and if blocks\nwhich do not introduce new scopes.\nThe three types of scopes follow somewhat different rules which will be explained below.\n\nJulia uses lexical scoping,\nmeaning that a function's scope does not inherit from its caller's scope, but from the scope in\nwhich the function was defined. For example, in the following code the x inside foo refers\nto the x in the global scope of its module Bar:\n\njulia> module Bar\n           x = 1\n           foo() = x\n       end;\n\nand not a x in the scope where foo is used:\n\njulia> import .Bar\n\njulia> x = -1;\n\njulia> Bar.foo()\n1\n\nThus lexical scope means that what a variable in a particular piece of code refers to can be\ndeduced from the code in which it appears alone and does not depend on how the program executes. A\nscope nested inside another scope can \"see\" variables in all the outer scopes in which it is\ncontained. Outer scopes, on the other hand, cannot see variables in inner scopes."},{"title":"Global Scope","page":"Scope of Variables","location":"manual/variables-and-scoping.html#Global-Scope","category":"section","text":"Each module introduces a new global scope, separate from the global scope of all other modules—there\nis no all-encompassing global scope. Modules can introduce variables of other modules into their\nscope through the using or import statements or through qualified access using the\ndot-notation, i.e. each module is a so-called namespace as well as a first-class data structure\nassociating names with values.\n\nIf a top-level expression contains a variable declaration with keyword local,\nthen that variable is not accessible outside that expression.\nThe variable inside the expression does not affect global variables of the same name.\nAn example is to declare local x in a begin or if block at the top-level:\n\njulia> x = 1\n       begin\n           local x = 0\n           @show x\n       end\n       @show x;\nx = 0\nx = 1\n\nNote that the interactive prompt (aka REPL) is in the global scope of the module Main."},{"title":"Local Scope","page":"Scope of Variables","location":"manual/variables-and-scoping.html#local-scope","category":"section","text":"A new local scope is introduced by most code blocks (see above [table](@ref\nman-scope-table) for a complete list). If such a block is syntactically nested\ninside of another local scope, the scope it creates is nested inside of all the\nlocal scopes that it appears within, which are all ultimately nested inside of\nthe global scope of the module in which the code is evaluated. Variables in\nouter scopes are visible from any scope they contain — meaning that they can be\nread and written in inner scopes — unless there is a variable with the same name\nthat \"shadows\" the outer variable of the same name. This is true even if the\nouter local is declared after (in the sense of textually below) an inner\nblock. When we say that a variable \"exists\" in a given scope, this means that a\nvariable by that name exists in any of the scopes that the current scope is\nnested inside of, including the current one. If a variable's value is used in a\nlocal scope, but nothing with its name exists in this scope, it is assumed to be\na global.\n\nSome programming languages require explicitly declaring new variables before\nusing them. Explicit declaration works in Julia too: in any local scope, writing\nlocal x declares a new local variable in that scope, regardless of whether\nthere is already a variable named x in an outer scope or not. Declaring each\nnew variable like this is somewhat verbose and tedious, however, so Julia, like\nmany other languages, considers assignment to a variable name that doesn't\nalready exist to implicitly declare that variable. If the current scope is\nglobal, the new variable is global; if the current scope is local, the new\nvariable is local to the innermost local scope and will be visible inside of\nthat scope but not outside of it. If you assign to an existing local, it\nalways updates that existing local: you can only shadow a local by explicitly\ndeclaring a new local in a nested scope with the local keyword. In particular,\nthis applies to variables assigned in inner functions, which may surprise users\ncoming from Python where assignment in an inner function creates a new local\nunless the variable is explicitly declared to be non-local.\n\nMostly this is pretty intuitive, but as with many things that behave\nintuitively, the details are more subtle than one might naïvely imagine.\n\nWhen x = <value> occurs in a local scope, Julia applies the following rules to decide what the\nexpression means based on where the assignment expression occurs and what x already refers to at\nthat location:\n\nExisting local: If x is already a local variable, then the existing local x is\nassigned;\nHard scope: If x is not already a local variable and assignment occurs inside of any\nhard scope construct (i.e. within a let block, function, struct or macro body, comprehension, or\ngenerator), a new local named x is created in the scope of the assignment;\nSoft scope: If x is not already a local variable and all of the scope constructs\ncontaining the assignment are soft scopes (loops, try/catch blocks), the\nbehavior depends on whether the global variable x is defined:\nif global x is undefined, a new local named x is created in the scope of the\nassignment;\nif global x is defined, the assignment is considered ambiguous:\nin non-interactive contexts (files, eval), an ambiguity warning is printed and a new\nlocal is created;\nin interactive contexts (REPL, notebooks), the global variable x is assigned.\n\nYou may note that in non-interactive contexts the hard and soft scope behaviors are identical except\nthat a warning is printed when an implicitly local variable (i.e. not declared with local x)\nshadows a global. In interactive contexts, the rules follow a more complex heuristic for the sake of\nconvenience. This is covered in depth in examples that follow.\n\nNow that you know the rules, let's look at some examples. Each example is assumed to be evaluated in\na fresh REPL session so that the only globals in each snippet are the ones that are assigned in that\nblock of code.\n\nWe'll begin with a nice and clear-cut situation—assignment inside of a hard scope, in this case a\nfunction body, when no local variable by that name already exists:\n\njulia> function greet()\n           x = \"hello\" # new local\n           println(x)\n       end\ngreet (generic function with 1 method)\n\njulia> greet()\nhello\n\njulia> x # global\nERROR: UndefVarError: `x` not defined in `Main`\n\nInside of the greet function, the assignment x = \"hello\" causes x to be a new local variable\nin the function's scope. There are two relevant facts: the assignment occurs in local scope and\nthere is no existing local x variable. Since x is local, it doesn't matter if there is a global\nnamed x or not. Here for example we define x = 123 before defining and calling greet:\n\njulia> x = 123 # global\n123\n\njulia> function greet()\n           x = \"hello\" # new local\n           println(x)\n       end\ngreet (generic function with 1 method)\n\njulia> greet()\nhello\n\njulia> x # global\n123\n\nSince the x in greet is local, the value (or lack thereof) of the global x is unaffected by\ncalling greet. The hard scope rule doesn't care whether a global named x exists or not:\nassignment to x in a hard scope is local (unless x is declared global).\n\nThe next clear cut situation we'll consider is when there is already a local\nvariable named x, in which case x = <value> always assigns to this existing\nlocal x. This is true whether the assignment occurs in the same local scope,\nan inner local scope in the same function body, or in the body of a function\nnested inside of another function, also known as a\nclosure.\n\nWe'll use the sum_to function, which computes the sum of integers from one up\nto n, as an example:\n\nfunction sum_to(n)\n    s = 0 # new local\n    for i = 1:n\n        s = s + i # assign existing local\n    end\n    return s # same local\nend\n\nAs in the previous example, the first assignment to s at the top of sum_to causes s to be a\nnew local variable in the body of the function. The for loop has its own inner local scope within\nthe function scope. At the point where s = s + i occurs, s is already a local variable, so the\nassignment updates the existing s instead of creating a new local. We can test this out by calling\nsum_to in the REPL:\n\njulia> function sum_to(n)\n           s = 0 # new local\n           for i = 1:n\n               s = s + i # assign existing local\n           end\n           return s # same local\n       end\nsum_to (generic function with 1 method)\n\njulia> sum_to(10)\n55\n\njulia> s # global\nERROR: UndefVarError: `s` not defined in `Main`\n\nSince s is local to the function sum_to, calling the function has no effect on the global\nvariable s. We can also see that the update s = s + i in the for loop must have updated the same\ns created by the initialization s = 0 since we get the correct sum of 55 for the integers 1\nthrough 10.\n\nLet's dig into the fact that the for loop body has its own scope for a second by writing a slightly\nmore verbose variation which we'll call sum_to_def, in which we save the sum s + i in a variable t\nbefore updating s:\n\njulia> function sum_to_def(n)\n           s = 0 # new local\n           for i = 1:n\n               t = s + i # new local `t`\n               s = t # assign existing local `s`\n           end\n           return s, @isdefined(t)\n       end\nsum_to_def (generic function with 1 method)\n\njulia> sum_to_def(10)\n(55, false)\n\nThis version returns s as before but it also uses the @isdefined macro to return a boolean\nindicating whether there is a local variable named t defined in the function's outermost local\nscope. As you can see, there is no t defined outside of the for loop body. This is because of the\nhard scope rule again: since the assignment to t occurs inside of a function, which\nintroduces a hard scope, the assignment causes t to become a new local variable in the local scope\nwhere it appears, i.e. inside of the loop body. Even if there were a global named t, it would make\nno difference—the hard scope rule isn't affected by anything in global scope.\n\nNote that the local scope of a for loop body is no different from the local\nscope of an inner function. This means that we could rewrite this example so\nthat the loop body is implemented as a call to an inner helper function and it\nbehaves the same way:\n\njulia> function sum_to_def_closure(n)\n           function loop_body(i)\n               t = s + i # new local `t`\n               s = t # assign same local `s` as below\n           end\n           s = 0 # new local\n           for i = 1:n\n               loop_body(i)\n           end\n           return s, @isdefined(t)\n       end\nsum_to_def_closure (generic function with 1 method)\n\njulia> sum_to_def_closure(10)\n(55, false)\n\nThis example illustrates a couple of key points:\n\nInner function scopes are just like any other nested local scope. In\nparticular, if a variable is already a local outside of an inner function and\nyou assign to it in the inner function, the outer local variable is updated.\nIt doesn't matter if the definition of an outer local happens below where it\nis updated, the rule remains the same. The entire enclosing local scope is\nparsed and its locals determined before inner local meanings are resolved.\n\nThis design means that you can generally move code in or out of an inner\nfunction without changing its meaning, which facilitates a number of common\nidioms in the language using closures (see [do blocks](@ref\nDo-Block-Syntax-for-Function-Arguments)).\n\nLet's move onto some more ambiguous cases covered by the soft scope rule. We'll explore this by\nextracting the bodies of the greet and sum_to_def functions into soft scope contexts. First, let's put the\nbody of greet in a for loop—which is soft, rather than hard—and evaluate it in the REPL:\n\njulia> for i = 1:3\n           x = \"hello\" # new local\n           println(x)\n       end\nhello\nhello\nhello\n\njulia> x\nERROR: UndefVarError: `x` not defined in `Main`\n\nSince the global x is not defined when the for loop is evaluated, the first clause of the soft\nscope rule applies and x is created as local to the for loop and therefore global x remains\nundefined after the loop executes. Next, let's consider the body of sum_to_def extracted into global\nscope, fixing its argument to n = 10\n\ns = 0\nfor i = 1:10\n    t = s + i\n    s = t\nend\ns\n@isdefined(t)\n\nWhat does this code do? Hint: it's a trick question. The answer is \"it depends.\" If this code is\nentered interactively, it behaves the same way it does in a function body. But if the code appears\nin a file, it  prints an ambiguity warning and throws an undefined variable error. Let's see it\nworking in the REPL first:\n\njulia> s = 0 # global\n0\n\njulia> for i = 1:10\n           t = s + i # new local `t`\n           s = t # assign global `s`\n       end\n\njulia> s # global\n55\n\njulia> @isdefined(t) # global\nfalse\n\nThe REPL approximates being in the body of a function by deciding whether assignment inside the loop\nassigns to a global or creates new local based on whether a global variable by that name is defined\nor not. If a global by the name exists, then the assignment updates it. If no global exists, then\nthe assignment creates a new local variable. In this example we see both cases in action:\n\nThere is no global named t, so t = s + i creates a new t that is local to the for loop;\nThere is a global named s, so s = t assigns to it.\n\nThe second fact is why execution of the loop changes the global value of s and the first fact is\nwhy t is still undefined after the loop executes. Now, let's try evaluating this same code as\nthough it were in a file instead:\n\njulia> code = \"\"\"\n       s = 0 # global\n       for i = 1:10\n           t = s + i # new local `t`\n           s = t # new local `s` with warning\n       end\n       s, # global\n       @isdefined(t) # global\n       \"\"\";\n\njulia> include_string(Main, code)\n┌ Warning: Assignment to `s` in soft scope is ambiguous because a global variable by the same name exists: `s` will be treated as a new local. Disambiguate by using `local s` to suppress this warning or `global s` to assign to the existing global variable.\n└ @ string:4\nERROR: LoadError: UndefVarError: `s` not defined in local scope\n\nHere we use include_string, to evaluate code as though it were the contents of a file.\nWe could also save code to a file and then call include on that file—the result would be the\nsame. As you can see, this behaves quite different from evaluating the same code in the REPL. Let's\nbreak down what's happening here:\n\nglobal s is defined with the value 0 before the loop is evaluated\nthe assignment s = t occurs in a soft scope—a for loop outside of any function body or other hard\nscope construct\ntherefore the second clause of the soft scope rule applies, and the assignment is ambiguous so a\nwarning is emitted\nexecution continues, making s local to the for loop body\nsince s is local to the for loop, it is undefined when t = s + i is evaluated, causing an error\nevaluation stops there, but if it got to s and @isdefined(t), it would return 0 and false.\n\nThis demonstrates some important aspects of scope: in a scope, each variable can only have one\nmeaning, and that meaning is determined regardless of the order of expressions. The presence of the\nexpression s = t in the loop causes s to be local to the loop, which means that it is also local\nwhen it appears on the right hand side of t = s + i, even though that expression appears first and is\nevaluated first. One might imagine that the s on the first line of the loop could be global while\nthe s on the second line of the loop is local, but that's not possible since the two lines are in\nthe same scope block and each variable can only mean one thing in a given scope."},{"title":"On Soft Scope","page":"Scope of Variables","location":"manual/variables-and-scoping.html#on-soft-scope","category":"section","text":"We have now covered all the local scope rules, but before wrapping up this section, perhaps a few\nwords should be said about why the ambiguous soft scope case is handled differently in interactive\nand non-interactive contexts. There are two obvious questions one could ask:\n\nWhy doesn't it just work like the REPL everywhere?\nWhy doesn't it just work like in files everywhere? And maybe skip the warning?\n\nIn Julia ≤ 0.6, all global scopes did work like the current REPL: when x = <value> occurred in a\nloop (or try/catch, or struct body) but outside of a function body (or let block or comprehension),\nit was decided based on whether a global named x was defined or not whether x should be local to\nthe loop. This behavior has the advantage of being intuitive and convenient since it approximates\nthe behavior inside of a function body as closely as possible. In particular, it makes it easy to\nmove code back and forth between a function body and the REPL when trying to debug the behavior of a\nfunction. However, it has some downsides. First, it's quite a complex behavior: many people over the\nyears were confused about this behavior and complained that it was complicated and hard both to\nexplain and understand. Fair point. Second, and arguably worse, is that it's bad for programming \"at\nscale.\" When you see a small piece of code in one place like this, it's quite clear what's going on:\n\ns = 0\nfor i = 1:10\n    s += i\nend\n\nObviously the intention is to modify the existing global variable s. What else could it mean?\nHowever, not all real world code is so short or so clear. We found that code like the following\noften occurs in the wild:\n\nx = 123\n\n# much later\n# maybe in a different file\n\nfor i = 1:10\n    x = \"hello\"\n    println(x)\nend\n\n# much later\n# maybe in yet another file\n# or maybe back in the first one where `x = 123`\n\ny = x + 234\n\nIt's far less clear what should happen here. Since x + \"hello\" is a method error, it seems\nprobable that the intention is for x to be local to the for loop. But runtime values and what\nmethods happen to exist cannot be used to determine the scopes of variables. With the Julia ≤ 0.6\nbehavior, it's especially concerning that someone might have written the for loop first, had it\nworking just fine, but later when someone else adds a new global far away—possibly in a different\nfile—the code suddenly changes meaning and either breaks noisily or, worse still, silently does the\nwrong thing. This kind of \"spooky action at a distance\" is something that good programming language\ndesigns should prevent.\n\nSo in Julia 1.0, we simplified the rules for scope: in any local scope, assignment to a name that\nwasn't already a local variable created a new local variable. This eliminated the notion of soft\nscope entirely as well as removing the potential for spooky action. We uncovered and fixed a significant number of bugs due to the removal of soft scope, vindicating the choice to get rid of it.\nAnd there was much rejoicing! Well, no, not really. Because some people were\nangry that they now had to write:\n\ns = 0\nfor i = 1:10\n    global s += i\nend\n\nDo you see that global annotation in there? Hideous. Obviously this situation could not be\ntolerated. But seriously, there are two main issues with requiring global for this kind of\ntop-level code:\n\nIt's no longer convenient to copy and paste the code from inside a function body into the REPL\nto debug it—you have to add global annotations and then remove them again to go back;\nBeginners will write this kind of code without the global and have no idea why their code\ndoesn't work—the error that they get is that s is undefined, which does not seem to enlighten\nanyone who happens to make this mistake.\n\nAs of Julia 1.5, this code works without the global annotation in interactive contexts like the\nREPL or Jupyter notebooks (just like Julia 0.6) and in files and other non-interactive contexts, it\nprints this very direct warning:\n\nAssignment to s in soft scope is ambiguous because a global variable by the same name exists:\ns will be treated as a new local. Disambiguate by using local s to suppress this warning or\nglobal s to assign to the existing global variable.\n\nThis addresses both issues while preserving the \"programming at scale\" benefits of the 1.0 behavior:\nglobal variables have no spooky effect on the meaning of code that may be far away; in the REPL\ncopy-and-paste debugging works and beginners don't have any issues; any time someone either forgets\na global annotation or accidentally shadows an existing global with a local in a soft scope,\nwhich would be confusing anyway, they get a nice clear warning.\n\nAn important property of this design is that any code that executes in a file without a warning will\nbehave the same way in a fresh REPL. And on the flip side, if you take a REPL session and save it to\nfile, if it behaves differently than it did in the REPL, then you will get a warning."},{"title":"Let Blocks","page":"Scope of Variables","location":"manual/variables-and-scoping.html#Let-Blocks","category":"section","text":"let statements create a new hard scope block (see above) and introduce new variable\nbindings each time they run. The variable need not be immediately assigned:\n\njulia> var1 = let x\n           for i in 1:5\n               (i == 4) && (x = i; break)\n           end\n           x\n       end\n4\n\nWhereas assignments might reassign a new value to an existing value location, let always creates a\nnew location. This difference is usually not important, and is only detectable in the case of\nvariables that outlive their scope via closures. The let syntax accepts a comma-separated series of\nassignments and variable names:\n\njulia> x, y, z = -1, -1, -1;\n\njulia> let x = 1, z\n           println(\"x: $x, y: $y\") # x is local variable, y the global\n           println(\"z: $z\") # errors as z has not been assigned yet but is local\n       end\nx: 1, y: -1\nERROR: UndefVarError: `z` not defined in local scope\n\nThe assignments are evaluated in order, with each right-hand side evaluated in the scope before\nthe new variable on the left-hand side has been introduced. Therefore it makes sense to write\nsomething like let x = x since the two x variables are distinct and have separate storage.\nHere is an example where the behavior of let is needed:\n\njulia> Fs = Vector{Any}(undef, 2); i = 1;\n\njulia> while i <= 2\n           Fs[i] = ()->i\n           global i += 1\n       end\n\njulia> Fs[1]()\n3\n\njulia> Fs[2]()\n3\n\nHere we create and store two closures that return variable i. However, it is always the same\nvariable i, so the two closures behave identically. We can use let to create a new binding\nfor i:\n\njulia> Fs = Vector{Any}(undef, 2); i = 1;\n\njulia> while i <= 2\n           let i = i\n               Fs[i] = ()->i\n           end\n           global i += 1\n       end\n\njulia> Fs[1]()\n1\n\njulia> Fs[2]()\n2\n\nSince the begin construct does not introduce a new scope, it can be useful to use a zero-argument\nlet to just introduce a new scope block without creating any new bindings immediately:\n\njulia> let\n           local x = 1\n           let\n               local x = 2\n           end\n           x\n       end\n1\n\nSince let introduces a new scope block, the inner local x is a different variable than the\nouter local x. This particular example is equivalent to:\n\njulia> let x = 1\n           let x = 2\n           end\n           x\n       end\n1"},{"title":"Loops and Comprehensions","page":"Scope of Variables","location":"manual/variables-and-scoping.html#Loops-and-Comprehensions","category":"section","text":"In loops and comprehensions, new variables\nintroduced in their body scopes are freshly allocated for each loop iteration, as if the loop body\nwere surrounded by a let block, as demonstrated by this example:\n\njulia> Fs = Vector{Any}(undef, 2);\n\njulia> for j = 1:2\n           Fs[j] = ()->j\n       end\n\njulia> Fs[1]()\n1\n\njulia> Fs[2]()\n2\n\nA for loop or comprehension iteration variable is always a new variable:\n\njulia> function f()\n           i = 0\n           for i = 1:3\n               # empty\n           end\n           return i\n       end;\n\njulia> f()\n0\n\nHowever, it is occasionally useful to reuse an existing local variable as the iteration variable.\nThis can be done conveniently by adding the keyword outer:\n\njulia> function f()\n           i = 0\n           for outer i = 1:3\n               # empty\n           end\n           return i\n       end;\n\njulia> f()\n3"},{"title":"Constants","page":"Scope of Variables","location":"manual/variables-and-scoping.html#Constants","category":"section","text":"A common use of variables is giving names to specific, unchanging values. Such variables are only\nassigned once. This intent can be conveyed to the compiler using the const keyword:\n\njulia> const e  = 2.71828182845904523536;\n\njulia> const pi = 3.14159265358979323846;\n\nMultiple variables can be declared in a single const statement:\n\njulia> const a, b = 1, 2\n(1, 2)\n\nThe const declaration should only be used in global scope on globals.\nIt is difficult for the compiler to optimize code involving global variables, since\ntheir values (or even their types) might change at almost any time. If a global variable will\nnot change, adding a const declaration solves this performance problem.\n\nLocal constants are quite different. The compiler is able to determine automatically when a local\nvariable is constant, so local constant declarations are not necessary, and in fact are currently\nnot supported.\n\nSpecial top-level assignments, such as those performed by the function and struct keywords,\nare constant by default.\n\nNote that const only affects the variable binding; the variable may be bound to a mutable\nobject (such as an array), and that object may still be modified. Additionally when one tries\nto assign a value to a variable that is declared constant the following scenarios are possible:\n\nAttempting to replace a constant without the const keyword is disallowed:\njulia> const x = 1.0\n1.0\n\njulia> x = 1\nERROR: invalid assignment to constant x. This redefinition may be permitted using the `const` keyword.\nAll other definitions of constants are permitted, but may cause significant re-compilation:\njulia> const y = 1.0\n1.0\n\njulia> const y = 2.0\n2.0\n\ncompat: Julia 1.12\nPrior to julia 1.12, redefinition of constants was poorly supported. It was restricted to\nredefinition of constants of the same type and could lead to observably incorrect behavior\nor crashes. Constant redefinition is highly discouraged in versions of julia prior to 1.12.\nSee the manual for prior julia versions for further information."},{"title":"Typed Globals","page":"Scope of Variables","location":"manual/variables-and-scoping.html#man-typed-globals","category":"section","text":"compat: Julia 1.8\nSupport for typed globals was added in Julia 1.8\n\nSimilar to being declared as constants, global bindings can also be declared to always be of a\nconstant type. This can either be done without assigning an actual value using the syntax\nglobal x::T or upon assignment as x::T = 123.\n\njulia> x::Float64 = 2.718\n2.718\n\njulia> f() = x\nf (generic function with 1 method)\n\njulia> Base.return_types(f)\n1-element Vector{Any}:\n Float64\n\nFor any assignment to a global, Julia will first try to convert it to the appropriate type using\nconvert:\n\njulia> global y::Int\n\njulia> y = 1.0\n1.0\n\njulia> y\n1\n\njulia> y = 3.14\nERROR: InexactError: Int64(3.14)\nStacktrace:\n[...]\n\nThe type does not need to be concrete, but annotations with abstract types typically have little\nperformance benefit.\n\nOnce a global has either been assigned to or its type has been set, the binding type is not allowed\nto change:\n\njulia> x = 1\n1\n\njulia> global x::Int\nERROR: cannot set type for global x. It already has a value or is already set to a different type.\nStacktrace:\n[...]"},{"title":"Downloads","page":"Downloads","location":"stdlib/Downloads.html#Downloads","category":"section","text":""},{"title":"Downloads.download","page":"Downloads","location":"stdlib/Downloads.html#Downloads.download","category":"function","text":"download(url, [ output = tempname() ];\n    [ method = \"GET\", ]\n    [ headers = <none>, ]\n    [ timeout = <none>, ]\n    [ progress = <none>, ]\n    [ verbose = false, ]\n    [ debug = <none>, ]\n    [ downloader = <default>, ]\n) -> output\n\n    url        :: AbstractString\n    output     :: Union{AbstractString, AbstractCmd, IO}\n    method     :: AbstractString\n    headers    :: Union{AbstractVector, AbstractDict}\n    timeout    :: Real\n    progress   :: (total::Integer, now::Integer) --> Any\n    verbose    :: Bool\n    debug      :: (type, message) --> Any\n    downloader :: Downloader\n\nDownload a file from the given url, saving it to output or if not specified, a\ntemporary path. The output can also be an IO handle, in which case the body\nof the response is streamed to that handle and the handle is returned. If\noutput is a command, the command is run and output is sent to it on stdin.\n\nIf the downloader keyword argument is provided, it must be a Downloader\nobject. Resources and connections will be shared between downloads performed by\nthe same Downloader and cleaned up automatically when the object is garbage\ncollected or there have been no downloads performed with it for a grace period.\nSee Downloader for more info about configuration and usage.\n\nIf the headers keyword argument is provided, it must be a vector or dictionary\nwhose elements are all pairs of strings. These pairs are passed as headers when\ndownloading URLs with protocols that supports them, such as HTTP/S.\n\nThe timeout keyword argument specifies a timeout for the download to complete in\nseconds, with a resolution of milliseconds. By default no timeout is set, but this\ncan also be explicitly requested by passing a timeout value of Inf. Separately,\nif 20 seconds elapse without receiving any data, the download will timeout. See\nextended help for how to disable this timeout.\n\nIf the progress keyword argument is provided, it must be a callback function\nwhich will be called whenever there are updates about the size and status of the\nongoing download. The callback must take two integer arguments: total and\nnow which are the total size of the download in bytes, and the number of bytes\nwhich have been downloaded so far. Note that total starts out as zero and\nremains zero until the server gives an indication of the total size of the\ndownload (e.g. with a Content-Length header), which may never happen. So a\nwell-behaved progress callback should handle a total size of zero gracefully.\n\nIf the verbose option is set to true, libcurl, which is used to implement\nthe download functionality will print debugging information to stderr. If the\ndebug option is set to a function accepting two String arguments, then the\nverbose option is ignored and instead the data that would have been printed to\nstderr is passed to the debug callback with type and message arguments.\nThe type argument indicates what kind of event has occurred, and is one of:\nTEXT, HEADER IN, HEADER OUT, DATA IN, DATA OUT, SSL DATA IN or SSL DATA OUT. The message argument is the description of the debug event.\n\nExtended Help\n\nFor further customization, use a Downloader and\neasy_hooks.\nFor example, to disable the 20 second timeout when no data is received, you may\nuse the following:\n\ndownloader = Downloads.Downloader()\ndownloader.easy_hook = (easy, info) -> Downloads.Curl.setopt(easy, Downloads.Curl.CURLOPT_LOW_SPEED_TIME, 0)\n\nDownloads.download(\"https://httpbingo.julialang.org/delay/30\"; downloader)\n\n\n\n\n\n"},{"title":"Downloads.request","page":"Downloads","location":"stdlib/Downloads.html#Downloads.request","category":"function","text":"request(url;\n    [ input = <none>, ]\n    [ output = <none>, ]\n    [ method = input ? \"PUT\" : output ? \"GET\" : \"HEAD\", ]\n    [ headers = <none>, ]\n    [ timeout = <none>, ]\n    [ progress = <none>, ]\n    [ verbose = false, ]\n    [ debug = <none>, ]\n    [ throw = true, ]\n    [ downloader = <default>, ]\n    [ interrupt = <none>, ]\n) -> Union{Response, RequestError}\n\n    url        :: AbstractString\n    input      :: Union{AbstractString, AbstractCmd, IO}\n    output     :: Union{AbstractString, AbstractCmd, IO}\n    method     :: AbstractString\n    headers    :: Union{AbstractVector, AbstractDict}\n    timeout    :: Real\n    progress   :: (dl_total, dl_now, ul_total, ul_now) --> Any\n    verbose    :: Bool\n    debug      :: (type, message) --> Any\n    throw      :: Bool\n    downloader :: Downloader\n    interrupt  :: Base.Event\n\nMake a request to the given url, returning a Response object capturing the\nstatus, headers and other information about the response. The body of the\nresponse is written to output if specified and discarded otherwise. For HTTP/S\nrequests, if an input stream is given, a PUT request is made; otherwise if\nan output stream is given, a GET request is made; if neither is given a\nHEAD request is made. For other protocols, appropriate default methods are\nused based on what combination of input and output are requested. The following\noptions differ from the download function:\n\ninput allows providing a request body; if provided default to PUT request\nprogress is a callback taking four integers for upload and download progress\nthrow controls whether to throw or return a RequestError on request error\n\nNote that unlike download which throws an error if the requested URL could not\nbe downloaded (indicated by non-2xx status code), request returns a Response\nobject no matter what the status code of the response is. If there is an error\nwith getting a response at all, then a RequestError is thrown or returned.\n\nIf the interrupt keyword argument is provided, it must be a Base.Event object.\nIf the event is triggered while the request is in progress, the request will be\ncancelled and an error will be thrown. This can be used to interrupt a long\nrunning request, for example if the user wants to cancel a download.\n\n\n\n\n\n"},{"title":"Downloads.Response","page":"Downloads","location":"stdlib/Downloads.html#Downloads.Response","category":"type","text":"struct Response\n    proto   :: String\n    url     :: String\n    status  :: Int\n    message :: String\n    headers :: Vector{Pair{String,String}}\nend\n\nResponse is a type capturing the properties of a successful response to a\nrequest as an object. It has the following fields:\n\nproto: the protocol that was used to get the response\nurl: the URL that was ultimately requested after following redirects\nstatus: the status code of the response, indicating success, failure, etc.\nmessage: a textual message describing the nature of the response\nheaders: any headers that were returned with the response\n\nThe meaning and availability of some of these responses depends on the protocol\nused for the request. For many protocols, including HTTP/S and S/FTP, a 2xx\nstatus code indicates a successful response. For responses in protocols that do\nnot support headers, the headers vector will be empty. HTTP/2 does not include a\nstatus message, only a status code, so the message will be empty.\n\n\n\n\n\n"},{"title":"Downloads.RequestError","page":"Downloads","location":"stdlib/Downloads.html#Downloads.RequestError","category":"type","text":"struct RequestError <: ErrorException\n    url      :: String\n    code     :: Int\n    message  :: String\n    response :: Response\nend\n\nRequestError is a type capturing the properties of a failed response to a\nrequest as an exception object:\n\nurl: the original URL that was requested without any redirects\ncode: the libcurl error code; 0 if a protocol-only error occurred\nmessage: the libcurl error message indicating what went wrong\nresponse: response object capturing what response info is available\n\nThe same RequestError type is thrown by download if the request was\nsuccessful but there was a protocol-level error indicated by a status code that\nis not in the 2xx range, in which case code will be zero and the message\nfield will be the empty string. The request API only throws a RequestError\nif the libcurl error code is non-zero, in which case the included response\nobject is likely to have a status of zero and an empty message. There are,\nhowever, situations where a curl-level error is thrown due to a protocol error,\nin which case both the inner and outer code and message may be of interest.\n\n\n\n\n\n"},{"title":"Downloads.Downloader","page":"Downloads","location":"stdlib/Downloads.html#Downloads.Downloader","category":"type","text":"Downloader(; [ grace::Real = 30 ])\n\nDownloader objects are used to perform individual download operations.\nConnections, name lookups and other resources are shared within a Downloader.\nThese connections and resources are cleaned up after a configurable grace period\n(default: 30 seconds) since anything was downloaded with it, or when it is\ngarbage collected, whichever comes first. If the grace period is set to zero,\nall resources will be cleaned up immediately as soon as there are no more\nongoing downloads in progress. If the grace period is set to Inf then\nresources are not cleaned up until Downloader is garbage collected.\n\n\n\n\n\n"},{"title":"Package Images","page":"Package Images","location":"devdocs/pkgimg.html#pkgimages","category":"section","text":"Julia package images provide object (native code) caches for Julia packages.\nThey are similar to Julia's system image and support many of the same features.\nIn fact the underlying serialization format is the same, and the system image is the base image that the package images are build against."},{"title":"High-level overview","page":"Package Images","location":"devdocs/pkgimg.html#High-level-overview","category":"section","text":"Package images are shared libraries that contain both code and data. Like .ji cache files, they are generated per package. The data section contains both global data (global variables in the package) as well as the necessary metadata about what methods and types are defined by the package. The code section contains native objects that cache the final output of Julia's LLVM-based compiler.\n\nThe command line option --pkgimages=no can be used to turn off object caching for this session. Note that this means that cache files have to likely be regenerated.\nSee JULIA_MAX_NUM_PRECOMPILE_FILES for the upper limit of variants Julia caches per default.\n\nnote: Note\nWhile the package images present themselves as native shared libraries, they are only an approximation thereof. You will not be able to link against them from a native program and they must be loaded from Julia."},{"title":"Linking","page":"Package Images","location":"devdocs/pkgimg.html#Linking","category":"section","text":"Since the package images contain native code, we must run a linker over them before we can use them. You can set the environment variable JULIA_VERBOSE_LINKING to true to make the package image linking process verbose.\n\nFurthermore, we cannot assume that the user has a working system linker installed. Therefore, Julia ships with LLD, the LLVM linker, to provide a working out of the box experience. In base/linking.jl, we implement a limited interface to be able to link package images on all supported platforms."},{"title":"Quirks","page":"Package Images","location":"devdocs/pkgimg.html#Quirks","category":"section","text":"Despite LLD being a multi-platform linker, it does not provide a consistent interface across platforms. Furthermore, it is meant to be used from clang or\nanother compiler driver, we therefore reimplement some of the logic from llvm-project/clang/lib/Driver/ToolChains. Thankfully one can use lld -flavor to set lld to the right platform"},{"title":"Windows","page":"Package Images","location":"devdocs/pkgimg.html#Windows","category":"section","text":"To avoid having to deal with link.exe we use -flavor gnu, effectively turning lld into a cross-linker from a mingw32 environment. Windows DLLs are required to contain a _DllMainCRTStartup function and to minimize our dependence on mingw32 libraries, we inject a stub definition ourselves."},{"title":"MacOS","page":"Package Images","location":"devdocs/pkgimg.html#MacOS","category":"section","text":"Dynamic libraries on macOS need to link against -lSystem. On recent macOS versions, -lSystem is only available for linking when Xcode is available.\nTo that effect we link with -undefined dynamic_lookup."},{"title":"Package images optimized for multiple microarchitectures","page":"Package Images","location":"devdocs/pkgimg.html#pkgimgs-multi-versioning","category":"section","text":"Similar to multi-versioning for system images, package images support multi-versioning. This allows creating package caches that can run efficiently on different CPU architectures within the same environment.\n\nSee the JULIA_CPU_TARGET environment variable for more information on how to set the CPU target for package images."},{"title":"Flags that impact package image creation and selection","page":"Package Images","location":"devdocs/pkgimg.html#Flags-that-impact-package-image-creation-and-selection","category":"section","text":"These are the Julia command line flags that impact cache selection. Package images\nthat were created with different flags will be rejected.\n\n-g, --debug-info: Exact match required since it changes code generation.\n--check-bounds: Exact match required since it changes code generation.\n--inline: Exact match required since it changes code generation.\n--pkgimages: To allow running without object caching enabled.\n-O, --optimize: Reject package images generated for a lower optimization level,\nbut allow for higher optimization levels to be loaded."},{"title":"Dynamic Linker","page":"Dynamic Linker","location":"stdlib/Libdl.html#Dynamic-Linker","category":"section","text":""},{"title":"Lazy Library Loading","page":"Dynamic Linker","location":"stdlib/Libdl.html#Lazy-Library-Loading","category":"section","text":""},{"title":"Libdl","page":"Dynamic Linker","location":"stdlib/Libdl.html#Libdl","category":"module","text":"The Libdl module in Julia provides specialized and lower-level facilities for dynamic linking with shared libraries. While Julia\ninherently supports linking to runtime shared libraries through the ccall intrinsic, Libdl extends this capability by offering additional, more\ngranular control. It enables users to search for shared libraries both in memory and the filesystem, manually load them with specific runtime linker options, and look up\nlibrary symbols as low-level pointers.\n\n\n\n\n\n"},{"title":"Base.Libc.Libdl.dlopen","page":"Dynamic Linker","location":"stdlib/Libdl.html#Base.Libc.Libdl.dlopen","category":"function","text":"dlopen(libfile::AbstractString [, flags::Integer]; throw_error:Bool = true)\n\nLoad a shared library, returning an opaque handle.\n\nThe extension given by the constant dlext (.so, .dll, or .dylib)\ncan be omitted from the libfile string, as it is automatically appended\nif needed.   If libfile is not an absolute path name, then the paths\nin the array DL_LOAD_PATH are searched for libfile, followed by the\nsystem load path.\n\nThe optional flags argument is a bitwise-or of zero or more of RTLD_LOCAL, RTLD_GLOBAL,\nRTLD_LAZY, RTLD_NOW, RTLD_NODELETE, RTLD_NOLOAD, RTLD_DEEPBIND, and RTLD_FIRST.\nThese are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS)\ndlopen command, if possible, or are ignored if the specified functionality is not available\non the current platform. The default flags are platform specific. On MacOS the default\ndlopen flags are RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL while on other platforms the\ndefaults are RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL. An important usage of these flags is to\nspecify non default behavior for when the dynamic library loader binds library references to\nexported symbols and if the bound references are put into process local or global scope. For\ninstance RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL allows the library's symbols to be available\nfor usage in other shared libraries, addressing situations where there are dependencies\nbetween shared libraries.\n\nIf the library cannot be found, this method throws an error, unless the keyword argument\nthrow_error is set to false, in which case this method returns nothing.\n\nnote: Note\nFrom Julia 1.6 on, this method replaces paths starting with @executable_path/ with\n the path to the Julia executable, allowing for relocatable relative-path loads. In\n Julia 1.5 and earlier, this only worked on macOS.\n\n\n\n\n\n"},{"title":"Base.Libc.Libdl.dlopen_e","page":"Dynamic Linker","location":"stdlib/Libdl.html#Base.Libc.Libdl.dlopen_e","category":"function","text":"dlopen_e(libfile::AbstractString [, flags::Integer])\n\nSimilar to dlopen, except returns C_NULL instead of raising errors.\nThis method is now deprecated in favor of dlopen(libfile::AbstractString [, flags::Integer]; throw_error=false).\n\n\n\n\n\n"},{"title":"Base.Libc.Libdl.RTLD_NOW","page":"Dynamic Linker","location":"stdlib/Libdl.html#Base.Libc.Libdl.RTLD_NOW","category":"constant","text":"RTLD_DEEPBIND\nRTLD_FIRST\nRTLD_GLOBAL\nRTLD_LAZY\nRTLD_LOCAL\nRTLD_NODELETE\nRTLD_NOLOAD\nRTLD_NOW\n\nEnum constant for dlopen. See your platform man page for details, if\napplicable.\n\n\n\n\n\n"},{"title":"Base.Libc.Libdl.dlsym","page":"Dynamic Linker","location":"stdlib/Libdl.html#Base.Libc.Libdl.dlsym","category":"function","text":"dlsym(handle, sym; throw_error::Bool = true)\n\nLook up a symbol from a shared library handle, return callable function pointer on success.\n\nIf the symbol cannot be found, this method throws an error, unless the keyword argument\nthrow_error is set to false, in which case this method returns nothing.\n\n\n\n\n\n"},{"title":"Base.Libc.Libdl.dlsym_e","page":"Dynamic Linker","location":"stdlib/Libdl.html#Base.Libc.Libdl.dlsym_e","category":"function","text":"dlsym_e(handle, sym)\n\nLook up a symbol from a shared library handle, silently return C_NULL on lookup failure.\nThis method is now deprecated in favor of dlsym(handle, sym; throw_error=false).\n\n\n\n\n\n"},{"title":"Base.Libc.Libdl.dlclose","page":"Dynamic Linker","location":"stdlib/Libdl.html#Base.Libc.Libdl.dlclose","category":"function","text":"dlclose(::Nothing)\n\nFor the very common pattern usage pattern of\n\ntry\n    hdl = dlopen(library_name)\n    ... do something\nfinally\n    dlclose(hdl)\nend\n\nWe define a dlclose() method that accepts a parameter of type Nothing, so\nthat user code does not have to change its behavior for the case that library_name\nwas not found.\n\n\n\n\n\ndlclose(handle)\n\nClose shared library referenced by handle.\n\n\n\n\n\n"},{"title":"Base.Libc.Libdl.dlext","page":"Dynamic Linker","location":"stdlib/Libdl.html#Base.Libc.Libdl.dlext","category":"constant","text":"dlext\n\nFile extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\n\n\n\n\n\n"},{"title":"Base.Libc.Libdl.dllist","page":"Dynamic Linker","location":"stdlib/Libdl.html#Base.Libc.Libdl.dllist","category":"function","text":"dllist()\n\nReturn the paths of dynamic libraries currently loaded in a Vector{String}.\n\n\n\n\n\n"},{"title":"Base.Libc.Libdl.dlpath","page":"Dynamic Linker","location":"stdlib/Libdl.html#Base.Libc.Libdl.dlpath","category":"function","text":"dlpath(libname::Union{AbstractString, Symbol})\n\nGet the full path of the library libname.\n\nExamples\n\njulia> dlpath(\"libjulia\")\n\n\n\n\n\ndlpath(handle::Ptr{Cvoid})\n\nGiven a library handle from dlopen, return the full path.\n\n\n\n\n\n"},{"title":"Base.Libc.Libdl.find_library","page":"Dynamic Linker","location":"stdlib/Libdl.html#Base.Libc.Libdl.find_library","category":"function","text":"find_library(names [, locations])\n\nSearches for the first library in names in the paths in the locations list,\nDL_LOAD_PATH, or system library paths (in that order) which can successfully be dlopen'd.\nOn success, the return value will be one of the names (potentially prefixed by one of the\npaths in locations). This string can be assigned to a global const and used as the library\nname in future ccall's. On failure, it returns the empty string.\n\n\n\n\n\n"},{"title":"Base.DL_LOAD_PATH","page":"Dynamic Linker","location":"stdlib/Libdl.html#Base.DL_LOAD_PATH","category":"constant","text":"DL_LOAD_PATH\n\nWhen calling dlopen, the paths in this list will be searched first, in\norder, before searching the system locations for a valid library handle.\n\n\n\n\n\n"},{"title":"Base.Libc.Libdl.LazyLibrary","page":"Dynamic Linker","location":"stdlib/Libdl.html#Base.Libc.Libdl.LazyLibrary","category":"type","text":"LazyLibrary(name; flags = <default dlopen flags>,\n            dependencies = LazyLibrary[], on_load_callback = nothing)\n\nRepresents a lazily-loaded shared library that delays loading itself and its dependencies\nuntil first use in a ccall(), @ccall, dlopen(), dlsym(), dlpath(), or cglobal().\nThis is a thread-safe mechanism for on-demand library initialization.\n\nArguments\n\nname: Library name (or lazy path computation) as a String,\nLazyLibraryPath, or BundledLazyLibraryPath.\nflags: Optional dlopen flags (default: RTLD_LAZY | RTLD_DEEPBIND). See dlopen.\ndependencies: Vector of LazyLibrary object references to load before this one.\non_load_callback: Optional function to run arbitrary code on first load (use sparingly,\nas it is not expected that ccall() should result in large amounts of Julia code being run.\nYou may call ccall() from within the on_load_callback but only for the current library\nand its dependencies, and user should not call wait() on any tasks within the on load\ncallback as they may deadlock).\n\nThe dlopen operation is thread-safe: only one thread loads the library, acquired after the\nrelease store of the reference to each dependency from loading of each dependency. Other\ntasks block until loading completes. The handle is then cached and reused for all subsequent\ncalls (there is no dlclose for lazy library and dlclose should not be called on the returned\nhandled).\n\nExamples\n\n# Basic usage\nconst mylib = LazyLibrary(\"libmylib\")\n@ccall mylib.myfunc(42::Cint)::Cint\n\n# With dependencies\nconst libfoo = LazyLibrary(\"libfoo\")\nconst libbar = LazyLibrary(\"libbar\"; dependencies=[libfoo])\n\nFor more examples including platform-specific libraries, lazy path construction, and\nmigration from __init__() patterns, see the manual section on\nUsing LazyLibrary for Lazy Loading.\n\ncompat: Julia 1.11\nLazyLibrary was added in Julia 1.11.\n\nSee also LazyLibraryPath, BundledLazyLibraryPath, dlopen,\ndlsym, add_dependency!.\n\n\n\n\n\n"},{"title":"Base.Libc.Libdl.LazyLibraryPath","page":"Dynamic Linker","location":"stdlib/Libdl.html#Base.Libc.Libdl.LazyLibraryPath","category":"type","text":"LazyLibraryPath(path_pieces...)\n\nHelper type for lazily constructed library paths for use with LazyLibrary.\nPath pieces are stored unevaluated and joined with joinpath() when the library is first\naccessed. Arguments must be able to have string() called on them.\n\nExample\n\nconst mylib = LazyLibrary(LazyLibraryPath(artifact_dir, \"lib\", \"libmylib.so.1.2.3\"))\n\ncompat: Julia 1.11\nLazyLibraryPath was added in Julia 1.11.\n\nSee also LazyLibrary, BundledLazyLibraryPath.\n\n\n\n\n\n"},{"title":"Base.Libc.Libdl.BundledLazyLibraryPath","page":"Dynamic Linker","location":"stdlib/Libdl.html#Base.Libc.Libdl.BundledLazyLibraryPath","category":"function","text":"BundledLazyLibraryPath(subpath)\n\nHelper type for lazily constructed library paths within the Julia distribution.\nConstructs paths relative to Julia's private shared library directory.\n\nPrimarily used by Julia's standard library. For example:\n\nconst libgmp = LazyLibrary(BundledLazyLibraryPath(\"libgmp.so.10\"))\n\ncompat: Julia 1.11\nBundledLazyLibraryPath was added in Julia 1.11.\n\nSee also LazyLibrary, LazyLibraryPath.\n\n\n\n\n\n"},{"title":"Base.Libc.Libdl.add_dependency!","page":"Dynamic Linker","location":"stdlib/Libdl.html#Base.Libc.Libdl.add_dependency!","category":"function","text":"add_dependency!(library::LazyLibrary, dependency::LazyLibrary)\n\nDynamically add a dependency that must be loaded before library. Only needed when\ndependencies cannot be determined at construction time.\n\nwarning: Warning\nDependencies added with this function are ephemeral and only persist within the\ncurrent process. They will not persist across precompilation boundaries.\n\nPrefer specifying dependencies in the LazyLibrary constructor when possible.\n\ncompat: Julia 1.11\nadd_dependency! was added in Julia 1.11.\n\nSee also LazyLibrary.\n\n\n\n\n\n"},{"title":"Logging","page":"Logging","location":"stdlib/Logging.html#man-logging","category":"section","text":"The Logging module provides a way to record the history and progress of a\ncomputation as a log of events. Events are created by inserting a logging\nstatement into the source code, for example:\n\n@warn \"Abandon printf debugging, all ye who enter here!\"\n┌ Warning: Abandon printf debugging, all ye who enter here!\n└ @ Main REPL[1]:1\n\nThe system provides several advantages over peppering your source code with\ncalls to println(). First, it allows you to control the visibility and\npresentation of messages without editing the source code. For example, in\ncontrast to the @warn above\n\n@debug \"The sum of some values $(sum(rand(100)))\"\n\nwill produce no output by default. Furthermore, it's very cheap to leave debug\nstatements like this in the source code because the system avoids evaluating\nthe message if it would later be ignored. In this case sum(rand(100)) and\nthe associated string processing will never be executed unless debug logging is\nenabled.\n\nSecond, the logging tools allow you to attach arbitrary data to each event as a\nset of key–value pairs. This allows you to capture local variables and other\nprogram state for later analysis. For example, to attach the local array\nvariable A and the sum of a vector v as the key s you can use\n\nA = ones(Int, 4, 4)\nv = ones(100)\n@info \"Some variables\"  A  s=sum(v)\n\n# output\n┌ Info: Some variables\n│   A =\n│    4×4 Matrix{Int64}:\n│     1  1  1  1\n│     1  1  1  1\n│     1  1  1  1\n│     1  1  1  1\n└   s = 100.0\n\nAll of the logging macros @debug, @info, @warn and @error share common\nfeatures that are described in detail in the documentation for the more\ngeneral macro @logmsg."},{"title":"Log event structure","page":"Logging","location":"stdlib/Logging.html#Log-event-structure","category":"section","text":"Each event generates several pieces of data, some provided by the user and some\nautomatically extracted. Let's examine the user-defined data first:\n\nThe log level is a broad category for the message that is used for early\nfiltering. There are several standard levels of type LogLevel;\nuser-defined levels are also possible.\nEach is distinct in purpose:\nLogging.Debug (log level -1000) is information intended for the developer of\nthe program. These events are disabled by default.\nLogging.Info (log level 0) is for general information to the user.\nThink of it as an alternative to using println directly.\nLogging.Warn (log level 1000) means something is wrong and action is likely\nrequired but that for now the program is still working.\nLogging.Error (log level 2000) means something is wrong and it is unlikely to\nbe recovered, at least by this part of the code.\nOften this log-level is unneeded as throwing an exception can convey\nall the required information.\nThe message  is an object describing the event. By convention\nAbstractStrings passed as messages are assumed to be in markdown format.\nOther types will be displayed using print(io, obj) or string(obj) for\ntext-based output and possibly show(io,mime,obj) for other multimedia\ndisplays used in the installed logger.\nOptional key–value pairs allow arbitrary data to be attached to each event.\nSome keys have conventional meaning that can affect the way an event is\ninterpreted (see @logmsg).\n\nThe system also generates some standard information for each event:\n\nThe module in which the logging macro was expanded.\nThe file and line where the logging macro occurs in the source code.\nA message id that is a unique, fixed identifier for the source code\nstatement where the logging macro appears. This identifier is designed to be\nfairly stable even if the source code of the file changes, as long as the\nlogging statement itself remains the same.\nA group for the event, which is set to the base name of the file by default,\nwithout extension. This can be used to group messages into categories more\nfinely than the log level (for example, all deprecation warnings have group\n:depwarn), or into logical groupings across or within modules.\n\nNotice that some useful information such as the event time is not included by\ndefault. This is because such information can be expensive to extract and is\nalso dynamically available to the current logger. It's simple to define a\ncustom logger to augment event data with the\ntime, backtrace, values of global variables and other useful information as\nrequired."},{"title":"Processing log events","page":"Logging","location":"stdlib/Logging.html#Processing-log-events","category":"section","text":"As you can see in the examples, logging statements make no mention of\nwhere log events go or how they are processed. This is a key design feature\nthat makes the system composable and natural for concurrent use. It does this\nby separating two different concerns:\n\nCreating log events is the concern of the module author who needs to\ndecide where events are triggered and which information to include.\nProcessing of log events — that is, display, filtering, aggregation and\nrecording — is the concern of the application author who needs to bring\nmultiple modules together into a cooperating application."},{"title":"Loggers","page":"Logging","location":"stdlib/Logging.html#Loggers","category":"section","text":"Processing of events is performed by a logger, which is the first piece of\nuser configurable code to see the event. All loggers must be subtypes of\nAbstractLogger.\n\nWhen an event is triggered, the appropriate logger is found by looking for a\ntask-local logger with the global logger as fallback. The idea here is that\nthe application code knows how log events should be processed and exists\nsomewhere at the top of the call stack. So we should look up through the call\nstack to discover the logger — that is, the logger should be dynamically\nscoped. (This is a point of contrast with logging frameworks where the\nlogger is lexically scoped; provided explicitly by the module author or as a\nsimple global variable. In such a system it's awkward to control logging while\ncomposing functionality from multiple modules.)\n\nThe global logger may be set with global_logger, and task-local\nloggers controlled using with_logger. Newly spawned tasks inherit\nthe logger of the parent task.\n\nThere are three logger types provided by the library.  ConsoleLogger\nis the default logger you see when starting the REPL. It displays events in a\nreadable text format and tries to give simple but user friendly control over\nformatting and filtering.  NullLogger is a convenient way to drop all\nmessages where necessary; it is the logging equivalent of the devnull\nstream.  SimpleLogger is a very simplistic text formatting logger,\nmainly useful for debugging the logging system itself.\n\nCustom loggers should come with overloads for the functions described in the\nreference section."},{"title":"Early filtering and message handling","page":"Logging","location":"stdlib/Logging.html#Early-filtering-and-message-handling","category":"section","text":"When an event occurs, a few steps of early filtering occur to avoid generating\nmessages that will be discarded:\n\nThe message log level is checked against a global minimum level (set via\ndisable_logging). This is a crude but extremely cheap global\nsetting.\nThe current logger state is looked up and the message level checked against the\nlogger's cached minimum level, as found by calling Logging.min_enabled_level.\nThis behavior can be overridden via environment variables (more on this later).\nThe Logging.shouldlog function is called with the current logger, taking\nsome minimal information (level, module, group, id) which can be computed\nstatically. Most usefully, shouldlog is passed an event id which can be\nused to discard events early based on a cached predicate.\n\nIf all these checks pass, the message and key–value pairs are evaluated in full\nand passed to the current logger via the Logging.handle_message function.\nhandle_message() may perform additional filtering as required and display the\nevent to the screen, save it to a file, etc.\n\nExceptions that occur while generating the log event are captured and logged\nby default. This prevents individual broken events from crashing the\napplication, which is helpful when enabling little-used debug events in a\nproduction system. This behavior can be customized per logger type by\nextending Logging.catch_exceptions."},{"title":"Testing log events","page":"Logging","location":"stdlib/Logging.html#Testing-log-events","category":"section","text":"Log events are a side effect of running normal code, but you might find\nyourself wanting to test particular informational messages and warnings. The\nTest module provides a @test_logs macro that can be used to\npattern match against the log event stream."},{"title":"Environment variables","page":"Logging","location":"stdlib/Logging.html#Environment-variables","category":"section","text":"Message filtering can be influenced through the JULIA_DEBUG environment\nvariable, and serves as an easy way to enable debug logging for a file or\nmodule. Loading julia with JULIA_DEBUG=loading will activate\n@debug log messages in loading.jl. For example, in Linux shells:\n\n$ JULIA_DEBUG=loading julia -e 'using OhMyREPL'\n┌ Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji due to it containing an incompatible cache header\n└ @ Base loading.jl:1328\n[ Info: Recompiling stale cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji for module OhMyREPL\n┌ Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/Tokenize.ji due to it containing an incompatible cache header\n└ @ Base loading.jl:1328\n...\n\nOn windows, the same can be achieved in CMD via first running set JULIA_DEBUG=\"loading\" and in Powershell via\n$env:JULIA_DEBUG=\"loading\".\n\nSimilarly, the environment variable can be used to enable debug logging of\nmodules, such as Pkg, or module roots (see Base.moduleroot). To\nenable all debug logging, use the special value all.\n\nTo turn debug logging on from the REPL, set ENV[\"JULIA_DEBUG\"] to the\nname of the module of interest. Functions defined in the REPL belong to\nmodule Main; logging for them can be enabled like this:\n\njulia> foo() = @debug \"foo\"\nfoo (generic function with 1 method)\n\njulia> foo()\n\njulia> ENV[\"JULIA_DEBUG\"] = Main\nMain\n\njulia> foo()\n┌ Debug: foo\n└ @ Main REPL[1]:1\n\n\nUse a comma separator to enable debug for multiple\nmodules: JULIA_DEBUG=loading,Main."},{"title":"Examples","page":"Logging","location":"stdlib/Logging.html#Examples","category":"section","text":""},{"title":"Example: Writing log events to a file","page":"Logging","location":"stdlib/Logging.html#Example:-Writing-log-events-to-a-file","category":"section","text":"Sometimes it can be useful to write log events to a file. Here is an example\nof how to use a task-local and global logger to write information to a text\nfile:\n\n# Load the logging module\njulia> using Logging\n\n# Open a textfile for writing\njulia> io = open(\"log.txt\", \"w+\")\nIOStream(<file log.txt>)\n\n# Create a simple logger\njulia> logger = SimpleLogger(io)\nSimpleLogger(IOStream(<file log.txt>), Info, Dict{Any,Int64}())\n\n# Log a task-specific message\njulia> with_logger(logger) do\n           @info(\"a context specific log message\")\n       end\n\n# Write all buffered messages to the file\njulia> flush(io)\n\n# Set the global logger to logger\njulia> global_logger(logger)\nSimpleLogger(IOStream(<file log.txt>), Info, Dict{Any,Int64}())\n\n# This message will now also be written to the file\njulia> @info(\"a global log message\")\n\n# Close the file\njulia> close(io)"},{"title":"Example: Enable debug-level messages","page":"Logging","location":"stdlib/Logging.html#Example:-Enable-debug-level-messages","category":"section","text":"Here is an example of creating a ConsoleLogger that lets through any messages\nwith log level higher than, or equal, to Logging.Debug.\n\njulia> using Logging\n\n# Create a ConsoleLogger that prints any log messages with level >= Debug to stderr\njulia> debuglogger = ConsoleLogger(stderr, Logging.Debug)\n\n# Enable debuglogger for a task\njulia> with_logger(debuglogger) do\n           @debug \"a context specific log message\"\n       end\n\n# Set the global logger\njulia> global_logger(debuglogger)"},{"title":"Reference","page":"Logging","location":"stdlib/Logging.html#Reference","category":"section","text":""},{"title":"Logging module","page":"Logging","location":"stdlib/Logging.html#Logging-module","category":"section","text":""},{"title":"Creating events","page":"Logging","location":"stdlib/Logging.html#Creating-events","category":"section","text":""},{"title":"Processing events with AbstractLogger","page":"Logging","location":"stdlib/Logging.html#AbstractLogger-interface","category":"section","text":"Event processing is controlled by overriding functions associated with\nAbstractLogger:\n\nMethods to implement  Brief description\nLogging.handle_message  Handle a log event\nLogging.shouldlog  Early filtering of events\nLogging.min_enabled_level  Lower bound for log level of accepted events\nOptional methods Default definition Brief description\nLogging.catch_exceptions true Catch exceptions during event evaluation"},{"title":"Using Loggers","page":"Logging","location":"stdlib/Logging.html#Using-Loggers","category":"section","text":"Logger installation and inspection:\n\nLoggers that are supplied with the system:"},{"title":"Logging.Logging","page":"Logging","location":"stdlib/Logging.html#Logging.Logging","category":"module","text":"Utilities for capturing, filtering and presenting streams of log events.\nNormally you don't need to import Logging to create log events; for this\nthe standard logging macros such as @info are already exported by Base\nand available by default.\n\n\n\n\n\n"},{"title":"Base.CoreLogging.@logmsg","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.@logmsg","category":"macro","text":"@debug message  [key=value | value ...]\n@info  message  [key=value | value ...]\n@warn  message  [key=value | value ...]\n@error message  [key=value | value ...]\n\n@logmsg level message [key=value | value ...]\n\nCreate a log record with an informational message.  For convenience, four\nlogging macros @debug, @info, @warn and @error are defined which log at\nthe standard severity levels Debug, Info, Warn and Error.  @logmsg\nallows level to be set programmatically to any LogLevel or custom log level\ntypes.\n\nmessage should be an expression which evaluates to a string which is a human\nreadable description of the log event.  By convention, this string will be\nformatted as markdown when presented.\n\nThe optional list of key=value pairs supports arbitrary user defined\nmetadata which will be passed through to the logging backend as part of the\nlog record.  If only a value expression is supplied, a key representing the\nexpression will be generated using Symbol. For example, x becomes x=x,\nand foo(10) becomes Symbol(\"foo(10)\")=foo(10).  For splatting a list of\nkey value pairs, use the normal splatting syntax, @info \"blah\" kws....\n\nThere are some keys which allow automatically generated log data to be\noverridden:\n\n_module=mod can be used to specify a different originating module from\nthe source location of the message.\n_group=symbol can be used to override the message group (this is\nnormally derived from the base name of the source file).\n_id=symbol can be used to override the automatically generated unique\nmessage identifier.  This is useful if you need to very closely associate\nmessages generated on different source lines.\n_file=string and _line=integer can be used to override the apparent\nsource location of a log message.\n\nThere's also some key value pairs which have conventional meaning:\n\nmaxlog=integer should be used as a hint to the backend that the message\nshould be displayed no more than maxlog times.\nexception=ex should be used to transport an exception with a log message,\noften used with @error. An associated backtrace bt may be attached\nusing the tuple exception=(ex,bt).\n\nExamples\n\n@debug \"Verbose debugging information.  Invisible by default\"\n@info  \"An informational message\"\n@warn  \"Something was odd.  You should pay attention\"\n@error \"A non fatal error occurred\"\n\nx = 10\n@info \"Some variables attached to the message\" x a=42.0\n\n@debug begin\n    sA = sum(A)\n    \"sum(A) = $sA is an expensive operation, evaluated only when `shouldlog` returns true\"\nend\n\nfor i=1:10000\n    @info \"With the default backend, you will only see (i = $i) ten times\"  maxlog=10\n    @debug \"Algorithm1\" i progress=i/10000\nend\n\n\n\n\n\n"},{"title":"Base.CoreLogging.LogLevel","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.LogLevel","category":"type","text":"LogLevel(level)\n\nSeverity/verbosity of a log record.\n\nThe log level provides a key against which potential log records may be\nfiltered, before any other work is done to construct the log record data\nstructure itself.\n\nExamples\n\njulia> Logging.LogLevel(0) == Logging.Info\ntrue\n\n\n\n\n\n"},{"title":"Base.CoreLogging.Debug","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.Debug","category":"constant","text":"Debug\n\nAlias for LogLevel(-1000).\n\n\n\n\n\n"},{"title":"Base.CoreLogging.Info","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.Info","category":"constant","text":"Info\n\nAlias for LogLevel(0).\n\n\n\n\n\n"},{"title":"Base.CoreLogging.Warn","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.Warn","category":"constant","text":"Warn\n\nAlias for LogLevel(1000).\n\n\n\n\n\n"},{"title":"Base.CoreLogging.Error","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.Error","category":"constant","text":"Error\n\nAlias for LogLevel(2000).\n\n\n\n\n\n"},{"title":"Base.CoreLogging.BelowMinLevel","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.BelowMinLevel","category":"constant","text":"BelowMinLevel\n\nAlias for LogLevel(-1_000_001).\n\n\n\n\n\n"},{"title":"Base.CoreLogging.AboveMaxLevel","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.AboveMaxLevel","category":"constant","text":"AboveMaxLevel\n\nAlias for LogLevel(1_000_001).\n\n\n\n\n\n"},{"title":"Base.CoreLogging.AbstractLogger","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.AbstractLogger","category":"type","text":"A logger controls how log records are filtered and dispatched.  When a log\nrecord is generated, the logger is the first piece of user configurable code\nwhich gets to inspect the record and decide what to do with it.\n\n\n\n\n\n"},{"title":"Base.CoreLogging.handle_message","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.handle_message","category":"function","text":"handle_message(logger, level, message, _module, group, id, file, line; key1=val1, ...)\n\nLog a message to logger at level.  The logical location at which the\nmessage was generated is given by module _module and group; the source\nlocation by file and line. id is an arbitrary unique value (typically a\nSymbol) to be used as a key to identify the log statement when\nfiltering.\n\n\n\n\n\n"},{"title":"Base.CoreLogging.shouldlog","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.shouldlog","category":"function","text":"shouldlog(logger, level, _module, group, id)\n\nReturn true when logger accepts a message at level, generated for\n_module, group and with unique log identifier id.\n\n\n\n\n\n"},{"title":"Base.CoreLogging.min_enabled_level","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.min_enabled_level","category":"function","text":"min_enabled_level(logger)\n\nReturn the minimum enabled level for logger for early filtering.  That is,\nthe log level below or equal to which all messages are filtered.\n\n\n\n\n\n"},{"title":"Base.CoreLogging.catch_exceptions","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.catch_exceptions","category":"function","text":"catch_exceptions(logger)\n\nReturn true if the logger should catch exceptions which happen during log\nrecord construction.  By default, messages are caught.\n\nBy default all exceptions are caught to prevent log message generation from\ncrashing the program.  This lets users confidently toggle little-used\nfunctionality - such as debug logging - in a production system.\n\nIf you want to use logging as an audit trail you should disable this for your\nlogger type.\n\n\n\n\n\n"},{"title":"Base.CoreLogging.disable_logging","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.disable_logging","category":"function","text":"disable_logging(level)\n\nDisable all log messages at log levels equal to or less than level.  This is\na global setting, intended to make debug logging extremely cheap when\ndisabled. Note that this cannot be used to enable logging that is currently disabled\nby other mechanisms.\n\nExamples\n\nLogging.disable_logging(Logging.Info) # Disable debug and info\n\n\n\n\n\n"},{"title":"Base.CoreLogging.global_logger","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.global_logger","category":"function","text":"global_logger()\n\nReturn the global logger, used to receive messages when no specific logger\nexists for the current task.\n\nglobal_logger(logger)\n\nSet the global logger to logger, and return the previous global logger.\n\n\n\n\n\n"},{"title":"Base.CoreLogging.with_logger","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.with_logger","category":"function","text":"with_logger(function, logger)\n\nExecute function, directing all log messages to logger.\n\nExamples\n\nfunction test(x)\n    @info \"x = $x\"\nend\n\nwith_logger(logger) do\n    test(1)\n    test([1,2])\nend\n\n\n\n\n\n"},{"title":"Base.CoreLogging.current_logger","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.current_logger","category":"function","text":"current_logger()\n\nReturn the logger for the current task, or the global logger if none is\nattached to the task.\n\n\n\n\n\n"},{"title":"Base.CoreLogging.NullLogger","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.NullLogger","category":"type","text":"NullLogger()\n\nLogger which disables all messages and produces no output - the logger\nequivalent of /dev/null.\n\n\n\n\n\n"},{"title":"Base.CoreLogging.ConsoleLogger","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.ConsoleLogger","category":"type","text":"ConsoleLogger([stream,] min_level=Info; meta_formatter=default_metafmt,\n              show_limited=true, right_justify=0)\n\nLogger with formatting optimized for readability in a text console, for example\ninteractive work with the Julia REPL.\n\nLog levels less than min_level are filtered out.\n\nThis Logger is thread-safe, with locks for both orchestration of message\nlimits i.e. maxlog, and writes to the stream.\n\nMessage formatting can be controlled by setting keyword arguments:\n\nmeta_formatter is a function which takes the log event metadata\n(level, _module, group, id, file, line) and returns a color (as would be\npassed to printstyled), prefix and suffix for the log message.  The\ndefault is to prefix with the log level and a suffix containing the module,\nfile and line location.\nshow_limited limits the printing of large data structures to something\nwhich can fit on the screen by setting the :limit IOContext key during\nformatting.\nright_justify is the integer column which log metadata is right justified\nat. The default is zero (metadata goes on its own line).\n\n\n\n\n\n"},{"title":"Base.CoreLogging.SimpleLogger","page":"Logging","location":"stdlib/Logging.html#Base.CoreLogging.SimpleLogger","category":"type","text":"SimpleLogger([stream,] min_level=Info)\n\nSimplistic logger for logging all messages with level greater than or equal to\nmin_level to stream. If stream is closed then messages with log level\ngreater or equal to Warn will be logged to stderr and below to stdout.\n\nThis Logger is thread-safe, with a lock taken around orchestration of message\nlimits i.e. maxlog, and writes to the stream.\n\n\n\n\n\n"},{"title":"Fixing precompilation hangs due to open tasks or IO","page":"Fixing precompilation hangs due to open tasks or IO","location":"devdocs/precompile_hang.html#Fixing-precompilation-hangs-due-to-open-tasks-or-IO","category":"section","text":"On Julia 1.10 or higher, you might see the following message:\n\n(Image: Screenshot of precompilation hang)\n\nThis may repeat. If it continues to repeat with no hints that it will\nresolve itself, you may have a \"precompilation hang\" that requires\nfixing. Even if it's transient, you might prefer to resolve it so that\nusers will not be bothered by this warning. This page walks you\nthrough how to analyze and fix such issues.\n\nIf you follow the advice and hit Ctrl-C, you might see\n\n^C Interrupted: Exiting precompilation...\n\n  1 dependency had warnings during precompilation:\n┌ Test1 [ac89d554-e2ba-40bc-bc5c-de68b658c982]\n│  [pid 2745] Waiting for background task / IO / timer to finish:\n│   Handle type        uv_handle_t->data\n│   timer              0x55580decd1e0->0x7f94c3a4c340\n\nThis message conveys two key pieces of information:\n\nthe hang is occurring during precompilation of Test1, a dependency of Test2 (the package we were trying to load with using Test2)\nduring precompilation of Test1, Julia created a Timer object (use ?Timer if you're unfamiliar with Timers) which is still open; until that closes, the process is hung\n\nIf this is enough of a hint for you to figure out how timer = Timer(args...) is being created, one good solution is to add wait(timer) if timer eventually finishes on its own, or close(timer) if you need to force-close it, before the final end of the module.\n\nHowever, there are cases that may not be that straightforward. Usually the best option is to start by determining whether the hang is due to code in Test1 or whether it is due to one of Test1's dependencies:\n\nOption 1: Pkg.add(\"Aqua\") and use Aqua.test_persistent_tasks. This should help you identify which package is causing the problem, after which the instructions below should be followed. If needed, you can create a PkgId as Base.PkgId(UUID(\"...\"), \"Test1\"), where ... comes from the uuid entry in Test1/Project.toml.\nOption 2: manually diagnose the source of the hang.\n\nTo manually diagnose:\n\nPkg.develop(\"Test1\")\nComment out all the code included or defined in Test1, except the using/import statements.\nTry using Test2 (or even using Test1 assuming that hangs too) again\n\nNow we arrive at a fork in the road: either\n\nthe hang persists, indicating it is due to one of your dependencies\nthe hang disappears, indicating that it is due to something in your code."},{"title":"Diagnosing and fixing hangs due to a package dependency","page":"Fixing precompilation hangs due to open tasks or IO","location":"devdocs/precompile_hang.html#pchang_deps","category":"section","text":"Use a binary search to identify the problematic dependency: start by commenting out half your dependencies, then when you isolate which half is responsible comment out half of that half, etc. (You don't have to remove them from the project, just comment out the using/import statements.)\n\nOnce you've identified a suspect (here we'll call it ThePackageYouThinkIsCausingTheProblem), first try precompiling that package. If it also hangs during precompilation, continue chasing the problem backwards.\n\nHowever, most likely ThePackageYouThinkIsCausingTheProblem will precompile fine. This suggests it's in the function ThePackageYouThinkIsCausingTheProblem.__init__, which does not run during precompilation of ThePackageYouThinkIsCausingTheProblem but does in any package that loads ThePackageYouThinkIsCausingTheProblem. To test this theory, set up a minimal working example (MWE), something like\n\n(@v1.10) pkg> generate MWE\n  Generating  project MWE:\n    MWE\\Project.toml\n    MWE\\src\\MWE.jl\n\nwhere the source code of MWE.jl is\n\nmodule MWE\nusing ThePackageYouThinkIsCausingTheProblem\nend\n\nand you've added ThePackageYouThinkIsCausingTheProblem to MWE's dependencies.\n\nIf that MWE reproduces the hang, you've found your culprit:\nThePackageYouThinkIsCausingTheProblem.__init__ must be creating the Timer object. If the timer object can be safely closed, that's a good option. Otherwise, the most common solution is to avoid creating the timer while any package is being precompiled: add\n\nccall(:jl_generating_output, Cint, ()) == 1 && return nothing\n\nas the first line of ThePackageYouThinkIsCausingTheProblem.__init__, and it will avoid doing any initialization in any Julia process whose purpose is to precompile packages."},{"title":"Fixing package code to avoid hangs","page":"Fixing precompilation hangs due to open tasks or IO","location":"devdocs/precompile_hang.html#pchang_fix","category":"section","text":"Search your package for suggestive words (here like \"Timer\") and see if you can identify where the problem is being created. Note that a method definition like\n\nmaketimer() = Timer(timer -> println(\"hi\"), 0; interval=1)\n\nis not problematic in and of itself: it can cause this problem only if maketimer gets called while the module is being defined. This might be happening from a top-level statement such as\n\nconst GLOBAL_TIMER = maketimer()\n\nor it might conceivably occur in a precompile workload.\n\nIf you struggle to identify the causative lines, then consider doing a binary search: comment out sections of your package (or include lines to omit entire files) until you've reduced the problem in scope."},{"title":"Using Valgrind with Julia","page":"Using Valgrind with Julia","location":"devdocs/valgrind.html#Using-Valgrind-with-Julia","category":"section","text":"Valgrind is a tool for memory debugging, memory leak detection, and profiling.\n This section describes things to keep in mind when using Valgrind to debug memory issues with\nJulia."},{"title":"General considerations","page":"Using Valgrind with Julia","location":"devdocs/valgrind.html#General-considerations","category":"section","text":"By default, Valgrind assumes that there is no self modifying code in the programs it runs. This\nassumption works fine in most instances but fails miserably for a just-in-time compiler like\njulia. For this reason it is crucial to pass --smc-check=all-non-file to valgrind, else\ncode may crash or behave unexpectedly (often in subtle ways).\n\nIn some cases, to better detect memory errors using Valgrind, it can help to compile julia with\nmemory pools disabled. The compile-time flag MEMDEBUG disables memory pools in Julia, and\nMEMDEBUG2 disables memory pools in FemtoLisp. To build julia with both flags, add the following\nline to Make.user:\n\nCFLAGS = -DMEMDEBUG -DMEMDEBUG2\n\nAnother thing to note: if your program uses multiple worker processes, it is likely that you\nwant all such worker processes to run under Valgrind, not just the parent process. To do this,\npass --trace-children=yes to valgrind.\n\nYet another thing to note: if using valgrind errors with Unable to find compatible target in system image,\ntry rebuilding the sysimage with target generic or julia with JULIA_CPU_TARGET=generic."},{"title":"Suppressions","page":"Using Valgrind with Julia","location":"devdocs/valgrind.html#Suppressions","category":"section","text":"Valgrind will typically display spurious warnings as it runs. To reduce the number of such warnings,\nit helps to provide a suppressions file\nto Valgrind. A sample suppressions file is included in the Julia source distribution at contrib/valgrind-julia.supp.\n\nThe suppressions file can be used from the julia/ source directory as follows:\n\n$ valgrind --smc-check=all-non-file --suppressions=contrib/valgrind-julia.supp ./julia progname.jl\n\nAny memory errors that are displayed should either be reported as bugs or contributed as additional\nsuppressions. Note that some versions of Valgrind are shipped with insufficient default suppressions,\nso that may be one thing to consider before submitting any bugs."},{"title":"Running the Julia test suite under Valgrind","page":"Using Valgrind with Julia","location":"devdocs/valgrind.html#Running-the-Julia-test-suite-under-Valgrind","category":"section","text":"It is possible to run the entire Julia test suite under Valgrind, but it does take quite some\ntime (typically several hours). To do so, run the following command from the julia/test/ directory:\n\nvalgrind --smc-check=all-non-file --trace-children=yes --suppressions=$PWD/../contrib/valgrind-julia.supp ../julia runtests.jl all\n\nIf you would like to see a report of \"definite\" memory leaks, pass the flags --leak-check=full --show-leak-kinds=definite\nto valgrind as well."},{"title":"Additional spurious warnings","page":"Using Valgrind with Julia","location":"devdocs/valgrind.html#Additional-spurious-warnings","category":"section","text":"This section covers Valgrind warnings that cannot be added to the\nsuppressions file yet are nonetheless safe to ignore."},{"title":"Unhandled rr system calls","page":"Using Valgrind with Julia","location":"devdocs/valgrind.html#Unhandled-rr-system-calls","category":"section","text":"Valgrind will emit a warning if it encounters any of the [system calls\nthat are specific to\nrr](https://github.com/rr-debugger/rr/blob/master/src/preload/rrcalls.h),\nthe Record and Replay Framework. In\nparticular, a warning about an unhandled 1008 syscall will be shown\nwhen julia tries to detect whether it is running under rr:\n\n--xxxxxx-- WARNING: unhandled amd64-linux syscall: 1008\n--xxxxxx-- You may be able to write your own handler.\n--xxxxxx-- Read the file README_MISSING_SYSCALL_OR_IOCTL.\n--xxxxxx-- Nevertheless we consider this a bug.  Please report\n--xxxxxx-- it at http://valgrind.org/support/bug_reports.html.\n\nThis issue\nhas been reported\nto the Valgrind developers as they have requested."},{"title":"Caveats","page":"Using Valgrind with Julia","location":"devdocs/valgrind.html#Caveats","category":"section","text":"Valgrind currently does not support multiple rounding modes,\nso code that adjusts the rounding mode will behave differently when run under Valgrind.\n\nIn general, if after setting --smc-check=all-non-file you find that your program behaves differently\nwhen run under Valgrind, it may help to pass --tool=none to valgrind as you investigate further.\n This will enable the minimal Valgrind machinery but will also run much faster than when the full\nmemory checker is enabled."},{"title":"Workflow Tips","page":"Workflow Tips","location":"manual/workflow-tips.html#man-workflow-tips","category":"section","text":"Here are some tips for working with Julia efficiently."},{"title":"REPL-based workflow","page":"Workflow Tips","location":"manual/workflow-tips.html#REPL-based-workflow","category":"section","text":"As already elaborated in The Julia REPL, Julia's REPL provides rich functionality\nthat facilitates an efficient interactive workflow. Here are some tips that might further enhance\nyour experience at the command line."},{"title":"A basic editor/REPL workflow","page":"Workflow Tips","location":"manual/workflow-tips.html#A-basic-editor/REPL-workflow","category":"section","text":"The most basic Julia workflows involve using a text editor in conjunction with the julia command line.\n\nCreate a file, say Tmp.jl, and include within it\n\nmodule Tmp\n\nsay_hello() = println(\"Hello!\")\n\n# Your other definitions here\n\nend # module\n\nusing .Tmp\n\nThen, in the same directory, start the Julia REPL (using the julia command).\nRun the new file as follows:\n\njulia> include(\"Tmp.jl\")\n\njulia> Tmp.say_hello()\nHello!\n\nExplore ideas in the REPL. Save good ideas in Tmp.jl.\nTo reload the file after it has been changed, just include it again.\n\nThe key in the above is that your code is encapsulated in a module.\nThat allows you to edit struct definitions and remove methods, without restarting Julia.\n\n(Explanation: structs cannot be edited after definition, nor can methods be deleted.\nBut you can overwrite the definition of a module, which is what we do when we re-include(\"Tmp.jl\")).\n\nIn addition, the encapsulation of code in a module protects it from being influenced\nby previous state in the REPL, protecting you from hard-to-detect errors."},{"title":"Browser-based workflow","page":"Workflow Tips","location":"manual/workflow-tips.html#Browser-based-workflow","category":"section","text":"There are a few ways to interact with Julia in a browser:\n\nUsing Pluto notebooks through Pluto.jl\nUsing Jupyter notebooks through IJulia.jl"},{"title":"Revise-based workflows","page":"Workflow Tips","location":"manual/workflow-tips.html#Revise-based-workflows","category":"section","text":"Whether you're at the REPL or in IJulia, you can typically improve\nyour development experience with\nRevise.\nIt is common to configure Revise to start whenever julia is started,\nas per the instructions in the Revise documentation.\nOnce configured, Revise will track changes to files in any loaded modules,\nand to any files loaded in to the REPL with includet (but not with plain include);\nyou can then edit the files and the changes take effect without restarting your julia session.\nA standard workflow is similar to the REPL-based workflow above, with\nthe following modifications:\n\nPut your code in a module somewhere on your load path. There are\nseveral options for achieving this, of which two recommended choices are:\nFor long-term projects, use\nPkgTemplates:\nusing PkgTemplates\nt = Template()\nt(\"MyPkg\")\nThis will create a blank package, \"MyPkg\", in your .julia/dev directory.\nNote that PkgTemplates allows you to control many different options\nthrough its Template constructor.\nIn step 2 below, edit MyPkg/src/MyPkg.jl to change the source code, and\nMyPkg/test/runtests.jl for the tests.\nFor \"throw-away\" projects, you can avoid any need for cleanup\nby doing your work in your temporary directory (e.g., /tmp).\nNavigate to your temporary directory and launch Julia, then do the following:\npkg> generate MyPkg            # type ] to enter pkg mode\njulia> push!(LOAD_PATH, pwd())   # hit backspace to exit pkg mode\nIf you restart your Julia session you'll have to re-issue that command\nmodifying LOAD_PATH.\nIn step 2 below, edit MyPkg/src/MyPkg.jl to change the source code, and create any\ntest file of your choosing.\nDevelop your package\nBefore loading any code, make sure you're running Revise: say\nusing Revise or follow its documentation on configuring it to run\nautomatically.\nThen navigate to the directory containing your test file (here\nassumed to be \"runtests.jl\") and do the following:\njulia> using MyPkg\n\njulia> include(\"runtests.jl\")\nYou can iteratively modify the code in MyPkg in your editor and re-run the\ntests with include(\"runtests.jl\"). You generally should not need to restart\nyour Julia session to see the changes take effect (subject to a few limitations)."},{"title":"Complex and Rational Numbers","page":"Complex and Rational Numbers","location":"manual/complex-and-rational-numbers.html#Complex-and-Rational-Numbers","category":"section","text":"Julia includes predefined types for both complex and rational numbers, and supports\nall the standard Mathematical Operations and Elementary Functions on them. Conversion and Promotion are defined\nso that operations on any combination of predefined numeric types, whether primitive or composite,\nbehave as expected."},{"title":"Complex Numbers","page":"Complex and Rational Numbers","location":"manual/complex-and-rational-numbers.html#Complex-Numbers","category":"section","text":"The global constant im is bound to the complex number i, representing the principal\nsquare root of -1. (Using mathematicians' i or engineers' j for this global constant was rejected since they are such popular index variable names.) Since Julia allows numeric literals to be juxtaposed with identifiers as coefficients,\nthis binding suffices to provide convenient syntax for complex numbers, similar to the traditional\nmathematical notation:\n\njulia> 1+2im\n1 + 2im\n\nYou can perform all the standard arithmetic operations with complex numbers:\n\njulia> (1 + 2im)*(2 - 3im)\n8 + 1im\n\njulia> (1 + 2im)/(1 - 2im)\n-0.6 + 0.8im\n\njulia> (1 + 2im) + (1 - 2im)\n2 + 0im\n\njulia> (-3 + 2im) - (5 - 1im)\n-8 + 3im\n\njulia> (-1 + 2im)^2\n-3 - 4im\n\njulia> (-1 + 2im)^2.5\n2.729624464784009 - 6.9606644595719im\n\njulia> (-1 + 2im)^(1 + 1im)\n-0.27910381075826657 + 0.08708053414102428im\n\njulia> 3(2 - 5im)\n6 - 15im\n\njulia> 3(2 - 5im)^2\n-63 - 60im\n\njulia> 3(2 - 5im)^-1.0\n0.20689655172413793 + 0.5172413793103449im\n\nThe promotion mechanism ensures that combinations of operands of different types just work:\n\njulia> 2(1 - 1im)\n2 - 2im\n\njulia> (2 + 3im) - 1\n1 + 3im\n\njulia> (1 + 2im) + 0.5\n1.5 + 2.0im\n\njulia> (2 + 3im) - 0.5im\n2.0 + 2.5im\n\njulia> 0.75(1 + 2im)\n0.75 + 1.5im\n\njulia> (2 + 3im) / 2\n1.0 + 1.5im\n\njulia> (1 - 3im) / (2 + 2im)\n-0.5 - 1.0im\n\njulia> 2im^2\n-2 + 0im\n\njulia> 1 + 3/4im\n1.0 - 0.75im\n\nNote that 3/4im == 3/(4*im) == -(3/4*im), since a literal coefficient binds more tightly than\ndivision.\n\nStandard functions to manipulate complex values are provided:\n\njulia> z = 1 + 2im\n1 + 2im\n\njulia> real(1 + 2im) # real part of z\n1\n\njulia> imag(1 + 2im) # imaginary part of z\n2\n\njulia> conj(1 + 2im) # complex conjugate of z\n1 - 2im\n\njulia> abs(1 + 2im) # absolute value of z\n2.23606797749979\n\njulia> abs2(1 + 2im) # squared absolute value\n5\n\njulia> angle(1 + 2im) # phase angle in radians\n1.1071487177940904\n\nAs usual, the absolute value (abs) of a complex number is its distance from zero.\nabs2 gives the square of the absolute value, and is of particular use for complex\nnumbers since it avoids taking a square root. angle returns the phase angle in radians\n(also known as the argument or arg function). The full gamut of other Elementary Functions\nis also defined for complex numbers:\n\njulia> sqrt(1im)\n0.7071067811865476 + 0.7071067811865475im\n\njulia> sqrt(1 + 2im)\n1.272019649514069 + 0.7861513777574233im\n\njulia> cos(1 + 2im)\n2.0327230070196656 - 3.0518977991517997im\n\njulia> exp(1 + 2im)\n-1.1312043837568135 + 2.4717266720048188im\n\njulia> sinh(1 + 2im)\n-0.4890562590412937 + 1.4031192506220405im\n\nNote that mathematical functions typically return real values when applied to real numbers and\ncomplex values when applied to complex numbers. For example, sqrt behaves differently\nwhen applied to -1 versus -1 + 0im even though -1 == -1 + 0im:\n\njulia> sqrt(-1)\nERROR: DomainError with -1.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n\njulia> sqrt(-1 + 0im)\n0.0 + 1.0im\n\nThe literal numeric coefficient notation does not work when constructing a complex number\nfrom variables. Instead, the multiplication must be explicitly written out:\n\njulia> a = 1; b = 2; a + b*im\n1 + 2im\n\nHowever, this is not recommended. Instead, use the more efficient complex function to construct\na complex value directly from its real and imaginary parts:\n\njulia> a = 1; b = 2; complex(a, b)\n1 + 2im\n\nThis construction avoids the multiplication and addition operations.\n\nInf and NaN propagate through complex numbers in the real and imaginary parts\nof a complex number as described in the Special floating-point values section:\n\njulia> 1 + Inf*im\n1.0 + Inf*im\n\njulia> 1 + NaN*im\n1.0 + NaN*im"},{"title":"Rational Numbers","page":"Complex and Rational Numbers","location":"manual/complex-and-rational-numbers.html#Rational-Numbers","category":"section","text":"Julia has a rational number type to represent exact ratios of integers. Rationals are constructed\nusing the // operator:\n\njulia> 2//3\n2//3\n\nIf the numerator and denominator of a rational have common factors, they are reduced to lowest\nterms such that the denominator is non-negative:\n\njulia> 6//9\n2//3\n\njulia> -4//8\n-1//2\n\njulia> 5//-15\n-1//3\n\njulia> -4//-12\n1//3\n\nThis normalized form for a ratio of integers is unique, so equality of rational values can be\ntested by checking for equality of the numerator and denominator. The standardized numerator and\ndenominator of a rational value can be extracted using the numerator and denominator\nfunctions:\n\njulia> numerator(2//3)\n2\n\njulia> denominator(2//3)\n3\n\nDirect comparison of the numerator and denominator is generally not necessary, since the standard\narithmetic and comparison operations are defined for rational values:\n\njulia> 2//3 == 6//9\ntrue\n\njulia> 2//3 == 9//27\nfalse\n\njulia> 3//7 < 1//2\ntrue\n\njulia> 3//4 > 2//3\ntrue\n\njulia> 2//4 + 1//6\n2//3\n\njulia> 5//12 - 1//4\n1//6\n\njulia> 5//8 * 3//12\n5//32\n\njulia> 6//5 / 10//7\n21//25\n\nRationals can easily be converted to floating-point numbers:\n\njulia> float(3//4)\n0.75\n\nConversion from rational to floating-point respects the following identity for any integral values\nof a and b, except when a==0 && b <= 0:\n\njulia> a = 1; b = 2;\n\njulia> isequal(float(a//b), a/b)\ntrue\n\njulia> a, b = 0, 0\n(0, 0)\n\njulia> float(a//b)\nERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)\nStacktrace:\n[...]\n\njulia> a/b\nNaN\n\njulia> a, b = 0, -1\n(0, -1)\n\njulia> float(a//b), a/b\n(0.0, -0.0)\n\nConstructing infinite rational values is acceptable:\n\njulia> 5//0\n1//0\n\njulia> x = -3//0\n-1//0\n\njulia> typeof(x)\nRational{Int64}\n\nTrying to construct a NaN rational value, however, is invalid:\n\njulia> 0//0\nERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)\nStacktrace:\n[...]\n\nAs usual, the promotion system makes interactions with other numeric types effortless:\n\njulia> 3//5 + 1\n8//5\n\njulia> 3//5 - 0.5\n0.09999999999999998\n\njulia> 2//7 * (1 + 2im)\n2//7 + 4//7*im\n\njulia> 2//7 * (1.5 + 2im)\n0.42857142857142855 + 0.5714285714285714im\n\njulia> 3//2 / (1 + 2im)\n3//10 - 3//5*im\n\njulia> 1//2 + 2im\n1//2 + 2//1*im\n\njulia> 1 + 2//3im\n1//1 - 2//3*im\n\njulia> 0.5 == 1//2\ntrue\n\njulia> 0.33 == 1//3\nfalse\n\njulia> 0.33 < 1//3\ntrue\n\njulia> 1//3 - 0.33\n0.0033333333333332993"},{"title":"SHA","page":"SHA","location":"stdlib/SHA.html#SHA","category":"section","text":""},{"title":"SHA functions","page":"SHA","location":"stdlib/SHA.html#SHA-functions","category":"section","text":"Usage is very straightforward:\n\njulia> using SHA\n\njulia> bytes2hex(sha256(\"test\"))\n\"9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\"\n\nEach exported function (at the time of this writing, SHA-1, SHA-2 224, 256, 384 and 512, and SHA-3 224, 256, 384 and 512 functions are implemented) takes in either an AbstractVector{UInt8}, an AbstractString or an IO object.  This makes it trivial to checksum a file:\n\nshell> cat /tmp/test.txt\ntest\njulia> using SHA\n\njulia> open(\"/tmp/test.txt\") do f\n           sha2_256(f)\n       end\n32-element Vector{UInt8}:\n 0x9f\n 0x86\n 0xd0\n 0x81\n 0x88\n 0x4c\n 0x7d\n 0x65\n    ⋮\n 0x5d\n 0x6c\n 0x15\n 0xb0\n 0xf0\n 0x0a\n 0x08"},{"title":"All SHA functions","page":"SHA","location":"stdlib/SHA.html#All-SHA-functions","category":"section","text":"Due to the colloquial usage of sha256 to refer to sha2_256, convenience functions are provided, mapping shaxxx() function calls to sha2_xxx().\nFor SHA-3, no such colloquialisms exist and the user must use the full sha3_xxx() names.\n\nshaxxx() takes AbstractString and array-like objects (NTuple and Vector) with elements of type UInt8.\n\nSHA-1\n\nSHA-2\n\nSHA-3"},{"title":"Working with context","page":"SHA","location":"stdlib/SHA.html#Working-with-context","category":"section","text":"To create a hash from multiple items the SHAX_XXX_CTX() types can be used to create a stateful hash object that\nis updated with update! and finalized with digest!\n\njulia> using SHA\n\njulia> ctx = SHA2_256_CTX()\nSHA2 256-bit hash state\n\njulia> update!(ctx, b\"some data\")\n0x0000000000000009\n\njulia> update!(ctx, b\"some more data\")\n0x0000000000000017\n\njulia> digest!(ctx)\n32-element Vector{UInt8}:\n 0xbe\n 0xcf\n 0x23\n 0xda\n 0xaf\n 0x02\n 0xf7\n 0xa3\n 0x57\n 0x92\n    ⋮\n 0x89\n 0x4f\n 0x59\n 0xd8\n 0xb3\n 0xb4\n 0x81\n 0x8b\n 0xc5\n\nNote that, at the time of this writing, the SHA3 code is not optimized, and as such is roughly an order of magnitude slower than SHA2."},{"title":"All SHA context types","page":"SHA","location":"stdlib/SHA.html#All-SHA-context-types","category":"section","text":"SHA-1\n\nSHA-2\n\nConvenience types are also provided, where SHAXXX_CTX is a type alias for SHA2_XXX_CTX.\n\nSHA-3"},{"title":"HMAC functions","page":"SHA","location":"stdlib/SHA.html#HMAC-functions","category":"section","text":"julia> using SHA\n\njulia> key = collect(codeunits(\"key_string\"))\n10-element Vector{UInt8}:\n 0x6b\n 0x65\n 0x79\n 0x5f\n 0x73\n 0x74\n 0x72\n 0x69\n 0x6e\n 0x67\n\njulia> bytes2hex(hmac_sha3_256(key, \"test-message\"))\n\"bc49a6f2aa29b27ee5ed1e944edd7f3d153e8a01535d98b5e24dac9a589a6248\"\n\nTo create a hash from multiple items, the HMAC_CTX() types can be used to create a stateful hash object that\nis updated with update! and finalized with digest!.\n\njulia> using SHA\n\njulia> key = collect(codeunits(\"key_string\"))\n10-element Vector{UInt8}:\n 0x6b\n 0x65\n 0x79\n 0x5f\n 0x73\n 0x74\n 0x72\n 0x69\n 0x6e\n 0x67\n\njulia> ctx = HMAC_CTX(SHA3_256_CTX(), key);\n\njulia> update!(ctx, b\"test-\")\n0x0000000000000000000000000000008d\n\njulia> update!(ctx, b\"message\")\n0x00000000000000000000000000000094\n\njulia> bytes2hex(digest!(ctx))\n\"bc49a6f2aa29b27ee5ed1e944edd7f3d153e8a01535d98b5e24dac9a589a6248\""},{"title":"All HMAC functions","page":"SHA","location":"stdlib/SHA.html#All-HMAC-functions","category":"section","text":"HMAC context type\n\nSHA-1\n\nSHA-2\n\nSHA-3"},{"title":"SHA.sha1","page":"SHA","location":"stdlib/SHA.html#SHA.sha1","category":"function","text":"sha1(data)\n\nHash data using the sha1 algorithm and return the resulting digest.\nSee also SHA1_CTX.\n\n\n\n\n\nsha1(io::IO)\n\nHash data from io using sha1 algorithm.\n\n\n\n\n\n"},{"title":"SHA.sha224","page":"SHA","location":"stdlib/SHA.html#SHA.sha224","category":"function","text":"sha224(data)\n\nHash data using the sha224 algorithm and return the resulting digest.\nSee also SHA2_224_CTX.\n\n\n\n\n\nsha224(io::IO)\n\nHash data from io using sha224 algorithm.\n\n\n\n\n\n"},{"title":"SHA.sha256","page":"SHA","location":"stdlib/SHA.html#SHA.sha256","category":"function","text":"sha256(data)\n\nHash data using the sha256 algorithm and return the resulting digest.\nSee also SHA2_256_CTX.\n\n\n\n\n\nsha256(io::IO)\n\nHash data from io using sha256 algorithm.\n\n\n\n\n\n"},{"title":"SHA.sha384","page":"SHA","location":"stdlib/SHA.html#SHA.sha384","category":"function","text":"sha384(data)\n\nHash data using the sha384 algorithm and return the resulting digest.\nSee also SHA2_384_CTX.\n\n\n\n\n\nsha384(io::IO)\n\nHash data from io using sha384 algorithm.\n\n\n\n\n\n"},{"title":"SHA.sha512","page":"SHA","location":"stdlib/SHA.html#SHA.sha512","category":"function","text":"sha512(data)\n\nHash data using the sha512 algorithm and return the resulting digest.\nSee also SHA2_512_CTX.\n\n\n\n\n\nsha512(io::IO)\n\nHash data from io using sha512 algorithm.\n\n\n\n\n\n"},{"title":"SHA.sha2_224","page":"SHA","location":"stdlib/SHA.html#SHA.sha2_224","category":"function","text":"sha2_224(data)\n\nHash data using the sha2_224 algorithm and return the resulting digest.\nSee also SHA2_224_CTX.\n\n\n\n\n\nsha2_224(io::IO)\n\nHash data from io using sha2_224 algorithm.\n\n\n\n\n\n"},{"title":"SHA.sha2_256","page":"SHA","location":"stdlib/SHA.html#SHA.sha2_256","category":"function","text":"sha2_256(data)\n\nHash data using the sha2_256 algorithm and return the resulting digest.\nSee also SHA2_256_CTX.\n\n\n\n\n\nsha2_256(io::IO)\n\nHash data from io using sha2_256 algorithm.\n\n\n\n\n\n"},{"title":"SHA.sha2_384","page":"SHA","location":"stdlib/SHA.html#SHA.sha2_384","category":"function","text":"sha2_384(data)\n\nHash data using the sha2_384 algorithm and return the resulting digest.\nSee also SHA2_384_CTX.\n\n\n\n\n\nsha2_384(io::IO)\n\nHash data from io using sha2_384 algorithm.\n\n\n\n\n\n"},{"title":"SHA.sha2_512","page":"SHA","location":"stdlib/SHA.html#SHA.sha2_512","category":"function","text":"sha2_512(data)\n\nHash data using the sha2_512 algorithm and return the resulting digest.\nSee also SHA2_512_CTX.\n\n\n\n\n\nsha2_512(io::IO)\n\nHash data from io using sha2_512 algorithm.\n\n\n\n\n\n"},{"title":"SHA.sha2_512_224","page":"SHA","location":"stdlib/SHA.html#SHA.sha2_512_224","category":"function","text":"sha2_512_224(data)\n\nHash data using the sha2_512_224 algorithm and return the resulting digest.\nSee also SHA2_512_224_CTX.\n\n\n\n\n\nsha2_512_224(io::IO)\n\nHash data from io using sha2_512_224 algorithm.\n\n\n\n\n\n"},{"title":"SHA.sha2_512_256","page":"SHA","location":"stdlib/SHA.html#SHA.sha2_512_256","category":"function","text":"sha2_512_256(data)\n\nHash data using the sha2_512_256 algorithm and return the resulting digest.\nSee also SHA2_512_256_CTX.\n\n\n\n\n\nsha2_512_256(io::IO)\n\nHash data from io using sha2_512_256 algorithm.\n\n\n\n\n\n"},{"title":"SHA.sha3_224","page":"SHA","location":"stdlib/SHA.html#SHA.sha3_224","category":"function","text":"sha3_224(data)\n\nHash data using the sha3_224 algorithm and return the resulting digest.\nSee also SHA3_224_CTX.\n\n\n\n\n\nsha3_224(io::IO)\n\nHash data from io using sha3_224 algorithm.\n\n\n\n\n\n"},{"title":"SHA.sha3_256","page":"SHA","location":"stdlib/SHA.html#SHA.sha3_256","category":"function","text":"sha3_256(data)\n\nHash data using the sha3_256 algorithm and return the resulting digest.\nSee also SHA3_256_CTX.\n\n\n\n\n\nsha3_256(io::IO)\n\nHash data from io using sha3_256 algorithm.\n\n\n\n\n\n"},{"title":"SHA.sha3_384","page":"SHA","location":"stdlib/SHA.html#SHA.sha3_384","category":"function","text":"sha3_384(data)\n\nHash data using the sha3_384 algorithm and return the resulting digest.\nSee also SHA3_384_CTX.\n\n\n\n\n\nsha3_384(io::IO)\n\nHash data from io using sha3_384 algorithm.\n\n\n\n\n\n"},{"title":"SHA.sha3_512","page":"SHA","location":"stdlib/SHA.html#SHA.sha3_512","category":"function","text":"sha3_512(data)\n\nHash data using the sha3_512 algorithm and return the resulting digest.\nSee also SHA3_512_CTX.\n\n\n\n\n\nsha3_512(io::IO)\n\nHash data from io using sha3_512 algorithm.\n\n\n\n\n\n"},{"title":"SHA.update!","page":"SHA","location":"stdlib/SHA.html#SHA.update!","category":"function","text":"update!(context, data[, datalen])\n\nUpdate the SHA context with the bytes in data. See also digest! for\nfinalizing the hash.\n\nExamples\n\njulia> ctx = SHA1_CTX()\nSHA1 hash state\n\njulia> update!(ctx, b\"data to to be hashed\")\n\n\n\n\n\n"},{"title":"SHA.digest!","page":"SHA","location":"stdlib/SHA.html#SHA.digest!","category":"function","text":"digest!(context)\n\nFinalize the SHA context and return the hash as array of bytes (Vector{Uint8}).\nUpdating the context after calling digest! on it will error.\n\nExamples\n\njulia> ctx = SHA1_CTX()\nSHA1 hash state\n\njulia> update!(ctx, b\"data to to be hashed\")\n\njulia> digest!(ctx)\n20-element Vector{UInt8}:\n 0x83\n 0xe4\n ⋮\n 0x89\n 0xf5\n\njulia> update!(ctx, b\"more data\")\nERROR: Cannot update CTX after `digest!` has been called on it\n[...]\n\n\n\n\n\n"},{"title":"SHA.SHA1_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.SHA1_CTX","category":"type","text":"SHA1_CTX()\n\nConstruct an empty SHA1 context.\n\n\n\n\n\n"},{"title":"SHA.SHA224_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.SHA224_CTX","category":"type","text":"SHA2_224_CTX()\n\nConstruct an empty SHA2_224 context.\n\n\n\n\n\n"},{"title":"SHA.SHA256_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.SHA256_CTX","category":"type","text":"SHA2_256_CTX()\n\nConstruct an empty SHA2_256 context.\n\n\n\n\n\n"},{"title":"SHA.SHA384_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.SHA384_CTX","category":"type","text":"SHA2_384()\n\nConstruct an empty SHA2_384 context.\n\n\n\n\n\n"},{"title":"SHA.SHA512_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.SHA512_CTX","category":"type","text":"SHA2_512_CTX()\n\nConstruct an empty SHA2_512 context.\n\n\n\n\n\n"},{"title":"SHA.SHA2_224_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.SHA2_224_CTX","category":"type","text":"SHA2_224_CTX()\n\nConstruct an empty SHA2_224 context.\n\n\n\n\n\n"},{"title":"SHA.SHA2_256_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.SHA2_256_CTX","category":"type","text":"SHA2_256_CTX()\n\nConstruct an empty SHA2_256 context.\n\n\n\n\n\n"},{"title":"SHA.SHA2_384_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.SHA2_384_CTX","category":"type","text":"SHA2_384()\n\nConstruct an empty SHA2_384 context.\n\n\n\n\n\n"},{"title":"SHA.SHA2_512_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.SHA2_512_CTX","category":"type","text":"SHA2_512_CTX()\n\nConstruct an empty SHA2_512 context.\n\n\n\n\n\n"},{"title":"SHA.SHA2_512_224_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.SHA2_512_224_CTX","category":"type","text":"SHA2_512_224_CTX()\n\nConstruct an empty SHA2_512/224 context and set the initial hash value.\n\nFor the source of the initial value,\nrefer to FIPS 180-4, 5.3.6.1 SHA-512/224\n\n\n\n\n\n"},{"title":"SHA.SHA2_512_256_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.SHA2_512_256_CTX","category":"type","text":"SHA2_512_256_CTX()\n\nConstruct an empty SHA2_512/256 context and set the initial hash value.\n\nFor the source of the initial value,\nrefer to FIPS 180-4, 5.3.6.2 SHA-512/256\n\n\n\n\n\n"},{"title":"SHA.SHA3_224_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.SHA3_224_CTX","category":"type","text":"SHA3_224_CTX()\n\nConstruct an empty SHA3_224 context.\n\n\n\n\n\n"},{"title":"SHA.SHA3_256_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.SHA3_256_CTX","category":"type","text":"SHA3_256_CTX()\n\nConstruct an empty SHA3_256 context.\n\n\n\n\n\n"},{"title":"SHA.SHA3_384_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.SHA3_384_CTX","category":"type","text":"SHA3_384_CTX()\n\nConstruct an empty SHA3_384 context.\n\n\n\n\n\n"},{"title":"SHA.SHA3_512_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.SHA3_512_CTX","category":"type","text":"SHA3_512_CTX()\n\nConstruct an empty SHA3_512 context.\n\n\n\n\n\n"},{"title":"SHA.HMAC_CTX","page":"SHA","location":"stdlib/SHA.html#SHA.HMAC_CTX","category":"type","text":"HMAC_CTX(ctx::CTX, key::Vector{UInt8}) where {CTX<:SHA_CTX}\n\nConstruct an empty HMAC_CTX context.\n\n\n\n\n\n"},{"title":"SHA.hmac_sha1","page":"SHA","location":"stdlib/SHA.html#SHA.hmac_sha1","category":"function","text":"hmac_sha1(key, data)\n\nHash data using the sha1 algorithm using the passed key.\nSee also HMAC_CTX.\n\n\n\n\n\nhmac_sha1(key, io::IO)\n\nHash data from io with the passed key using sha1 algorithm.\n\n\n\n\n\n"},{"title":"SHA.hmac_sha224","page":"SHA","location":"stdlib/SHA.html#SHA.hmac_sha224","category":"function","text":"hmac_sha224(key, data)\n\nHash data using the sha224 algorithm using the passed key.\nSee also HMAC_CTX.\n\n\n\n\n\nhmac_sha224(key, io::IO)\n\nHash data from io with the passed key using sha224 algorithm.\n\n\n\n\n\n"},{"title":"SHA.hmac_sha256","page":"SHA","location":"stdlib/SHA.html#SHA.hmac_sha256","category":"function","text":"hmac_sha256(key, data)\n\nHash data using the sha256 algorithm using the passed key.\nSee also HMAC_CTX.\n\n\n\n\n\nhmac_sha256(key, io::IO)\n\nHash data from io with the passed key using sha256 algorithm.\n\n\n\n\n\n"},{"title":"SHA.hmac_sha384","page":"SHA","location":"stdlib/SHA.html#SHA.hmac_sha384","category":"function","text":"hmac_sha384(key, data)\n\nHash data using the sha384 algorithm using the passed key.\nSee also HMAC_CTX.\n\n\n\n\n\nhmac_sha384(key, io::IO)\n\nHash data from io with the passed key using sha384 algorithm.\n\n\n\n\n\n"},{"title":"SHA.hmac_sha512","page":"SHA","location":"stdlib/SHA.html#SHA.hmac_sha512","category":"function","text":"hmac_sha512(key, data)\n\nHash data using the sha512 algorithm using the passed key.\nSee also HMAC_CTX.\n\n\n\n\n\nhmac_sha512(key, io::IO)\n\nHash data from io with the passed key using sha512 algorithm.\n\n\n\n\n\n"},{"title":"SHA.hmac_sha2_224","page":"SHA","location":"stdlib/SHA.html#SHA.hmac_sha2_224","category":"function","text":"hmac_sha2_224(key, data)\n\nHash data using the sha2_224 algorithm using the passed key.\nSee also HMAC_CTX.\n\n\n\n\n\nhmac_sha2_224(key, io::IO)\n\nHash data from io with the passed key using sha2_224 algorithm.\n\n\n\n\n\n"},{"title":"SHA.hmac_sha2_256","page":"SHA","location":"stdlib/SHA.html#SHA.hmac_sha2_256","category":"function","text":"hmac_sha2_256(key, data)\n\nHash data using the sha2_256 algorithm using the passed key.\nSee also HMAC_CTX.\n\n\n\n\n\nhmac_sha2_256(key, io::IO)\n\nHash data from io with the passed key using sha2_256 algorithm.\n\n\n\n\n\n"},{"title":"SHA.hmac_sha2_384","page":"SHA","location":"stdlib/SHA.html#SHA.hmac_sha2_384","category":"function","text":"hmac_sha2_384(key, data)\n\nHash data using the sha2_384 algorithm using the passed key.\nSee also HMAC_CTX.\n\n\n\n\n\nhmac_sha2_384(key, io::IO)\n\nHash data from io with the passed key using sha2_384 algorithm.\n\n\n\n\n\n"},{"title":"SHA.hmac_sha2_512","page":"SHA","location":"stdlib/SHA.html#SHA.hmac_sha2_512","category":"function","text":"hmac_sha2_512(key, data)\n\nHash data using the sha2_512 algorithm using the passed key.\nSee also HMAC_CTX.\n\n\n\n\n\nhmac_sha2_512(key, io::IO)\n\nHash data from io with the passed key using sha2_512 algorithm.\n\n\n\n\n\n"},{"title":"SHA.hmac_sha3_224","page":"SHA","location":"stdlib/SHA.html#SHA.hmac_sha3_224","category":"function","text":"hmac_sha3_224(key, data)\n\nHash data using the sha3_224 algorithm using the passed key.\nSee also HMAC_CTX.\n\n\n\n\n\nhmac_sha3_224(key, io::IO)\n\nHash data from io with the passed key using sha3_224 algorithm.\n\n\n\n\n\n"},{"title":"SHA.hmac_sha3_256","page":"SHA","location":"stdlib/SHA.html#SHA.hmac_sha3_256","category":"function","text":"hmac_sha3_256(key, data)\n\nHash data using the sha3_256 algorithm using the passed key.\nSee also HMAC_CTX.\n\n\n\n\n\nhmac_sha3_256(key, io::IO)\n\nHash data from io with the passed key using sha3_256 algorithm.\n\n\n\n\n\n"},{"title":"SHA.hmac_sha3_384","page":"SHA","location":"stdlib/SHA.html#SHA.hmac_sha3_384","category":"function","text":"hmac_sha3_384(key, data)\n\nHash data using the sha3_384 algorithm using the passed key.\nSee also HMAC_CTX.\n\n\n\n\n\nhmac_sha3_384(key, io::IO)\n\nHash data from io with the passed key using sha3_384 algorithm.\n\n\n\n\n\n"},{"title":"SHA.hmac_sha3_512","page":"SHA","location":"stdlib/SHA.html#SHA.hmac_sha3_512","category":"function","text":"hmac_sha3_512(key, data)\n\nHash data using the sha3_512 algorithm using the passed key.\nSee also HMAC_CTX.\n\n\n\n\n\nhmac_sha3_512(key, io::IO)\n\nHash data from io with the passed key using sha3_512 algorithm.\n\n\n\n\n\n"},{"title":"LibCURL","page":"LibCURL","location":"stdlib/LibCURL.html#LibCURL","category":"section","text":"This is a simple Julia wrapper around http://curl.haxx.se/libcurl/ generated using Clang.jl. \nPlease see the libcurl API documentation for help on how to use this package."},{"title":"JIT Design and Implementation","page":"JIT Design and Implementation","location":"devdocs/jit.html#JIT-Design-and-Implementation","category":"section","text":"This document explains the design and implementation of Julia's JIT, after codegen has finished and unoptimized LLVM IR has been produced. The JIT is responsible for optimizing and compiling this IR to machine code, and for linking it into the current process and making the code available for execution."},{"title":"Introduction","page":"JIT Design and Implementation","location":"devdocs/jit.html#Introduction","category":"section","text":"The JIT is responsible for managing compilation resources, looking up previously compiled code, and compiling new code. It is primarily built on LLVM's On-Request-Compilation (ORCv2) technology, which provides support for a number of useful features such as concurrent compilation, lazy compilation, and the ability to compile code in a separate process. Though LLVM provides a basic JIT compiler in the form of LLJIT, Julia uses many ORCv2 APIs directly to create its own custom JIT compiler."},{"title":"Overview","page":"JIT Design and Implementation","location":"devdocs/jit.html#Overview","category":"section","text":"(Image: Diagram of the compiler flow)\n\nCodegen produces an LLVM module containing IR for one or more Julia functions from the original Julia SSA IR produced by type inference (labeled as translate on the compiler diagram above). It also produces a mapping of code-instance to LLVM function name. However, though some optimizations have been applied by the Julia-based compiler on Julia IR, the LLVM IR produced by codegen still contains many opportunities for optimization. Thus, the first step the JIT takes is to run a target-independent optimization pipeline[tdp] on the LLVM module. Then, the JIT runs a target-dependent optimization pipeline, which includes target-specific optimizations and code generation, and outputs an object file. Finally, the JIT links the resulting object file into the current process and makes the code available for execution. All of this is controlled by code in src/jitlayers.cpp.\n\n[tdp]: This is not a totally-target independent pipeline, as transformations such as vectorization rely upon target information such as vector register width and cost modeling. Additionally, codegen itself makes a few target-dependent assumptions, and the optimization pipeline will take advantage of that knowledge.\n\nCurrently, only one thread at a time is permitted to enter the optimize-compile-link pipeline at a time, due to restrictions imposed by one of our linkers (RuntimeDyld). However, the JIT is designed to support concurrent optimization and compilation, and the linker restriction is expected to be lifted in the future when RuntimeDyld has been fully superseded on all platforms."},{"title":"Optimization Pipeline","page":"JIT Design and Implementation","location":"devdocs/jit.html#Optimization-Pipeline","category":"section","text":"The optimization pipeline is based off LLVM's new pass manager, but the pipeline is customized for Julia's needs. The pipeline is defined in src/pipeline.cpp, and broadly proceeds through a number of stages as detailed below.\n\nEarly Simplification\nThese passes are mainly used to simplify the IR and canonicalize patterns so that later passes can identify those patterns more easily. Additionally, various intrinsic calls such as branch prediction hints and annotations are lowered into other metadata or other IR features. SimplifyCFG (simplify control flow graph), DCE (dead code elimination), and SROA (scalar replacement of aggregates) are some of the key players here.\nEarly Optimization\nThese passes are typically cheap and are primarily focused around reducing the number of instructions in the IR and propagating knowledge to other instructions. For example, EarlyCSE is used to perform common subexpression elimination, and InstCombine and InstSimplify perform a number of small peephole optimizations to make operations less expensive.\nLoop Optimization\nThese passes canonicalize and simplify loops. Loops are often hot code, which makes loop optimization extremely important for performance. Key players here include LoopRotate, LICM, and LoopFullUnroll. Some bounds check elimination also happens here, as a result of the IRCE pass which can prove certain bounds are never exceeded.\nScalar Optimization\nThe scalar optimization pipeline contains a number of more expensive, but more powerful passes such as GVN (global value numbering), SCCP (sparse conditional constant propagation), and another round of bounds check elimination. These passes are expensive, but they can often remove large amounts of code and make vectorization much more successful and effective. Several other simplification and optimization passes intersperse the more expensive ones to reduce the amount of work they have to do.\nVectorization\nAutomatic vectorization is an extremely powerful transformation for CPU-intensive code. Briefly, vectorization allows execution of a single instruction on multiple data (SIMD), e.g. performing 8 addition operations at the same time. However, proving code to be both capable of vectorization and profitable to vectorize is difficult, and this relies heavily on the prior optimization passes to massage the IR into a state where vectorization is worth it.\nIntrinsic Lowering\nJulia inserts a number of custom intrinsics, for reasons such as object allocation, garbage collection, and exception handling. These intrinsics were originally placed to make optimization opportunities more obvious, but they are now lowered into LLVM IR to enable the IR to be emitted as machine code.\nCleanup\nThese passes are last-chance optimizations, and perform small optimizations such as fused multiply-add propagation and division-remainder simplification. Additionally, targets that do not support half-precision floating point numbers will have their half-precision instructions lowered into single-precision instructions here, and passes are added to provide sanitizer support."},{"title":"Target-Dependent Optimization and Code Generation","page":"JIT Design and Implementation","location":"devdocs/jit.html#Target-Dependent-Optimization-and-Code-Generation","category":"section","text":"LLVM provides target-dependent optimization and machine code generation in the same pipeline, located in the TargetMachine for a given platform. These passes include instruction selection, instruction scheduling, register allocation, and machine code emission. The LLVM documentation provides a good overview of the process, and the LLVM source code is the best place to look for details on the pipeline and passes."},{"title":"Linking","page":"JIT Design and Implementation","location":"devdocs/jit.html#Linking","category":"section","text":"Currently, Julia is transitioning between two linkers: the older RuntimeDyld linker, and the newer JITLink linker. JITLink contains a number of features that RuntimeDyld does not have, such as concurrent and reentrant linking, but currently lacks good support for profiling integrations and does not yet support all of the platforms that RuntimeDyld supports. Over time, JITLink is expected to replace RuntimeDyld entirely. Further details on JITLink can be found in the LLVM documentation."},{"title":"Execution","page":"JIT Design and Implementation","location":"devdocs/jit.html#Execution","category":"section","text":"Once the code has been linked into the current process, it is available for execution. This fact is made known to the generating codeinst by updating the invoke, specsigflags, and specptr fields appropriately. Codeinsts support upgrading invoke, specsigflags, and specptr fields, so long as every combination of these fields that exists at any given point in time is valid to be called. This allows the JIT to update these fields without invalidating existing codeinsts, supporting a potential future concurrent JIT. Specifically, the following states may be valid:\n\ninvoke is NULL, specsigflags is 0b00, specptr is NULL\nThis is the initial state of a codeinst, and indicates that the codeinst has not yet been compiled.\ninvoke is non-null, specsigflags is 0b00, specptr is NULL\nThis indicates that the codeinst was not compiled with any specialization, and that the codeinst should be invoked directly. Note that in this instance, invoke does not read either the specsigflags or specptr fields, and therefore they may be modified without invalidating the invoke pointer.\ninvoke is non-null, specsigflags is 0b10, specptr is non-null\nThis indicates that the codeinst was compiled, but a specialized function signature was deemed unnecessary by codegen.\ninvoke is non-null, specsigflags is 0b11, specptr is non-null\nThis indicates that the codeinst was compiled, and a specialized function signature was deemed necessary by codegen. The specptr field contains a pointer to the specialized function signature. The invoke pointer is permitted to read both specsigflags and specptr fields.\n\nIn addition, there are a number of different transitional states that occur during the update process. To account for these potential situations, the following write and read patterns should be used when dealing with these codeinst fields.\n\nWhen writing invoke, specsigflags, and specptr:\nPerform an atomic compare-exchange operation of specptr assuming the old value was NULL. This compare-exchange operation should have at least acquire-release ordering, to provide ordering guarantees of the remaining memory operations in the write.\nIf specptr was non-null, cease the write operation and wait for bit 0b10 of specsigflags to be written, then restart from step 1 if desired.\nWrite the new low bit of specsigflags to its final value. This may be a relaxed write.\nWrite the new invoke pointer to its final value. This must have at least a release memory ordering to synchronize with reads of invoke.\nSet the second bit of specsigflags to 1. This must be at least a release memory ordering to synchronize with reads of specsigflags. This step completes the write operation and announces to all other threads that all fields have been set.\nWhen reading all of invoke, specsigflags, and specptr:\nRead the specptr field with any memory ordering.\nRead the invoke field with at least an acquire memory ordering. This load will be referred to as initial_invoke.\nIf initial_invoke is NULL, the codeinst is not yet executable. invoke is NULL, specsigflags may be treated as 0b00, specptr may be treated as NULL.\nIf specptr is NULL, then the initial_invoke pointer must not be relying on specptr to guarantee correct execution. Therefore, invoke is non-null, specsigflags may be treated as 0b00, specptr may be treated as NULL.\nIf specptr is non-null, then initial_invoke might not be the final invoke field that uses specptr. This can occur if specptr has been written, but invoke has not yet been written. Therefore, spin on the second bit of specsigflags until it is set to 1 with at least acquire memory ordering.\nRe-read the invoke field with any memory ordering. This load will be referred to as final_invoke.\nRead the specsigflags field with any memory ordering.\ninvoke is final_invoke, specsigflags is the value read in step 7, specptr is the value read in step 3.\nWhen updating a specptr to a different but equivalent function pointer:\nPerform a release store of the new function pointer to specptr. Races here must be benign, as the old function pointer is required to still be valid, and any new ones are also required to be valid as well. Once a pointer has been written to specptr, it must always be callable whether or not it is later overwritten.\n\nCorrectly reading these fields is implemented in jl_read_codeinst_invoke.\n\nAlthough these write, read, and update steps are complicated, they ensure that the JIT can update codeinsts without invalidating existing codeinsts, and that the JIT can update codeinsts without invalidating existing invoke pointers. This allows the JIT to potentially reoptimize functions at higher optimization levels in the future, and also will allow the JIT to support concurrent compilation of functions in the future."},{"title":"Working with LLVM","page":"Working with LLVM","location":"devdocs/llvm.html#Working-with-LLVM","category":"section","text":"This is not a replacement for the LLVM documentation, but a collection of tips for working on\nLLVM for Julia."},{"title":"Overview of Julia to LLVM Interface","page":"Working with LLVM","location":"devdocs/llvm.html#Overview-of-Julia-to-LLVM-Interface","category":"section","text":"Julia dynamically links against LLVM by default. Build with USE_LLVM_SHLIB=0 to link statically.\n\nThe code for lowering Julia AST to LLVM IR or interpreting it directly is in directory src/.\n\nFile Description\naotcompile.cpp Compiler C-interface entry and object file emission\nbuiltins.c Builtin functions\nccall.cpp Lowering ccall\ncgutils.cpp Lowering utilities, notably for array and tuple accesses\ncodegen.cpp Top-level of code generation, pass list, lowering builtins\ndebuginfo.cpp Tracks debug information for JIT code\ndisasm.cpp Handles native object file and JIT code disassembly\ngf.c Generic functions\nintrinsics.cpp Lowering intrinsics\njitlayers.cpp JIT-specific code, ORC compilation layers/utilities\nllvm-alloc-helpers.cpp Julia-specific escape analysis\nllvm-alloc-opt.cpp Custom LLVM pass to demote heap allocations to the stack\nllvm-cpufeatures.cpp Custom LLVM pass to lower CPU-based functions (e.g. haveFMA)\nllvm-demote-float16.cpp Custom LLVM pass to lower 16b float ops to 32b float ops\nllvm-final-gc-lowering.cpp Custom LLVM pass to lower GC calls to their final form\nllvm-gc-invariant-verifier.cpp Custom LLVM pass to verify Julia GC invariants\nllvm-julia-licm.cpp Custom LLVM pass to hoist/sink Julia-specific intrinsics\nllvm-late-gc-lowering.cpp Custom LLVM pass to root GC-tracked values\nllvm-multiversioning.cpp Custom LLVM pass to generate sysimg code on multiple architectures\nllvm-propagate-addrspaces.cpp Custom LLVM pass to canonicalize addrspaces\nllvm-ptls.cpp Custom LLVM pass to lower TLS operations\nllvm-remove-addrspaces.cpp Custom LLVM pass to remove Julia addrspaces\nllvm-remove-ni.cpp Custom LLVM pass to remove Julia non-integral addrspaces\nllvm-simdloop.cpp Custom LLVM pass for @simd\npipeline.cpp New pass manager pipeline, pass pipeline parsing\nsys.c I/O and operating system utility functions\n\nSome of the .cpp files form a group that compile to a single object.\n\nThe difference between an intrinsic and a builtin is that a builtin is a first class function\nthat can be used like any other Julia function. An intrinsic can operate only on unboxed data,\nand therefore its arguments must be statically typed."},{"title":"Alias Analysis","page":"Working with LLVM","location":"devdocs/llvm.html#LLVM-Alias-Analysis","category":"section","text":"Julia currently uses LLVM's Type Based Alias Analysis.\nTo find the comments that document the inclusion relationships, look for static MDNode* in\nsrc/codegen.cpp.\n\nThe -O option enables LLVM's Basic Alias Analysis."},{"title":"Building Julia with a different version of LLVM","page":"Working with LLVM","location":"devdocs/llvm.html#Building-Julia-with-a-different-version-of-LLVM","category":"section","text":"The default version of LLVM is specified in deps/llvm.version. You can override it by creating\na file called Make.user in the top-level directory and adding a line to it such as:\n\nLLVM_VER = 13.0.0\n\nBesides the LLVM release numerals, you can also use DEPS_GIT = llvm in combination with\nUSE_BINARYBUILDER_LLVM = 0 to build against the latest development version of LLVM.\n\nYou can also specify to build a debug version of LLVM, by setting either LLVM_DEBUG = 1 or\nLLVM_DEBUG = Release in your Make.user file. The former will be a fully unoptimized build\nof LLVM and the latter will produce an optimized build of LLVM. Depending on your needs the\nlatter will suffice and it quite a bit faster. If you use LLVM_DEBUG = Release you will also\nwant to set LLVM_ASSERTIONS = 1 to enable diagnostics for different passes. Only LLVM_DEBUG = 1\nimplies that option by default."},{"title":"Passing options to LLVM","page":"Working with LLVM","location":"devdocs/llvm.html#Passing-options-to-LLVM","category":"section","text":"You can pass options to LLVM via the environment variable JULIA_LLVM_ARGS.\nHere are example settings using bash syntax:\n\nexport JULIA_LLVM_ARGS=-print-after-all dumps IR after each pass.\nexport JULIA_LLVM_ARGS=-debug-only=loop-vectorize dumps LLVM DEBUG(...) diagnostics for\nloop vectorizer. If you get warnings about \"Unknown command line argument\", rebuild LLVM with\nLLVM_ASSERTIONS = 1.\nexport JULIA_LLVM_ARGS=-help shows a list of available options. export JULIA_LLVM_ARGS=-help-hidden shows even more.\nexport JULIA_LLVM_ARGS=\"-fatal-warnings -print-options\" is an example how to use multiple options."},{"title":"Useful JULIA_LLVM_ARGS parameters","page":"Working with LLVM","location":"devdocs/llvm.html#Useful-JULIA_LLVM_ARGS-parameters","category":"section","text":"-print-after=PASS: prints the IR after any execution of PASS, useful for checking changes done by a pass.\n-print-before=PASS: prints the IR before any execution of PASS, useful for checking the input to a pass.\n-print-changed: prints the IR whenever a pass changes the IR, useful for narrowing down which passes are causing problems.\n-print-(before|after)=MARKER-PASS: the Julia pipeline ships with a number of marker passes in the pipeline, which can be used to identify where problems or optimizations are occurring. A marker pass is defined as a pass which appears once in the pipeline and performs no transformations on the IR, and is only useful for targeting print-before/print-after. Currently, the following marker passes exist in the pipeline:\nBeforeOptimization\nBeforeEarlySimplification\nAfterEarlySimplification\nBeforeEarlyOptimization\nAfterEarlyOptimization\nBeforeLoopOptimization\nBeforeLICM\nAfterLICM\nBeforeLoopSimplification\nAfterLoopSimplification\nAfterLoopOptimization\nBeforeScalarOptimization\nAfterScalarOptimization\nBeforeVectorization\nAfterVectorization\nBeforeIntrinsicLowering\nAfterIntrinsicLowering\nBeforeCleanup\nAfterCleanup\nAfterOptimization\n-time-passes: prints the time spent in each pass, useful for identifying which passes are taking a long time.\n-print-module-scope: used in conjunction with -print-(before|after), gets the entire module rather than the IR unit received by the pass\n-debug: prints out a lot of debugging information throughout LLVM\n-debug-only=NAME, prints out debugging statements from files with DEBUG_TYPE defined to NAME, useful for getting additional context about a problem"},{"title":"Debugging LLVM transformations in isolation","page":"Working with LLVM","location":"devdocs/llvm.html#Debugging-LLVM-transformations-in-isolation","category":"section","text":"On occasion, it can be useful to debug LLVM's transformations in isolation from\nthe rest of the Julia system, e.g. because reproducing the issue inside julia\nwould take too long, or because one wants to take advantage of LLVM's tooling\n(e.g. bugpoint).\n\nTo start with, you can install the developer tools to work with LLVM via:\n\nmake -C deps install-llvm-tools\n\nTo get unoptimized IR for the entire system image, pass the\n--output-unopt-bc unopt.bc option to the system image build process, which will\noutput the unoptimized IR to an unopt.bc file. This file can then be passed to\nLLVM tools as usual. libjulia can function as an LLVM pass plugin and can be\nloaded into LLVM tools, to make julia-specific passes available in this\nenvironment. In addition, it exposes the -julia meta-pass, which runs the\nentire Julia pass-pipeline over the IR. As an example, to generate a system\nimage with the old pass manager, one could do:\n\n\nllc -o sys.o opt.bc\ncc -shared -o sys.so sys.o\n\nTo generate a system image with the new pass manager, one could do:\n\n./usr/tools/opt -load-pass-plugin=libjulia-codegen.so --passes='julia' -o opt.bc unopt.bc\n./usr/tools/llc -o sys.o opt.bc\n./usr/tools/cc -shared -o sys.so sys.o\n\nThis system image can then be loaded by julia as usual.\n\nIt is also possible to dump an LLVM IR module for just one Julia function,\nusing:\n\nfun, T = +, Tuple{Int,Int} # Substitute your function of interest here\noptimize = false\nopen(\"plus.ll\", \"w\") do file\n    code_llvm(file, fun, T; raw=true, dump_module=true, optimize)\nend\n\nThese files can be processed the same way as the unoptimized sysimg IR shown\nabove, or if you want to see the LLVM IR yourself and get extra verification run, you can use\n\n./usr/tools/opt -load-pass-plugin=libjulia-codegen.so --passes='julia' -S -verify-each plus.ll\n\n(note on MacOS this would be libjulia-codegen.dylib and on Windows libjulia-codegen.dll)"},{"title":"Running the LLVM test suite","page":"Working with LLVM","location":"devdocs/llvm.html#Running-the-LLVM-test-suite","category":"section","text":"To run the llvm tests locally, you need to first install the tools, build julia, then you\ncan run the tests:\n\nmake -C deps install-llvm-tools\nmake -j julia-src-release\nmake -C test/llvmpasses\n\nIf you want to run the individual test files directly, via the commands at the top of each\ntest file, the first step here will have installed the tools into ./usr/tools/opt. Then\nyou'll want to manually replace %s with the name of the test file."},{"title":"Improving LLVM optimizations for Julia","page":"Working with LLVM","location":"devdocs/llvm.html#Improving-LLVM-optimizations-for-Julia","category":"section","text":"Improving LLVM code generation usually involves either changing Julia lowering to be more friendly\nto LLVM's passes, or improving a pass.\n\nIf you are planning to improve a pass, be sure to read the LLVM developer policy.\nThe best strategy is to create a code example in a form where you can use LLVM's opt tool to\nstudy it and the pass of interest in isolation.\n\nCreate an example Julia code of interest.\nUse JULIA_LLVM_ARGS=-print-after-all to dump the IR.\nPick out the IR at the point just before the pass of interest runs.\nStrip the debug metadata and fix up the TBAA metadata by hand.\n\nThe last step is labor intensive. Suggestions on a better way would be appreciated."},{"title":"The jlcall calling convention","page":"Working with LLVM","location":"devdocs/llvm.html#The-jlcall-calling-convention","category":"section","text":"Julia has a generic calling convention for unoptimized code, which looks somewhat\nas follows:\n\njl_value_t *any_unoptimized_call(jl_value_t *, jl_value_t **, int);\n\nwhere the first argument is the boxed function object, the second argument is\nan on-stack array of arguments and the third is the number of arguments. Now,\nwe could perform a straightforward lowering and emit an alloca for the argument\narray. However, this would betray the SSA nature of the uses at the call site,\nmaking optimizations (including GC root placement), significantly harder.\nInstead, we emit it as follows:\n\ncall %jl_value_t *@julia.call(jl_value_t *(*)(...) @any_unoptimized_call, %jl_value_t *%arg1, %jl_value_t *%arg2)\n\nThis allows us to retain the SSA-ness of the\nuses throughout the optimizer. GC root placement will later lower this call to\nthe original C ABI."},{"title":"GC root placement","page":"Working with LLVM","location":"devdocs/llvm.html#GC-root-placement","category":"section","text":"GC root placement is done by an LLVM pass late in the pass pipeline. Doing GC root\nplacement this late enables LLVM to make more aggressive optimizations around\ncode that requires GC roots, as well as allowing us to reduce the number of\nrequired GC roots and GC root store operations (since LLVM doesn't understand\nour GC, it wouldn't otherwise know what it is and is not allowed to do with\nvalues stored to the GC frame, so it'll conservatively do very little). As an\nexample, consider an error path\n\nif some_condition()\n    #= Use some variables maybe =#\n    error(\"An error occurred\")\nend\n\nDuring constant folding, LLVM may discover that the condition is always false,\nand can remove the basic block. However, if GC root lowering is done early,\nthe GC root slots used in the deleted block, as well as any values kept alive\nin those slots only because they were used in the error path, would be kept\nalive by LLVM. By doing GC root lowering late, we give LLVM the license to do\nany of its usual optimizations (constant folding, dead code elimination, etc.),\nwithout having to worry (too much) about which values may or may not be GC\ntracked.\n\nHowever, in order to be able to do late GC root placement, we need to be able to\nidentify a) which pointers are GC tracked and b) all uses of such pointers. The\ngoal of the GC placement pass is thus simple:\n\nMinimize the number of needed GC roots/stores to them subject to the constraint\nthat at every safepoint, any live GC-tracked pointer (i.e. for which there is\na path after this point that contains a use of this pointer) is in some GC slot."},{"title":"Representation","page":"Working with LLVM","location":"devdocs/llvm.html#Representation","category":"section","text":"The primary difficulty is thus choosing an IR representation that allows us to\nidentify GC-tracked pointers and their uses, even after the program has been\nrun through the optimizer. Our design makes use of three LLVM features to achieve\nthis:\n\nCustom address spaces\nOperand Bundles\nNon-integral pointers\n\nCustom address spaces allow us to tag every point with an integer that needs\nto be preserved through optimizations. The compiler may not insert casts between\naddress spaces that did not exist in the original program and it must never\nchange the address space of a pointer on a load/store/etc operation. This allows\nus to annotate which pointers are GC-tracked in an optimizer-resistant way. Note\nthat metadata would not be able to achieve the same purpose. Metadata is supposed\nto always be discardable without altering the semantics of the program. However,\nfailing to identify a GC-tracked pointer alters the resulting program behavior\ndramatically - it'll probably crash or return wrong results. We currently use\nthree different address spaces (their numbers are defined in src/codegen_shared.cpp):\n\nGC Tracked Pointers (currently 10): These are pointers to boxed values that may be put\ninto a GC frame. It is loosely equivalent to a jl_value_t* pointer on the C\nside. N.B. It is illegal to ever have a pointer in this address space that may\nnot be stored to a GC slot.\nDerived Pointers (currently 11): These are pointers that are derived from some GC\ntracked pointer. Uses of these pointers generate uses of the original pointer.\nHowever, they need not themselves be known to the GC. The GC root placement\npass MUST always find the GC tracked pointer from which this pointer is\nderived and use that as the pointer to root.\nCallee Rooted Pointers (currently 12): This is a utility address space to express the\nnotion of a callee rooted value. All values of this address space MUST be\nstorable to a GC root (though it is possible to relax this condition in the\nfuture), but unlike the other pointers need not be rooted if passed to a\ncall (they do still need to be rooted if they are live across another safepoint\nbetween the definition and the call).\nPointers loaded from tracked object (currently 13): This is used by arrays,\nwhich themselves contain a pointer to the managed data. This data area is owned\nby the array, but is not a GC-tracked object by itself. The compiler guarantees\nthat as long as this pointer is live, the object that this pointer was loaded\nfrom will keep being live."},{"title":"Invariants","page":"Working with LLVM","location":"devdocs/llvm.html#Invariants","category":"section","text":"The GC root placement pass makes use of several invariants, which need\nto be observed by the frontend and are preserved by the optimizer.\n\nFirst, only the following address space casts are allowed:\n\n0->{Tracked,Derived,CalleeRooted}: It is allowable to decay an untracked pointer to any of the\nothers. However, do note that the optimizer has broad license to not root\nsuch a value. It is never safe to have a value in address space 0 in any part\nof the program if it is (or is derived from) a value that requires a GC root.\nTracked->Derived: This is the standard decay route for interior values. The placement\npass will look for these to identify the base pointer for any use.\nTracked->CalleeRooted: Addrspace CalleeRooted serves merely as a hint that a GC root is not\nrequired. However, do note that the Derived->CalleeRooted decay is prohibited, since\npointers should generally be storable to a GC slot, even in this address space.\n\nNow let us consider what constitutes a use:\n\nLoads whose loaded values is in one of the address spaces\nStores of a value in one of the address spaces to a location\nStores to a pointer in one of the address spaces\nCalls for which a value in one of the address spaces is an operand\nCalls in jlcall ABI, for which the argument array contains a value\nReturn instructions.\n\nWe explicitly allow load/stores and simple calls in address spaces Tracked/Derived. Elements of jlcall\nargument arrays must always be in address space Tracked (it is required by the ABI that\nthey are valid jl_value_t* pointers). The same is true for return instructions\n(though note that struct return arguments are allowed to have any of the address\nspaces). The only allowable use of an address space CalleeRooted pointer is to pass it to\na call (which must have an appropriately typed operand).\n\nFurther, we disallow getelementptr in addrspace Tracked. This is because unless\nthe operation is a noop, the resulting pointer will not be validly storable\nto a GC slot and may thus not be in this address space. If such a pointer\nis required, it should be decayed to addrspace Derived first.\n\nLastly, we disallow inttoptr/ptrtoint instructions in these address spaces.\nHaving these instructions would mean that some i64 values are really GC tracked.\nThis is problematic, because it breaks that stated requirement that we're able\nto identify GC-relevant pointers. This invariant is accomplished using the LLVM\n\"non-integral pointers\" feature, which is new in LLVM 5.0. It prohibits the\noptimizer from making optimizations that would introduce these operations. Note\nwe can still insert static constants at JIT time by using inttoptr in address\nspace 0 and then decaying to the appropriate address space afterwards."},{"title":"Supporting ccall","page":"Working with LLVM","location":"devdocs/llvm.html#Supporting-[ccall](@ref)","category":"section","text":"One important aspect missing from the discussion so far is the handling of\nccall. ccall has the peculiar feature that the location and\nscope of a use do not coincide. As an example consider:\n\nA = randn(1024)\nccall(:foo, Cvoid, (Ptr{Float64},), A)\n\nIn lowering, the compiler will insert a conversion from the array to the\npointer which drops the reference to the array value. However, we of course\nneed to make sure that the array does stay alive while we're doing the\nccall. To understand how this is done, lets look at a hypothetical\napproximate possible lowering of the above code:\n\nreturn $(Expr(:foreigncall, Expr(:tuple, :(:foo)), Cvoid, svec(Ptr{Float64}), 0, :(:ccall), Expr(:foreigncall, Expr(:tuple, :(:jl_array_ptr)), Ptr{Float64}, svec(Any), 0, :(:ccall), :(A)), :(A)))\n\nThe last :(A), is an extra argument list inserted during lowering that informs\nthe code generator which Julia level values need to be kept alive for the\nduration of this ccall. We then take this information and represent\nit in an \"operand bundle\" at the IR level. An operand bundle is essentially a fake\nuse that is attached to the call site. At the IR level, this looks like so:\n\ncall void inttoptr (i64 ... to void (double*)*)(double* %5) [ \"jl_roots\"(%jl_value_t addrspace(10)* %A) ]\n\nThe GC root placement pass will treat the jl_roots operand bundle as if it were\na regular operand. However, as a final step, after the GC roots are inserted,\nit will drop the operand bundle to avoid confusing instruction selection."},{"title":"Supporting pointer_from_objref","page":"Working with LLVM","location":"devdocs/llvm.html#Supporting-[pointer_from_objref](@ref)","category":"section","text":"pointer_from_objref is special because it requires the user to take\nexplicit control of GC rooting. By our above invariants, this function is illegal,\nbecause it performs an address space cast from 10 to 0. However, it can be useful,\nin certain situations, so we provide a special intrinsic:\n\ndeclared %jl_value_t *julia.pointer_from_objref(%jl_value_t addrspace(10)*)\n\nwhich is lowered to the corresponding address space cast after GC root lowering.\nDo note however that by using this intrinsic, the caller assumes all responsibility\nfor making sure that the value in question is rooted. Further this intrinsic is\nnot considered a use, so the GC root placement pass will not provide a GC root\nfor the function. As a result, the external rooting must be arranged while the\nvalue is still tracked by the system. I.e. it is not valid to attempt to use the\nresult of this operation to establish a global root - the optimizer may have\nalready dropped the value."},{"title":"Keeping values alive in the absence of uses","page":"Working with LLVM","location":"devdocs/llvm.html#Keeping-values-alive-in-the-absence-of-uses","category":"section","text":"In certain cases it is necessary to keep an object alive, even though there is\nno compiler-visible use of said object. This may be case for low level code\nthat operates on the memory-representation of an object directly or code that\nneeds to interface with C code. In order to allow this, we provide the following\nintrinsics at the LLVM level:\n\ntoken @llvm.julia.gc_preserve_begin(...)\nvoid @llvm.julia.gc_preserve_end(token)\n\n(The llvm. in the name is required in order to be able to use the token\ntype). The semantics of these intrinsics are as follows:\nAt any safepoint that is dominated by a gc_preserve_begin call, but that is not\nnot dominated by a corresponding gc_preserve_end call (i.e. a call whose argument\nis the token returned by a gc_preserve_begin call), the values passed as\narguments to that gc_preserve_begin will be kept live. Note that the\ngc_preserve_begin still counts as a regular use of those values, so the\nstandard lifetime semantics will ensure that the values will be kept alive\nbefore entering the preserve region."},{"title":"Printf","page":"Printf","location":"stdlib/Printf.html#man-printf","category":"section","text":"The Printf module provides formatted output functions similar to the C standard library's printf. It allows formatted printing to an output stream or to a string."},{"title":"Printf.@printf","page":"Printf","location":"stdlib/Printf.html#Printf.@printf","category":"macro","text":"@printf([io::IO], \"%Fmt\", args...)\n\nPrint args using C printf style format specification string.\nOptionally, an IO may be passed as the first argument to redirect output.\n\nExamples\n\njulia> @printf \"Hello %s\" \"world\"\nHello world\n\njulia> @printf \"Scientific notation %e\" 1.234\nScientific notation 1.234000e+00\n\njulia> @printf \"Scientific notation three digits %.3e\" 1.23456\nScientific notation three digits 1.235e+00\n\njulia> @printf \"Decimal two digits %.2f\" 1.23456\nDecimal two digits 1.23\n\njulia> @printf \"Padded to length 5 %5i\" 123\nPadded to length 5   123\n\njulia> @printf \"Padded with zeros to length 6 %06i\" 123\nPadded with zeros to length 6 000123\n\njulia> @printf \"Use shorter of decimal or scientific %g %g\" 1.23 12300000.0\nUse shorter of decimal or scientific 1.23 1.23e+07\n\njulia> @printf \"Use dynamic width and precision  %*.*f\" 10 2 0.12345\nUse dynamic width and precision        0.12\n\nFor a systematic specification of the format, see here.\nSee also @sprintf to get the result as a String instead of it being printed.\n\nCaveats\n\nInf and NaN are printed consistently as Inf and NaN for flags %a, %A,\n%e, %E, %f, %F, %g, and %G. Furthermore, if a floating point number is\nequally close to the numeric values of two possible output strings, the output\nstring further away from zero is chosen.\n\nExamples\n\njulia> @printf(\"%f %F %f %F\", Inf, Inf, NaN, NaN)\nInf Inf NaN NaN\n\njulia> @printf \"%.0f %.1f %f\" 0.5 0.025 -0.0078125\n0 0.0 -0.007812\n\ncompat: Julia 1.8\nStarting in Julia 1.8, %s (string) and %c (character) widths are computed\nusing textwidth, which e.g. ignores zero-width characters\n(such as combining characters for diacritical marks) and treats certain\n\"wide\" characters (e.g. emoji) as width 2.\n\ncompat: Julia 1.10\nDynamic width specifiers like %*s and %0*.*f require Julia 1.10.\n\n\n\n\n\n"},{"title":"Printf.@sprintf","page":"Printf","location":"stdlib/Printf.html#Printf.@sprintf","category":"macro","text":"@sprintf(\"%Fmt\", args...)\n\nReturn @printf formatted output as string.\n\nExamples\n\njulia> @sprintf \"this is a %s %15.1f\" \"test\" 34.567\n\"this is a test            34.6\"\n\n\n\n\n\n"},{"title":"Printf.Format","page":"Printf","location":"stdlib/Printf.html#Printf.Format","category":"type","text":"Printf.Format(format_str)\n\nCreate a C printf-compatible format object that can be used for formatting values.\n\nThe input format_str can include any valid format specifier character and modifiers.\n\nA Format object can be passed to Printf.format(f::Format, args...) to produce a\nformatted string, or Printf.format(io::IO, f::Format, args...) to print the\nformatted string directly to io.\n\nFor convenience, the Printf.format\"...\" string macro form can be used for building\na Printf.Format object at macro-expansion-time.\n\ncompat: Julia 1.6\nPrintf.Format requires Julia 1.6 or later.\n\n\n\n\n\n"},{"title":"Printf.format","page":"Printf","location":"stdlib/Printf.html#Printf.format","category":"function","text":"Printf.format(f::Printf.Format, args...) => String\nPrintf.format(io::IO, f::Printf.Format, args...)\n\nApply a printf format object f to provided args and return the formatted string\n(1st method), or print directly to an io object (2nd method). See @printf\nfor more details on C printf support.\n\n\n\n\n\n"},{"title":"Sparse Arrays","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#Sparse-Arrays","category":"section","text":"Julia has support for sparse vectors and sparse matrices\nin the SparseArrays stdlib module. Sparse arrays are arrays that contain enough zeros that storing them in a special data structure leads to savings in space and execution time, compared to dense arrays.\n\nExternal packages which implement different sparse storage types, multidimensional sparse arrays, and more can be found in Noteworthy External Sparse Packages"},{"title":"Compressed Sparse Column (CSC) Sparse Matrix Storage","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#man-csc","category":"section","text":"In Julia, sparse matrices are stored in the Compressed Sparse Column (CSC) format.\nJulia sparse matrices have the type SparseMatrixCSC{Tv,Ti}, where Tv is the\ntype of the stored values, and Ti is the integer type for storing column pointers and\nrow indices. The internal representation of SparseMatrixCSC is as follows:\n\nstruct SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrixCSC{Tv,Ti}\n    m::Int                  # Number of rows\n    n::Int                  # Number of columns\n    colptr::Vector{Ti}      # Column j is in colptr[j]:(colptr[j+1]-1)\n    rowval::Vector{Ti}      # Row indices of stored values\n    nzval::Vector{Tv}       # Stored values, typically nonzeros\nend\n\nThe compressed sparse column storage makes it easy and quick to access the elements in the column\nof a sparse matrix, whereas accessing the sparse matrix by rows is considerably slower. Operations\nsuch as insertion of previously unstored entries one at a time in the CSC structure tend to be slow. This is\nbecause all elements of the sparse matrix that are beyond the point of insertion have to be moved\none place over.\n\nAll operations on sparse matrices are carefully implemented to exploit the CSC data structure\nfor performance, and to avoid expensive operations.\n\nIf you have data in CSC format from a different application or\nlibrary, and wish to import it in Julia, make sure that you use\n1-based indexing. The row indices in every column need to be sorted,\nand if they are not, the matrix will display incorrectly.  If your\nSparseMatrixCSC object contains unsorted row indices, one quick way\nto sort them is by doing a double transpose. Since the transpose operation\nis lazy, make a copy to materialize each transpose.\n\nIn some applications, it is convenient to store explicit zero values in a SparseMatrixCSC. These\nare accepted by functions in Base (but there is no guarantee that they will be preserved in\nmutating operations). Such explicitly stored zeros are treated as structural nonzeros by many\nroutines. The nnz function returns the number of elements explicitly stored in the\nsparse data structure, including non-structural zeros. In order to count the exact number of\nnumerical nonzeros, use count(!iszero, x), which inspects every stored element of a sparse\nmatrix. dropzeros, and the in-place dropzeros!, can be used to\nremove stored zeros from the sparse matrix.\n\njulia> A = sparse([1, 1, 2, 3], [1, 3, 2, 3], [0, 1, 2, 0])\n3×3 SparseMatrixCSC{Int64, Int64} with 4 stored entries:\n 0  ⋅  1\n ⋅  2  ⋅\n ⋅  ⋅  0\n\njulia> dropzeros(A)\n3×3 SparseMatrixCSC{Int64, Int64} with 2 stored entries:\n ⋅  ⋅  1\n ⋅  2  ⋅\n ⋅  ⋅  ⋅"},{"title":"Sparse Vector Storage","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#Sparse-Vector-Storage","category":"section","text":"Sparse vectors are stored in a close analog to compressed sparse column format for sparse\nmatrices. In Julia, sparse vectors have the type SparseVector{Tv,Ti} where Tv\nis the type of the stored values and Ti the integer type for the indices. The internal\nrepresentation is as follows:\n\nstruct SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}\n    n::Int              # Length of the sparse vector\n    nzind::Vector{Ti}   # Indices of stored values\n    nzval::Vector{Tv}   # Stored values, typically nonzeros\nend\n\nLike SparseMatrixCSC, the SparseVector type can also contain explicitly\nstored zeros. (See Sparse Matrix Storage.)."},{"title":"Sparse Vector and Matrix Constructors","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#Sparse-Vector-and-Matrix-Constructors","category":"section","text":"The simplest way to create a sparse array is to use a function equivalent to the zeros\nfunction that Julia provides for working with dense arrays. To produce a\nsparse array instead, you can use the same name with an sp prefix:\n\njulia> spzeros(3)\n3-element SparseVector{Float64, Int64} with 0 stored entries\n\nThe sparse function is often a handy way to construct sparse arrays. For\nexample, to construct a sparse matrix we can input a vector I of row indices, a vector\nJ of column indices, and a vector V of stored values (this is also known as the\nCOO (coordinate) format).\nsparse(I,J,V) then constructs a sparse matrix such that S[I[k], J[k]] = V[k]. The\nequivalent sparse vector constructor is sparsevec, which takes the (row) index\nvector I and the vector V with the stored values and constructs a sparse vector R\nsuch that R[I[k]] = V[k].\n\njulia> I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];\n\njulia> S = sparse(I,J,V)\n5×18 SparseMatrixCSC{Int64, Int64} with 4 stored entries:\n⎡⠀⠈⠀⠀⠀⠀⠀⠀⢀⎤\n⎣⠀⠀⠀⠂⡀⠀⠀⠀⠀⎦\n\njulia> R = sparsevec(I,V)\n5-element SparseVector{Int64, Int64} with 4 stored entries:\n  [1]  =  1\n  [3]  =  -5\n  [4]  =  2\n  [5]  =  3\n\nThe inverse of the sparse and sparsevec functions is\nfindnz, which retrieves the inputs used to create the sparse array (including stored entries equal to zero).\nfindall(!iszero, x) returns the Cartesian indices of non-zero entries in x\n(not including stored entries equal to zero).\n\njulia> findnz(S)\n([1, 4, 5, 3], [4, 7, 9, 18], [1, 2, 3, -5])\n\njulia> findall(!iszero, S)\n4-element Vector{CartesianIndex{2}}:\n CartesianIndex(1, 4)\n CartesianIndex(4, 7)\n CartesianIndex(5, 9)\n CartesianIndex(3, 18)\n\njulia> findnz(R)\n([1, 3, 4, 5], [1, -5, 2, 3])\n\njulia> findall(!iszero, R)\n4-element Vector{Int64}:\n 1\n 3\n 4\n 5\n\nAnother way to create a sparse array is to convert a dense array into a sparse array using\nthe sparse function:\n\njulia> sparse(Matrix(1.0I, 5, 5))\n5×5 SparseMatrixCSC{Float64, Int64} with 5 stored entries:\n 1.0   ⋅    ⋅    ⋅    ⋅\n  ⋅   1.0   ⋅    ⋅    ⋅\n  ⋅    ⋅   1.0   ⋅    ⋅\n  ⋅    ⋅    ⋅   1.0   ⋅\n  ⋅    ⋅    ⋅    ⋅   1.0\n\njulia> sparse([1.0, 0.0, 1.0])\n3-element SparseVector{Float64, Int64} with 2 stored entries:\n  [1]  =  1.0\n  [3]  =  1.0\n\nYou can go in the other direction using the Array constructor. The issparse\nfunction can be used to query if a matrix is sparse.\n\njulia> issparse(spzeros(5))\ntrue"},{"title":"Sparse matrix operations","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#Sparse-matrix-operations","category":"section","text":"Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of,\nassignment into, and concatenation of sparse matrices work in the same way as dense matrices.\nIndexing operations, especially assignment, are expensive, when carried out one element at a time.\nIn many cases it may be better to convert the sparse matrix into (I,J,V) format using findnz,\nmanipulate the values or the structure in the dense vectors (I,J,V), and then reconstruct\nthe sparse matrix."},{"title":"Correspondence of dense and sparse methods","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#Correspondence-of-dense-and-sparse-methods","category":"section","text":"The following table gives a correspondence between built-in methods on sparse matrices and their\ncorresponding methods on dense matrix types. In general, methods that generate sparse matrices\ndiffer from their dense counterparts in that the resulting matrix follows the same sparsity pattern\nas a given sparse matrix S, or that the resulting sparse matrix has density d, i.e. each matrix\nelement has a probability d of being non-zero.\n\nDetails can be found in the Sparse Vectors and Matrices\nsection of the standard library reference.\n\nSparse Dense Description\nspzeros(m,n) zeros(m,n) Creates a m-by-n matrix of zeros. (spzeros(m,n) is empty.)\nsparse(I,n,n) Matrix(I,n,n) Creates a n-by-n identity matrix.\nsparse(A) Array(S) Interconverts between dense and sparse formats.\nsprand(m,n,d) rand(m,n) Creates a m-by-n random matrix (of density d) with iid non-zero elements distributed uniformly on the half-open interval 0 1).\nsprandn(m,n,d) randn(m,n) Creates a m-by-n random matrix (of density d) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution.\nsprandn(rng,m,n,d) randn(rng,m,n) Creates a m-by-n random matrix (of density d) with iid non-zero elements generated with the rng random number generator"},{"title":"SparseArrays API","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#stdlib-sparse-arrays","category":"section","text":""},{"title":"Noteworthy External Sparse Packages","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#Noteworthy-External-Sparse-Packages","category":"section","text":"Several other Julia packages provide sparse matrix implementations that should be mentioned:\n\nSuiteSparseGraphBLAS.jl is a wrapper over the fast, multithreaded SuiteSparse:GraphBLAS C library. On CPU this is typically the fastest option, often significantly outperforming MKLSparse.\nCUDA.jl exposes the CUSPARSE library for GPU sparse matrix operations.\nSparseMatricesCSR.jl provides a Julia native implementation of the Compressed Sparse Rows (CSR) format.\nMKLSparse.jl accelerates SparseArrays sparse-dense matrix operations using Intel's MKL library.\nSparseArrayKit.jl available for multidimensional sparse arrays.\nLuxurySparse.jl provides static sparse array formats, as well as a coordinate format.\nExtendableSparse.jl enables fast insertion into sparse matrices using a lazy approach to new stored indices.\nFinch.jl supports extensive multidimensional sparse array formats and operations through a mini tensor language and compiler, all in native Julia. Support for COO, CSF, CSR, CSC and more, as well as operations like broadcast, reduce, etc. and custom operations.\n\nExternal packages providing sparse direct solvers:\n\nKLU.jl\nPardiso.jl\n\nExternal packages providing solvers for iterative solution of eigensystems and singular value decompositions:\n\nArnoldiMethods.jl\nKrylovKit\nArpack.jl\n\nExternal packages for working with graphs:\n\nGraphs.jl"},{"title":"SparseArrays.AbstractSparseArray","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.AbstractSparseArray","category":"type","text":"AbstractSparseArray{Tv,Ti,N}\n\nSupertype for N-dimensional sparse arrays (or array-like types) with elements\nof type Tv and index type Ti. SparseMatrixCSC, SparseVector\nand SuiteSparse.CHOLMOD.Sparse are subtypes of this.\n\n\n\n\n\n"},{"title":"SparseArrays.AbstractSparseVector","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.AbstractSparseVector","category":"type","text":"AbstractSparseVector{Tv,Ti}\n\nSupertype for one-dimensional sparse arrays (or array-like types) with elements\nof type Tv and index type Ti. Alias for AbstractSparseArray{Tv,Ti,1}.\n\n\n\n\n\n"},{"title":"SparseArrays.AbstractSparseMatrix","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.AbstractSparseMatrix","category":"type","text":"AbstractSparseMatrix{Tv,Ti}\n\nSupertype for two-dimensional sparse arrays (or array-like types) with elements\nof type Tv and index type Ti. Alias for AbstractSparseArray{Tv,Ti,2}.\n\n\n\n\n\n"},{"title":"SparseArrays.SparseVector","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.SparseVector","category":"type","text":"SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}\n\nVector type for storing sparse vectors. Can be created by passing the length of the vector,\na sorted vector of non-zero indices, and a vector of non-zero values.\n\nFor instance, the vector [5, 6, 0, 7] can be represented as\n\nSparseVector(4, [1, 2, 4], [5, 6, 7])\n\nThis indicates that the element at index 1 is 5, at index 2 is 6, at index 3 is zero(Int),\nand at index 4 is 7.\n\nIt may be more convenient to create sparse vectors directly from dense vectors using sparse as\n\nsparse([5, 6, 0, 7])\n\nyields the same sparse vector.\n\n\n\n\n\n"},{"title":"SparseArrays.SparseMatrixCSC","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.SparseMatrixCSC","category":"type","text":"SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrixCSC{Tv,Ti}\n\nMatrix type for storing sparse matrices in the\nCompressed Sparse Column format. The standard way\nof constructing SparseMatrixCSC is through the sparse function.\nSee also spzeros, spdiagm and sprand.\n\n\n\n\n\n"},{"title":"SparseArrays.sparse","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.sparse","category":"function","text":"sparse(A::Union{AbstractVector, AbstractMatrix})\n\nConvert a vector or matrix A into a sparse array.\nNumerical zeros in A are turned into structural zeros.\n\nExamples\n\njulia> A = Matrix(1.0I, 3, 3)\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> sparse(A)\n3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:\n 1.0   ⋅    ⋅\n  ⋅   1.0   ⋅\n  ⋅    ⋅   1.0\n\njulia> [1.0, 0.0, 1.0]\n3-element Vector{Float64}:\n 1.0\n 0.0\n 1.0\n\njulia> sparse([1.0, 0.0, 1.0])\n3-element SparseVector{Float64, Int64} with 2 stored entries:\n  [1]  =  1.0\n  [3]  =  1.0\n\n\n\n\n\nsparse(I, J, V,[ m, n, combine])\n\nCreate a sparse matrix S of dimensions m x n such that S[I[k], J[k]] = V[k]. The\ncombine function is used to combine duplicates. If m and n are not specified, they\nare set to maximum(I) and maximum(J) respectively. If the combine function is not\nsupplied, combine defaults to + unless the elements of V are Booleans in which case\ncombine defaults to |. All elements of I must satisfy 1 <= I[k] <= m, and all\nelements of J must satisfy 1 <= J[k] <= n. Numerical zeros in (I, J, V) are\nretained as structural nonzeros; to drop numerical zeros, use dropzeros!.\n\nFor additional documentation and an expert driver, see SparseArrays.sparse!.\n\nExamples\n\njulia> Is = [1; 2; 3];\n\njulia> Js = [1; 2; 3];\n\njulia> Vs = [1; 2; 3];\n\njulia> sparse(Is, Js, Vs)\n3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:\n 1  ⋅  ⋅\n ⋅  2  ⋅\n ⋅  ⋅  3\n\n\n\n\n\n"},{"title":"SparseArrays.sparse!","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.sparse!","category":"function","text":"sparse!(I::AbstractVector{Ti}, J::AbstractVector{Ti}, V::AbstractVector{Tv},\n        m::Integer, n::Integer, combine, klasttouch::Vector{Ti},\n        csrrowptr::Vector{Ti}, csrcolval::Vector{Ti}, csrnzval::Vector{Tv},\n        [csccolptr::Vector{Ti}], [cscrowval::Vector{Ti}, cscnzval::Vector{Tv}] ) where {Tv,Ti<:Integer}\n\nParent of and expert driver for sparse;\nsee sparse for basic usage. This method\nallows the user to provide preallocated storage for sparse's intermediate objects and\nresult as described below. This capability enables more efficient successive construction\nof SparseMatrixCSCs from coordinate representations, and also enables extraction\nof an unsorted-column representation of the result's transpose at no additional cost.\n\nThis method consists of three major steps: (1) Counting-sort the provided coordinate\nrepresentation into an unsorted-row CSR form including repeated entries. (2) Sweep through\nthe CSR form, simultaneously calculating the desired CSC form's column-pointer array,\ndetecting repeated entries, and repacking the CSR form with repeated entries combined;\nthis stage yields an unsorted-row CSR form with no repeated entries. (3) Counting-sort the\npreceding CSR form into a fully-sorted CSC form with no repeated entries.\n\nInput arrays csrrowptr, csrcolval, and csrnzval constitute storage for the\nintermediate CSR forms and require length(csrrowptr) >= m + 1,\nlength(csrcolval) >= length(I), and length(csrnzval >= length(I)). Input\narray klasttouch, workspace for the second stage, requires length(klasttouch) >= n.\nOptional input arrays csccolptr, cscrowval, and cscnzval constitute storage for the\nreturned CSC form S. If necessary, these are resized automatically to satisfy\nlength(csccolptr) = n + 1, length(cscrowval) = nnz(S) and length(cscnzval) = nnz(S); hence, if nnz(S) is\nunknown at the outset, passing in empty vectors of the appropriate type (Vector{Ti}()\nand Vector{Tv}() respectively) suffices, or calling the sparse! method\nneglecting cscrowval and cscnzval.\n\nOn return, csrrowptr, csrcolval, and csrnzval contain an unsorted-column\nrepresentation of the result's transpose.\n\nYou may reuse the input arrays' storage (I, J, V) for the output arrays\n(csccolptr, cscrowval, cscnzval). For example, you may call\nsparse!(I, J, V, csrrowptr, csrcolval, csrnzval, I, J, V).\nNote that they will be resized to satisfy the conditions above.\n\nFor the sake of efficiency, this method performs no argument checking beyond\n1 <= I[k] <= m and 1 <= J[k] <= n. Use with care. Testing with --check-bounds=yes\nis wise.\n\nThis method runs in O(m, n, length(I)) time. The HALFPERM algorithm described in\nF. Gustavson, \"Two fast algorithms for sparse matrices: multiplication and permuted\ntransposition,\" ACM TOMS 4(3), 250-269 (1978) inspired this method's use of a pair of\ncounting sorts.\n\n\n\n\n\nSparseArrays.sparse!(I, J, V, [m, n, combine]) -> SparseMatrixCSC\n\nVariant of sparse! that re-uses the input vectors (I, J, V) for the final matrix\nstorage. After construction the input vectors will alias the matrix buffers; S.colptr === I, S.rowval === J, and S.nzval === V holds, and they will be resize!d as necessary.\n\nNote that some work buffers will still be allocated. Specifically, this method is a\nconvenience wrapper around sparse!(I, J, V, m, n, combine, klasttouch, csrrowptr, csrcolval, csrnzval, csccolptr, cscrowval, cscnzval) where this method allocates\nklasttouch, csrrowptr, csrcolval, and csrnzval of appropriate size, but reuses I,\nJ, and V for csccolptr, cscrowval, and cscnzval.\n\nArguments m, n, and combine defaults to maximum(I), maximum(J), and +,\nrespectively.\n\ncompat: Julia 1.10\nThis method requires Julia version 1.10 or later.\n\n\n\n\n\n"},{"title":"SparseArrays.sparsevec","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.sparsevec","category":"function","text":"sparsevec(I, V, [m, combine])\n\nCreate a sparse vector S of length m such that S[I[k]] = V[k].\nDuplicates are combined using the combine function, which defaults to\n+ if no combine argument is provided, unless the elements of V are Booleans\nin which case combine defaults to |.\n\nExamples\n\njulia> II = [1, 3, 3, 5]; V = [0.1, 0.2, 0.3, 0.2];\n\njulia> sparsevec(II, V)\n5-element SparseVector{Float64, Int64} with 3 stored entries:\n  [1]  =  0.1\n  [3]  =  0.5\n  [5]  =  0.2\n\njulia> sparsevec(II, V, 8, -)\n8-element SparseVector{Float64, Int64} with 3 stored entries:\n  [1]  =  0.1\n  [3]  =  -0.1\n  [5]  =  0.2\n\njulia> sparsevec([1, 3, 1, 2, 2], [true, true, false, false, false])\n3-element SparseVector{Bool, Int64} with 3 stored entries:\n  [1]  =  1\n  [2]  =  0\n  [3]  =  1\n\n\n\n\n\nsparsevec(d::Dict, [m])\n\nCreate a sparse vector of length m where the nonzero indices are keys from\nthe dictionary, and the nonzero values are the values from the dictionary.\n\nExamples\n\njulia> sparsevec(Dict(1 => 3, 2 => 2))\n2-element SparseVector{Int64, Int64} with 2 stored entries:\n  [1]  =  3\n  [2]  =  2\n\n\n\n\n\nsparsevec(A)\n\nConvert a vector A into a sparse vector of length m.\nNumerical zeros in A are turned into structural zeros.\n\nExamples\n\njulia> sparsevec([1.0, 2.0, 0.0, 0.0, 3.0, 0.0])\n6-element SparseVector{Float64, Int64} with 3 stored entries:\n  [1]  =  1.0\n  [2]  =  2.0\n  [5]  =  3.0\n\n\n\n\n\n"},{"title":"Base.similar","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#Base.similar-Tuple{SparseArrays.AbstractSparseMatrixCSC, Type}","category":"method","text":"similar(A::AbstractSparseMatrixCSC{Tv,Ti}, [::Type{TvNew}, ::Type{TiNew}, m::Integer, n::Integer]) where {Tv,Ti}\n\nCreate an uninitialized mutable array with the given element type,\nindex type, and size, based upon the given source\nSparseMatrixCSC. The new sparse matrix maintains the structure of\nthe original sparse matrix, except in the case where dimensions of the\noutput matrix are different from the output.\n\nThe output matrix has zeros in the same locations as the input, but\nuninitialized values for the nonzero locations.\n\n\n\n\n\n"},{"title":"SparseArrays.issparse","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.issparse","category":"function","text":"issparse(S)\n\nReturns true if S is sparse, and false otherwise.\n\nExamples\n\njulia> sv = sparsevec([1, 4], [2.3, 2.2], 10)\n10-element SparseVector{Float64, Int64} with 2 stored entries:\n  [1]  =  2.3\n  [4]  =  2.2\n\njulia> issparse(sv)\ntrue\n\njulia> issparse(Array(sv))\nfalse\n\n\n\n\n\n"},{"title":"SparseArrays.nnz","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.nnz","category":"function","text":"nnz(A)\n\nReturns the number of stored (filled) elements in a sparse array.\n\nExamples\n\njulia> A = sparse(2I, 3, 3)\n3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:\n 2  ⋅  ⋅\n ⋅  2  ⋅\n ⋅  ⋅  2\n\njulia> nnz(A)\n3\n\n\n\n\n\n"},{"title":"SparseArrays.findnz","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.findnz","category":"function","text":"findnz(A::SparseMatrixCSC)\n\nReturn a tuple (I, J, V) where I and J are the row and column indices of the stored\n(\"structurally non-zero\") values in sparse matrix A, and V is a vector of the values.\n\nExamples\n\njulia> A = sparse([1 2 0; 0 0 3; 0 4 0])\n3×3 SparseMatrixCSC{Int64, Int64} with 4 stored entries:\n 1  2  ⋅\n ⋅  ⋅  3\n ⋅  4  ⋅\n\njulia> findnz(A)\n([1, 1, 3, 2], [1, 2, 2, 3], [1, 2, 4, 3])\n\n\n\n\n\n"},{"title":"SparseArrays.spzeros","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.spzeros","category":"function","text":"spzeros([type,]m[,n])\n\nCreate a sparse vector of length m or sparse matrix of size m x n. This\nsparse array will not contain any nonzero values. No storage will be allocated\nfor nonzero values during construction. The type defaults to Float64 if not\nspecified.\n\nExamples\n\njulia> spzeros(3, 3)\n3×3 SparseMatrixCSC{Float64, Int64} with 0 stored entries:\n  ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅\n\njulia> spzeros(Float32, 4)\n4-element SparseVector{Float32, Int64} with 0 stored entries\n\n\n\n\n\nspzeros([type], I::AbstractVector, J::AbstractVector, [m, n])\n\nCreate a sparse matrix S of dimensions m x n with structural zeros at S[I[k], J[k]].\n\nThis method can be used to construct the sparsity pattern of the matrix, and is more\nefficient than using e.g. sparse(I, J, zeros(length(I))).\n\nFor additional documentation and an expert driver, see SparseArrays.spzeros!.\n\ncompat: Julia 1.10\nThis methods requires Julia version 1.10 or later.\n\n\n\n\n\n"},{"title":"SparseArrays.spzeros!","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.spzeros!","category":"function","text":"spzeros!(::Type{Tv}, I::AbstractVector{Ti}, J::AbstractVector{Ti}, m::Integer, n::Integer,\n         klasttouch::Vector{Ti}, csrrowptr::Vector{Ti}, csrcolval::Vector{Ti},\n         [csccolptr::Vector{Ti}], [cscrowval::Vector{Ti}, cscnzval::Vector{Tv}]) where {Tv,Ti<:Integer}\n\nParent of and expert driver for spzeros(I, J) allowing user to provide preallocated\nstorage for intermediate objects. This method is to spzeros what SparseArrays.sparse! is\nto sparse. See documentation for SparseArrays.sparse! for details and required buffer\nlengths.\n\ncompat: Julia 1.10\nThis methods requires Julia version 1.10 or later.\n\n\n\n\n\nSparseArrays.spzeros!(::Type{Tv}, I, J, [m, n]) -> SparseMatrixCSC{Tv}\n\nVariant of spzeros! that re-uses the input vectors I and J for the final matrix\nstorage. After construction the input vectors will alias the matrix buffers; S.colptr === I and S.rowval === J holds, and they will be resize!d as necessary.\n\nNote that some work buffers will still be allocated. Specifically, this method is a\nconvenience wrapper around spzeros!(Tv, I, J, m, n, klasttouch, csrrowptr, csrcolval, csccolptr, cscrowval) where this method allocates klasttouch, csrrowptr, and\ncsrcolval of appropriate size, but reuses I and J for csccolptr and cscrowval.\n\nArguments m and n defaults to maximum(I) and maximum(J).\n\ncompat: Julia 1.10\nThis method requires Julia version 1.10 or later.\n\n\n\n\n\n"},{"title":"SparseArrays.spdiagm","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.spdiagm","category":"function","text":"spdiagm(kv::Pair{<:Integer,<:AbstractVector}...)\nspdiagm(m::Integer, n::Integer, kv::Pair{<:Integer,<:AbstractVector}...)\n\nConstruct a sparse diagonal matrix from Pairs of vectors and diagonals.\nEach vector kv.second will be placed on the kv.first diagonal.  By\ndefault, the matrix is square and its size is inferred\nfrom kv, but a non-square size m×n (padded with zeros as needed)\ncan be specified by passing m,n as the first arguments.\n\nExamples\n\njulia> spdiagm(-1 => [1,2,3,4], 1 => [4,3,2,1])\n5×5 SparseMatrixCSC{Int64, Int64} with 8 stored entries:\n ⋅  4  ⋅  ⋅  ⋅\n 1  ⋅  3  ⋅  ⋅\n ⋅  2  ⋅  2  ⋅\n ⋅  ⋅  3  ⋅  1\n ⋅  ⋅  ⋅  4  ⋅\n\n\n\n\n\nspdiagm(v::AbstractVector)\nspdiagm(m::Integer, n::Integer, v::AbstractVector)\n\nConstruct a sparse matrix with elements of the vector as diagonal elements.\nBy default (no given m and n), the matrix is square and its size is given\nby length(v), but a non-square size m×n can be specified by passing m\nand n as the first arguments.\n\ncompat: Julia 1.6\nThese functions require at least Julia 1.6.\n\nExamples\n\njulia> spdiagm([1,2,3])\n3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:\n 1  ⋅  ⋅\n ⋅  2  ⋅\n ⋅  ⋅  3\n\njulia> spdiagm(sparse([1,0,3]))\n3×3 SparseMatrixCSC{Int64, Int64} with 2 stored entries:\n 1  ⋅  ⋅\n ⋅  ⋅  ⋅\n ⋅  ⋅  3\n\n\n\n\n\n"},{"title":"SparseArrays.sparse_hcat","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.sparse_hcat","category":"function","text":"sparse_hcat(A...)\n\nConcatenate along dimension 2. Return a SparseMatrixCSC object.\n\ncompat: Julia 1.8\nThis method was added in Julia 1.8. It mimics previous concatenation behavior, where\nthe concatenation with specialized \"sparse\" matrix types from LinearAlgebra.jl\nautomatically yielded sparse output even in the absence of any SparseArray argument.\n\n\n\n\n\n"},{"title":"SparseArrays.sparse_vcat","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.sparse_vcat","category":"function","text":"sparse_vcat(A...)\n\nConcatenate along dimension 1. Return a SparseMatrixCSC object.\n\ncompat: Julia 1.8\nThis method was added in Julia 1.8. It mimics previous concatenation behavior, where\nthe concatenation with specialized \"sparse\" matrix types from LinearAlgebra.jl\nautomatically yielded sparse output even in the absence of any SparseArray argument.\n\n\n\n\n\n"},{"title":"SparseArrays.sparse_hvcat","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.sparse_hvcat","category":"function","text":"sparse_hvcat(rows::Tuple{Vararg{Int}}, values...)\n\nSparse horizontal and vertical concatenation in one call. This function is called\nfor block matrix syntax. The first argument specifies the number of\narguments to concatenate in each block row.\n\ncompat: Julia 1.8\nThis method was added in Julia 1.8. It mimics previous concatenation behavior, where\nthe concatenation with specialized \"sparse\" matrix types from LinearAlgebra.jl\nautomatically yielded sparse output even in the absence of any SparseArray argument.\n\n\n\n\n\n"},{"title":"SparseArrays.blockdiag","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.blockdiag","category":"function","text":"blockdiag(A...)\n\nConcatenate matrices block-diagonally. Currently only implemented for sparse matrices.\n\nExamples\n\njulia> blockdiag(sparse(2I, 3, 3), sparse(4I, 2, 2))\n5×5 SparseMatrixCSC{Int64, Int64} with 5 stored entries:\n 2  ⋅  ⋅  ⋅  ⋅\n ⋅  2  ⋅  ⋅  ⋅\n ⋅  ⋅  2  ⋅  ⋅\n ⋅  ⋅  ⋅  4  ⋅\n ⋅  ⋅  ⋅  ⋅  4\n\n\n\n\n\n"},{"title":"SparseArrays.sprand","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.sprand","category":"function","text":"sprand([rng],[T::Type],m,[n],p::AbstractFloat)\nsprand([rng],m,[n],p::AbstractFloat,[rfn=rand])\n\nCreate a random length m sparse vector or m by n sparse matrix, in\nwhich the probability of any element being nonzero is independently given by\np (and hence the mean density of nonzeros is also exactly p).\nThe optional rng argument specifies a random number generator, see Random Numbers.\nThe optional T argument specifies the element type, which defaults to Float64.\n\nBy default, nonzero values are sampled from a uniform distribution using\nthe rand function, i.e. by rand(T), or rand(rng, T) if rng\nis supplied; for the default T=Float64, this corresponds to nonzero values\nsampled uniformly in [0,1).\n\nYou can sample nonzero values from a different distribution by passing a\ncustom rfn function instead of rand.   This should be a function rfn(k)\nthat returns an array of k random numbers sampled from the desired distribution;\nalternatively, if rng is supplied, it should instead be a function rfn(rng, k).\n\nExamples\n\njulia> sprand(Bool, 2, 2, 0.5)\n2×2 SparseMatrixCSC{Bool, Int64} with 2 stored entries:\n 1  1\n ⋅  ⋅\n\njulia> sprand(Float64, 3, 0.75)\n3-element SparseVector{Float64, Int64} with 2 stored entries:\n  [1]  =  0.795547\n  [2]  =  0.49425\n\n\n\n\n\n"},{"title":"SparseArrays.sprandn","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.sprandn","category":"function","text":"sprandn([rng][,Type],m[,n],p::AbstractFloat)\n\nCreate a random sparse vector of length m or sparse matrix of size m by n\nwith the specified (independent) probability p of any entry being nonzero,\nwhere nonzero values are sampled from the normal distribution. The optional rng\nargument specifies a random number generator, see Random Numbers.\n\ncompat: Julia 1.1\nSpecifying the output element type Type requires at least Julia 1.1.\n\nExamples\n\njulia> sprandn(2, 2, 0.75)\n2×2 SparseMatrixCSC{Float64, Int64} with 3 stored entries:\n -1.20577     ⋅\n  0.311817  -0.234641\n\n\n\n\n\n"},{"title":"SparseArrays.nonzeros","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.nonzeros","category":"function","text":"nonzeros(A)\n\nReturn a vector of the structural nonzero values in sparse array A. This\nincludes zeros that are explicitly stored in the sparse array. The returned\nvector points directly to the internal nonzero storage of A, and any\nmodifications to the returned vector will mutate A as well. See\nrowvals and nzrange.\n\nExamples\n\njulia> A = sparse(2I, 3, 3)\n3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:\n 2  ⋅  ⋅\n ⋅  2  ⋅\n ⋅  ⋅  2\n\njulia> nonzeros(A)\n3-element Vector{Int64}:\n 2\n 2\n 2\n\n\n\n\n\n"},{"title":"SparseArrays.rowvals","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.rowvals","category":"function","text":"rowvals(A)\n\nReturn a vector of the row indices of sparse array A. Any modifications to the returned\nvector will mutate A as well. Providing access to how the row indices are\nstored internally can be useful in conjunction with iterating over structural\nnonzero values. See also nonzeros and nzrange.\n\nExamples\n\njulia> A = sparse(2I, 3, 3)\n3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:\n 2  ⋅  ⋅\n ⋅  2  ⋅\n ⋅  ⋅  2\n\njulia> rowvals(A)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\n\n"},{"title":"SparseArrays.nzrange","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.nzrange","category":"function","text":"nzrange(A, col::Integer)\n\nReturn the range of indices to the structural nonzero values of column col\nof sparse array A. In conjunction with nonzeros and\nrowvals, this allows for convenient iterating over a sparse matrix :\n\nA = sparse(I,J,V)\nrows = rowvals(A)\nvals = nonzeros(A)\nm, n = size(A)\nfor j = 1:n\n   for i in nzrange(A, j)\n      row = rows[i]\n      val = vals[i]\n      # perform sparse wizardry...\n   end\nend\n\nwarning: Warning\nAdding or removing nonzero elements to the matrix may invalidate the nzrange, one should not mutate the matrix while iterating.\n\n\n\n\n\nnzrange(x::SparseVectorUnion, col)\n\nGive the range of indices to the structural nonzero values of a sparse vector.\nThe column index col is ignored (assumed to be 1).\n\n\n\n\n\n"},{"title":"SparseArrays.droptol!","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.droptol!","category":"function","text":"droptol!(A::AbstractSparseMatrixCSC, tol)\n\nRemoves stored values from A whose absolute value is less than or equal to tol.\n\n\n\n\n\ndroptol!(x::AbstractCompressedVector, tol)\n\nRemoves stored values from x whose absolute value is less than or equal to tol.\n\n\n\n\n\n"},{"title":"SparseArrays.dropzeros!","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.dropzeros!","category":"function","text":"dropzeros!(x::AbstractCompressedVector)\n\nRemoves stored numerical zeros from x.\n\nFor an out-of-place version, see dropzeros. For\nalgorithmic information, see fkeep!.\n\n\n\n\n\n"},{"title":"SparseArrays.dropzeros","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.dropzeros","category":"function","text":"dropzeros(A::AbstractSparseMatrixCSC;)\n\nGenerates a copy of A and removes stored numerical zeros from that copy.\n\nFor an in-place version and algorithmic information, see dropzeros!.\n\nExamples\n\njulia> A = sparse([1, 2, 3], [1, 2, 3], [1.0, 0.0, 1.0])\n3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:\n 1.0   ⋅    ⋅\n  ⋅   0.0   ⋅\n  ⋅    ⋅   1.0\n\njulia> dropzeros(A)\n3×3 SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n 1.0   ⋅    ⋅\n  ⋅    ⋅    ⋅\n  ⋅    ⋅   1.0\n\n\n\n\n\ndropzeros(x::AbstractCompressedVector)\n\nGenerates a copy of x and removes numerical zeros from that copy.\n\nFor an in-place version and algorithmic information, see dropzeros!.\n\nExamples\n\njulia> A = sparsevec([1, 2, 3], [1.0, 0.0, 1.0])\n3-element SparseVector{Float64, Int64} with 3 stored entries:\n  [1]  =  1.0\n  [2]  =  0.0\n  [3]  =  1.0\n\njulia> dropzeros(A)\n3-element SparseVector{Float64, Int64} with 2 stored entries:\n  [1]  =  1.0\n  [3]  =  1.0\n\n\n\n\n\n"},{"title":"SparseArrays.permute","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.permute","category":"function","text":"permute(A::AbstractSparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},\n        q::AbstractVector{<:Integer}) where {Tv,Ti}\n\nBilaterally permute A, returning PAQ (A[p,q]). Column-permutation q's length must\nmatch A's column count (length(q) == size(A, 2)). Row-permutation p's length must match A's\nrow count (length(p) == size(A, 1)).\n\nFor expert drivers and additional information, see permute!.\n\nExamples\n\njulia> A = spdiagm(0 => [1, 2, 3, 4], 1 => [5, 6, 7])\n4×4 SparseMatrixCSC{Int64, Int64} with 7 stored entries:\n 1  5  ⋅  ⋅\n ⋅  2  6  ⋅\n ⋅  ⋅  3  7\n ⋅  ⋅  ⋅  4\n\njulia> permute(A, [4, 3, 2, 1], [1, 2, 3, 4])\n4×4 SparseMatrixCSC{Int64, Int64} with 7 stored entries:\n ⋅  ⋅  ⋅  4\n ⋅  ⋅  3  7\n ⋅  2  6  ⋅\n 1  5  ⋅  ⋅\n\njulia> permute(A, [1, 2, 3, 4], [4, 3, 2, 1])\n4×4 SparseMatrixCSC{Int64, Int64} with 7 stored entries:\n ⋅  ⋅  5  1\n ⋅  6  2  ⋅\n 7  3  ⋅  ⋅\n 4  ⋅  ⋅  ⋅\n\n\n\n\n\n"},{"title":"Base.permute!","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#Base.permute!-Union{Tuple{Tq}, Tuple{Tp}, Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv, Ti}, SparseMatrixCSC{Tv, Ti}, AbstractVector{Tp}, AbstractVector{Tq}}} where {Tv, Ti, Tp<:Integer, Tq<:Integer}","category":"method","text":"permute!(X::AbstractSparseMatrixCSC{Tv,Ti}, A::AbstractSparseMatrixCSC{Tv,Ti},\n         p::AbstractVector{<:Integer}, q::AbstractVector{<:Integer},\n         [C::AbstractSparseMatrixCSC{Tv,Ti}]) where {Tv,Ti}\n\nBilaterally permute A, storing result PAQ (A[p,q]) in X. Stores intermediate result\n(AQ)^T (transpose(A[:,q])) in optional argument C if present. Requires that none of\nX, A, and, if present, C alias each other; to store result PAQ back into A, use\nthe following method lacking X:\n\npermute!(A::AbstractSparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},\n         q::AbstractVector{<:Integer}[, C::AbstractSparseMatrixCSC{Tv,Ti},\n         [workcolptr::Vector{Ti}]]) where {Tv,Ti}\n\nX's dimensions must match those of A (size(X, 1) == size(A, 1) and size(X, 2) == size(A, 2)), and X must\nhave enough storage to accommodate all allocated entries in A (length(rowvals(X)) >= nnz(A)\nand length(nonzeros(X)) >= nnz(A)). Column-permutation q's length must match A's column\ncount (length(q) == size(A, 2)). Row-permutation p's length must match A's row count\n(length(p) == size(A, 1)).\n\nC's dimensions must match those of transpose(A) (size(C, 1) == size(A, 2) and size(C, 2) == size(A, 1)), and C\nmust have enough storage to accommodate all allocated entries in A (length(rowvals(C)) >= nnz(A)\nand length(nonzeros(C)) >= nnz(A)).\n\nFor additional (algorithmic) information, and for versions of these methods that forgo\nargument checking, see (unexported) parent methods unchecked_noalias_permute!\nand unchecked_aliasing_permute!.\n\nSee also permute.\n\n\n\n\n\n"},{"title":"SparseArrays.halfperm!","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.halfperm!","category":"function","text":"halfperm!(X::AbstractSparseMatrixCSC{Tv,Ti}, A::AbstractSparseMatrixCSC{TvA,Ti},\n          q::AbstractVector{<:Integer}, f::Function = identity) where {Tv,TvA,Ti}\n\nColumn-permute and transpose A, simultaneously applying f to each entry of A, storing\nthe result (f(A)Q)^T (map(f, transpose(A[:,q]))) in X.\n\nElement type Tv of X must match f(::TvA), where TvA is the element type of A.\nX's dimensions must match those of transpose(A) (size(X, 1) == size(A, 2) and\nsize(X, 2) == size(A, 1)), and X must have enough storage to accommodate all allocated\nentries in A (length(rowvals(X)) >= nnz(A) and length(nonzeros(X)) >= nnz(A)).\nColumn-permutation q's length must match A's column count (length(q) == size(A, 2)).\n\nThis method is the parent of several methods performing transposition and permutation\noperations on SparseMatrixCSCs. As this method performs no argument checking,\nprefer the safer child methods ([c]transpose[!], permute[!]) to direct use.\n\nThis method implements the HALFPERM algorithm described in F. Gustavson, \"Two fast\nalgorithms for sparse matrices: multiplication and permuted transposition,\" ACM TOMS 4(3),\n250-269 (1978). The algorithm runs in O(size(A, 1), size(A, 2), nnz(A)) time and requires no space\nbeyond that passed in.\n\n\n\n\n\n"},{"title":"SparseArrays.ftranspose!","page":"Sparse Arrays","location":"stdlib/SparseArrays.html#SparseArrays.ftranspose!","category":"function","text":"ftranspose!(X::AbstractSparseMatrixCSC{Tv,Ti}, A::AbstractSparseMatrixCSC{Tv,Ti}, f::Function) where {Tv,Ti}\n\nTranspose A and store it in X while applying the function f to the non-zero elements.\nDoes not remove the zeros created by f. size(X) must be equal to size(transpose(A)).\nNo additional memory is allocated other than resizing the rowval and nzval of X, if needed.\n\nSee halfperm!\n\n\n\n\n\n"},{"title":"Style Guide","page":"Style Guide","location":"manual/style-guide.html#Style-Guide","category":"section","text":"The following sections explain a few aspects of idiomatic Julia coding style. None of these rules\nare absolute; they are only suggestions to help familiarize you with the language and to help\nyou choose among alternative designs."},{"title":"Indentation","page":"Style Guide","location":"manual/style-guide.html#Indentation","category":"section","text":"Use 4 spaces per indentation level."},{"title":"Write functions, not just scripts","page":"Style Guide","location":"manual/style-guide.html#Write-functions,-not-just-scripts","category":"section","text":"Writing code as a series of steps at the top level is a quick way to get started solving a problem,\nbut you should try to divide a program into functions as soon as possible. Functions are more\nreusable and testable, and clarify what steps are being done and what their inputs and outputs\nare. Furthermore, code inside functions tends to run much faster than top level code, due to how\nJulia's compiler works.\n\nIt is also worth emphasizing that functions should take arguments, instead of operating directly\non global variables (aside from constants like pi)."},{"title":"Write docstrings","page":"Style Guide","location":"manual/style-guide.html#Write-docstrings","category":"section","text":"Comments describing an object should typically be written as docstrings for editor and REPL accessibility.\nInline comments (# comment) and multiline comments (#= comment =#) are appropriate for information that is intended only for the reader of the code (as opposed to a user)."},{"title":"Avoid writing overly-specific types","page":"Style Guide","location":"manual/style-guide.html#Avoid-writing-overly-specific-types","category":"section","text":"Code should be as generic as possible. Instead of writing:\n\nComplex{Float64}(x)\n\nit's better to use available generic functions:\n\ncomplex(float(x))\n\nThe second version will convert x to an appropriate type, instead of always the same type.\n\nThis style point is especially relevant to function arguments. For example, don't declare an argument\nto be of type Int or Int32 if it really could be any integer, expressed with the abstract\ntype Integer. In fact, in many cases you can omit the argument type altogether,\nunless it is needed to disambiguate from other method definitions, since a\nMethodError will be thrown anyway if a type is passed that does not support any\nof the requisite operations. (This is known as\nduck typing.)\n\nFor example, consider the following definitions of a function addone that returns one plus its\nargument:\n\naddone(x::Int) = x + 1                 # works only for Int\naddone(x::Integer) = x + oneunit(x)    # any integer type\naddone(x::Number) = x + oneunit(x)     # any numeric type\naddone(x) = x + oneunit(x)             # any type supporting + and oneunit\n\nThe last definition of addone handles any type supporting oneunit (which returns 1 in\nthe same type as x, which avoids unwanted type promotion) and the + function with\nthose arguments. The key thing to realize is that there is no performance penalty to defining\nonly the general addone(x) = x + oneunit(x), because Julia will automatically compile specialized\nversions as needed. For example, the first time you call addone(12), Julia will automatically\ncompile a specialized addone function for x::Int arguments, with the call to oneunit\nreplaced by its inlined value 1. Therefore, the first three definitions of addone above are\ncompletely redundant with the fourth definition."},{"title":"Handle excess argument diversity in the caller","page":"Style Guide","location":"manual/style-guide.html#Handle-excess-argument-diversity-in-the-caller","category":"section","text":"Instead of:\n\nfunction foo(x, y)\n    x = Int(x); y = Int(y)\n    ...\nend\nfoo(x, y)\n\nuse:\n\nfunction foo(x::Int, y::Int)\n    ...\nend\nfoo(Int(x), Int(y))\n\nThis is better style because foo does not really accept numbers of all types; it really needs\nInt s.\n\nOne issue here is that if a function inherently requires integers, it might be better to force\nthe caller to decide how non-integers should be converted (e.g. floor or ceiling). Another issue\nis that declaring more specific types leaves more \"space\" for future method definitions."},{"title":"Append ! to names of functions that modify their arguments","page":"Style Guide","location":"manual/style-guide.html#bang-convention","category":"section","text":"Instead of:\n\nfunction double(a::AbstractArray{<:Number})\n    for i in eachindex(a)\n        a[i] *= 2\n    end\n    return a\nend\n\nuse:\n\nfunction double!(a::AbstractArray{<:Number})\n    for i in eachindex(a)\n        a[i] *= 2\n    end\n    return a\nend\n\nJulia Base uses this convention throughout and contains examples of functions\nwith both copying and modifying forms (e.g., sort and sort!), and others\nwhich are just modifying (e.g., push!, pop!, splice!). It\nis typical for such functions to also return the modified array for convenience.\n\nFunctions related to IO or making use of random number generators (RNG) are notable exceptions:\nSince these functions almost invariably must mutate the IO or RNG, functions ending with ! are used to signify a mutation other than mutating the IO or advancing the RNG state.\nFor example, rand(x) mutates the RNG, whereas rand!(x) mutates both the RNG and x; similarly, read(io) mutates io, whereas read!(io, x) mutates both arguments."},{"title":"Avoid strange type Unions","page":"Style Guide","location":"manual/style-guide.html#Avoid-strange-type-Unions","category":"section","text":"Types such as Union{Function,AbstractString} are often a sign that some design could be cleaner."},{"title":"Avoid elaborate container types","page":"Style Guide","location":"manual/style-guide.html#Avoid-elaborate-container-types","category":"section","text":"It is usually not much help to construct arrays like the following:\n\na = Vector{Union{Int,AbstractString,Tuple,Array}}(undef, n)\n\nIn this case Vector{Any}(undef, n) is better. It is also more helpful to the compiler to annotate specific\nuses (e.g. a[i]::Int) than to try to pack many alternatives into one type."},{"title":"Prefer exported methods over direct field access","page":"Style Guide","location":"manual/style-guide.html#Prefer-exported-methods-over-direct-field-access","category":"section","text":"Idiomatic Julia code should generally treat a module's exported methods as the\ninterface to its types. An object's fields are generally considered\nimplementation details and user code should only access them directly if this\nis stated to be the API. This has several benefits:\n\nPackage developers are freer to change the implementation without breaking\nuser code.\nMethods can be passed to higher-order constructs like map (e.g.\nmap(imag, zs)) rather than [z.im for z in zs]).\nMethods can be defined on abstract types.\nMethods can describe a conceptual operation that can be shared across\ndisparate types (e.g. real(z) works on Complex numbers or Quaternions).\n\nJulia's dispatch system encourages this style because play(x::MyType) only\ndefines the play method on that particular type, leaving other types to\nhave their own implementation.\n\nSimilarly, non-exported functions are typically internal and subject to change,\nunless the documentations states otherwise. Names sometimes are given a _ prefix\n(or suffix) to further suggest that something is \"internal\" or an\nimplementation-detail, but it is not a rule.\n\nCounter-examples to this rule include NamedTuple, RegexMatch, StatStruct."},{"title":"Use naming conventions consistent with Julia base/","page":"Style Guide","location":"manual/style-guide.html#Use-naming-conventions-consistent-with-Julia-base/","category":"section","text":"modules and type names use capitalization and camel case: module SparseArrays, struct UnitRange.\nconstants use all uppercase and underscores (LOAD_PATH, VERSION).\nwhile anything not marked with public or export is considered internal, a prefix of\n_ also indicates that an object is not intended for public use.\nfunctions mutating at least one of their arguments end in !.\nconciseness is valued, but avoid abbreviation (indexin rather than indxin) as\nit becomes difficult to remember whether and how particular words are abbreviated.\n\nIf a function name requires multiple words, consider whether it might represent more than one\nconcept and might be better split into pieces.\n\nFunction names should be written in snake case (minimum, count_zeros, escape_string).\nBase often breaks this convention by squashing words together (splitpath, readeach) but this style is not recommended for packages."},{"title":"Write functions with argument ordering similar to Julia Base","page":"Style Guide","location":"manual/style-guide.html#Write-functions-with-argument-ordering-similar-to-Julia-Base","category":"section","text":"As a general rule, the Base library uses the following order of arguments to functions,\nas applicable:\n\nFunction argument.\nPutting a function argument first permits the use of do blocks for passing\nmultiline anonymous functions.\nI/O stream.\nSpecifying the IO object first permits passing the function to functions such as\nsprint, e.g. sprint(show, x).\nInput being mutated.\nFor example, in fill!(x, v), x is the object being mutated and it\nappears before the value to be inserted into x.\nType.\nPassing a type typically means that the output will have the given type.\nIn parse(Int, \"1\"), the type comes before the string to parse.\nThere are many such examples where the type appears first, but it's useful to note that\nin read(io, String), the IO argument appears before the type, which is\nin keeping with the order outlined here.\nInput not being mutated.\nIn fill!(x, v), v is not being mutated and it comes after x.\nKey.\nFor associative collections, this is the key of the key-value pair(s).\nFor other indexed collections, this is the index.\nValue.\nFor associative collections, this is the value of the key-value pair(s).\nIn cases like fill!(x, v), this is v.\nEverything else.\nAny other arguments.\nVarargs.\nThis refers to arguments that can be listed indefinitely at the end of a function call.\nFor example, in Matrix{T}(undef, dims), the dimensions can be given as a\nTuple, e.g. Matrix{T}(undef, (1,2)), or as Varargs,\ne.g. Matrix{T}(undef, 1, 2).\nKeyword arguments.\nIn Julia keyword arguments have to come last anyway in function definitions; they're\nlisted here for the sake of completeness.\n\nThe vast majority of functions will not take every kind of argument listed above; the\nnumbers merely denote the precedence that should be used for any applicable arguments\nto a function.\n\nThere are of course a few exceptions.\nFor example, in convert, the type should always come first.\nIn setindex!, the value comes before the indices so that the indices can be\nprovided as varargs.\n\nWhen designing APIs, adhering to this general order as much as possible is likely to give\nusers of your functions a more consistent experience."},{"title":"Don't overuse try-catch","page":"Style Guide","location":"manual/style-guide.html#Don't-overuse-try-catch","category":"section","text":"It is better to avoid errors than to rely on catching them."},{"title":"Don't parenthesize conditions","page":"Style Guide","location":"manual/style-guide.html#Don't-parenthesize-conditions","category":"section","text":"Julia doesn't require parens around conditions in if and while. Write:\n\nif a == b\n\ninstead of:\n\nif (a == b)"},{"title":"Don't overuse ...","page":"Style Guide","location":"manual/style-guide.html#Don't-overuse-...","category":"section","text":"Splicing function arguments can be addictive. Instead of [a..., b...], use simply [a; b],\nwhich already concatenates arrays. collect(a) is better than [a...], but since a\nis already iterable it is often even better to leave it alone, and not convert it to an array."},{"title":"Ensure constructors return an instance of their own type","page":"Style Guide","location":"manual/style-guide.html#Ensure-constructors-return-an-instance-of-their-own-type","category":"section","text":"When a method T(x) is called on a type T, it is generally expected to return a value of type T.\nDefining a constructor that returns an unexpected type can lead to confusing and unpredictable behavior:\n\njulia> struct Foo{T}\n           x::T\n       end\n\njulia> Base.Float64(foo::Foo) = Foo(Float64(foo.x))  # Do not define methods like this\n\njulia> Float64(Foo(3))  # Should return `Float64`\nFoo{Float64}(3.0)\n\njulia> Foo{Int}(x) = Foo{Float64}(x)  # Do not define methods like this\n\njulia> Foo{Int}(3)  # Should return `Foo{Int}`\nFoo{Float64}(3.0)\n\nTo maintain code clarity and ensure type consistency, always design constructors to return an instance of the type they are supposed to construct."},{"title":"Don't use unnecessary static parameters","page":"Style Guide","location":"manual/style-guide.html#Don't-use-unnecessary-static-parameters","category":"section","text":"A function signature:\n\nfoo(x::T) where {T<:Real} = ...\n\nshould be written as:\n\nfoo(x::Real) = ...\n\ninstead, especially if T is not used in the function body. Even if T is used, it can be replaced\nwith typeof(x) if convenient. There is no performance difference. Note that this is\nnot a general caution against static parameters, just against uses where they are not needed.\n\nNote also that container types, specifically may need type parameters in function calls. See the\nFAQ Avoid fields with abstract containers for more information."},{"title":"Avoid confusion about whether something is an instance or a type","page":"Style Guide","location":"manual/style-guide.html#Avoid-confusion-about-whether-something-is-an-instance-or-a-type","category":"section","text":"Sets of definitions like the following are confusing:\n\nfoo(::Type{MyType}) = ...\nfoo(::MyType) = foo(MyType)\n\nDecide whether the concept in question will be written as MyType or MyType(), and stick to\nit.\n\nThe preferred style is to use instances by default, and only add methods involving Type{MyType}\nlater if they become necessary to solve some problems.\n\nIf a type is effectively an enumeration, it should be defined as a single (ideally immutable struct or primitive)\ntype, with the enumeration values being instances of it. Constructors and conversions can check\nwhether values are valid. This design is preferred over making the enumeration an abstract type,\nwith the \"values\" as subtypes."},{"title":"Don't overuse macros","page":"Style Guide","location":"manual/style-guide.html#Don't-overuse-macros","category":"section","text":"Be aware of when a macro could really be a function instead.\n\nCalling eval inside a macro is a particularly dangerous warning sign; it means the\nmacro will only work when called at the top level. If such a macro is written as a function instead,\nit will naturally have access to the run-time values it needs."},{"title":"Don't expose unsafe operations at the interface level","page":"Style Guide","location":"manual/style-guide.html#Don't-expose-unsafe-operations-at-the-interface-level","category":"section","text":"If you have a type that uses a native pointer:\n\nmutable struct NativeType\n    p::Ptr{UInt8}\n    ...\nend\n\ndon't write definitions like the following:\n\ngetindex(x::NativeType, i) = unsafe_load(x.p, i)\n\nThe problem is that users of this type can write x[i] without realizing that the operation is\nunsafe, and then be susceptible to memory bugs.\n\nSuch a function should either check the operation to ensure it is safe, or have unsafe somewhere\nin its name to alert callers."},{"title":"Don't overload methods of base container types","page":"Style Guide","location":"manual/style-guide.html#Don't-overload-methods-of-base-container-types","category":"section","text":"It is possible to write definitions like the following:\n\nshow(io::IO, v::Vector{MyType}) = ...\n\nThis would provide custom showing of vectors with a specific new element type. While tempting,\nthis should be avoided. The trouble is that users will expect a well-known type like Vector()\nto behave in a certain way, and overly customizing its behavior can make it harder to work with."},{"title":"Avoid type piracy","page":"Style Guide","location":"manual/style-guide.html#avoid-type-piracy","category":"section","text":"\"Type piracy\" refers to the practice of extending or redefining methods in Base\nor other packages on types that you have not defined. In extreme cases, you can crash Julia\n(e.g. if your method extension or redefinition causes invalid input to be passed to a\nccall). Type piracy can complicate reasoning about code, and may introduce\nincompatibilities that are hard to predict and diagnose.\n\nAs an example, suppose you wanted to define multiplication on symbols in a module:\n\nmodule A\nimport Base.*\n*(x::Symbol, y::Symbol) = Symbol(x,y)\nend\n\nThe problem is that now any other module that uses Base.* will also see this definition.\nSince Symbol is defined in Base and is used by other modules, this can change the\nbehavior of unrelated code unexpectedly. There are several alternatives here, including\nusing a different function name, or wrapping the Symbols in another type that you define.\n\nSometimes, coupled packages may engage in type piracy to separate features from definitions,\nespecially when the packages were designed by collaborating authors, and when the\ndefinitions are reusable. For example, one package might provide some types useful for\nworking with colors; another package could define methods for those types that enable\nconversions between color spaces. Another example might be a package that acts as a thin\nwrapper for some C code, which another package might then pirate to implement a\nhigher-level, Julia-friendly API."},{"title":"Be careful with type equality","page":"Style Guide","location":"manual/style-guide.html#Be-careful-with-type-equality","category":"section","text":"You generally want to use isa and <: for testing types,\nnot ==. Checking types for exact equality typically only makes sense when comparing to a known\nconcrete type (e.g. T == Float64), or if you really, really know what you're doing."},{"title":"Don't write a trivial anonymous function x->f(x) for a named function f","page":"Style Guide","location":"manual/style-guide.html#Don't-write-a-trivial-anonymous-function-x-f(x)-for-a-named-function-f","category":"section","text":"Since higher-order functions are often called with anonymous functions, it is easy to conclude\nthat this is desirable or even necessary. But any function can be passed directly, without being\n\"wrapped\" in an anonymous function. Instead of writing map(x->f(x), a), write map(f, a)."},{"title":"Avoid using floats for numeric literals in generic code when possible","page":"Style Guide","location":"manual/style-guide.html#Avoid-using-floats-for-numeric-literals-in-generic-code-when-possible","category":"section","text":"If you write generic code which handles numbers, and which can be expected to run with many different\nnumeric type arguments, try using literals of a numeric type that will affect the arguments as\nlittle as possible through promotion.\n\nFor example,\n\njulia> f(x) = 2.0 * x\nf (generic function with 1 method)\n\njulia> f(1//2)\n1.0\n\njulia> f(1/2)\n1.0\n\njulia> f(1)\n2.0\n\nwhile\n\njulia> g(x) = 2 * x\ng (generic function with 1 method)\n\njulia> g(1//2)\n1//1\n\njulia> g(1/2)\n1.0\n\njulia> g(1)\n2\n\nAs you can see, the second version, where we used an Int literal, preserved the type of the\ninput argument, while the first didn't. This is because e.g. promote_type(Int, Float64) == Float64,\nand promotion happens with the multiplication. Similarly, Rational literals are less type disruptive\nthan Float64 literals, but more disruptive than Ints:\n\njulia> h(x) = 2//1 * x\nh (generic function with 1 method)\n\njulia> h(1//2)\n1//1\n\njulia> h(1/2)\n1.0\n\njulia> h(1)\n2//1\n\nThus, use Int literals when possible, with Rational{Int} for literal non-integer numbers,\nin order to make it easier to use your code."},{"title":"Asynchronous Programming","page":"Asynchronous Programming","location":"manual/asynchronous-programming.html#man-asynchronous","category":"section","text":"When a program needs to interact with the outside world, for example communicating\nwith another machine over the internet, operations in the program may need to\nhappen in an unpredictable order.\nSay your program needs to download a file. We would like to initiate the download\noperation, perform other operations while we wait for it to complete, and then\nresume the code that needs the downloaded file when it is available.\nThis sort of scenario falls in the domain of asynchronous programming, sometimes\nalso referred to as concurrent programming (since, conceptually, multiple things\nare happening at once).\n\nTo address these scenarios, Julia provides Tasks (also known by several other\nnames, such as symmetric coroutines, lightweight threads, cooperative multitasking,\nor one-shot continuations).\nWhen a piece of computing work (in practice, executing a particular function) is designated as\na Task, it becomes possible to interrupt it by switching to another Task.\nThe original Task can later be resumed, at which point it will pick up right where it\nleft off. At first, this may seem similar to a function call. However there are two key differences.\nFirst, switching tasks does not use any space, so any number of task switches can occur without\nconsuming the call stack. Second, switching among tasks can occur in any order, unlike function\ncalls, where the called function must finish executing before control returns to the calling function."},{"title":"Basic Task operations","page":"Asynchronous Programming","location":"manual/asynchronous-programming.html#Basic-Task-operations","category":"section","text":"You can think of a Task as a handle to a unit of computational work to be performed.\nIt has a create-start-run-finish lifecycle.\nTasks are created by calling the Task constructor on a 0-argument function to run,\nor using the @task macro:\n\njulia> t = @task begin; sleep(5); println(\"done\"); end\nTask (runnable) @0x00007f13a40c0eb0\n\n@task x is equivalent to Task(()->x).\n\nThis task will wait for five seconds, and then print done. However, it has not\nstarted running yet. We can run it whenever we're ready by calling schedule:\n\njulia> schedule(t);\n\nIf you try this in the REPL, you will see that schedule returns immediately.\nThat is because it simply adds t to an internal queue of tasks to run.\nThen, the REPL will print the next prompt and wait for more input.\nWaiting for keyboard input provides an opportunity for other tasks to run,\nso at that point t will start.\nt calls sleep, which sets a timer and stops execution.\nIf other tasks have been scheduled, they could run then.\nAfter five seconds, the timer fires and restarts t, and you will see done\nprinted. t is then finished.\n\nThe wait function blocks the calling task until some other task finishes.\nSo for example if you type\n\njulia> schedule(t); wait(t)\n\ninstead of only calling schedule, you will see a five second pause before\nthe next input prompt appears. That is because the REPL is waiting for t\nto finish before proceeding.\n\nIt is common to want to create a task and schedule it right away, so the\nmacro Threads.@spawn is provided for that purpose — Threads.@spawn x is\nequivalent to task = @task x; task.sticky = false; schedule(task)."},{"title":"Communicating with Channels","page":"Asynchronous Programming","location":"manual/asynchronous-programming.html#Communicating-with-Channels","category":"section","text":"In some problems,\nthe various pieces of required work are not naturally related by function calls; there is no obvious\n\"caller\" or \"callee\" among the jobs that need to be done. An example is the producer-consumer\nproblem, where one complex procedure is generating values and another complex procedure is consuming\nthem. The consumer cannot simply call a producer function to get a value, because the producer\nmay have more values to generate and so might not yet be ready to return. With tasks, the producer\nand consumer can both run as long as they need to, passing values back and forth as necessary.\n\nJulia provides a Channel mechanism for solving this problem.\nA Channel is a waitable first-in first-out queue which can have\nmultiple tasks reading from and writing to it.\n\nLet's define a producer task, which produces values via the put! call.\nTo consume values, we need to schedule the producer to run in a new task. A special Channel\nconstructor which accepts a 1-arg function as an argument can be used to run a task bound to a channel.\nWe can then take! values repeatedly from the channel object:\n\njulia> function producer(c::Channel)\n           put!(c, \"start\")\n           for n=1:4\n               put!(c, 2n)\n           end\n           put!(c, \"stop\")\n       end;\n\njulia> chnl = Channel(producer);\n\njulia> take!(chnl)\n\"start\"\n\njulia> take!(chnl)\n2\n\njulia> take!(chnl)\n4\n\njulia> take!(chnl)\n6\n\njulia> take!(chnl)\n8\n\njulia> take!(chnl)\n\"stop\"\n\nOne way to think of this behavior is that producer was able to return multiple times. Between\ncalls to put!, the producer's execution is suspended and the consumer has control.\n\nThe returned Channel can be used as an iterable object in a for loop, in which case the\nloop variable takes on all the produced values. The loop is terminated when the channel is closed.\n\njulia> for x in Channel(producer)\n           println(x)\n       end\nstart\n2\n4\n6\n8\nstop\n\nNote that we did not have to explicitly close the channel in the producer. This is because\nthe act of binding a Channel to a Task associates the open lifetime of\na channel with that of the bound task. The channel object is closed automatically when the task\nterminates. Multiple channels can be bound to a task, and vice-versa.\n\nWhile the Task constructor expects a 0-argument function, the Channel\nmethod that creates a task-bound channel expects a function that accepts a single argument of\ntype Channel. A common pattern is for the producer to be parameterized, in which case a partial\nfunction application is needed to create a 0 or 1 argument anonymous function.\n\nFor Task objects this can be done either directly or by use of a convenience macro:\n\nfunction mytask(myarg)\n    ...\nend\n\ntaskHdl = Task(() -> mytask(7))\n# or, equivalently\ntaskHdl = @task mytask(7)\n\nTo orchestrate more advanced work distribution patterns, bind and schedule\ncan be used in conjunction with Task and Channel\nconstructors to explicitly link a set of channels with a set of producer/consumer tasks."},{"title":"More on Channels","page":"Asynchronous Programming","location":"manual/asynchronous-programming.html#More-on-Channels","category":"section","text":"A channel can be visualized as a pipe, i.e., it has a write end and a read end:\n\nMultiple writers in different tasks can write to the same channel concurrently via put!\ncalls.\nMultiple readers in different tasks can read data concurrently via take! calls.\nAs an example:\n# Given Channels c1 and c2,\nc1 = Channel(32)\nc2 = Channel(32)\n\n# and a function `foo` which reads items from c1, processes the item read\n# and writes a result to c2,\nfunction foo()\n    while true\n        data = take!(c1)\n        [...]               # process data\n        put!(c2, result)    # write out result\n    end\nend\n\n# we can schedule `n` instances of `foo` to be active concurrently.\nfor _ in 1:n\n    errormonitor(Threads.@spawn foo())\nend\nChannels are created via the Channel{T}(sz) constructor. The channel will only hold objects\nof type T. If the type is not specified, the channel can hold objects of any type. sz refers\nto the maximum number of elements that can be held in the channel at any time. For example, Channel(32)\ncreates a channel that can hold a maximum of 32 objects of any type. A Channel{MyType}(64) can\nhold up to 64 objects of MyType at any time.\nIf a Channel is empty, readers (on a take! call) will block until data is available (see isempty).\nIf a Channel is full, writers (on a put! call) will block until space becomes available (see isfull).\nisready tests for the presence of any object in the channel, while wait\nwaits for an object to become available.\nNote that if another task is currently waiting to put! an object into a channel, a channel can have more items available than its capacity.\nA Channel is in an open state initially. This means that it can be read from and written to\nfreely via take! and put! calls. close closes a Channel.\nOn a closed Channel, put! will fail. For example:\njulia> c = Channel(2);\n\njulia> put!(c, 1) # `put!` on an open channel succeeds\n1\n\njulia> close(c);\n\njulia> put!(c, 2) # `put!` on a closed channel throws an exception.\nERROR: InvalidStateException: Channel is closed.\nStacktrace:\n[...]\ntake! and fetch (which retrieves but does not remove the value) on a closed\nchannel successfully return any existing values until it is emptied. Continuing the above example:\njulia> fetch(c) # Any number of `fetch` calls succeed.\n1\n\njulia> fetch(c)\n1\n\njulia> take!(c) # The first `take!` removes the value.\n1\n\njulia> take!(c) # No more data available on a closed channel.\nERROR: InvalidStateException: Channel is closed.\nStacktrace:\n[...]\n\nConsider a simple example using channels for inter-task communication. We start 4 tasks to process\ndata from a single jobs channel. Jobs, identified by an id (job_id), are written to the channel.\nEach task in this simulation reads a job_id, waits for a random amount of time and writes back\na tuple of job_id and the simulated time to the results channel. Finally all the results are\nprinted out.\n\njulia> const jobs = Channel{Int}(32);\n\njulia> const results = Channel{Tuple}(32);\n\njulia> function do_work()\n           for job_id in jobs\n               exec_time = rand()\n               sleep(exec_time)                # simulates elapsed time doing actual work\n                                               # typically performed externally.\n               put!(results, (job_id, exec_time))\n           end\n       end;\n\njulia> function make_jobs(n)\n           for i in 1:n\n               put!(jobs, i)\n           end\n       end;\n\njulia> n = 12;\n\njulia> errormonitor(Threads.@spawn make_jobs(n)); # feed the jobs channel with \"n\" jobs\n\njulia> for i in 1:4 # start 4 tasks to process requests in parallel\n           errormonitor(Threads.@spawn do_work())\n       end\n\njulia> @elapsed while n > 0 # print out results\n           job_id, exec_time = take!(results)\n           println(\"$job_id finished in $(round(exec_time; digits=2)) seconds\")\n           global n = n - 1\n       end\n4 finished in 0.22 seconds\n3 finished in 0.45 seconds\n1 finished in 0.5 seconds\n7 finished in 0.14 seconds\n2 finished in 0.78 seconds\n5 finished in 0.9 seconds\n9 finished in 0.36 seconds\n6 finished in 0.87 seconds\n8 finished in 0.79 seconds\n10 finished in 0.64 seconds\n12 finished in 0.5 seconds\n11 finished in 0.97 seconds\n0.029772311\n\nInstead of errormonitor(t), a more robust solution may be to use bind(results, t), as that will\nnot only log any unexpected failures, but also force the associated resources to close and propagate\nthe exception everywhere."},{"title":"More task operations","page":"Asynchronous Programming","location":"manual/asynchronous-programming.html#More-task-operations","category":"section","text":"Task operations are built on a low-level primitive called yieldto.\nyieldto(task, value) suspends the current task, switches to the specified task, and causes\nthat task's last yieldto call to return the specified value. Notice that yieldto\nis the only operation required to use task-style control flow; instead of calling and returning\nwe are always just switching to a different task. This is why this feature is also called \"symmetric\ncoroutines\"; each task is switched to and from using the same mechanism.\n\nyieldto is powerful, but most uses of tasks do not invoke it directly. Consider why\nthis might be. If you switch away from the current task, you will probably want to switch back\nto it at some point, but knowing when to switch back, and knowing which task has the responsibility\nof switching back, can require considerable coordination. For example, put! and take!\nare blocking operations, which, when used in the context of channels maintain state to remember\nwho the consumers are. Not needing to manually keep track of the consuming task is what makes put!\neasier to use than the low-level yieldto.\n\nIn addition to yieldto, a few other basic functions are needed to use tasks effectively.\n\ncurrent_task gets a reference to the currently-running task.\nistaskdone queries whether a task has exited.\nistaskstarted queries whether a task has run yet.\ntask_local_storage manipulates a key-value store specific to the current task."},{"title":"Tasks and events","page":"Asynchronous Programming","location":"manual/asynchronous-programming.html#Tasks-and-events","category":"section","text":"Most task switches occur as a result of waiting for events such as I/O requests, and are performed\nby a scheduler included in Julia Base. The scheduler maintains a queue of runnable tasks,\nand executes an event loop that restarts tasks based on external events such as message arrival.\n\nThe basic function for waiting for an event is wait. Several objects implement wait;\nfor example, given a Process object, wait will wait for it to exit. wait\nis often implicit; for example, a wait can happen inside a call to read\nto wait for data to be available.\n\nIn all of these cases, wait ultimately operates on a Condition object, which\nis in charge of queueing and restarting tasks. When a task calls wait on a Condition,\nthe task is marked as non-runnable, added to the condition's queue, and switches to the scheduler.\nThe scheduler will then pick another task to run, or block waiting for external events. If all\ngoes well, eventually an event handler will call notify on the condition, which causes\ntasks waiting for that condition to become runnable again.\n\nA task created explicitly by calling Task is initially not known to the scheduler. This\nallows you to manage tasks manually using yieldto if you wish. However, when such\na task waits for an event, it still gets restarted automatically when the event happens, as you\nwould expect."},{"title":"Inference","page":"Inference","location":"devdocs/inference.html#Inference","category":"section","text":""},{"title":"How inference works","page":"Inference","location":"devdocs/inference.html#How-inference-works","category":"section","text":"In Julia compiler, \"type inference\" refers to the process of deducing the types of later\nvalues from the types of input values. Julia's approach to inference has been described in\nthe blog posts below:\n\nShows a simplified implementation of the data-flow analysis algorithm, that Julia's type inference routine is based on.\nGives a high level view of inference with a focus on its inter-procedural convergence guarantee.\nExplains a refinement on the algorithm introduced in 2."},{"title":"Debugging compiler.jl","page":"Inference","location":"devdocs/inference.html#Debugging-compiler.jl","category":"section","text":"You can start a Julia session, edit compiler/*.jl (for example to\ninsert print statements), and then replace Core.Compiler in your\nrunning session by navigating to base and executing\ninclude(\"compiler/compiler.jl\"). This trick typically leads to much faster\ndevelopment than if you rebuild Julia for each change.\n\nAlternatively, you can use the Revise.jl\npackage to track the compiler changes by using the command\nRevise.track(Core.Compiler) at the beginning of your Julia session. As\nexplained in the Revise documentation,\nthe modifications to the compiler will be reflected when the modified files\nare saved.\n\nA convenient entry point into inference is typeinf_code. Here's a\ndemo running inference on convert(Int, UInt(1)):\n\n# Get the method\natypes = Tuple{Type{Int}, UInt}  # argument types\nmths = methods(convert, atypes)  # worth checking that there is only one\nm = first(mths)\n\n# Create variables needed to call `typeinf_code`\ninterp = Core.Compiler.NativeInterpreter()\nsparams = Core.svec()      # this particular method doesn't have type-parameters\nrun_optimizer = true       # run all inference optimizations\ntypes = Tuple{typeof(convert), atypes.parameters...} # Tuple{typeof(convert), Type{Int}, UInt}\nCore.Compiler.typeinf_code(interp, m, types, sparams, run_optimizer)\n\nIf your debugging adventures require a MethodInstance, you can look it up by\ncalling Core.Compiler.specialize_method using many of the variables above.\nA CodeInfo object may be obtained with\n\n# Returns the CodeInfo object for `convert(Int, ::UInt)`:\nci = (@code_typed convert(Int, UInt(1)))[1]"},{"title":"The inlining algorithm (inline_worthy)","page":"Inference","location":"devdocs/inference.html#The-inlining-algorithm-(inline_worthy)","category":"section","text":"Much of the hardest work for inlining runs in ssa_inlining_pass!.\nHowever, if your question is \"why didn't my function inline?\"\nthen you will most likely be interested in inline_worthy,\nwhich makes a decision to inline the function call or not.\n\ninline_worthy implements a cost-model, where \"cheap\" functions get\ninlined; more specifically, we inline functions if their anticipated\nrun-time is not large compared to the time it would take to\nissue a call to\nthem if they were not inlined. The cost-model is extremely simple and\nignores many important details: for example, all for loops are\nanalyzed as if they will be executed once, and the cost of an\nif...else...end includes the summed cost of all branches. It's also\nworth acknowledging that we currently lack a suite of functions\nsuitable for testing how well the cost model predicts the actual\nrun-time cost, although\nBaseBenchmarks\nprovides a great deal of indirect information about the successes and\nfailures of any modification to the inlining algorithm.\n\nThe foundation of the cost-model is a lookup table, implemented in\nadd_tfunc and its callers, that assigns an estimated cost (measured\nin CPU cycles) to each of Julia's intrinsic functions. These costs are\nbased on\nstandard ranges for common architectures\n(see\nAgner Fog's analysis\nfor more detail).\n\nWe supplement this low-level lookup table with a number of special\ncases. For example, an :invoke expression (a call for which all\ninput and output types were inferred in advance) is assigned a fixed\ncost (currently 20 cycles). In contrast, a :call expression, for\nfunctions other than intrinsics/builtins, indicates that the call will\nrequire dynamic dispatch, in which case we assign a cost set by\nParams.inline_nonleaf_penalty (currently set at 1000). Note\nthat this is not a \"first-principles\" estimate of the raw cost of\ndynamic dispatch, but a mere heuristic indicating that dynamic\ndispatch is extremely expensive.\n\nEach statement gets analyzed for its total cost in a function called\nstatement_cost. You can display the cost associated with each statement\nas follows:\n\njulia> Base.print_statement_costs(stdout, map, (typeof(sqrt), Tuple{Int},)) # map(sqrt, (2,))\nmap(f, t::Tuple{Any}) @ Base tuple.jl:358\n  0 1 ─ %1  = $(Expr(:boundscheck, true))::Bool\n  0 │   %2  =   builtin Base.getfield(_3, 1, %1)::Int64\n  1 │   %3  = intrinsic Base.sitofp(Float64, %2)::Float64\n  0 │   %4  = intrinsic Base.lt_float(%3, 0.0)::Bool\n  0 └──       goto #3 if not %4\n  0 2 ─          invoke Base.Math.throw_complex_domainerror(:sqrt::Symbol, %3::Float64)::Union{}\n  0 └──       unreachable\n 20 3 ─ %8  = intrinsic Base.Math.sqrt_llvm(%3)::Float64\n  0 └──       goto #4\n  0 4 ─       goto #5\n  0 5 ─ %11 =   builtin Core.tuple(%8)::Tuple{Float64}\n  0 └──       return %11\n\n\nThe line costs are in the left column. This includes the consequences of inlining and other forms of optimization."},{"title":"Functions","page":"Functions","location":"manual/functions.html#man-functions","category":"section","text":"In Julia, a function is an object that maps a tuple of argument values to a return value. Julia\nfunctions are not pure mathematical functions, because they can alter and be affected\nby the global state of the program. The basic syntax for defining functions in Julia is:\n\njulia> function f(x, y)\n           x + y\n       end\nf (generic function with 1 method)\n\nThis function accepts two arguments x and y and returns the value\nof the last expression evaluated, which is x + y.\n\nThere is a second, more terse syntax for defining a function in Julia. The traditional function\ndeclaration syntax demonstrated above is equivalent to the following compact \"assignment form\":\n\njulia> f(x, y) = x + y\nf (generic function with 1 method)\n\nIn the assignment form, the body of the function must be a single expression, although it can\nbe a compound expression (see Compound Expressions). Short, simple function definitions\nare common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing\nboth typing and visual noise.\n\nA function is called using the traditional parenthesis syntax:\n\njulia> f(2, 3)\n5\n\nWithout parentheses, the expression f refers to the function object, and can be passed around\nlike any other value:\n\njulia> g = f;\n\njulia> g(2, 3)\n5\n\nAs with variables, Unicode can also be used for function names:\n\njulia> ∑(x, y) = x + y\n∑ (generic function with 1 method)\n\njulia> ∑(2, 3)\n5"},{"title":"Argument Passing Behavior","page":"Functions","location":"manual/functions.html#man-argument-passing","category":"section","text":"Julia function arguments follow a convention sometimes called \"pass-by-sharing\", which means that\nvalues are not copied when they are passed to functions. Function arguments themselves act as\nnew variable bindings (new \"names\" that can refer to values), much like\nassignments argument_name = argument_value, so that the objects they refer to\nare identical to the passed values. Modifications to mutable values (such as Arrays) made within\na function will be visible to the caller. (This is the same behavior found in Scheme, most Lisps,\nPython, Ruby and Perl, among other dynamic languages.)\n\nFor example, in the function\n\nfunction f(x, y)\n    x[1] = 42    # mutates x\n    y = 7 + y    # new binding for y, no mutation\n    return y\nend\n\nThe statement x[1] = 42 mutates the object x, and hence this change will be visible in the array passed\nby the caller for this argument. On the other hand, the assignment y = 7 + y changes the binding (\"name\")\ny to refer to a new value 7 + y, rather than mutating the original object referred to by y,\nand hence does not change the corresponding argument passed by the caller. This can be seen if we call f(x, y):\n\njulia> a = [4, 5, 6]\n3-element Vector{Int64}:\n 4\n 5\n 6\n\njulia> b = 3\n3\n\njulia> f(a, b) # returns 7 + b == 10\n10\n\njulia> a  # a[1] is changed to 42 by f\n3-element Vector{Int64}:\n 42\n  5\n  6\n\njulia> b  # not changed\n3\n\nAs a common convention in Julia (not a syntactic requirement), such a function would\ntypically be named f!(x, y) rather than f(x, y), as a visual reminder at\nthe call site that at least one of the arguments (often the first one) is being mutated.\n\nwarning: Shared memory between arguments\nThe behavior of a mutating function can be unexpected when a mutated argument shares memory with another argument, a situation known as aliasing (e.g. when one is a view of the other).\nUnless the function docstring explicitly indicates that aliasing produces the expected result, it is the responsibility of the caller to ensure proper behavior on such inputs."},{"title":"Argument-type declarations","page":"Functions","location":"manual/functions.html#Argument-type-declarations","category":"section","text":"You can declare the types of function arguments by appending ::TypeName to the argument name, as usual for Type Declarations in Julia.\nFor example, the following function computes Fibonacci numbers recursively:\n\nfib(n::Integer) = n ≤ 2 ? one(n) : fib(n-1) + fib(n-2)\n\nand the ::Integer specification means that it will only be callable when n is a subtype of the abstract Integer type.\n\nArgument-type declarations normally have no impact on performance: regardless of what argument types (if any) are declared, Julia compiles a specialized version of the function for the actual argument types passed by the caller. For example, calling fib(1) will trigger the compilation of specialized version of fib optimized specifically for Int arguments, which is then re-used if fib(7) or fib(15) are called.  (There are rare exceptions when an argument-type declaration can trigger additional compiler specializations; see: Be aware of when Julia avoids specializing.)  The most common reasons to declare argument types in Julia are, instead:\n\nDispatch: As explained in Methods, you can have different versions (\"methods\") of a function for different argument types, in which case the argument types are used to determine which implementation is called for which arguments. For example, you might implement a completely different algorithm fib(x::Number) = ... that works for any Number type by using Binet's formula to extend it to non-integer values.\nCorrectness: Type declarations can be useful if your function only returns correct results for certain argument types. For example, if we omitted argument types and wrote fib(n) = n ≤ 2 ? one(n) : fib(n-1) + fib(n-2), then fib(1.5) would silently give us the nonsensical answer 1.0.\nClarity: Type declarations can serve as a form of documentation about the expected arguments.\n\nHowever, it is a common mistake to overly restrict the argument types, which can unnecessarily limit the applicability of the function and prevent it from being re-used in circumstances you did not anticipate. For example, the fib(n::Integer) function above works equally well for Int arguments (machine integers) and BigInt arbitrary-precision integers (see BigFloats and BigInts), which is especially useful because Fibonacci numbers grow exponentially rapidly and will quickly overflow any fixed-precision type like Int (see Overflow behavior). If we had declared our function as fib(n::Int), however, the application to BigInt would have been prevented for no reason. In general, you should use the most general applicable abstract types for arguments, and when in doubt, omit the argument types. You can always add argument-type specifications later if they become necessary, and you don't sacrifice performance or functionality by omitting them."},{"title":"The return Keyword","page":"Functions","location":"manual/functions.html#The-return-Keyword","category":"section","text":"The value returned by a function is the value of the last expression evaluated, which, by default,\nis the last expression in the body of the function definition. In the example function, f, from\nthe previous section this is the value of the expression x + y.\nAs an alternative, as in many other languages,\nthe return keyword causes a function to return immediately, providing\nan expression whose value is returned:\n\nfunction g(x, y)\n    return x * y\n    x + y\nend\n\nSince function definitions can be entered into interactive sessions, it is easy to compare these\ndefinitions:\n\njulia> f(x, y) = x + y\nf (generic function with 1 method)\n\njulia> function g(x, y)\n           return x * y\n           x + y\n       end\ng (generic function with 1 method)\n\njulia> f(2, 3)\n5\n\njulia> g(2, 3)\n6\n\nOf course, in a purely linear function body like g, the usage of return is pointless since\nthe expression x + y is never evaluated and we could simply make x * y the last expression\nin the function and omit the return. In conjunction with other control flow, however, return\nis of real use. Here, for example, is a function that computes the hypotenuse length of a right\ntriangle with sides of length x and y, avoiding overflow:\n\njulia> function hypot(x, y)\n           x = abs(x)\n           y = abs(y)\n           if x > y\n               r = y/x\n               return x*sqrt(1 + r*r)\n           end\n           if y == 0\n               return float(x)\n           end\n           r = x/y\n           return y*sqrt(1 + r*r)\n       end\nhypot (generic function with 1 method)\n\njulia> hypot(3, 4)\n5.0\n\nThere are three possible points of return from this function, returning the values of three different\nexpressions, depending on the values of x and y. The return on the last line could be omitted\nsince it is the last expression."},{"title":"Return type","page":"Functions","location":"manual/functions.html#man-functions-return-type","category":"section","text":"A return type can be specified in the function declaration using the :: operator. This converts\nthe return value to the specified type.\n\njulia> function g(x, y)::Int8\n           return x * y\n       end;\n\njulia> typeof(g(1, 2))\nInt8\n\nThis function will always return an Int8 regardless of the types of x and y.\nSee Type Declarations for more on return types.\n\nReturn type declarations are rarely used in Julia: in general, you should\ninstead write \"type-stable\" functions in which Julia's compiler can automatically\ninfer the return type. For more information, see the Performance Tips chapter."},{"title":"Returning nothing","page":"Functions","location":"manual/functions.html#Returning-nothing","category":"section","text":"For functions that do not need to return a value (functions used only for some side effects),\nthe Julia convention is to return the value nothing:\n\nfunction printx(x)\n    println(\"x = $x\")\n    return nothing\nend\n\nThis is a convention in the sense that nothing is not a Julia keyword\nbut only a singleton object of type Nothing.\nAlso, you may notice that the printx function example above is contrived,\nbecause println already returns nothing, so that the return line is redundant.\n\nThere are two possible shortened forms for the return nothing expression.\nOn the one hand, the return keyword implicitly returns nothing, so it can be used alone.\nOn the other hand, since functions implicitly return their last expression evaluated,\nnothing can be used alone when it's the last expression.\nThe preference for the expression return nothing as opposed to return or nothing\nalone is a matter of coding style."},{"title":"Operators Are Functions","page":"Functions","location":"manual/functions.html#Operators-Are-Functions","category":"section","text":"In Julia, most operators are just functions with support for special syntax. (The exceptions are\noperators with special evaluation semantics like && and ||. These operators cannot be functions\nsince Short-Circuit Evaluation requires that their operands are not evaluated before evaluation\nof the operator.) Accordingly, you can also apply them using parenthesized argument lists, just\nas you would any other function:\n\njulia> 1 + 2 + 3\n6\n\njulia> +(1, 2, 3)\n6\n\nThe infix form is exactly equivalent to the function application form – in fact the former is\nparsed to produce the function call internally. This also means that you can assign and pass around\noperators such as + and * just like you would with other function values:\n\njulia> f = +;\n\njulia> f(1, 2, 3)\n6\n\nUnder the name f, the function does not support infix notation, however."},{"title":"Operators With Special Names","page":"Functions","location":"manual/functions.html#Operators-With-Special-Names","category":"section","text":"A few special expressions correspond to calls to functions with non-obvious names. These are:\n\nExpression Calls\n[A B C ...] hcat\n[A; B; C; ...] vcat\n[A B; C D; ...] hvcat\n[A; B;; C; D;; ...] hvncat\nA' adjoint\nA[i] getindex\nA[i] = x setindex!\nA.n getproperty\nA.n = x setproperty!\n\nNote that expressions similar to [A; B;; C; D;; ...] but with more than two\nconsecutive ; also correspond to hvncat calls."},{"title":"Anonymous Functions","page":"Functions","location":"manual/functions.html#man-anonymous-functions","category":"section","text":"Functions in Julia are first-class objects:\nthey can be assigned to variables, and called using the standard function call syntax from the\nvariable they have been assigned to. They can be used as arguments, and they can be returned as\nvalues. They can also be created anonymously, without being given a name, using either of these\nsyntaxes:\n\njulia> x -> x^2 + 2x - 1\n#2 (generic function with 1 method)\n\njulia> function (x)\n           x^2 + 2x - 1\n       end\n#5 (generic function with 1 method)\n\nEach statement creates a function taking one argument x and returning the value of the polynomial x^2 + 2x - 1 at that value. Notice that the result is a generic function, but with a compiler-generated\nname based on consecutive numbering.\n\nThe primary use for anonymous functions is passing them to functions which take other functions\nas arguments. A classic example is map, which applies a function to each value of\nan array and returns a new array containing the resulting values:\n\njulia> map(round, [1.2, 3.5, 1.7])\n3-element Vector{Float64}:\n 1.0\n 4.0\n 2.0\n\nThis is fine if a named function effecting the transform already exists to pass as the first argument\nto map. Often, however, a ready-to-use, named function does not exist. In these\nsituations, the anonymous function construct allows easy creation of a single-use function object\nwithout needing a name:\n\njulia> map(x -> x^2 + 2x - 1, [1, 3, -1])\n3-element Vector{Int64}:\n  2\n 14\n -2\n\nAn anonymous function accepting multiple arguments can be written using the syntax (x,y,z)->2x+y-z.\n\nArgument-type declarations for anonymous functions work as for named functions, for example x::Integer->2x.\nThe return type of an anonymous function cannot be specified.\n\nA zero-argument anonymous function can be written as ()->2+2. The idea of a function with\nno arguments may seem strange, but is useful in cases where a result cannot (or should not)\nbe precomputed. For example, Julia has a zero-argument time function that returns\nthe current time in seconds, and thus seconds = ()->round(Int, time()) is an anonymous\nfunction that returns this time rounded to the nearest integer assigned to the variable\nseconds. Each time this anonymous function is called as seconds() the current time will\nbe calculated and returned."},{"title":"Tuples","page":"Functions","location":"manual/functions.html#Tuples","category":"section","text":"Julia has a built-in data structure called a tuple that is closely related to function\narguments and return values.\nA tuple is a fixed-length container that can hold any values, but cannot be modified\n(it is immutable).\nTuples are constructed with commas and parentheses, and can be accessed via indexing:\n\njulia> (1, 1+1)\n(1, 2)\n\njulia> (1,)\n(1,)\n\njulia> x = (0.0, \"hello\", 6*7)\n(0.0, \"hello\", 42)\n\njulia> x[2]\n\"hello\"\n\nNotice that a length-1 tuple must be written with a comma, (1,), since (1) would just\nbe a parenthesized value.\n() represents the empty (length-0) tuple."},{"title":"Named Tuples","page":"Functions","location":"manual/functions.html#Named-Tuples","category":"section","text":"The components of tuples can optionally be named, in which case a named tuple is\nconstructed:\n\njulia> x = (a=2, b=1+2)\n(a = 2, b = 3)\n\njulia> x[1]\n2\n\njulia> x.a\n2\n\nThe fields of named tuples can be accessed by name using dot syntax (x.a) in\naddition to the regular indexing syntax (x[1] or x[:a])."},{"title":"Destructuring Assignment and Multiple Return Values","page":"Functions","location":"manual/functions.html#destructuring-assignment","category":"section","text":"A comma-separated list of variables (optionally wrapped in parentheses) can appear on the\nleft side of an assignment: the value on the right side is destructured by iterating\nover and assigning to each variable in turn:\n\njulia> (a, b, c) = 1:3\n1:3\n\njulia> b\n2\n\nThe value on the right should be an iterator (see Iteration interface)\nat least as long as the number of variables on the left (any excess elements of the\niterator are ignored).\n\nThis can be used to return multiple values from functions by returning a tuple or\nother iterable value. For example, the following function returns two values:\n\njulia> function foo(a, b)\n           a+b, a*b\n       end\nfoo (generic function with 1 method)\n\nIf you call it in an interactive session without assigning the return value anywhere, you will\nsee the tuple returned:\n\njulia> foo(2, 3)\n(5, 6)\n\nDestructuring assignment extracts each value into a variable:\n\njulia> x, y = foo(2, 3)\n(5, 6)\n\njulia> x\n5\n\njulia> y\n6\n\nAnother common use is for swapping variables:\n\njulia> y, x = x, y\n(5, 6)\n\njulia> x\n6\n\njulia> y\n5\n\nIf only a subset of the elements of the iterator are required, a common convention is to assign ignored elements to a variable\nconsisting of only underscores _ (which is an otherwise invalid variable name, see\nAllowed Variable Names):\n\njulia> _, _, _, d = 1:10\n1:10\n\njulia> d\n4\n\nOther valid left-hand side expressions can be used as elements of the assignment list, which will call setindex! or setproperty!, or recursively destructure individual elements of the iterator:\n\njulia> X = zeros(3);\n\njulia> X[1], (a, b) = (1, (2, 3))\n(1, (2, 3))\n\njulia> X\n3-element Vector{Float64}:\n 1.0\n 0.0\n 0.0\n\njulia> a\n2\n\njulia> b\n3\n\ncompat: Julia 1.6\n... with assignment requires Julia 1.6\n\nIf the last symbol in the assignment list is suffixed by ... (known as slurping), then\nit will be assigned a collection or lazy iterator of the remaining elements of the\nright-hand side iterator:\n\njulia> a, b... = \"hello\"\n\"hello\"\n\njulia> a\n'h': ASCII/Unicode U+0068 (category Ll: Letter, lowercase)\n\njulia> b\n\"ello\"\n\njulia> a, b... = Iterators.map(abs2, 1:4)\nBase.Generator{UnitRange{Int64}, typeof(abs2)}(abs2, 1:4)\n\njulia> a\n1\n\njulia> b\nBase.Iterators.Rest{Base.Generator{UnitRange{Int64}, typeof(abs2)}, Int64}(Base.Generator{UnitRange{Int64}, typeof(abs2)}(abs2, 1:4), 1)\n\nSee Base.rest for details on the precise handling and customization for specific iterators.\n\ncompat: Julia 1.9\n... in non-final position of an assignment requires Julia 1.9\n\nSlurping in assignments can also occur in any other position. As opposed to slurping the end\nof a collection however, this will always be eager.\n\njulia> a, b..., c = 1:5\n1:5\n\njulia> a\n1\n\njulia> b\n3-element Vector{Int64}:\n 2\n 3\n 4\n\njulia> c\n5\n\njulia> front..., tail = \"Hi!\"\n\"Hi!\"\n\njulia> front\n\"Hi\"\n\njulia> tail\n'!': ASCII/Unicode U+0021 (category Po: Punctuation, other)\n\nThis is implemented in terms of the function Base.split_rest.\n\nNote that for variadic function definitions, slurping is still only allowed in final position.\nThis does not apply to single argument destructuring though,\nas that does not affect method dispatch:\n\njulia> f(x..., y) = x\nERROR: syntax: invalid \"...\" on non-final argument\nStacktrace:\n[...]\n\njulia> f((x..., y)) = x\nf (generic function with 1 method)\n\njulia> f((1, 2, 3))\n(1, 2)"},{"title":"Property destructuring","page":"Functions","location":"manual/functions.html#Property-destructuring","category":"section","text":"Instead of destructuring based on iteration, the right side of assignments can also be destructured using property names.\nThis follows the syntax for NamedTuples, and works by assigning to each variable on the left a\nproperty of the right side of the assignment with the same name using getproperty:\n\njulia> (; b, a) = (a=1, b=2, c=3)\n(a = 1, b = 2, c = 3)\n\njulia> a\n1\n\njulia> b\n2"},{"title":"Argument destructuring","page":"Functions","location":"manual/functions.html#man-argument-destructuring","category":"section","text":"The destructuring feature can also be used within a function argument.\nIf a function argument name is written as a tuple (e.g. (x, y)) instead of just\na symbol, then an assignment (x, y) = argument will be inserted for you:\n\njulia> minmax(x, y) = (y < x) ? (y, x) : (x, y)\nminmax (generic function with 1 method)\n\njulia> gap((min, max)) = max - min\ngap (generic function with 1 method)\n\njulia> gap(minmax(10, 2))\n8\n\nNotice the extra set of parentheses in the definition of gap. Without those, gap\nwould be a two-argument function, and this example would not work.\n\nSimilarly, property destructuring can also be used for function arguments:\n\njulia> foo((; x, y)) = x + y\nfoo (generic function with 1 method)\n\njulia> foo((x=1, y=2))\n3\n\njulia> struct A\n           x\n           y\n       end\n\njulia> foo(A(3, 4))\n7\n\nFor anonymous functions, destructuring a single argument requires an extra comma:\n\njulia> map(((x, y),) -> x + y, [(1, 2), (3, 4)])\n2-element Vector{Int64}:\n 3\n 7"},{"title":"Varargs Functions","page":"Functions","location":"manual/functions.html#Varargs-Functions","category":"section","text":"It is often convenient to be able to write functions taking an arbitrary number of arguments.\nSuch functions are traditionally known as \"varargs\" functions, which is short for \"variable number\nof arguments\". You can define a varargs function by following the last positional argument with an ellipsis:\n\njulia> bar(a, b, x...) = (a, b, x)\nbar (generic function with 1 method)\n\nThe variables a and b are bound to the first two argument values as usual, and the variable\nx is bound to an iterable collection of the zero or more values passed to bar after its first\ntwo arguments:\n\njulia> bar(1, 2)\n(1, 2, ())\n\njulia> bar(1, 2, 3)\n(1, 2, (3,))\n\njulia> bar(1, 2, 3, 4)\n(1, 2, (3, 4))\n\njulia> bar(1, 2, 3, 4, 5, 6)\n(1, 2, (3, 4, 5, 6))\n\nIn all these cases, x is bound to a tuple of the trailing values passed to bar.\n\nIt is possible to constrain the number of values passed as a variable argument; this will be discussed\nlater in Parametrically-constrained Varargs methods.\n\nOn the flip side, it is often handy to \"splat\" the values contained in an iterable collection\ninto a function call as individual arguments. To do this, one also uses ... but in the function\ncall instead:\n\njulia> x = (3, 4)\n(3, 4)\n\njulia> bar(1, 2, x...)\n(1, 2, (3, 4))\n\nIn this case a tuple of values is spliced into a varargs call precisely where the variable number\nof arguments go. This need not be the case, however:\n\njulia> x = (2, 3, 4)\n(2, 3, 4)\n\njulia> bar(1, x...)\n(1, 2, (3, 4))\n\njulia> x = (1, 2, 3, 4)\n(1, 2, 3, 4)\n\njulia> bar(x...)\n(1, 2, (3, 4))\n\nFurthermore, the iterable object splatted into a function call need not be a tuple:\n\njulia> x = [3, 4]\n2-element Vector{Int64}:\n 3\n 4\n\njulia> bar(1, 2, x...)\n(1, 2, (3, 4))\n\njulia> x = [1, 2, 3, 4]\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> bar(x...)\n(1, 2, (3, 4))\n\nAlso, the function that arguments are splatted into need not be a varargs function (although it\noften is):\n\njulia> baz(a, b) = a + b;\n\njulia> args = [1, 2]\n2-element Vector{Int64}:\n 1\n 2\n\njulia> baz(args...)\n3\n\njulia> args = [1, 2, 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> baz(args...)\nERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)\nThe function `baz` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  baz(::Any, ::Any)\n   @ Main none:1\n\nStacktrace:\n[...]\n\nAs you can see, if the wrong number of elements are in the splatted container, then the function\ncall will fail, just as it would if too many arguments were given explicitly."},{"title":"Optional Arguments","page":"Functions","location":"manual/functions.html#Optional-Arguments","category":"section","text":"It is often possible to provide sensible default values for function arguments.\nThis can save users from having to pass every argument on every call.\nFor example, the function Date(y, [m, d])\nfrom Dates module constructs a Date type for a given year y, month m and day d.\nHowever, m and d arguments are optional and their default value is 1.\nThis behavior can be expressed concisely as:\n\njulia> using Dates\n\njulia> function date(y::Int64, m::Int64=1, d::Int64=1)\n           err = Dates.validargs(Date, y, m, d)\n           err === nothing || throw(err)\n           return Date(Dates.UTD(Dates.totaldays(y, m, d)))\n       end\ndate (generic function with 3 methods)\n\nObserve, that this definition calls another method of the Date function that takes one argument\nof type UTInstant{Day}.\n\nWith this definition, the function can be called with either one, two or three arguments, and\n1 is automatically passed when only one or two of the arguments are specified:\n\njulia> date(2000, 12, 12)\n2000-12-12\n\njulia> date(2000, 12)\n2000-12-01\n\njulia> date(2000)\n2000-01-01\n\nOptional arguments are actually just a convenient syntax for writing multiple method definitions\nwith different numbers of arguments (see Note on Optional and keyword Arguments).\nThis can be checked for our date function example by calling the methods function:\n\njulia> methods(date)\n# 3 methods for generic function \"date\" from Main:\n [1] date(y::Int64, m::Int64, d::Int64)\n     @ REPL[2]:1\n [2] date(y::Int64, m::Int64)\n     @ REPL[2]:1\n [3] date(y::Int64)\n     @ REPL[2]:1"},{"title":"Keyword Arguments","page":"Functions","location":"manual/functions.html#Keyword-Arguments","category":"section","text":"Some functions need a large number of arguments, or have a large number of behaviors. Remembering\nhow to call such functions can be difficult. Keyword arguments can make these complex interfaces\neasier to use and extend by allowing arguments to be identified by name instead of only by position.\n\nFor example, consider a function plot that plots a line. This function might have many options,\nfor controlling line style, width, color, and so on. If it accepts keyword arguments, a possible\ncall might look like plot(x, y, width=2), where we have chosen to specify only line width. Notice\nthat this serves two purposes. The call is easier to read, since we can label an argument with\nits meaning. It also becomes possible to pass any subset of a large number of arguments, in any\norder.\n\nFunctions with keyword arguments are defined using a semicolon in the signature:\n\nfunction plot(x, y; style=\"solid\", width=1, color=\"black\")\n    ###\nend\n\nWhen the function is called, the semicolon is optional: one can either call plot(x, y, width=2)\nor plot(x, y; width=2), but the former style is more common. An explicit semicolon is required\nonly for passing varargs or computed keywords as described below.\n\nKeyword argument default values are evaluated only when necessary (when a corresponding keyword\nargument is not passed), and in left-to-right order. Therefore default expressions may refer to\nprior keyword arguments.\n\nThe types of keyword arguments can be made explicit as follows:\n\nfunction f(; x::Int=1)\n    ###\nend\n\nKeyword arguments can also be used in varargs functions:\n\nfunction plot(x...; style=\"solid\")\n    ###\nend\n\nExtra keyword arguments can be collected using ..., as in varargs functions:\n\nfunction f(x; y=0, kwargs...)\n    ###\nend\n\nInside f, kwargs will be an immutable key-value iterator over a named tuple.\nNamed tuples (as well as dictionaries with keys of Symbol, and other iterators\nyielding two-value collections with symbol as first values) can be passed as\nkeyword arguments using a semicolon in a call, e.g. f(x, z=1; kwargs...).\n\nIf a keyword argument is not assigned a default value in the method definition,\nthen it is required: an UndefKeywordError exception will be thrown\nif the caller does not assign it a value:\n\nfunction f(x; y)\n    ###\nend\nf(3, y=5) # ok, y is assigned\nf(3)      # throws UndefKeywordError(:y)\n\nOne can also pass key => value expressions after a semicolon. For example, plot(x, y; :width => 2)\nis equivalent to plot(x, y, width=2). This is useful in situations where the keyword name is computed\nat runtime.\n\nWhen a bare identifier or dot expression occurs after a semicolon, the keyword argument name is\nimplied by the identifier or field name. For example plot(x, y; width) is equivalent to\nplot(x, y; width=width) and plot(x, y; options.width) is equivalent to plot(x, y; width=options.width).\n\nThe nature of keyword arguments makes it possible to specify the same argument more than once.\nFor example, in the call plot(x, y; options..., width=2) it is possible that the options structure\nalso contains a value for width. In such a case the rightmost occurrence takes precedence; in\nthis example, width is certain to have the value 2. However, explicitly specifying the same keyword\nargument multiple times, for example plot(x, y, width=2, width=3), is not allowed and results in\na syntax error."},{"title":"Evaluation Scope of Default Values","page":"Functions","location":"manual/functions.html#Evaluation-Scope-of-Default-Values","category":"section","text":"When optional and keyword argument default expressions are evaluated, only previous arguments are in\nscope.\nFor example, given this definition:\n\nfunction f(x, a=b, b=1)\n    ###\nend\n\nthe b in a=b refers to a b in an outer scope, not the subsequent argument b."},{"title":"Do-Block Syntax for Function Arguments","page":"Functions","location":"manual/functions.html#Do-Block-Syntax-for-Function-Arguments","category":"section","text":"Passing functions as arguments to other functions is a powerful technique, but the syntax for\nit is not always convenient. Such calls are especially awkward to write when the function argument\nrequires multiple lines. As an example, consider calling map on a function with several\ncases:\n\nmap(x->begin\n           if x < 0 && iseven(x)\n               return 0\n           elseif x == 0\n               return 1\n           else\n               return x\n           end\n       end,\n    [A, B, C])\n\nJulia provides a reserved word do for rewriting this code more clearly:\n\nmap([A, B, C]) do x\n    if x < 0 && iseven(x)\n        return 0\n    elseif x == 0\n        return 1\n    else\n        return x\n    end\nend\n\nThe do x syntax creates an anonymous function with argument x and passes\nthe anonymous function as the first argument\nto the \"outer\" function - map in this example.\nSimilarly, do a,b would create a two-argument anonymous function. Note that do (a,b) would create a one-argument anonymous function,\nwhose argument is a tuple to be deconstructed. A plain do would declare that what follows is an anonymous function of the form () -> ....\n\nHow these arguments are initialized depends on the \"outer\" function; here, map will\nsequentially set x to A, B, C, calling the anonymous function on each, just as would happen\nin the syntax map(func, [A, B, C]).\n\nThis syntax makes it easier to use functions to effectively extend the language, since calls look\nlike normal code blocks. There are many possible uses quite different from map, such\nas managing system state. For example, there is a version of open that runs code ensuring\nthat the opened file is eventually closed:\n\nopen(\"outfile\", \"w\") do io\n    write(io, data)\nend\n\nThis is accomplished by the following definition:\n\nfunction open(f::Function, args...)\n    io = open(args...)\n    try\n        f(io)\n    finally\n        close(io)\n    end\nend\n\nHere, open first opens the file for writing and then passes the resulting output stream\nto the anonymous function you defined in the do ... end block. After your function exits, open\nwill make sure that the stream is properly closed, regardless of whether your function exited\nnormally or threw an exception. (The try/finally construct will be described in Control Flow.)\n\nWith the do block syntax, it helps to check the documentation or implementation to know how\nthe arguments of the user function are initialized.\n\nA do block, like any other inner function, can \"capture\" variables from its\nenclosing scope. For example, the variable data in the above example of\nopen...do is captured from the outer scope. Captured variables\ncan create performance challenges as discussed in performance tips."},{"title":"Function composition and piping","page":"Functions","location":"manual/functions.html#Function-composition-and-piping","category":"section","text":"Functions in Julia can be combined by composing or piping (chaining) them together.\n\nFunction composition is when you combine functions together and apply the resulting composition to arguments.\nYou use the function composition operator (∘) to compose the functions, so (f ∘ g)(args...; kw...) is the same as f(g(args...; kw...)).\n\nYou can type the composition operator at the REPL and suitably-configured editors using \\circ<tab>.\n\nFor example, the sqrt and + functions can be composed like this:\n\njulia> (sqrt ∘ +)(3, 6)\n3.0\n\nThis adds the numbers first, then finds the square root of the result.\n\nThe next example composes three functions and maps the result over an array of strings:\n\njulia> map(first ∘ reverse ∘ uppercase, split(\"you can compose functions like this\"))\n6-element Vector{Char}:\n 'U': ASCII/Unicode U+0055 (category Lu: Letter, uppercase)\n 'N': ASCII/Unicode U+004E (category Lu: Letter, uppercase)\n 'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n\nFunction chaining (sometimes called \"piping\" or \"using a pipe\" to send data to a subsequent function) is when you apply a function to the previous function's output:\n\njulia> 1:10 |> sum |> sqrt\n7.416198487095663\n\nHere, the total produced by sum is passed to the sqrt function. The equivalent composition would be:\n\njulia> (sqrt ∘ sum)(1:10)\n7.416198487095663\n\nThe pipe operator can also be used with broadcasting, as .|>, to provide a useful combination of the chaining/piping and dot vectorization syntax (described below).\n\njulia> [\"a\", \"list\", \"of\", \"strings\"] .|> [uppercase, reverse, titlecase, length]\n4-element Vector{Any}:\n  \"A\"\n  \"tsil\"\n  \"Of\"\n 7\n\nWhen combining pipes with anonymous functions, parentheses must be used if subsequent pipes are not to be parsed as part of the anonymous function's body. Compare:\n\njulia> 1:3 .|> (x -> x^2) |> sum |> sqrt\n3.7416573867739413\n\njulia> 1:3 .|> x -> x^2 |> sum |> sqrt\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.0"},{"title":"Dot Syntax for Vectorizing Functions","page":"Functions","location":"manual/functions.html#man-vectorized","category":"section","text":"In technical-computing languages, it is common to have \"vectorized\" versions of functions, which\nsimply apply a given function f(x) to each element of an array A to yield a new array via\nf(A). This kind of syntax is convenient for data processing, but in other languages vectorization\nis also often required for performance: if loops are slow, the \"vectorized\" version of a function\ncan call fast library code written in a low-level language. In Julia, vectorized functions are\nnot required for performance, and indeed it is often beneficial to write your own loops (see\nPerformance Tips), but they can still be convenient. Therefore, any Julia function\nf can be applied elementwise to any array (or other collection) with the syntax f.(A).\nFor example, sin can be applied to all elements in the vector A like so:\n\njulia> A = [1.0, 2.0, 3.0]\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n\njulia> sin.(A)\n3-element Vector{Float64}:\n 0.8414709848078965\n 0.9092974268256817\n 0.1411200080598672\n\nOf course, you can omit the dot if you write a specialized \"vector\" method of f, e.g. via f(A::AbstractArray) = map(f, A),\nand this is just as efficient as f.(A). The advantage of the f.(A) syntax is that which functions are vectorizable need not be decided upon\nin advance by the library writer.\n\nMore generally, f.(args...) is actually equivalent to broadcast(f, args...), which allows\nyou to operate on multiple arrays (even of different shapes), or a mix of arrays and scalars (see\nBroadcasting). For example, if you have f(x, y) = 3x + 4y, then f.(pi, A) will return\na new array consisting of f(pi,a) for each a in A, and f.(vector1, vector2) will return\na new vector consisting of f(vector1[i], vector2[i]) for each index i (throwing an exception\nif the vectors have different length).\n\njulia> f(x, y) = 3x + 4y;\n\njulia> A = [1.0, 2.0, 3.0];\n\njulia> B = [4.0, 5.0, 6.0];\n\njulia> f.(pi, A)\n3-element Vector{Float64}:\n 13.42477796076938\n 17.42477796076938\n 21.42477796076938\n\njulia> f.(A, B)\n3-element Vector{Float64}:\n 19.0\n 26.0\n 33.0\n\nKeyword arguments are not broadcasted over, but are simply passed through to each call of\nthe function. For example, round.(x, digits=3) is equivalent to broadcast(x -> round(x, digits=3), x).\n\nMoreover, nested f.(args...) calls are fused into a single broadcast loop. For example,\nsin.(cos.(X)) is equivalent to broadcast(x -> sin(cos(x)), X), similar to [sin(cos(x)) for x in X]:\nthere is only a single loop over X, and a single array is allocated for the result. [In contrast,\nsin(cos(X)) in a typical \"vectorized\" language would first allocate one temporary array for\ntmp=cos(X), and then compute sin(tmp) in a separate loop, allocating a second array.] This\nloop fusion is not a compiler optimization that may or may not occur, it is a syntactic guarantee\nwhenever nested f.(args...) calls are encountered. Technically, the fusion stops as soon as\na \"non-dot\" function call is encountered; for example, in sin.(sort(cos.(X))) the sin and cos\nloops cannot be merged because of the intervening sort function.\n\nFinally, the maximum efficiency is typically achieved when the output array of a vectorized operation\nis pre-allocated, so that repeated calls do not allocate new arrays over and over again for\nthe results (see Pre-allocating outputs). A convenient syntax for this is X .= ..., which\nis equivalent to broadcast!(identity, X, ...) except that, as above, the broadcast! loop is\nfused with any nested \"dot\" calls. For example, X .= sin.(Y) is equivalent to broadcast!(sin, X, Y),\noverwriting X with sin.(Y) in-place. If the left-hand side is an array-indexing expression,\ne.g. X[begin+1:end] .= sin.(Y), then it translates to broadcast! on a view, e.g.\nbroadcast!(sin, view(X, firstindex(X)+1:lastindex(X)), Y),\nso that the left-hand side is updated in-place.\n\nSince adding dots to many operations and function calls in an expression\ncan be tedious and lead to code that is difficult to read, the macro\n@. is provided to convert every function call,\noperation, and assignment in an expression into the \"dotted\" version.\n\njulia> Y = [1.0, 2.0, 3.0, 4.0];\n\njulia> X = similar(Y); # pre-allocate output array\n\njulia> @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))\n4-element Vector{Float64}:\n  0.5143952585235492\n -0.4042391538522658\n -0.8360218615377305\n -0.6080830096407656\n\nBinary (or unary) operators like .+ are handled with the same mechanism:\nthey are equivalent to broadcast calls and are fused with other nested \"dot\" calls.\n X .+= Y etcetera is equivalent to X .= X .+ Y and results in a fused in-place assignment;\n see also dot operators.\n\nYou can also combine dot operations with function chaining using |>, as in this example:\n\njulia> 1:5 .|> [x->x^2, inv, x->2*x, -, isodd]\n5-element Vector{Real}:\n    1\n    0.5\n    6\n   -4\n true\n\nAll functions in the fused broadcast are always called for every element of the result. Thus X .+ σ .* randn.() will add a mask of independent and identically sampled random values to each element of the array X, but X .+ σ .* randn() will add the same random sample to each element. In cases where the fused computation is constant along one or more axes of the broadcast iteration, it may be possible to leverage a space-time tradeoff and allocate intermediate values to reduce the number of computations. See more at performance tips."},{"title":"Further Reading","page":"Functions","location":"manual/functions.html#Further-Reading","category":"section","text":"We should mention here that this is far from a complete picture of defining functions. Julia has\na sophisticated type system and allows multiple dispatch on argument types. None of the examples\ngiven here provide any type annotations on their arguments, meaning that they are applicable to\nall types of arguments. The type system is described in Types and defining a function\nin terms of methods chosen by multiple dispatch on run-time argument types is described in Methods."},{"title":"Types","page":"Types","location":"manual/types.html#man-types","category":"section","text":"Type systems have traditionally fallen into two quite different camps: static type systems, where\nevery program expression must have a type computable before the execution of the program, and\ndynamic type systems, where nothing is known about types until run time, when the actual values\nmanipulated by the program are available. Object orientation allows some flexibility in statically\ntyped languages by letting code be written without the precise types of values being known at\ncompile time. The ability to write code that can operate on different types is called polymorphism.\nAll code in classic dynamically typed languages is polymorphic: only by explicitly checking types,\nor when objects fail to support operations at run-time, are the types of any values ever restricted.\n\nJulia's type system is dynamic, but gains some of the advantages of static type systems by making\nit possible to indicate that certain values are of specific types. This can be of great assistance\nin generating efficient code, but even more significantly, it allows method dispatch on the types\nof function arguments to be deeply integrated with the language. Method dispatch is explored in\ndetail in Methods, but is rooted in the type system presented here.\n\nThe default behavior in Julia when types are omitted is to allow values to be of any type. Thus,\none can write many useful Julia functions without ever explicitly using types. When additional\nexpressiveness is needed, however, it is easy to gradually introduce explicit type annotations\ninto previously \"untyped\" code. Adding annotations serves three primary purposes: to take advantage\nof Julia's powerful multiple-dispatch mechanism,  to improve human readability, and to catch\nprogrammer errors.\n\nDescribing Julia in the lingo of type systems, it\nis: dynamic, nominative and parametric. Generic types can be parameterized, and the hierarchical\nrelationships between types are explicitly declared,\nrather than implied by compatible structure.\nOne particularly distinctive feature of Julia's type system is that concrete types may not subtype\neach other: all concrete types are final and may only have abstract types as their supertypes.\nWhile this might at first seem unduly restrictive, it has many beneficial consequences with surprisingly\nfew drawbacks. It turns out that being able to inherit behavior is much more important than being\nable to inherit structure, and inheriting both causes significant difficulties in traditional\nobject-oriented languages. While concrete types do have abstract subtypes, there are only two examples of this\n(Union{} and Type{T})) and additional subtypes\nof concrete types cannot be declared.\n\nOther high-level aspects of Julia's type system that should be mentioned up front are:\n\nThere is no division between object and non-object values: all values in Julia are true objects\nhaving a type that belongs to a single, fully connected type graph, all nodes of which are equally\nfirst-class as types.\nThere is no meaningful concept of a \"compile-time type\": the only type a value has is its actual\ntype when the program is running. This is called a \"run-time type\" in object-oriented languages\nwhere the combination of static compilation with polymorphism makes this distinction significant.\nOnly values, not variables, have types – variables are simply names bound to values, although for\nsimplicity we may say \"type of a variable\" as shorthand for \"type of the value to which a variable refers\".\nBoth abstract and concrete types can be parameterized by other types. They can also be parameterized\nby symbols, by values of any type for which isbits returns true (essentially, things\nlike numbers and bools that are stored like C types or structs with no pointers to other objects),\nand also by tuples thereof. Type parameters may be omitted when they do not need to be referenced\nor restricted.\n\nJulia's type system is designed to be powerful and expressive, yet clear, intuitive and unobtrusive.\nMany Julia programmers may never feel the need to write code that explicitly uses types. Some\nkinds of programming, however, become clearer, simpler, faster and more robust with declared types."},{"title":"Type Declarations","page":"Types","location":"manual/types.html#Type-Declarations","category":"section","text":"The :: operator can be used to attach type annotations to expressions and variables in programs.\nThere are two primary reasons to do this:\n\nAs an assertion to help confirm that your program works the way you expect, and\nTo provide extra type information to the compiler, which can then improve performance in some\ncases.\n\nWhen appended to an expression computing a value, the :: operator is read as \"is an instance\nof\". It can be used anywhere to assert that the value of the expression on the left is an instance\nof the type on the right. When the type on the right is concrete, the value on the left must have\nthat type as its implementation – recall that all concrete types are final, so no implementation\nis a subtype of any other. When the type is abstract, it suffices for the value to be implemented\nby a concrete type that is a subtype of the abstract type. If the type assertion is not true,\nan exception is thrown, otherwise, the left-hand value is returned:\n\njulia> (1+2)::AbstractFloat\nERROR: TypeError: in typeassert, expected AbstractFloat, got a value of type Int64\n\njulia> (1+2)::Int\n3\n\nThis allows a type assertion to be attached to any expression in-place.\n\nWhen appended to a variable on the left-hand side of an assignment, or as part of a local declaration,\nthe :: operator means something a bit different: it declares the variable to always have the\nspecified type, like a type declaration in a statically-typed language such as C. Every value\nassigned to the variable will be converted to the declared type using convert:\n\njulia> function foo()\n           x::Int8 = 100\n           x\n       end\nfoo (generic function with 1 method)\n\njulia> x = foo()\n100\n\njulia> typeof(x)\nInt8\n\nThis feature is useful for avoiding performance \"gotchas\" that could occur if one of the assignments\nto a variable changed its type unexpectedly.\n\nThis \"declaration\" behavior only occurs in specific contexts:\n\nlocal x::Int8  # in a local declaration\nx::Int8 = 10   # as the left-hand side of an assignment\n\nand applies to the whole current scope, even before the declaration.\n\nAs of Julia 1.8, type declarations can now be used in global scope i.e.\ntype annotations can be added to global variables to make accessing them type stable.\n\njulia> x::Int = 10\n10\n\njulia> x = 3.5\nERROR: InexactError: Int64(3.5)\n\njulia> function foo(y)\n           global x = 15.8    # throws an error when foo is called\n           return x + y\n       end\nfoo (generic function with 1 method)\n\njulia> foo(10)\nERROR: InexactError: Int64(15.8)\n\nDeclarations can also be attached to function definitions:\n\nfunction sinc(x)::Float64\n    if x == 0\n        return 1\n    end\n    return sin(pi*x)/(pi*x)\nend\n\nReturning from this function behaves just like an assignment to a variable with a declared type:\nthe value is always converted to Float64."},{"title":"Abstract Types","page":"Types","location":"manual/types.html#man-abstract-types","category":"section","text":"Abstract types cannot be instantiated, and serve only as nodes in the type graph, thereby describing\nsets of related concrete types: those concrete types which are their descendants. We begin with\nabstract types even though they have no instantiation because they are the backbone of the type\nsystem: they form the conceptual hierarchy which makes Julia's type system more than just a collection\nof object implementations.\n\nRecall that in Integers and Floating-Point Numbers, we introduced a variety of concrete\ntypes of numeric values: Int8, UInt8, Int16, UInt16,\nInt32, UInt32, Int64, UInt64, Int128,\nUInt128, Float16, Float32, and Float64. Although\nthey have different representation sizes, Int8, Int16, Int32, Int64 and Int128\nall have in common that they are signed integer types. Likewise UInt8, UInt16, UInt32,\nUInt64 and UInt128 are all unsigned integer types, while Float16, Float32 and\nFloat64 are distinct in being floating-point types rather than integers. It is common for\na piece of code to make sense, for example, only if its arguments are some kind of integer,\nbut not really depend on what particular kind of integer. For example, the greatest common\ndenominator algorithm works for all kinds of integers, but will not work for floating-point\nnumbers. Abstract types allow the construction of a hierarchy of types, providing a context\ninto which concrete types can fit. This allows you, for example, to easily program to any type\nthat is an integer, without restricting an algorithm to a specific type of integer.\n\nAbstract types are declared using the abstract type keyword. The general syntaxes for declaring an\nabstract type are:\n\nabstract type «name» end\nabstract type «name» <: «supertype» end\n\nThe abstract type keyword introduces a new abstract type, whose name is given by «name». This\nname can be optionally followed by <: and an already-existing type, indicating that the newly\ndeclared abstract type is a subtype of this \"parent\" type.\n\nWhen no supertype is given, the default supertype is Any – a predefined abstract type that\nall objects are instances of and all types are subtypes of. In type theory, Any is commonly\ncalled \"top\" because it is at the apex of the type graph. Julia also has a predefined abstract\n\"bottom\" type, at the nadir of the type graph, which is written as Union{}. It is the exact\nopposite of Any: no object is an instance of Union{} and all types (including concrete types) are supertypes of Union{}.\n\nLet's consider some of the abstract types that make up Julia's numerical hierarchy:\n\nabstract type Number end\nabstract type Real          <: Number end\nabstract type AbstractFloat <: Real end\nabstract type Integer       <: Real end\nabstract type Signed        <: Integer end\nabstract type Unsigned      <: Integer end\n\nThe Number type is a direct child type of Any, and Real is its child.\nIn turn, Real has two children (it has more, but only two are shown here; we'll get to\nthe others later): Integer and AbstractFloat, separating the world into\nrepresentations of integers and representations of real numbers. Representations of real\nnumbers include floating-point types, but also include other types, such as rationals.\nAbstractFloat includes only floating-point representations of real numbers. Integers\nare further subdivided into Signed and Unsigned varieties.\n\nThe <: operator in general means \"is a subtype of\", and, used in declarations like those above,\ndeclares the right-hand type to be an immediate supertype of the newly declared type. It can also\nbe used in expressions as a subtype operator which returns true when its left operand is a\nsubtype of its right operand:\n\njulia> Integer <: Number\ntrue\n\njulia> Integer <: AbstractFloat\nfalse\n\nAn important use of abstract types is to provide default implementations for concrete types. To\ngive a simple example, consider:\n\nfunction myplus(x,y)\n    x+y\nend\n\nThe first thing to note is that the above argument declarations are equivalent to x::Any and\ny::Any. When this function is invoked, say as myplus(2,5), the dispatcher chooses the most\nspecific method named myplus that matches the given arguments. (See Methods for more\ninformation on multiple dispatch.)\n\nAssuming no method more specific than the above is found, Julia next internally defines and compiles\na method called myplus specifically for two Int arguments based on the generic function given\nabove, i.e., it implicitly defines and compiles:\n\nfunction myplus(x::Int,y::Int)\n    x+y\nend\n\nand finally, it invokes this specific method.\n\nThus, abstract types allow programmers to write generic functions that can later be used as the\ndefault method by many combinations of concrete types. Thanks to multiple dispatch, the programmer\nhas full control over whether the default or more specific method is used.\n\nAn important point to note is that there is no loss in performance if the programmer relies on\na function whose arguments are abstract types, because it is recompiled for each tuple of concrete\nargument types with which it is invoked. (There may be a performance issue, however, in the case\nof function arguments that are containers of abstract types; see Performance Tips.)"},{"title":"Primitive Types","page":"Types","location":"manual/types.html#Primitive-Types","category":"section","text":"warning: Warning\nIt is almost always preferable to wrap an existing primitive type in a new\ncomposite type than to define your own primitive type.This functionality exists to allow Julia to bootstrap the standard primitive\ntypes that LLVM supports. Once they are defined, there is very little reason\nto define more.\n\nA primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive\ntypes are integers and floating-point values. Unlike most languages, Julia lets you declare your\nown primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard\nprimitive types are all defined in the language itself:\n\nprimitive type Float16 <: AbstractFloat 16 end\nprimitive type Float32 <: AbstractFloat 32 end\nprimitive type Float64 <: AbstractFloat 64 end\n\nprimitive type Bool <: Integer 8 end\nprimitive type Char <: AbstractChar 32 end\n\nprimitive type Int8    <: Signed   8 end\nprimitive type UInt8   <: Unsigned 8 end\nprimitive type Int16   <: Signed   16 end\nprimitive type UInt16  <: Unsigned 16 end\nprimitive type Int32   <: Signed   32 end\nprimitive type UInt32  <: Unsigned 32 end\nprimitive type Int64   <: Signed   64 end\nprimitive type UInt64  <: Unsigned 64 end\nprimitive type Int128  <: Signed   128 end\nprimitive type UInt128 <: Unsigned 128 end\n\nThe general syntaxes for declaring a primitive type are:\n\nprimitive type «name» «bits» end\nprimitive type «name» <: «supertype» «bits» end\n\nThe number of bits indicates how much storage the type requires and the name gives the new type\na name. A primitive type can optionally be declared to be a subtype of some supertype. If a supertype\nis omitted, then the type defaults to having Any as its immediate supertype. The declaration\nof Bool above therefore means that a boolean value takes eight bits to store, and has\nInteger as its immediate supertype. Currently, only sizes that are multiples of\n8 bits are supported and you are more likely to experience bugs with sizes other than those used above.\nTherefore, boolean values, although they really need just a single bit, cannot be declared to be any\nsmaller than eight bits.\n\nThe types Bool, Int8 and UInt8 all have identical representations:\nthey are eight-bit chunks of memory. Since Julia's type system is nominative, however, they\nare not interchangeable despite having identical structure. A fundamental difference between\nthem is that they have different supertypes: Bool's direct supertype is Integer,\nInt8's is Signed, and UInt8's is Unsigned. All other\ndifferences between Bool, Int8, and UInt8 are matters of\nbehavior – the way functions are defined to act when given objects of these types as\narguments. This is why a nominative type system is necessary: if structure determined type,\nwhich in turn dictates behavior, then it would be impossible to make Bool behave\nany differently than Int8 or UInt8."},{"title":"Composite Types","page":"Types","location":"manual/types.html#Composite-Types","category":"section","text":"Composite types are called records, structs,\nor objects in various languages. A composite type is a collection of named fields,\nan instance of which can be treated as a single value. In many languages, composite types are\nthe only kind of user-definable type, and they are by far the most commonly used user-defined\ntype in Julia as well.\n\nIn mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also\nhave named functions associated with them, and the combination is called an \"object\". In purer\nobject-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are\ncomposites or not. In less pure object oriented languages, including C++ and Java, some values,\nsuch as integers and floating-point values, are not objects, while instances of user-defined composite\ntypes are true objects with associated methods. In Julia, all values are objects, but functions\nare not bundled with the objects they operate on. This is necessary since Julia chooses which\nmethod of a function to use by multiple dispatch, meaning that the types of all of a function's\narguments are considered when selecting a method, rather than just the first one (see Methods\nfor more information on methods and dispatch). Thus, it would be inappropriate for functions to\n\"belong\" to only their first argument. Organizing methods into function objects rather than having\nnamed bags of methods \"inside\" each object ends up being a highly beneficial aspect of the language\ndesign.\n\nComposite types are introduced with the struct keyword followed by a block of field names, optionally\nannotated with types using the :: operator:\n\njulia> struct Foo\n           bar\n           baz::Int\n           qux::Float64\n       end\n\nFields with no type annotation default to Any, and can accordingly hold any type of value.\n\nNew objects of type Foo are created by applying the Foo type object like a function\nto values for its fields:\n\njulia> foo = Foo(\"Hello, world.\", 23, 1.5)\nFoo(\"Hello, world.\", 23, 1.5)\n\njulia> typeof(foo)\nFoo\n\nWhen a type is applied like a function it is called a constructor. Two constructors are generated\nautomatically (these are called default constructors). One accepts any arguments and calls\nconvert to convert them to the types of the fields, and the other accepts arguments\nthat match the field types exactly. The reason both of these are generated is that this makes\nit easier to add new definitions without inadvertently replacing a default constructor.\n\nSince the bar field is unconstrained in type, any value will do. However, the value for baz\nmust be convertible to Int:\n\njulia> Foo((), 23.5, 1)\nERROR: InexactError: Int64(23.5)\nStacktrace:\n[...]\n\nYou may find a list of field names using the fieldnames function.\n\njulia> fieldnames(Foo)\n(:bar, :baz, :qux)\n\nYou can access the field values of a composite object using the traditional foo.bar notation:\n\njulia> foo.bar\n\"Hello, world.\"\n\njulia> foo.baz\n23\n\njulia> foo.qux\n1.5\n\nComposite objects declared with struct are immutable; they cannot be modified\nafter construction. This may seem odd at first, but it has several advantages:\n\nIt can be more efficient. Some structs can be packed efficiently into arrays, and\nin some cases the compiler is able to avoid allocating immutable objects entirely.\nIt is not possible to violate the invariants provided by the type's constructors.\nCode using immutable objects can be easier to reason about.\n\nAn immutable object might contain mutable objects, such as arrays, as fields. Those contained\nobjects will remain mutable; only the fields of the immutable object itself cannot be changed\nto point to different objects.\n\nWhere required, mutable composite objects can be declared with the keyword mutable struct, to be\ndiscussed in the next section.\n\nIf all the fields of an immutable structure are indistinguishable (===) then two immutable values containing those fields are also indistinguishable:\n\njulia> struct X\n           a::Int\n           b::Float64\n       end\n\njulia> X(1, 2) === X(1, 2)\ntrue\n\nThere is much more to say about how instances of composite types are created, but that discussion\ndepends on both Parametric Types and on Methods, and is sufficiently important\nto be addressed in its own section: Constructors.\n\nFor many user-defined types X, you may want to define a method Base.broadcastable(x::X) = Ref(x)\nso that instances of that type act as 0-dimensional \"scalars\" for broadcasting."},{"title":"Mutable Composite Types","page":"Types","location":"manual/types.html#Mutable-Composite-Types","category":"section","text":"If a composite type is declared with mutable struct instead of struct, then instances of\nit can be modified:\n\njulia> mutable struct Bar\n           baz\n           qux::Float64\n       end\n\njulia> bar = Bar(\"Hello\", 1.5);\n\njulia> bar.qux = 2.0\n2.0\n\njulia> bar.baz = 1//2\n1//2\n\nAn extra interface between the fields and the user can be provided through Instance Properties.\nThis grants more control on what can be accessed and modified using the bar.baz notation.\n\nIn order to support mutation, such objects are generally allocated on the heap, and have\nstable memory addresses.\nA mutable object is like a little container that might hold different values over time,\nand so can only be reliably identified with its address.\nIn contrast, an instance of an immutable type is associated with specific field values —\nthe field values alone tell you everything about the object.\nIn deciding whether to make a type mutable, ask whether two instances\nwith the same field values would be considered identical, or if they might need to change independently\nover time. If they would be considered identical, the type should probably be immutable.\n\nTo recap, two essential properties define immutability in Julia:\n\nIt is not permitted to modify the value of an immutable type.\nFor bits types this means that the bit pattern of a value once set will never change\nand that value is the identity of a bits type.\nFor composite  types, this means that the identity of the values of its fields will\nnever change. When the fields are bits types, that means their bits will never change,\nfor fields whose values are mutable types like arrays, that means the fields will\nalways refer to the same mutable value even though that mutable value's content may\nitself be modified.\nAn object with an immutable type may be copied freely by the compiler since its\nimmutability makes it impossible to programmatically distinguish between the original\nobject and a copy.\nIn particular, this means that small enough immutable values like integers and floats\nare typically passed to functions in registers (or stack allocated).\nMutable values, on the other hand are heap-allocated and passed to\nfunctions as pointers to heap-allocated values except in cases where the compiler\nis sure that there's no way to tell that this is not what is happening.\n\nIn cases where one or more fields of an otherwise mutable struct is known to be immutable,\none can declare these fields as such using const as shown below. This enables some,\nbut not all of the optimizations of immutable structs, and can be used to enforce invariants\non the particular fields marked as const.\n\ncompat: Julia 1.8\nconst annotating fields of mutable structs requires at least Julia 1.8.\n\njulia> mutable struct Baz\n           a::Int\n           const b::Float64\n       end\n\njulia> baz = Baz(1, 1.5);\n\njulia> baz.a = 2\n2\n\njulia> baz.b = 2.0\nERROR: setfield!: const field .b of type Baz cannot be changed\n[...]"},{"title":"Declared Types","page":"Types","location":"manual/types.html#man-declared-types","category":"section","text":"The three kinds of types (abstract, primitive, composite) discussed in the previous\nsections are actually all closely related. They share the same key properties:\n\nThey are explicitly declared.\nThey have names.\nThey have explicitly declared supertypes.\nThey may have parameters.\n\nBecause of these shared properties, these types are internally represented as instances of the\nsame concept, DataType, which is the type of any of these types:\n\njulia> typeof(Real)\nDataType\n\njulia> typeof(Int)\nDataType\n\nA DataType may be abstract or concrete. If it is concrete, it has a specified size, storage\nlayout, and (optionally) field names. Thus a primitive type is a DataType with nonzero size, but\nno field names. A composite type is a DataType that has field names or is empty (zero size).\n\nEvery concrete value in the system is an instance of some DataType."},{"title":"Type Unions","page":"Types","location":"manual/types.html#Type-Unions","category":"section","text":"A type union is a special abstract type which includes as objects all instances of any of its\nargument types, constructed using the special Union keyword:\n\njulia> IntOrString = Union{Int,AbstractString}\nUnion{Int64, AbstractString}\n\njulia> 1 :: IntOrString\n1\n\njulia> \"Hello!\" :: IntOrString\n\"Hello!\"\n\njulia> 1.0 :: IntOrString\nERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got a value of type Float64\n\nThe compilers for many languages have an internal union construct for reasoning about types; Julia\nsimply exposes it to the programmer. The Julia compiler is able to generate efficient code in the\npresence of Union types with a small number of types [1], by generating specialized code\nin separate branches for each possible type.\n\nA particularly useful case of a Union type is Union{T, Nothing}, where T can be any type and\nNothing is the singleton type whose only instance is the object nothing. This pattern\nis the Julia equivalent of Nullable, Option or Maybe\ntypes in other languages. Declaring a function argument or a field as Union{T, Nothing} allows\nsetting it either to a value of type T, or to nothing to indicate that there is no value.\nSee this FAQ entry for more information."},{"title":"Parametric Types","page":"Types","location":"manual/types.html#Parametric-Types","category":"section","text":"An important and powerful feature of Julia's type system is that it is parametric: types can take\nparameters, so that type declarations actually introduce a whole family of new types – one for\neach possible combination of parameter values. There are many languages that support some version\nof generic programming, wherein data structures\nand algorithms to manipulate them may be specified without specifying the exact types involved.\nFor example, some form of generic programming exists in ML, Haskell, Ada, Eiffel, C++, Java, C#,\nF#, and Scala, just to name a few. Some of these languages support true parametric polymorphism\n(e.g. ML, Haskell, Scala), while others support ad-hoc, template-based styles of generic programming\n(e.g. C++, Java). With so many different varieties of generic programming and parametric types\nin various languages, we won't even attempt to compare Julia's parametric types to other languages,\nbut will instead focus on explaining Julia's system in its own right. We will note, however, that\nbecause Julia is a dynamically typed language and doesn't need to make all type decisions at compile\ntime, many traditional difficulties encountered in static parametric type systems can be relatively\neasily handled.\n\nAll declared types (the DataType variety) can be parameterized, with the same syntax in each\ncase. We will discuss them in the following order: first, parametric composite types, then parametric\nabstract types, and finally parametric primitive types."},{"title":"Parametric Composite Types","page":"Types","location":"manual/types.html#man-parametric-composite-types","category":"section","text":"Type parameters are introduced immediately after the type name, surrounded by curly braces:\n\njulia> struct Point{T}\n           x::T\n           y::T\n       end\n\nThis declaration defines a new parametric type, Point{T}, holding two \"coordinates\" of type\nT. What, one may ask, is T? Well, that's precisely the point of parametric types: it can be\nany type at all (or a value of any bits type, actually, although here it's clearly used as a type).\nPoint{Float64} is a concrete type equivalent to the type defined by replacing T in the definition\nof Point with Float64. Thus, this single declaration actually declares an unlimited\nnumber of types: Point{Float64}, Point{AbstractString}, Point{Int64}, etc. Each of these\nis now a usable concrete type:\n\njulia> Point{Float64}\nPoint{Float64}\n\njulia> Point{AbstractString}\nPoint{AbstractString}\n\nThe type Point{Float64} is a point whose coordinates are 64-bit floating-point values, while\nthe type Point{AbstractString} is a \"point\" whose \"coordinates\" are string objects (see Strings).\n\nPoint itself is also a valid type object, containing all instances Point{Float64}, Point{AbstractString},\netc. as subtypes:\n\njulia> Point{Float64} <: Point\ntrue\n\njulia> Point{AbstractString} <: Point\ntrue\n\nOther types, of course, are not subtypes of it:\n\njulia> Float64 <: Point\nfalse\n\njulia> AbstractString <: Point\nfalse\n\nConcrete Point types with different values of T are never subtypes of each other:\n\njulia> Point{Float64} <: Point{Int64}\nfalse\n\njulia> Point{Float64} <: Point{Real}\nfalse\n\nwarning: Warning\nThis last point is very important: even though Float64 <: Real we DO NOT have Point{Float64} <: Point{Real}.\n\nIn other words, in the parlance of type theory, Julia's type parameters are invariant, rather\nthan being covariant (or even contravariant). This is for practical reasons: while any instance\nof Point{Float64} may conceptually be like an instance of Point{Real} as well, the two types\nhave different representations in memory:\n\nAn instance of Point{Float64} can be represented compactly and efficiently as an immediate pair\nof 64-bit values;\nAn instance of Point{Real} must be able to hold any pair of instances of Real.\nSince objects that are instances of Real can be of arbitrary size and structure, in\npractice an instance of Point{Real} must be represented as a pair of pointers to\nindividually allocated Real objects.\n\nThe efficiency gained by being able to store Point{Float64} objects with immediate values is\nmagnified enormously in the case of arrays: an Array{Float64} can be stored as a contiguous\nmemory block of 64-bit floating-point values, whereas an Array{Real} must be an array of pointers\nto individually allocated Real objects – which may well be\nboxed\n64-bit floating-point values, but also might be arbitrarily large, complex objects, which are\ndeclared to be implementations of the Real abstract type.\n\nSince Point{Float64} is not a subtype of Point{Real}, the following method can't be applied\nto arguments of type Point{Float64}:\n\nfunction norm(p::Point{Real})\n    sqrt(p.x^2 + p.y^2)\nend\n\nA correct way to define a method that accepts all arguments of type Point{T} where T is\na subtype of Real is:\n\nfunction norm(p::Point{<:Real})\n    sqrt(p.x^2 + p.y^2)\nend\n\n(Equivalently, one could define function norm(p::Point{T} where T<:Real) or\nfunction norm(p::Point{T}) where T<:Real; see UnionAll Types.)\n\nMore examples will be discussed later in Methods.\n\nHow does one construct a Point object? It is possible to define custom constructors for composite\ntypes, which will be discussed in detail in Constructors, but in the absence of any special\nconstructor declarations, there are two default ways of creating new composite objects, one in\nwhich the type parameters are explicitly given and the other in which they are implied by the\narguments to the object constructor.\n\nSince the type Point{Float64} is a concrete type equivalent to Point declared with Float64\nin place of T, it can be applied as a constructor accordingly:\n\njulia> p = Point{Float64}(1.0, 2.0)\nPoint{Float64}(1.0, 2.0)\n\njulia> typeof(p)\nPoint{Float64}\n\nFor the default constructor, exactly one argument must be supplied for each field:\n\njulia> Point{Float64}(1.0)\nERROR: MethodError: no method matching Point{Float64}(::Float64)\nThe type `Point{Float64}` exists, but no method is defined for this combination of argument types when trying to construct it.\n[...]\n\njulia> Point{Float64}(1.0, 2.0, 3.0)\nERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)\nThe type `Point{Float64}` exists, but no method is defined for this combination of argument types when trying to construct it.\n[...]\n\nOnly one default constructor is generated for parametric types, since overriding it is not possible.\nThis constructor accepts any arguments and converts them to the field types.\n\nIn many cases, it is redundant to provide the type of Point object one wants to construct, since\nthe types of arguments to the constructor call already implicitly provide type information. For\nthat reason, you can also apply Point itself as a constructor, provided that the implied value\nof the parameter type T is unambiguous:\n\njulia> p1 = Point(1.0,2.0)\nPoint{Float64}(1.0, 2.0)\n\njulia> typeof(p1)\nPoint{Float64}\n\njulia> p2 = Point(1,2)\nPoint{Int64}(1, 2)\n\njulia> typeof(p2)\nPoint{Int64}\n\nIn the case of Point, the type of T is unambiguously implied if and only if the two arguments\nto Point have the same type. When this isn't the case, the constructor will fail with a MethodError:\n\njulia> Point(1,2.5)\nERROR: MethodError: no method matching Point(::Int64, ::Float64)\nThe type `Point` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  Point(::T, !Matched::T) where T\n   @ Main none:2\n\nStacktrace:\n[...]\n\nConstructor methods to appropriately handle such mixed cases can be defined, but that will not\nbe discussed until later on in Constructors."},{"title":"Parametric Abstract Types","page":"Types","location":"manual/types.html#Parametric-Abstract-Types","category":"section","text":"Parametric abstract type declarations declare a collection of abstract types, in much the same\nway:\n\njulia> abstract type Pointy{T} end\n\nWith this declaration, Pointy{T} is a distinct abstract type for each type or integer value\nof T. As with parametric composite types, each such instance is a subtype of Pointy:\n\njulia> Pointy{Int64} <: Pointy\ntrue\n\njulia> Pointy{1} <: Pointy\ntrue\n\nParametric abstract types are invariant, much as parametric composite types are:\n\njulia> Pointy{Float64} <: Pointy{Real}\nfalse\n\njulia> Pointy{Real} <: Pointy{Float64}\nfalse\n\nThe notation Pointy{<:Real} can be used to express the Julia analogue of a\ncovariant type, while Pointy{>:Int} the analogue of a contravariant type,\nbut technically these represent sets of types (see UnionAll Types).\n\njulia> Pointy{Float64} <: Pointy{<:Real}\ntrue\n\njulia> Pointy{Real} <: Pointy{>:Int}\ntrue\n\nMuch as plain old abstract types serve to create a useful hierarchy of types over concrete types,\nparametric abstract types serve the same purpose with respect to parametric composite types. We\ncould, for example, have declared Point{T} to be a subtype of Pointy{T} as follows:\n\njulia> struct Point{T} <: Pointy{T}\n           x::T\n           y::T\n       end\n\nGiven such a declaration, for each choice of T, we have Point{T} as a subtype of Pointy{T}:\n\njulia> Point{Float64} <: Pointy{Float64}\ntrue\n\njulia> Point{Real} <: Pointy{Real}\ntrue\n\njulia> Point{AbstractString} <: Pointy{AbstractString}\ntrue\n\nThis relationship is also invariant:\n\njulia> Point{Float64} <: Pointy{Real}\nfalse\n\njulia> Point{Float64} <: Pointy{<:Real}\ntrue\n\nWhat purpose do parametric abstract types like Pointy serve? Consider if we create a point-like\nimplementation that only requires a single coordinate because the point is on the diagonal line\nx = y:\n\njulia> struct DiagPoint{T} <: Pointy{T}\n           x::T\n       end\n\nNow both Point{Float64} and DiagPoint{Float64} are implementations of the Pointy{Float64}\nabstraction, and similarly for every other possible choice of type T. This allows programming\nto a common interface shared by all Pointy objects, implemented for both Point and DiagPoint.\nThis cannot be fully demonstrated, however, until we have introduced methods and dispatch in the\nnext section, Methods.\n\nThere are situations where it may not make sense for type parameters to range freely over all\npossible types. In such situations, one can constrain the range of T like so:\n\njulia> abstract type Pointy{T<:Real} end\n\nWith such a declaration, it is acceptable to use any type that is a subtype of\nReal in place of T, but not types that are not subtypes of Real:\n\njulia> Pointy{Float64}\nPointy{Float64}\n\njulia> Pointy{Real}\nPointy{Real}\n\njulia> Pointy{AbstractString}\nERROR: TypeError: in Pointy, in T, expected T<:Real, got Type{AbstractString}\n\njulia> Pointy{1}\nERROR: TypeError: in Pointy, in T, expected T<:Real, got a value of type Int64\n\nType parameters for parametric composite types can be restricted in the same manner:\n\nstruct Point{T<:Real} <: Pointy{T}\n    x::T\n    y::T\nend\n\nTo give a real-world example of how all this parametric type machinery can be useful, here is\nthe actual definition of Julia's Rational immutable type (except that we omit the\nconstructor here for simplicity), representing an exact ratio of integers:\n\nstruct Rational{T<:Integer} <: Real\n    num::T\n    den::T\nend\n\nIt only makes sense to take ratios of integer values, so the parameter type T is restricted\nto being a subtype of Integer, and a ratio of integers represents a value on the\nreal number line, so any Rational is an instance of the Real abstraction."},{"title":"Tuple Types","page":"Types","location":"manual/types.html#Tuple-Types","category":"section","text":"Tuples are an abstraction of the arguments of a function – without the function itself. The salient\naspects of a function's arguments are their order and their types. Therefore a tuple type is similar\nto a parameterized immutable type where each parameter is the type of one field. For example,\na 2-element tuple type resembles the following immutable type:\n\nstruct Tuple2{A,B}\n    a::A\n    b::B\nend\n\nHowever, there are three key differences:\n\nTuple types may have any number of parameters.\nTuple types are covariant in their parameters: Tuple{Int} is a subtype of Tuple{Any}. Therefore\nTuple{Any} is considered an abstract type, and tuple types are only concrete if their parameters\nare.\nTuples do not have field names; fields are only accessed by index.\n\nTuple values are written with parentheses and commas. When a tuple is constructed, an appropriate\ntuple type is generated on demand:\n\njulia> typeof((1,\"foo\",2.5))\nTuple{Int64, String, Float64}\n\nNote the implications of covariance:\n\njulia> Tuple{Int,AbstractString} <: Tuple{Real,Any}\ntrue\n\njulia> Tuple{Int,AbstractString} <: Tuple{Real,Real}\nfalse\n\njulia> Tuple{Int,AbstractString} <: Tuple{Real,}\nfalse\n\nIntuitively, this corresponds to the type of a function's arguments being a subtype of the function's\nsignature (when the signature matches)."},{"title":"Vararg Tuple Types","page":"Types","location":"manual/types.html#Vararg-Tuple-Types","category":"section","text":"The last parameter of a tuple type can be the special value Vararg, which denotes any number\nof trailing elements:\n\njulia> mytupletype = Tuple{AbstractString,Vararg{Int}}\nTuple{AbstractString, Vararg{Int64}}\n\njulia> isa((\"1\",), mytupletype)\ntrue\n\njulia> isa((\"1\",1), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2,3.0), mytupletype)\nfalse\n\nMoreover Vararg{T} corresponds to zero or more elements of type T. Vararg tuple types are\nused to represent the arguments accepted by varargs methods (see Varargs Functions).\n\nThe special value Vararg{T,N} (when used as the last parameter of a tuple type)\ncorresponds to exactly N elements of type T.  NTuple{N,T} is a convenient\nalias for Tuple{Vararg{T,N}}, i.e. a tuple type containing exactly N elements of type T."},{"title":"Named Tuple Types","page":"Types","location":"manual/types.html#Named-Tuple-Types","category":"section","text":"Named tuples are instances of the NamedTuple type, which has two parameters: a tuple of\nsymbols giving the field names, and a tuple type giving the field types.\nFor convenience, NamedTuple types are printed using the @NamedTuple macro which provides a\nconvenient struct-like syntax for declaring these types via key::Type declarations,\nwhere an omitted ::Type corresponds to ::Any.\n\njulia> typeof((a=1,b=\"hello\")) # prints in macro form\n@NamedTuple{a::Int64, b::String}\n\njulia> NamedTuple{(:a, :b), Tuple{Int64, String}} # long form of the type\n@NamedTuple{a::Int64, b::String}\n\nThe begin ... end form of the @NamedTuple macro allows the declarations to be\nsplit across multiple lines (similar to a struct declaration), but is otherwise equivalent:\n\njulia> @NamedTuple begin\n           a::Int\n           b::String\n       end\n@NamedTuple{a::Int64, b::String}\n\nA NamedTuple type can be used as a constructor, accepting a single tuple argument.\nThe constructed NamedTuple type can be either a concrete type, with both parameters specified,\nor a type that specifies only field names:\n\njulia> @NamedTuple{a::Float32,b::String}((1, \"\"))\n(a = 1.0f0, b = \"\")\n\njulia> NamedTuple{(:a, :b)}((1, \"\"))\n(a = 1, b = \"\")\n\nIf field types are specified, the arguments are converted. Otherwise the types of the arguments\nare used directly."},{"title":"Parametric Primitive Types","page":"Types","location":"manual/types.html#Parametric-Primitive-Types","category":"section","text":"Primitive types can also be declared parametrically. For example, pointers are represented as\nprimitive types which would be declared in Julia like this:\n\n# 32-bit system:\nprimitive type Ptr{T} 32 end\n\n# 64-bit system:\nprimitive type Ptr{T} 64 end\n\nThe slightly odd feature of these declarations as compared to typical parametric composite types,\nis that the type parameter T is not used in the definition of the type itself – it is just\nan abstract tag, essentially defining an entire family of types with identical structure, differentiated\nonly by their type parameter. Thus, Ptr{Float64} and Ptr{Int64} are distinct types, even though\nthey have identical representations. And of course, all specific pointer types are subtypes of\nthe umbrella Ptr type:\n\njulia> Ptr{Float64} <: Ptr\ntrue\n\njulia> Ptr{Int64} <: Ptr\ntrue"},{"title":"UnionAll Types","page":"Types","location":"manual/types.html#UnionAll-Types","category":"section","text":"We have said that a parametric type like Ptr acts as a supertype of all its instances\n(Ptr{Int64} etc.). How does this work? Ptr itself cannot be a normal data type, since without\nknowing the type of the referenced data the type clearly cannot be used for memory operations.\nThe answer is that Ptr (or other parametric types like Array) is a different kind of type called a\nUnionAll type. Such a type expresses the iterated union of types for all values of some parameter.\n\nUnionAll types are usually written using the keyword where. For example Ptr could be more\naccurately written as Ptr{T} where T, meaning all values whose type is Ptr{T} for some value\nof T. In this context, the parameter T is also often called a \"type variable\" since it is\nlike a variable that ranges over types.\nEach where introduces a single type variable, so these expressions are nested for types with\nmultiple parameters, for example Array{T,N} where N where T.\n\nThe type application syntax A{B,C} requires A to be a UnionAll type, and first substitutes B\nfor the outermost type variable in A.\nThe result is expected to be another UnionAll type, into which C is then substituted.\nSo A{B,C} is equivalent to A{B}{C}.\nThis explains why it is possible to partially instantiate a type, as in Array{Float64}: the first\nparameter value has been fixed, but the second still ranges over all possible values.\nUsing explicit where syntax, any subset of parameters can be fixed. For example, the type of all\n1-dimensional arrays can be written as Array{T,1} where T.\n\nType variables can be restricted with subtype relations.\nArray{T} where T<:Integer refers to all arrays whose element type is some kind of\nInteger.\nThe syntax Array{<:Integer} is a convenient shorthand for Array{T} where T<:Integer.\nType variables can have both lower and upper bounds.\nArray{T} where Int<:T<:Number refers to all arrays of Numbers that are able to\ncontain Ints (since T must be at least as big as Int).\nThe syntax where T>:Int also works to specify only the lower bound of a type variable,\nand Array{>:Int} is equivalent to Array{T} where T>:Int.\n\nSince where expressions nest, type variable bounds can refer to outer type variables.\nFor example Tuple{T,Array{S}} where S<:AbstractArray{T} where T<:Real refers to 2-tuples\nwhose first element is some Real, and whose second element is an Array of any\nkind of array whose element type contains the type of the first tuple element.\n\nThe where keyword itself can be nested inside a more complex declaration. For example,\nconsider the two types created by the following declarations:\n\njulia> const T1 = Array{Array{T, 1} where T, 1}\nVector{Vector} (alias for Array{Array{T, 1} where T, 1})\n\njulia> const T2 = Array{Array{T, 1}, 1} where T\nArray{Vector{T}, 1} where T\n\nType T1 defines a 1-dimensional array of 1-dimensional arrays; each\nof the inner arrays consists of objects of the same type, but this type may vary from one inner array to the next.\nOn the other hand, type T2 defines a 1-dimensional array of 1-dimensional arrays all of whose inner arrays must have the\nsame type. Note that T2 is an abstract type, e.g., Array{Array{Int,1},1} <: T2, whereas T1 is a concrete type. As a consequence, T1 can be constructed with a zero-argument constructor a=T1() but T2 cannot.\n\nThere is a convenient syntax for naming such types, similar to the short form of function\ndefinition syntax:\n\nVector{T} = Array{T, 1}\n\nThis is equivalent to const Vector = Array{T,1} where T.\nWriting Vector{Float64} is equivalent to writing Array{Float64,1}, and the umbrella type\nVector has as instances all Array objects where the second parameter – the number of array\ndimensions – is 1, regardless of what the element type is. In languages where parametric types\nmust always be specified in full, this is not especially helpful, but in Julia, this allows one\nto write just Vector for the abstract type including all one-dimensional dense arrays of any\nelement type."},{"title":"Singleton types","page":"Types","location":"manual/types.html#man-singleton-types","category":"section","text":"Immutable composite types with no fields are called singletons. Formally, if\n\nT is an immutable composite type (i.e. defined with struct),\na isa T && b isa T implies a === b,\n\nthen T is a singleton type.[2] Base.issingletontype can be used to check if a\ntype is a singleton type. Abstract types cannot be singleton\ntypes by construction.\n\nFrom the definition, it follows that there can be only one instance of such types:\n\njulia> struct NoFields\n       end\n\njulia> NoFields() === NoFields()\ntrue\n\njulia> Base.issingletontype(NoFields)\ntrue\n\nThe === function confirms that the constructed instances of NoFields are actually one\nand the same.\n\nParametric types can be singleton types when the above condition holds. For example,\n\njulia> struct NoFieldsParam{T}\n       end\n\njulia> Base.issingletontype(NoFieldsParam) # Can't be a singleton type ...\nfalse\n\njulia> NoFieldsParam{Int}() isa NoFieldsParam # ... because it has ...\ntrue\n\njulia> NoFieldsParam{Bool}() isa NoFieldsParam # ... multiple instances.\ntrue\n\njulia> Base.issingletontype(NoFieldsParam{Int}) # Parametrized, it is a singleton.\ntrue\n\njulia> NoFieldsParam{Int}() === NoFieldsParam{Int}()\ntrue"},{"title":"Types of functions","page":"Types","location":"manual/types.html#Types-of-functions","category":"section","text":"Each function has its own type, which is a subtype of Function.\n\njulia> foo41(x) = x + 1\nfoo41 (generic function with 1 method)\n\njulia> typeof(foo41)\ntypeof(foo41) (singleton type of function foo41, subtype of Function)\n\nNote how typeof(foo41) prints as itself. This is merely a convention for printing, as it is a first-class object that can be used like any other value:\n\njulia> T = typeof(foo41)\ntypeof(foo41) (singleton type of function foo41, subtype of Function)\n\njulia> T <: Function\ntrue\n\nTypes of functions defined at top-level are singletons. When necessary, you can compare them with ===.\n\nClosures also have their own type, which is usually printed with names that end in #<number>. Names and types for functions defined at different locations are distinct, but not guaranteed to be printed the same way across sessions.\n\njulia> typeof(x -> x + 1)\nvar\"#9#10\"\n\nTypes of closures are not necessarily singletons.\n\njulia> addy(y) = x -> x + y\naddy (generic function with 1 method)\n\njulia> typeof(addy(1)) === typeof(addy(2))\ntrue\n\njulia> addy(1) === addy(2)\nfalse\n\njulia> Base.issingletontype(typeof(addy(1)))\nfalse"},{"title":"Type{T} type selectors","page":"Types","location":"manual/types.html#man-typet-type","category":"section","text":"For each type T, Type{T} is an abstract parametric type whose only instance is the\nobject T. Until we discuss Parametric Methods and [conversions](@ref\nconversion-and-promotion), it is difficult to explain the utility of this construct, but in\nshort, it allows one to specialize function behavior on specific types as values. This is\nuseful for writing methods (especially parametric ones) whose behavior depends on a type\nthat is given as an explicit argument rather than implied by the type of one of its\narguments.\n\nSince the definition is a little difficult to parse, let's look at some examples:\n\njulia> isa(Float64, Type{Float64})\ntrue\n\njulia> isa(Real, Type{Float64})\nfalse\n\njulia> isa(Real, Type{Real})\ntrue\n\njulia> isa(Float64, Type{Real})\nfalse\n\nIn other words, isa(A, Type{B}) is true if and only if A and B are the same object\nand that object is a type.\n\nIn particular, since parametric types are invariant, we have\n\njulia> struct TypeParamExample{T}\n           x::T\n       end\n\njulia> TypeParamExample isa Type{TypeParamExample}\ntrue\n\njulia> TypeParamExample{Int} isa Type{TypeParamExample}\nfalse\n\njulia> TypeParamExample{Int} isa Type{TypeParamExample{Int}}\ntrue\n\nWithout the parameter, Type is simply an abstract type which has\nall type objects as its instances:\n\njulia> isa(Type{Float64}, Type)\ntrue\n\njulia> isa(Float64, Type)\ntrue\n\njulia> isa(Real, Type)\ntrue\n\nAny object that is not a type is not an instance of Type:\n\njulia> isa(1, Type)\nfalse\n\njulia> isa(\"foo\", Type)\nfalse\n\nWhile Type is part of Julia's type hierarchy like any other abstract parametric type, it\nis not commonly used outside method signatures except in some special cases. Another\nimportant use case for Type is sharpening field types which would otherwise be captured\nless precisely, e.g. as DataType in the example below where the\ndefault constructor could lead to performance problems in code relying on the precise wrapped\ntype (similarly to abstract type parameters).\n\njulia> struct WrapType{T}\n       value::T\n       end\n\njulia> WrapType(Float64) # default constructor, note DataType\nWrapType{DataType}(Float64)\n\njulia> WrapType(::Type{T}) where T = WrapType{Type{T}}(T)\nWrapType\n\njulia> WrapType(Float64) # sharpened constructor, note more precise Type{Float64}\nWrapType{Type{Float64}}(Float64)\n\nThis behavior of Type{Float64} is an example of an abstract type subtyping a\nconcrete type (here DataType)."},{"title":"Type Aliases","page":"Types","location":"manual/types.html#Type-Aliases","category":"section","text":"Sometimes it is convenient to introduce a new name for an already expressible type.\nThis can be done with a simple assignment statement.\nFor example, UInt is aliased to either UInt32 or UInt64 as is\nappropriate for the size of pointers on the system:\n\n# 32-bit system:\njulia> UInt\nUInt32\n\n# 64-bit system:\njulia> UInt\nUInt64\n\nThis is accomplished via the following code in base/boot.jl:\n\nif Int === Int64\n    const UInt = UInt64\nelse\n    const UInt = UInt32\nend\n\nOf course, this depends on what Int is aliased to – but that is predefined to be the correct\ntype – either Int32 or Int64.\n\n(Note that unlike Int, Float does not exist as a type alias for a specific sized\nAbstractFloat. Unlike with integer registers, where the size of Int\nreflects the size of a native pointer on that machine, the floating point register sizes\nare specified by the IEEE-754 standard.)\n\nType aliases may be parametrized:\n\njulia> const Family{T} = Set{T}\nSet\n\njulia> Family{Char} === Set{Char}\ntrue"},{"title":"Operations on Types","page":"Types","location":"manual/types.html#Operations-on-Types","category":"section","text":"Since types in Julia are themselves objects, ordinary functions can operate on them. Some functions\nthat are particularly useful for working with or exploring types have already been introduced,\nsuch as the <: operator, which indicates whether its left hand operand is a subtype of its right\nhand operand.\n\nThe isa function tests if an object is of a given type and returns true or false:\n\njulia> isa(1, Int)\ntrue\n\njulia> isa(1, AbstractFloat)\nfalse\n\nThe typeof function, already used throughout the manual in examples, returns the type\nof its argument. Since, as noted above, types are objects, they also have types, and we can ask\nwhat their types are:\n\njulia> typeof(Rational{Int})\nDataType\n\njulia> typeof(Union{Real,String})\nUnion\n\nWhat if we repeat the process? What is the type of a type of a type? As it happens, types are\nall composite values and thus all have a type of DataType:\n\njulia> typeof(DataType)\nDataType\n\njulia> typeof(Union)\nDataType\n\nDataType is its own type.\n\nAnother operation that applies to some types is supertype, which reveals a type's\nsupertype. Only declared types (DataType) have unambiguous supertypes:\n\njulia> supertype(Float64)\nAbstractFloat\n\njulia> supertype(Number)\nAny\n\njulia> supertype(AbstractString)\nAny\n\njulia> supertype(Any)\nAny\n\nIf you apply supertype to other type objects (or non-type objects), a MethodError\nis raised:\n\njulia> supertype(Union{Float64,Int64})\nERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})\nThe function `supertype` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n[...]"},{"title":"Custom pretty-printing","page":"Types","location":"manual/types.html#man-custom-pretty-printing","category":"section","text":"Often, one wants to customize how instances of a type are displayed. This is accomplished by\noverloading the show function. For example, suppose we define a type to represent\ncomplex numbers in polar form:\n\njulia> struct Polar{T<:Real} <: Number\n           r::T\n           Θ::T\n       end\n\njulia> Polar(r::Real,Θ::Real) = Polar(promote(r,Θ)...)\nPolar\n\nHere, we've added a custom constructor function so that it can take arguments of different\nReal types and promote them to a common type (see Constructors\nand Conversion and Promotion).\n(Of course, we would have to define lots of other methods, too, to make it act like a\nNumber, e.g. +, *, one, zero, promotion rules and so on.) By default,\ninstances of this type display rather simply, with information about the type name and\nthe field values, as e.g. Polar{Float64}(3.0,4.0).\n\nIf we want it to display instead as 3.0 * exp(4.0im), we would define the following method to\nprint the object to a given output object io (representing a file, terminal, buffer, etcetera;\nsee Networking and Streams):\n\njulia> Base.show(io::IO, z::Polar) = print(io, z.r, \" * exp(\", z.Θ, \"im)\")\n\nMore fine-grained control over display of Polar objects is possible. In particular, sometimes\none wants both a verbose multi-line printing format, used for displaying a single object in the\nREPL and other interactive environments, and also a more compact single-line format used for\nprint or for displaying the object as part of another object (e.g. in an array). Although\nby default the show(io, z) function is called in both cases, you can define a different multi-line\nformat for displaying an object by overloading a three-argument form of show that takes the\ntext/plain MIME type as its second argument (see Multimedia I/O), for example:\n\njulia> Base.show(io::IO, ::MIME\"text/plain\", z::Polar{T}) where{T} =\n           print(io, \"Polar{$T} complex number:\\n   \", z)\n\n(Note that print(..., z) here will call the 2-argument show(io, z) method.) This results in:\n\njulia> Polar(3, 4.0)\nPolar{Float64} complex number:\n   3.0 * exp(4.0im)\n\njulia> [Polar(3, 4.0), Polar(4.0,5.3)]\n2-element Vector{Polar{Float64}}:\n 3.0 * exp(4.0im)\n 4.0 * exp(5.3im)\n\nwhere the single-line show(io, z) form is still used for an array of Polar values. Technically,\nthe REPL calls display(z) to display the result z of executing a line, which defaults to show(io, MIME(\"text/plain\"), z) (where io is an IOContext wrapper around stdout),\nwhich in turn defaults to show(io, z), but you should not define new display\nmethods unless you are defining a new multimedia display handler (see Multimedia I/O).\n\nMoreover, you can also define show methods for other MIME types in order to enable richer display\n(HTML, images, etcetera) of objects in environments that support this (e.g. IJulia). For example,\nwe can define formatted HTML display of Polar objects, with superscripts and italics, via:\n\njulia> Base.show(io::IO, ::MIME\"text/html\", z::Polar{T}) where {T} =\n           println(io, \"<code>Polar{$T}</code> complex number: \",\n                   z.r, \" <i>e</i><sup>\", z.Θ, \" <i>i</i></sup>\")\n\nA Polar object will then display automatically using HTML in an environment that supports HTML\ndisplay, but you can call show manually to get HTML output if you want:\n\njulia> show(stdout, \"text/html\", Polar(3.0,4.0))\n<code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup>\n\n<p>An HTML renderer would display this as: <code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup></p>\n\nAs a rule of thumb, the single-line show method should print a valid Julia expression for creating\nthe shown object. When this show method contains infix operators, such as the multiplication\noperator (*) in our single-line show method for Polar above, it may not parse correctly when\nprinted as part of another object. To see this, consider the expression object (see [Program\nrepresentation](@ref)) which takes the square of a specific instance of our Polar type:\n\njulia> a = Polar(3, 4.0)\nPolar{Float64} complex number:\n   3.0 * exp(4.0im)\n\njulia> print(:($a^2))\n3.0 * exp(4.0im) ^ 2\n\nBecause the operator ^ has higher precedence than * (see Operator Precedence and Associativity), this\noutput does not faithfully represent the expression a ^ 2 which should be equal to (3.0 * exp(4.0im)) ^ 2. To solve this issue, we must make a custom method for Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int), which is called internally by the expression object when\nprinting:\n\njulia> function Base.show_unquoted(io::IO, z::Polar, ::Int, precedence::Int)\n           if Base.operator_precedence(:*) <= precedence\n               print(io, \"(\")\n               show(io, z)\n               print(io, \")\")\n           else\n               show(io, z)\n           end\n       end\n\njulia> :($a^2)\n:((3.0 * exp(4.0im)) ^ 2)\n\nThe method defined above adds parentheses around the call to show when the precedence of the\ncalling operator is higher than or equal to the precedence of multiplication. This check allows\nexpressions which parse correctly without the parentheses (such as :($a + 2) and :($a == 2)) to\nomit them when printing:\n\njulia> :($a + 2)\n:(3.0 * exp(4.0im) + 2)\n\njulia> :($a == 2)\n:(3.0 * exp(4.0im) == 2)\n\nIn some cases, it is useful to adjust the behavior of show methods depending\non the context. This can be achieved via the IOContext type, which allows\npassing contextual properties together with a wrapped IO stream.\nFor example, we can build a shorter representation in our show method\nwhen the :compact property is set to true, falling back to the long\nrepresentation if the property is false or absent:\n\njulia> function Base.show(io::IO, z::Polar)\n           if get(io, :compact, false)::Bool\n               print(io, z.r, \"ℯ\", z.Θ, \"im\")\n           else\n               print(io, z.r, \" * exp(\", z.Θ, \"im)\")\n           end\n       end\n\nThis new compact representation will be used when the passed IO stream is an IOContext\nobject with the :compact property set. In particular, this is the case when printing\narrays with multiple columns (where horizontal space is limited):\n\njulia> show(IOContext(stdout, :compact=>true), Polar(3, 4.0))\n3.0ℯ4.0im\n\njulia> [Polar(3, 4.0) Polar(4.0,5.3)]\n1×2 Matrix{Polar{Float64}}:\n 3.0ℯ4.0im  4.0ℯ5.3im\n\nSee the IOContext documentation for a list of common properties which can be used\nto adjust printing."},{"title":"Output-function summary","page":"Types","location":"manual/types.html#Output-function-summary","category":"section","text":"Here is a brief summary of the different output functions in Julia and how they are related.\nMost new types should only need to define show methods, if anything.\n\ndisplay(x) tells the current environment to display x in whatever way it thinks best. (This might even be a graphical display in something like a Jupyter or Pluto notebook.) By default (e.g. in scripts or in the text REPL), it calls show(io, \"text/plain\", x), or equivalently show(io, MIME\"text/plain\"(), x), for an appropriate io stream. (In the REPL, io is an IOContext wrapper around stdout.) The REPL uses display to output the result of an evaluated expression.\nThe 3-argument show(io, ::MIME\"text/plain\", x) method performs verbose pretty-printing of x. By default (if no 3-argument method is defined for typeof(x)), it calls the 2-argument show(io, x). It is called by the 2-argument repr(\"text/plain\", x). Other 3-argument show methods can be defined for additional MIME types as discussed above, to enable richer display of x in some interactive environments.\nThe 2-argument show(io, x) is the default simple text representation of x. It is called by the 1-argument repr(x), and is typically the format you might employ to input x into Julia. The 1-argument show(x) calls show(stdout, x).\nprint(io, x) by default calls show(io, x), but a few types have a distinct print format — most notably, when x is a string, print outputs the raw text whereas show outputs an escaped string enclosed in quotation marks. The 1-argument print(x) calls print(stdout, x). print is also called by string(x).  See also println (to append a newline) and printstyled (to add colors etc.), both of which call print.\nwrite(io, x), if it is defined (it generally has no default definition for new types), writes a \"raw\" binary representation of x to io, e.g. an x::Int32 will be written as 4 bytes.\n\nIt is also helpful to be familiar with the metadata that can be attached to an io stream by an IOContext wrapper. For example, the REPL sets the :limit => true flag from display for an evaluated expression, in order to limit the output to fit in the terminal; you can query this flag with get(io, :limit, false). And when displaying an object contained within, for example, a multi-column matrix, the :compact => true flag could be set, which you can query with get(io, :compact, false)."},{"title":"\"Value types\"","page":"Types","location":"manual/types.html#\"Value-types\"","category":"section","text":"In Julia, you can't dispatch on a value such as true or false. However, you can dispatch\non parametric types, and Julia allows you to include \"plain bits\" values (Types, Symbols, Integers,\nfloating-point numbers, tuples, etc.) as type parameters. A common example is the dimensionality\nparameter in Array{T,N}, where T is a type (e.g., Float64) but N is just an Int.\n\nYou can create your own custom types that take values as parameters, and use them to control dispatch\nof custom types. By way of illustration of this idea, let's introduce the parametric type Val{x},\nand its constructor Val(x) = Val{x}(), which serves as a customary way to exploit this technique\nfor cases where you don't need a more elaborate hierarchy.\n\nVal is defined as:\n\njulia> struct Val{x}\n       end\n\njulia> Val(x) = Val{x}()\nVal\n\nThere is no more to the implementation of Val than this. Some functions in Julia's standard\nlibrary accept Val instances as arguments, and you can also use it to write your own functions.\n For example:\n\njulia> firstlast(::Val{true}) = \"First\"\nfirstlast (generic function with 1 method)\n\njulia> firstlast(::Val{false}) = \"Last\"\nfirstlast (generic function with 2 methods)\n\njulia> firstlast(Val(true))\n\"First\"\n\njulia> firstlast(Val(false))\n\"Last\"\n\nFor consistency across Julia, the call site should always pass a Val instance rather than using\na type, i.e., use foo(Val(:bar)) rather than foo(Val{:bar}).\n\nIt's worth noting that it's extremely easy to mis-use parametric \"value\" types, including Val;\nin unfavorable cases, you can easily end up making the performance of your code much worse.\n In particular, you would never want to write actual code as illustrated above. For more information\nabout the proper (and improper) uses of Val, please read the more extensive discussion in the performance tips.\n\n[1]: \"Small\" is defined by the max_union_splitting configuration, which currently defaults to 4.\n\n[2]: A few popular languages have singleton types, including Haskell, Scala and Ruby."},{"title":"Scoped Values","page":"Scoped Values","location":"base/scopedvalues.html#scoped-values","category":"section","text":"Scoped values provide an implementation of dynamic scoping in Julia.\n\nnote: Lexical scoping vs dynamic scoping\nLexical scoping is the default behavior in Julia.\nUnder lexical scoping the scope of a variable is determined by the lexical\n(textual) structure of a program.\nUnder dynamic scoping a variable is bound to the most recent assigned value\nduring the program's execution.\n\nThe state of a scoped value is dependent on the execution path of the program.\nThis means that for a scoped value you may observe multiple different values\nconcurrently.\n\ncompat: Julia 1.11\nScoped values were introduced in Julia 1.11. In Julia 1.8+ a compatible\nimplementation is available from the package ScopedValues.jl.\n\nIn its simplest form you can create a ScopedValue\nwith a default value and then use with or\n@with to enter a new dynamic scope. The new scope will\ninherit all values from the parent scope (and recursively from all outer scopes) with the\nprovided scoped value taking priority over previous definitions.\n\nLet's first look at an example of lexical scope. A let statement begins\na new lexical scope within which the outer definition of x is shadowed by\nits inner definition.\n\njulia> x = 1\n1\n\njulia> let x = 5\n           @show x\n       end;\nx = 5\n\njulia> @show x;\nx = 1\n\nIn the following example, since Julia uses lexical scope, the variable x in the body\nof f refers to the x defined in the global scope, and entering a let scope does\nnot change the value f observes.\n\njulia> x = 1\n1\n\njulia> f() = @show x\nf (generic function with 1 method)\n\njulia> let x = 5\n           f()\n       end;\nx = 1\n\njulia> f();\nx = 1\n\nNow using a ScopedValue we can use dynamic scoping.\n\njulia> using Base.ScopedValues\n\njulia> x = ScopedValue(1)\nScopedValue{Int64}(1)\n\njulia> f() = @show x[]\nf (generic function with 1 method)\n\njulia> with(x=>5) do\n           f()\n       end;\nx[] = 5\n\njulia> f();\nx[] = 1\n\nNote that the observed value of the ScopedValue is dependent on the execution\npath of the program.\n\nIt often makes sense to use a const variable to point to a scoped value,\nand you can set the value of multiple ScopedValues with one call to with.\n\nusing Base.ScopedValues\n\nf() = @show a[]\ng() = @show b[]\n\nconst a = ScopedValue(1)\nconst b = ScopedValue(2)\n\nf() # a[] = 1\ng() # b[] = 2\n\n# Enter a new dynamic scope and set value.\nwith(a => 3) do\n    f() # a[] = 3\n    g() # b[] = 2\n    with(a => 4, b => 5) do\n        f() # a[] = 4\n        g() # b[] = 5\n    end\n    f() # a[] = 3\n    g() # b[] = 2\nend\n\nf() # a[] = 1\ng() # b[] = 2\n\nScopedValues provides a macro version of with. The expression @with var=>val expr\nevaluates expr in a new dynamic scope with var set to val. @with var=>val expr\nis equivalent to with(var=>val) do expr end. However, with requires a zero-argument\nclosure or function, which results in an extra call-frame. As an example, consider the\nfollowing function f:\n\nusing Base.ScopedValues\nconst a = ScopedValue(1)\nf(x) = a[] + x\n\nIf you wish to run f in a dynamic scope with a set to 2, then you can use with:\n\nwith(() -> f(10), a=>2)\n\nHowever, this requires wrapping f in a zero-argument function. If you wish to avoid\nthe extra call-frame, then you can use the @with macro:\n\n@with a=>2 f(10)\n\nnote: Note\nDynamic scopes are inherited by Tasks, at the moment of task creation. Dynamic scopes are not propagated through Distributed.jl operations.\n\nIn the example below we open a new dynamic scope before launching a task.\nThe parent task and the two child tasks observe independent values of the\nsame scoped value at the same time.\n\nusing Base.ScopedValues\nimport Base.Threads: @spawn\n\nconst scoped_val = ScopedValue(1)\n@sync begin\n    with(scoped_val => 2)\n        @spawn @show scoped_val[] # 2\n    end\n    with(scoped_val => 3)\n        @spawn @show scoped_val[] # 3\n    end\n    @show scoped_val[] # 1\nend\n\nScoped values are constant throughout a scope, but you can store mutable\nstate in a scoped value. Just keep in mind that the usual caveats\nfor global variables apply in the context of concurrent programming.\n\nCare is also required when storing references to mutable state in scoped\nvalues. You might want to explicitly unshare mutable state\nwhen entering a new dynamic scope.\n\nusing Base.ScopedValues\nimport Base.Threads: @spawn\n\nconst sval_dict = ScopedValue(Dict())\n\n# Example of using a mutable value wrongly\n@sync begin\n    # `Dict` is not thread-safe the usage below is invalid\n    @spawn (sval_dict[][:a] = 3)\n    @spawn (sval_dict[][:b] = 3)\nend\n\n@sync begin\n    # If we instead pass a unique dictionary to each\n    # task we can access the dictionaries race free.\n    with(sval_dict => Dict()) do\n        @spawn (sval_dict[][:a] = 3)\n    end\n    with(sval_dict => Dict()) do\n        @spawn (sval_dict[][:b] = 3)\n    end\nend"},{"title":"Example","page":"Scoped Values","location":"base/scopedvalues.html#Example","category":"section","text":"In the example below we use a scoped value to implement a permission check in\na web-application. After determining the permissions of the request,\na new dynamic scope is entered and the scoped value LEVEL is set.\nOther parts of the application can query the scoped value and will receive\nthe appropriate value. Other alternatives like task-local storage and global variables\nare not well suited for this kind of propagation; our only alternative would have\nbeen to thread a value through the entire call-chain.\n\nusing Base.ScopedValues\n\nconst LEVEL = ScopedValue(:GUEST)\n\nfunction serve(request, response)\n    level = isAdmin(request) ? :ADMIN : :GUEST\n    with(LEVEL => level) do\n        Threads.@spawn handle(request, response)\n    end\nend\n\nfunction open(connection::Database)\n    level = LEVEL[]\n    if level !== :ADMIN\n        error(\"Access disallowed\")\n    end\n    # ... open connection\nend\n\nfunction handle(request, response)\n    # ...\n    open(Database(#=...=#))\n    # ...\nend"},{"title":"Idioms","page":"Scoped Values","location":"base/scopedvalues.html#Idioms","category":"section","text":""},{"title":"Unshare mutable state","page":"Scoped Values","location":"base/scopedvalues.html#unshare_mutable_state","category":"section","text":"using Base.ScopedValues\nimport Base.Threads: @spawn\n\nconst sval_dict = ScopedValue(Dict())\n\n# If you want to add new values to the dict, instead of replacing\n# it, unshare the values explicitly. In this example we use `merge`\n# to unshare the state of the dictionary in parent scope.\n@sync begin\n    with(sval_dict => merge(sval_dict[], Dict(:a => 10))) do\n        @spawn @show sval_dict[][:a]\n    end\n    @spawn sval_dict[][:a] = 3 # Not a race since they are unshared.\nend"},{"title":"Scoped values as globals","page":"Scoped Values","location":"base/scopedvalues.html#Scoped-values-as-globals","category":"section","text":"In order to access the value of a scoped value, the scoped value itself has to\nbe in (lexical) scope. This means most often you likely want to use scoped values\nas constant globals.\n\nusing Base.ScopedValues\nconst sval = ScopedValue(1)\n\nIndeed one can think of scoped values as hidden function arguments.\n\nThis does not preclude their use as non-globals.\n\nusing Base.ScopedValues\nimport Base.Threads: @spawn\n\nfunction main()\n    role = ScopedValue(:client)\n\n    function launch()\n        #...\n        role[]\n    end\n\n    @with role => :server @spawn launch()\n    launch()\nend\n\nBut it might have been simpler to just directly pass the function argument\nin these cases."},{"title":"Very many ScopedValues","page":"Scoped Values","location":"base/scopedvalues.html#Very-many-ScopedValues","category":"section","text":"If you find yourself creating many ScopedValue's for one given module,\nit may be better to use a dedicated struct to hold them.\n\nusing Base.ScopedValues\n\nBase.@kwdef struct Configuration\n    color::Bool = false\n    verbose::Bool = false\nend\n\nconst CONFIG = ScopedValue(Configuration(color=true))\n\n@with CONFIG => Configuration(color=CONFIG[].color, verbose=true) begin\n    @show CONFIG[].color # true\n    @show CONFIG[].verbose # true\nend"},{"title":"API docs","page":"Scoped Values","location":"base/scopedvalues.html#API-docs","category":"section","text":""},{"title":"Implementation notes and performance","page":"Scoped Values","location":"base/scopedvalues.html#Implementation-notes-and-performance","category":"section","text":"Scopes use a persistent dictionary. Lookup and insertion is O(log(32, n)),\nupon dynamic scope entry a small amount of data is copied and the unchanged\ndata is shared among other scopes.\n\nThe Scope object itself is not user-facing and may be changed in a future\nversion of Julia."},{"title":"Design inspiration","page":"Scoped Values","location":"base/scopedvalues.html#Design-inspiration","category":"section","text":"This design was heavily inspired by JEPS-429,\nwhich in turn was inspired by dynamically scoped free variables in many Lisp dialects. In particular Interlisp-D and its deep binding strategy.\n\nA prior design discussed was context variables ala PEPS-567 and implemented in Julia as ContextVariablesX.jl."},{"title":"Base.ScopedValues.ScopedValue","page":"Scoped Values","location":"base/scopedvalues.html#Base.ScopedValues.ScopedValue","category":"type","text":"ScopedValue(x)\n\nCreate a container that propagates values across dynamic scopes.\nUse with to create and enter a new dynamic scope.\n\nValues can only be set when entering a new dynamic scope,\nand the value referred to will be constant during the\nexecution of a dynamic scope.\n\nDynamic scopes are propagated across tasks.\n\nExamples\n\njulia> using Base.ScopedValues;\n\njulia> const sval = ScopedValue(1);\n\njulia> sval[]\n1\n\njulia> with(sval => 2) do\n           sval[]\n       end\n2\n\njulia> sval[]\n1\n\ncompat: Julia 1.11\nScoped values were introduced in Julia 1.11. In Julia 1.8+ a compatible\nimplementation is available from the package ScopedValues.jl.\n\n\n\n\n\n"},{"title":"Base.ScopedValues.with","page":"Scoped Values","location":"base/scopedvalues.html#Base.ScopedValues.with","category":"function","text":"with(f, (var::ScopedValue{T} => val)...)\n\nExecute f in a new dynamic scope with var set to val. val will be converted\nto type T.\n\nSee also: ScopedValues.@with, ScopedValues.ScopedValue, ScopedValues.get.\n\nExamples\n\njulia> using Base.ScopedValues\n\njulia> a = ScopedValue(1);\n\njulia> f(x) = a[] + x;\n\njulia> f(10)\n11\n\njulia> with(a=>2) do\n           f(10)\n       end\n12\n\njulia> f(10)\n11\n\njulia> b = ScopedValue(2);\n\njulia> g(x) = a[] + b[] + x;\n\njulia> with(a=>10, b=>20) do\n           g(30)\n       end\n60\n\njulia> with(() -> a[] * b[], a=>3, b=>4)\n12\n\n\n\n\n\n"},{"title":"Base.ScopedValues.@with","page":"Scoped Values","location":"base/scopedvalues.html#Base.ScopedValues.@with","category":"macro","text":"@with (var::ScopedValue{T} => val)... expr\n\nMacro version of with. The expression @with var=>val expr evaluates expr in a\nnew dynamic scope with var set to val. val will be converted to type T.\n@with var=>val expr is equivalent to with(var=>val) do expr end, but @with\navoids creating a closure.\n\nSee also: ScopedValues.with, ScopedValues.ScopedValue, ScopedValues.get.\n\nExamples\n\njulia> using Base.ScopedValues\n\njulia> const a = ScopedValue(1);\n\njulia> f(x) = a[] + x;\n\njulia> @with a=>2 f(10)\n12\n\njulia> @with a=>3 begin\n           x = 100\n           f(x)\n       end\n103\n\n\n\n\n\n"},{"title":"Base.isassigned","page":"Scoped Values","location":"base/scopedvalues.html#Base.isassigned-Tuple{Base.ScopedValues.ScopedValue}","category":"method","text":"isassigned(val::ScopedValue)\n\nTest whether a ScopedValue has an assigned value.\n\nSee also: ScopedValues.with, ScopedValues.@with, ScopedValues.get.\n\nExamples\n\njulia> using Base.ScopedValues\n\njulia> a = ScopedValue(1); b = ScopedValue{Int}();\n\njulia> isassigned(a)\ntrue\n\njulia> isassigned(b)\nfalse\n\n\n\n\n\n"},{"title":"Base.ScopedValues.get","page":"Scoped Values","location":"base/scopedvalues.html#Base.ScopedValues.get","category":"function","text":"get(val::ScopedValue{T})::Union{Nothing, Some{T}}\nget(val::LazyScopedValue{T})::Union{Nothing, Some{T}}\n\nIf the scoped value isn't set and doesn't have a default value,\nreturn nothing. Otherwise returns Some{T} with the current\nvalue.\n\nSee also: ScopedValues.with, ScopedValues.@with, ScopedValues.ScopedValue.\n\nExamples\n\njulia> using Base.ScopedValues\n\njulia> a = ScopedValue(42); b = ScopedValue{Int}();\n\njulia> ScopedValues.get(a)\nSome(42)\n\njulia> isnothing(ScopedValues.get(b))\ntrue\n\n\n\n\n\n"},{"title":"Building Julia (Detailed)","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#Building-Julia-(Detailed)","category":"section","text":""},{"title":"Downloading the Julia source code","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#Downloading-the-Julia-source-code","category":"section","text":"If you are behind a firewall, you may need to use the https protocol instead of the git protocol:\n\ngit config --global url.\"https://\".insteadOf git://\n\nBe sure to also configure your system to use the appropriate proxy\nsettings, e.g. by setting the https_proxy and http_proxy\nvariables."},{"title":"Building Julia","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#Building-Julia","category":"section","text":"When compiled the first time, the build will automatically download\npre-built [external\ndependencies](#Required-Build-Tools-and-External-Libraries). If you\nprefer to build all the dependencies on your own, or are building on a system that cannot\naccess the network during the build process, add the following in Make.user:\n\nUSE_BINARYBUILDER=0\n\nBuilding Julia requires 5GiB if building all dependencies and approximately 4GiB of virtual memory.\n\nTo perform a parallel build, use make -j N and supply the maximum\nnumber of concurrent processes. If the defaults in the build do not work for you, and\nyou need to set specific make parameters, you can save them in\nMake.user, and place the file in the root of your Julia source. The\nbuild will automatically check for the existence of Make.user and\nuse it if it exists.\n\nYou can create out-of-tree builds of Julia by specifying make O=<build-directory> configure on the command line. This will create a\ndirectory mirror, with all of the necessary Makefiles to build Julia,\nin the specified directory. These builds will share the source files\nin Julia and deps/srccache. Each out-of-tree build directory can\nhave its own Make.user file to override the global Make.user file\nin the top-level folder. After modifying the Make.user file if necessary,\nbuild using: make -C <build-directory>.\n\nIf everything works correctly, there will be a symlink to\nthe julia executable in the build directory which can be run as:\n\n./julia\n\nThe actual executable is in <build-directory>/usr/bin.\nAfter running this, you will see a Julia banner and an\ninteractive prompt into which you can enter expressions for\nevaluation. (Errors related to libraries might be caused by old,\nincompatible libraries sitting around in your PATH. In this case, try\nmoving the julia directory earlier in the PATH). Note that most of\nthe instructions above apply to unix systems.\n\nTo run julia from anywhere you can:\n\nadd an alias (in bash: echo \"alias julia='<build-directory>/usr/bin/julia'\" >> ~/.bashrc && source ~/.bashrc), or\nadd a soft link to the julia executable in the <build-directory>/usr/bin directory to /usr/local/bin (or any suitable directory already in your path), or\nadd the julia directory to your executable path for this shell session (in bash: export PATH=\"$(pwd):$PATH\" ; in csh or tcsh:\n\nset path= ( $path $cwd ) ), or\n\nadd the julia directory to your executable path permanently (e.g. in .bash_profile), or\nwrite prefix=/path/to/install/folder into Make.user and then run make install. If there is a version of Julia already installed in this folder, you should delete it before running make install.\n\nSome of the options you can set to control the build of Julia are listed and documented at the beginning of the file Make.inc, but you should never edit it for this purpose, use Make.user instead.\n\nJulia's Makefiles define convenient automatic rules called print-<VARNAME> for printing the value of variables, replacing <VARNAME> with the name of the variable to print the value of.\nFor example\n\n$ make print-JULIA_PRECOMPILE\nJULIA_PRECOMPILE=1\n\nThese rules are useful for debugging purposes.\n\nNow you should be able to run Julia like this:\n\njulia\n\nIf you are building a Julia package for distribution on Linux, macOS,\nor Windows, take a look at the detailed notes in\ndistributing.md."},{"title":"Updating an existing source tree","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#Updating-an-existing-source-tree","category":"section","text":"If you have previously downloaded julia using git clone, you can update the\nexisting source tree using git pull rather than starting anew:\n\ncd julia\ngit pull && make\n\nAssuming that you had made no changes to the source tree that will conflict\nwith upstream updates, these commands will trigger a build to update to the\nlatest version."},{"title":"General troubleshooting","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#General-troubleshooting","category":"section","text":"Over time, the base library may accumulate enough changes such that the\nbootstrapping process in building the system image will fail. If this\nhappens, the build may fail with an error like\n *** This error is usually fixed by running 'make clean'. If the error persists, try 'make cleanall' ***\nAs described, running make clean && make is usually sufficient.\nOccasionally, the stronger cleanup done by make cleanall is needed.\nNew versions of external dependencies may be introduced which may\noccasionally cause conflicts with existing builds of older versions.\na. Special make targets exist to help wipe the existing build of a\n   dependency. For example, make -C deps clean-llvm will clean out the\n   existing build of llvm so that llvm will be rebuilt from the\n   downloaded source distribution the next time make is called.\n   make -C deps distclean-llvm is a stronger wipe which will also delete\n   the downloaded source distribution, ensuring that a fresh copy of the\n   source distribution will be downloaded and that any new patches will be\n   applied the next time make is called.\nb. To delete existing binaries of julia and all its dependencies,\n   delete the ./usr directory in the source tree.\nIf you've updated macOS recently, be sure to run xcode-select --install to update the command line tools.\nOtherwise, you could run into errors for missing headers and libraries, such as\nld: library not found for -lcrt1.10.6.o.\nIf you've moved the source directory, you might get errors such as\n CMake Error: The current CMakeCache.txt directory ... is different than the directory ... where     CMakeCache.txt was created., in which case you may delete the offending dependency under deps\nIn extreme cases, you may wish to reset the source tree to a pristine state.\nThe following git commands may be helpful:\n git reset --hard #Forcibly remove any changes to any files under version control\n git clean -x -f -d #Forcibly remove any file or directory not under version control\nTo avoid losing work, make sure you know what these commands do before you\nrun them. git will not be able to undo these changes!"},{"title":"Platform-Specific Notes","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#Platform-Specific-Notes","category":"section","text":"Notes for various operating systems:\n\nLinux\nmacOS\nWindows\nFreeBSD\n\nNotes for various architectures:\n\nARM\nRISC-V"},{"title":"Required Build Tools and External Libraries","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#Required-Build-Tools-and-External-Libraries","category":"section","text":"Building Julia requires that the following software be installed:\n\nGNU make                — building dependencies.\ngcc & g++ (>= 7.1) or Clang (>= 5.0, >= 9.3 for Apple Clang) — compiling and linking C, C++.\nOn Linux with g++, the static version of libstdc++ is also required.  If it is unavailable, set USE_RT_STATIC_LIBSTDCXX=0 in Make.user.\nlibatomic          — provided by [gcc] and needed to support atomic operations.\npython (>=2.7)          — needed to build LLVM.\ngfortran                — compiling and linking Fortran libraries.\nperl                    — preprocessing of header files of libraries.\nwget, curl, or fetch (FreeBSD) — to automatically download external libraries.\nm4                      — needed to build GMP.\nawk                     — helper tool for Makefiles.\npatch                   — for modifying source code.\ncmake (>= 3.4.3)        — needed to build libgit2.\npkg-config              — needed to build libgit2 correctly, especially for proxy support.\npowershell (>= 3.0)     — necessary only on Windows.\nwhich                   — needed for checking build dependencies.\ndiffutils                   - cmp is used by the makefiles\n\nOn Debian-based distributions (e.g. Ubuntu), you can easily install them with apt-get:\n\nsudo apt-get install build-essential libatomic1 python3 gfortran perl wget m4 cmake pkg-config curl\n\nOn Red Hat-based distributions (e.g. Fedora, CentOS), you can install them with yum:\n\nsudo dnf install gcc gcc-c++ gcc-gfortran python3 perl wget m4 cmake pkgconfig curl which diffutils libatomic libstdc++-static\n\nJulia uses the following external libraries, which are automatically\ndownloaded (or in a few cases, included in the Julia source\nrepository) and then compiled from source the first time you run\nmake. The specific version numbers of these libraries that Julia\nuses are listed in deps/$(libname).version:\n\nLLVM (15.0 + patches) — compiler infrastructure (see note below).\nFemtoLisp            — packaged with Julia source, and used to implement the compiler front-end.\nlibuv  (custom fork) — portable, high-performance event-based I/O library.\nOpenLibm             — portable libm library containing elementary math functions.\nDSFMT                — fast Mersenne Twister pseudorandom number generator library.\nOpenBLAS             — fast, open, and maintained [basic linear algebra subprograms (BLAS)]\nLAPACK               — library of linear algebra routines for solving systems of simultaneous linear equations, least-squares solutions of linear systems of equations, eigenvalue problems, and singular value problems.\nMKL (optional)       – OpenBLAS and LAPACK may be replaced by Intel's MKL library.\nSuiteSparse          — library of linear algebra routines for sparse matrices.\nPCRE                 — Perl-compatible regular expressions library.\nGMP                  — GNU multiple precision arithmetic library, needed for BigInt support.\nMPFR                 — GNU multiple precision floating point library, needed for arbitrary precision floating point (BigFloat) support.\nlibgit2              — Git linkable library, used by Julia's package manager.\ncurl                 — libcurl provides download and proxy support.\nlibssh2              — library for SSH transport, used by libgit2 for packages with SSH remotes.\nOpenSSL              — library used for cryptography and transport layer security, used by libgit2 and libssh2.\nutf8proc             — a library for processing UTF-8 encoded Unicode strings.\nLLVM libunwind       — LLVM's fork of [libunwind], a library that determines the call-chain of a program.\nITTAPI               — Intel's Instrumentation and Tracing Technology and Just-In-Time API."},{"title":"Build dependencies","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#Build-dependencies","category":"section","text":"If you already have one or more of these packages installed on your system, you can prevent Julia from compiling duplicates of these libraries by passing USE_SYSTEM_...=1 to make or adding the line to Make.user. The complete list of possible flags can be found in Make.inc.\n\nPlease be aware that this procedure is not officially supported, as it introduces additional variability into the installation and versioning of the dependencies, and is recommended only for system package maintainers. Unexpected compile errors may result, as the build system will do no further checking to ensure the proper packages are installed."},{"title":"LLVM","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#LLVM","category":"section","text":"The most complicated dependency is LLVM, for which we require additional patches from upstream (LLVM is not backward compatible).\n\nFor packaging Julia with LLVM, we recommend either:\n\nbundling a Julia-only LLVM library inside the Julia package, or\nadding the patches to the LLVM package of the distribution.\nA complete list of patches is available in on Github see the julia-release/18.x branch.\nThe remaining patches are all upstream bug fixes, and have been contributed into upstream LLVM.\n\nUsing an unpatched or different version of LLVM will result in errors and/or poor performance.\nYou can build a different version of LLVM from a remote Git repository with the following options in the Make.user file:\n\n# Force source build of LLVM\nUSE_BINARYBUILDER_LLVM = 0\n# Use Git for fetching LLVM source code\n# this is either `1` to get all of them\nDEPS_GIT = 1\n# or a space-separated list of specific dependencies to download with git\nDEPS_GIT = llvm\n\n# Other useful options:\n#URL of the Git repository you want to obtain LLVM from:\n#  LLVM_GIT_URL = ...\n#Name of the alternate branch to clone from git\n#  LLVM_BRANCH = julia-16.0.6-0\n#SHA hash of the alternate commit to check out automatically\n#  LLVM_SHA1 = $(LLVM_BRANCH)\n#List of LLVM targets to build. It is strongly recommended to keep at least all the\n#default targets listed in `deps/llvm.mk`, even if you don't necessarily need all of them.\n#  LLVM_TARGETS = ...\n#Use ccache for faster recompilation in case you need to restart a build.\n#  USECCACHE = 1\n#  CMAKE_GENERATOR=Ninja\n#  LLVM_ASSERTIONS=1\n#  LLVM_DEBUG=Symbols\n\nThe various build phases are controlled by specific files:\n\ndeps/llvm.version : touch or change to checkout a new version, make get-llvm check-llvm\ndeps/srccache/llvm/source-extracted : result of make extract-llvm\ndeps/llvm/build_Release*/build-configured : result of make configure-llvm\ndeps/llvm/build_Release*/build-configured : result of make compile-llvm\nusr-staging/llvm/build_Release*.tgz : result of make stage-llvm (regenerate with make reinstall-llvm)\nusr/manifest/llvm : result of make install-llvm (regenerate with make uninstall-llvm)\nmake version-check-llvm : runs every time to warn the user if there are local modifications\n\nThough Julia can be built with newer LLVM versions, support for this should be regarded as experimental and not suitable for packaging."},{"title":"libuv","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#libuv","category":"section","text":"Julia uses a custom fork of libuv. It is a small dependency, and can be safely bundled in the same package as Julia, and will not conflict with the system library. Julia builds should not try to use the system libuv."},{"title":"BLAS and LAPACK","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#BLAS-and-LAPACK","category":"section","text":"As a high-performance numerical language, Julia should be linked to a multi-threaded BLAS and LAPACK, such as OpenBLAS or ATLAS, which will provide much better performance than the reference libblas implementations which may be default on some systems."},{"title":"Source distributions of releases","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#Source-distributions-of-releases","category":"section","text":"Each pre-release and release of Julia has a \"full\" source distribution and a \"light\" source\ndistribution.\n\nThe full source distribution contains the source code for Julia and all dependencies so\nthat it can be built from source without an internet connection. The light source\ndistribution does not include the source code of dependencies.\n\nFor example, julia-1.0.0.tar.gz is the light source distribution for the v1.0.0 release\nof Julia, while julia-1.0.0-full.tar.gz is the full source distribution."},{"title":"Building Julia from source with a Git checkout of a stdlib","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#Building-Julia-from-source-with-a-Git-checkout-of-a-stdlib","category":"section","text":"If you need to build Julia from source with a Git checkout of a stdlib, then use make DEPS_GIT=NAME_OF_STDLIB when building Julia.\n\nFor example, if you need to build Julia from source with a Git checkout of Pkg, then use make DEPS_GIT=Pkg when building Julia. The Pkg repo is in stdlib/Pkg, and created initially with a detached HEAD. If you're doing this from a pre-existing Julia repository, you may need to make clean beforehand.\n\nIf you need to build Julia from source with Git checkouts of more than one stdlib, then DEPS_GIT should be a space-separated list of the stdlib names. For example, if you need to build Julia from source with a Git checkout of Pkg, Tar, and Downloads, then use make DEPS_GIT='Pkg Tar Downloads' when building Julia."},{"title":"Building an \"assert build\" of Julia","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#Building-an-\"assert-build\"-of-Julia","category":"section","text":"An \"assert build\" of Julia is a build that was built with both FORCE_ASSERTIONS=1 and\nLLVM_ASSERTIONS=1. To build an assert build, define both of the following variables\nin your Make.user file:\n\nFORCE_ASSERTIONS=1\nLLVM_ASSERTIONS=1\n\nPlease note that assert builds of Julia will be slower than regular (non-assert) builds."},{"title":"Building a debug build of Julia","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#Building-a-debug-build-of-Julia","category":"section","text":"A full debug build of Julia can be built with make debug.  This builds a debug\nversion of libjulia and uses it to bootstrap the compiler, before creating a\nsystem image with debug symbols enabled.  This can take more than 15 minutes.\n\nAlthough it may result in some differences, a debug build can be built much\nquicker by bootstrapping from a release build:\n\n$ make julia-src-release julia-sysbase-release\n$ make julia-sysimg-debug CROSS_BOOTSTRAP_JULIA=$PWD/usr/bin/julia CROSS_BOOTSTRAP_SYSBASE=$PWD/usr/lib/julia/sysbase.so"},{"title":"Building 32-bit Julia on a 64-bit machine","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#Building-32-bit-Julia-on-a-64-bit-machine","category":"section","text":"Occasionally, bugs specific to 32-bit architectures may arise, and when this happens it is useful to be able to debug the problem on your local machine. Since most modern 64-bit systems support running programs built for 32-bit ones, if you don't have to recompile Julia from source (e.g. you mainly need to inspect the behavior of a 32-bit Julia without having to touch the C code), you can likely use a 32-bit build of Julia for your system that you can obtain from the official downloads page.\nHowever, if you do need to recompile Julia from source one option is to use a Docker container of a 32-bit system. At least for now, building a 32-bit version of Julia is relatively straightforward using ubuntu 32-bit docker images. In brief, after setting up docker here are the required steps:\n\n$ docker pull i386/ubuntu\n$ docker run --platform i386 -i -t i386/ubuntu /bin/bash\n\nAt this point you should be in a 32-bit machine console (note that uname reports the host architecture, so will still say 64-bit, but this will not affect the Julia build). You can add packages and compile code; when you exit, all the changes will be lost, so be sure to finish your analysis in a single session or set up a copy/pastable script you can use to set up your environment.\n\nFrom this point, you should\n\n# apt update\n\n(Note that sudo isn't installed, but neither is it necessary since you are running as root, so you can omit sudo from all commands.)\n\nThen add all the build dependencies, a console-based editor of your choice, git, and anything else you'll need (e.g., gdb, rr, etc). Pick a directory to work in and git clone Julia, check out the branch you wish to debug, and build Julia as usual."},{"title":"Update the version number of a dependency","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#Update-the-version-number-of-a-dependency","category":"section","text":"There are two types of builds\n\nBuild everything (deps/ and src/) from source code.\n (Add USE_BINARYBUILDER=0 to Make.user, see Building Julia)\nBuild from source (src/) with pre-compiled dependencies (default)\n\nWhen you want to update the version number of a dependency in deps/,\nyou may want to use the following checklist:\n\n### Check list\n\nVersion numbers:\n- [ ] `deps/$(libname).version`: `LIBNAME_VER`, `LIBNAME_BRANCH`, `LIBNAME_SHA1` and `LIBNAME_JLL_VER`\n- [ ] `stdlib/$(LIBNAME_JLL_NAME)_jll/Project.toml`: `version`\n\nChecksum:\n- [ ] `deps/checksums/$(libname)`\n- [ ] `deps/checksums/$(LIBNAME_JLL_NAME)-*/`: `md5` and `sha512`\n\nPatches:\n- [ ] `deps/$(libname).mk`\n- [ ] `deps/patches/$(libname)-*.patch`\n\nNote:\n\nFor specific dependencies, some items in the checklist may not exist.\nFor checksum file, it may be a single file without a suffix, or a folder containing two files."},{"title":"Example: OpenLibm","page":"Building Julia (Detailed)","location":"devdocs/build/build.html#Example:-OpenLibm","category":"section","text":"Update Version numbers in deps/openlibm.version\nOPENLIBM_VER := 0.X.Y\nOPENLIBM_BRANCH = v0.X.Y\nOPENLIBM_SHA1 = new-sha1-hash\nUpdate Version number in stdlib/OpenLibm_jll/Project.toml\nversion = \"0.X.Y+0\"\nUpdate checksums in deps/checksums/openlibm\nmake -f contrib/refresh_checksums.mk openlibm\nCheck if the patch files deps/patches/openlibm-*.patch exist\nif patches don't exist, skip.\nif patches exist, check if they have been merged into the new version and need to be removed.\n  When deleting a patch, remember to modify the corresponding Makefile file (deps/openlibm.mk)."},{"title":"Julia Functions","page":"Julia Functions","location":"devdocs/functions.html#Julia-Functions","category":"section","text":"This document will explain how functions, method definitions, and method tables work."},{"title":"Method Tables","page":"Julia Functions","location":"devdocs/functions.html#Method-Tables","category":"section","text":"Every function in Julia is a generic function. A generic function is conceptually a single function,\nbut consists of many definitions, or methods. The methods of a generic function are stored in a\nmethod table. There is one global method table (type MethodTable) named Core.methodtable. Any\ndefault operation on methods (such as calls) uses that table."},{"title":"Function calls","page":"Julia Functions","location":"devdocs/functions.html#Function-calls","category":"section","text":"Given the call f(x, y), the following steps are performed: First, a tuple type is formed,\nTuple{typeof(f), typeof(x), typeof(y)}. Note that the type of the function itself is the first\nelement. This is because the function itself participates symmetrically in method lookup with the\nother arguments. This tuple type is looked up in the global method table. However, the system can\nthen cache the results, so these steps can be skipped later for similar lookups.\n\nThis dispatch process is performed by jl_apply_generic, which takes two arguments: a pointer\nto an array of the values f, x, and y, and the number of values (in this case 3).\n\nThroughout the system, there are two kinds of APIs that handle functions and argument lists: those\nthat accept the function and arguments separately, and those that accept a single argument structure.\nIn the first kind of API, the \"arguments\" part does not contain information about the function,\nsince that is passed separately. In the second kind of API, the function is the first element\nof the argument structure.\n\nFor example, the following function for performing a call accepts just an args pointer, so the\nfirst element of the args array will be the function to call:\n\njl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)\n\nThis entry point for the same functionality accepts the function separately, so the args array\ndoes not contain the function:\n\njl_value_t *jl_call(jl_value_t *f, jl_value_t **args, int32_t nargs);"},{"title":"Adding methods","page":"Julia Functions","location":"devdocs/functions.html#Adding-methods","category":"section","text":"Given the above dispatch process, conceptually all that is needed to add a new method is (1) a\ntuple type, and (2) code for the body of the method. jl_method_def implements this operation."},{"title":"Creating generic functions","page":"Julia Functions","location":"devdocs/functions.html#Creating-generic-functions","category":"section","text":"Since every object is callable, nothing special is needed to create a generic function. Therefore\njl_new_generic_function simply creates a new singleton (0 size) subtype of Function and returns\nits instance. A function can have a mnemonic \"display name\" which is used in debug info and when\nprinting objects. For example the name of Base.sin is sin. By convention, the name of the\ncreated type is the same as the function name, with a # prepended. So typeof(sin) is Base.#sin."},{"title":"Closures","page":"Julia Functions","location":"devdocs/functions.html#Closures","category":"section","text":"A closure is simply a callable object with field names corresponding to captured variables. For\nexample, the following code:\n\nfunction adder(x)\n    return y->x+y\nend\n\nis lowered to (roughly):\n\nstruct ##1{T}\n    x::T\nend\n\n(_::##1)(y) = _.x + y\n\nfunction adder(x)\n    return ##1(x)\nend"},{"title":"Constructors","page":"Julia Functions","location":"devdocs/functions.html#Constructors","category":"section","text":"A constructor call is just a call to a type, to a method defined on Type{T}."},{"title":"Builtins","page":"Julia Functions","location":"devdocs/functions.html#Builtins","category":"section","text":"The \"builtin\" functions, defined in the Core module, are:\n\nfunction lines(words)\n    io = IOBuffer()\n    n = 0\n    for w in words\n        if n+length(w) > 80\n            print(io, '\\n', w)\n            n = length(w)\n        elseif n == 0\n            print(io, w);\n            n += length(w)\n        else\n            print(io, ' ', w);\n            n += length(w)+1\n        end\n    end\n    takestring!(io)\nend\nimport Markdown\n[string(n) for n in names(Core;all=true)\n    if getfield(Core,n) isa Core.Builtin && nameof(getfield(Core,n)) === n] |>\n    lines |>\n    s ->  \"```\\n$s\\n```\" |>\n    Markdown.parse\n\nThese are mostly singleton objects all of whose types are subtypes of Builtin, which is a\nsubtype of Function. Their purpose is to expose entry points in the run time that use the\n\"jlcall\" calling convention:\n\njl_value_t *(jl_value_t*, jl_value_t**, uint32_t)"},{"title":"Keyword arguments","page":"Julia Functions","location":"devdocs/functions.html#Keyword-arguments","category":"section","text":"Keyword arguments work by adding methods to the kwcall function. This function\nis usually the \"keyword argument sorter\" or \"keyword sorter\", which then calls\nthe inner body of the function (defined anonymously).\nEvery definition in the kwsorter function has the same arguments as some definition in the normal\nmethod table, except with a single NamedTuple argument prepended, which gives\nthe names and values of passed keyword arguments. The kwsorter's job is to move keyword arguments\ninto their canonical positions based on name, plus evaluate and substitute any needed default value\nexpressions. The result is a normal positional argument list, which is then passed to yet another\ncompiler-generated function.\n\nThe easiest way to understand the process is to look at how a keyword argument method definition\nis lowered. The code:\n\nfunction circle(center, radius; color = black, fill::Bool = true, options...)\n    # draw\nend\n\nactually produces three method definitions. The first is a function that accepts all arguments\n(including keyword arguments) as positional arguments, and includes the code for the method body.\nIt has an auto-generated name:\n\nfunction #circle#1(color, fill::Bool, options, circle, center, radius)\n    # draw\nend\n\nThe second method is an ordinary definition for the original circle function, which handles\nthe case where no keyword arguments are passed:\n\nfunction circle(center, radius)\n    #circle#1(black, true, pairs(NamedTuple()), circle, center, radius)\nend\n\nThis simply dispatches to the first method, passing along default values.\npairs is applied to the named tuple of rest arguments to provide key-value pair iteration.\nNote that if the method doesn't accept rest keyword arguments then this argument\nis absent.\n\nFinally there is the kwsorter definition:\n\nfunction (::Core.kwcall)(kws, circle, center, radius)\n    if haskey(kws, :color)\n        color = kws.color\n    else\n        color = black\n    end\n    # etc.\n\n    # put remaining kwargs in `options`\n    options = structdiff(kws, NamedTuple{(:color, :fill)})\n\n    # if the method doesn't accept rest keywords, throw an error\n    # unless `options` is empty\n\n    #circle#1(color, fill, pairs(options), circle, center, radius)\nend"},{"title":"Compiler efficiency issues","page":"Julia Functions","location":"devdocs/functions.html#compiler-efficiency-issues","category":"section","text":"Generating a new type for every function has potentially serious consequences for compiler resource\nuse when combined with Julia's \"specialize on all arguments by default\" design. Indeed, the initial\nimplementation of this design suffered from much longer build and test times, higher memory use,\nand a system image nearly 2x larger than the baseline. In a naive implementation, the problem\nis bad enough to make the system nearly unusable. Several significant optimizations were needed\nto make the design practical.\n\nThe first issue is excessive specialization of functions for different values of function-valued\narguments. Many functions simply \"pass through\" an argument to somewhere else, e.g. to another\nfunction or to a storage location. Such functions do not need to be specialized for every closure\nthat might be passed in. Fortunately this case is easy to distinguish by simply considering whether\na function calls one of its arguments (i.e. the argument appears in \"head position\" somewhere).\nPerformance-critical higher-order functions like map certainly call their argument function\nand so will still be specialized as expected. This optimization is implemented by recording which\narguments are called during the analyze-variables pass in the front end. When cache_method\nsees an argument in the Function type hierarchy passed to a slot declared as Any or Function,\nit behaves as if the @nospecialize annotation were applied. This heuristic seems to be extremely\neffective in practice.\n\nThe next issue concerns the structure of method tables. Empirical studies show that the vast\nmajority of dynamically-dispatched calls involve one or two arguments. In turn, many of these cases\ncan be resolved by considering only the first argument. (Aside: proponents of single dispatch would\nnot be surprised by this at all. However, this argument means \"multiple dispatch is easy to optimize\nin practice\", and that we should therefore use it, not \"we should use single dispatch\"!). So the\nmethod table and cache splits up on the structure based on a left-to-right decision tree so allow\nefficient nearest-neighbor searches.\n\nThe front end generates type declarations for all closures. Initially, this was implemented by\ngenerating normal type declarations. However, this produced an extremely large number of constructors,\nall of which were trivial (simply passing all arguments through to new). Since methods are partially\nordered, inserting all of these methods is O(n²), plus there are just too many of them to keep\naround. This was optimized by generating struct_type expressions directly (bypassing default\nconstructor generation), and using new directly to create closure instances. Not the prettiest\nthing ever, but you do what you gotta do.\n\nThe next problem was the @test macro, which generated a 0-argument closure for each test case.\nThis is not really necessary, since each test case is simply run once in place. Therefore, @test\nwas modified to expand to a try-catch block that records the test result (true, false, or exception\nraised) and calls the test suite handler on it."},{"title":"Command-line Interface","page":"Command-line Interface","location":"manual/command-line-interface.html#cli","category":"section","text":""},{"title":"Using arguments inside scripts","page":"Command-line Interface","location":"manual/command-line-interface.html#Using-arguments-inside-scripts","category":"section","text":"When running a script using julia, you can pass additional arguments to your script:\n\n$ julia script.jl arg1 arg2...\n\nThese additional command-line arguments are passed in the global constant ARGS. The\nname of the script itself is passed in as the global PROGRAM_FILE. Note that ARGS is\nalso set when a Julia expression is given using the -e option on the command line (see the\njulia help output below) but PROGRAM_FILE will be empty. For example, to just print the\narguments given to a script, you could do this:\n\n$ julia -e 'println(PROGRAM_FILE); for x in ARGS; println(x); end' foo bar\n\nfoo\nbar\n\nOr you could put that code into a script and run it:\n\n$ echo 'println(PROGRAM_FILE); for x in ARGS; println(x); end' > script.jl\n$ julia script.jl foo bar\nscript.jl\nfoo\nbar\n\nThe -- delimiter can be used to separate command-line arguments intended for the script file from arguments intended for Julia:\n\n$ julia --color=yes -O -- script.jl arg1 arg2..\n\nSee also Scripting for more information on writing Julia scripts."},{"title":"The Main.main entry point","page":"Command-line Interface","location":"manual/command-line-interface.html#The-Main.main-entry-point","category":"section","text":"As of Julia 1.11, Base exports the macro @main. This macro expands to the symbol main,\nbut at the conclusion of executing a script or expression, julia will attempt to execute\nMain.main(Base.ARGS) if such a function Main.main has been defined and this behavior was opted into\nby using the @main macro.\n\nTo see this feature in action, consider the following definition:\n\n(@main)(args) = println(\"Hello $(args[1])!\")\n\nExecuting the above script with julia script.jl \"Buddy\" will automatically run (@main) and print \"Hello Buddy!\",\ndespite there being no explicit call to (@main).\n\nThe return value of the (@main) function must either be nothing, resulting in exit code\n0, or convertible to a Cint which will be the exit code:\n\n$ julia -e \"(@main)(args) = nothing\"; echo $?0\n0\n$ julia -e \"(@main)(args) = 1\"; echo $?\n1\n\nTypically exit codes are in the range 0:255, although the interpretation of the return value might be OS dependent.\n\nThis feature is intended to aid in the unification of compiled and interactive workflows. In compiled workflows, loading the code that defines the main\nfunction may be spatially and temporally separated from the invocation. However, for interactive workflows,\nthe behavior is equivalent to explicitly calling exit(main(ARGS)) at the end of the evaluated script or\nexpression.\n\ncompat: Julia 1.11\nThe special entry point Main.main was added in Julia 1.11. For compatibility with prior julia versions,\nadd an explicit @isdefined(var\"@main\") ? (@main) : exit(main(ARGS)) at the end of your scripts.\n\nOnly the main binding in the Main module has this behavior and only if\nthe macro @main was used within the defining module.\n\nFor example, using hello instead of main will not result in the hello function executing:\n\n$ julia -e 'hello(args) = println(\"Hello World!\")'\n$\n\nand neither will a plain definition of main:\n\n$ julia -e 'main(args) = println(\"Hello World!\")'\n$\n\nHowever, the opt-in need not occur at definition time:\n\n$ julia -e 'main(args) = println(\"Hello World!\"); @main'\nHello World!\n$\n\nThe main binding may be imported from a package. A hello world package defined as\n\nmodule Hello\n\nexport main\n(@main)(args) = println(\"Hello from the package!\")\n\nend\n\nmay be used as:\n\n$ julia -e 'using Hello'\nHello from the package!\n$ julia -e 'import Hello' # N.B.: Execution depends on the binding not whether the package is loaded\n$\n\nHowever, note that the current best practice recommendation is to not mix application and reusable library\ncode in the same package. Helper applications may be distributed as separate packages or as scripts with\nseparate main entry points in a package's bin folder."},{"title":"Parallel mode","page":"Command-line Interface","location":"manual/command-line-interface.html#Parallel-mode","category":"section","text":"Julia can be started in parallel mode with either the -p or the --machine-file options. -p n\nwill launch an additional n worker processes, while --machine-file file will launch a worker\nfor each line in file file. The machines defined in file must be accessible via a password-less\nssh login, with Julia installed at the same location as the current host. Each machine definition\ntakes the form [count*][user@]host[:port] [bind_addr[:port]]. user defaults to current user,\nport to the standard ssh port. count is the number of workers to spawn on the node, and defaults\nto 1. The optional bind-to bind_addr[:port] specifies the IP address and port that other workers\nshould use to connect to this worker."},{"title":"Startup file","page":"Command-line Interface","location":"manual/command-line-interface.html#Startup-file","category":"section","text":"If you have code that you want executed whenever Julia is run, you can put it in\n~/.julia/config/startup.jl:\n\n$ echo 'println(\"Greetings! 你好! 안녕하세요?\")' > ~/.julia/config/startup.jl\n$ julia\nGreetings! 你好! 안녕하세요?\n\n...\n\nNote that although you should have a ~/.julia directory once you've run Julia for the\nfirst time, you may need to create the ~/.julia/config folder and the\n~/.julia/config/startup.jl file if you use it.\n\nTo have startup code run only in The Julia REPL (and not when julia is e.g. run\non a script), use atreplinit in startup.jl:\n\natreplinit() do repl\n    # ...\nend\n\nIf JULIA_DEPOT_PATH is set, the startup file should be located there:\n$JULIA_DEPOT_PATH/config/startup.jl."},{"title":"Command-line switches for Julia","page":"Command-line Interface","location":"manual/command-line-interface.html#command-line-interface","category":"section","text":"There are various ways to run Julia code and provide options, similar to those available for the\nperl and ruby programs:\n\njulia [switches] -- [programfile] [args...]\n\nThe following is a complete list of command-line switches available when launching julia (a '*' marks the default value, if applicable; settings marked '($)' may trigger package precompilation):\n\nSwitch Description\n-v, --version Display version information\n-h, --help Print command-line options (this message)\n--help-hidden Print uncommon options not shown by -h\n--project[={<dir>|@temp|@.}] Set <dir> as the active project/environment. Or, create a temporary environment with @temp. The default @. option will search through parent directories until a Project.toml or JuliaProject.toml file is found.\n-J, --sysimage <file> Start up with the given system image file\n-H, --home <dir> Set location of julia executable\n--startup-file={yes*|no} Load JULIA_DEPOT_PATH/config/startup.jl; if JULIA_DEPOT_PATH environment variable is unset, load ~/.julia/config/startup.jl\n--handle-signals={yes*|no} Enable or disable Julia's default signal handlers\n--sysimage-native-code={yes*|no} Use native code from system image if available\n--compiled-modules={yes*|no|existing|strict} Enable or disable incremental precompilation of modules. The existing option allows use of existing compiled modules that were previously precompiled, but disallows creation of new precompile files. The strict option is similar, but will error if no precompile file is found.\n--pkgimages={yes*|no|existing} Enable or disable usage of native code caching in the form of pkgimages. The existing option allows use of existing pkgimages but disallows creation of new ones\n-e, --eval <expr> Evaluate <expr>\n-E, --print <expr> Evaluate <expr> and display the result\n-m, --module <Package> [args] Run entry point of Package (@main function) with args\n-L, --load <file> Load <file> immediately on all processors\n-t, --threads {auto|N[,auto|M]} Enable N[+M] threads; N threads are assigned to the default threadpool, and if M is specified, M threads are assigned to the interactive threadpool; auto tries to infer a useful default number of threads to use but the exact behavior might change in the future. Currently sets N to the number of CPUs assigned to this Julia process based on the OS-specific affinity assignment interface if supported (Linux and Windows) or to the number of CPU threads if not supported (MacOS) or if process affinity is not configured, and sets M to 1.\n--gcthreads=N[,M] Use N threads for the mark phase of GC and M (0 or 1) threads for the concurrent sweeping phase of GC. N is set to the number of compute threads and M is set to 0 if unspecified. See Memory Management and Garbage Collection for more details.\n-p, --procs {N|auto} Integer value N launches N additional local worker processes; auto launches as many workers as the number of local CPU threads (logical cores)\n--machine-file <file> Run processes on hosts listed in <file>\n-i, --interactive Interactive mode; REPL runs and isinteractive() is true\n-q, --quiet Quiet startup: no banner, suppress REPL warnings\n--banner={yes|no|short|auto*} Enable or disable startup banner\n--color={yes|no|auto*} Enable or disable color text\n--history-file={yes*|no} Load or save history\n--depwarn={yes|no*|error} Enable or disable syntax and method deprecation warnings (error turns warnings into errors)\n--warn-overwrite={yes|no*} Enable or disable method overwrite warnings\n--warn-scope={yes*|no} Enable or disable warning for ambiguous top-level scope\n-C, --cpu-target <target> Limit usage of CPU features up to <target>; set to help to see the available options\n-O, --optimize={0|1|2*|3} Set the optimization level (level is 3 if -O is used without a level) ($)\n--min-optlevel={0*|1|2|3} Set the lower bound on per-module optimization\n-g, --debug-info={0|1*|2} Set the level of debug info generation (level is 2 if -g is used without a level) ($)\n--inline={yes*|no} Control whether inlining is permitted, including overriding @inline declarations\n--check-bounds={yes|no|auto*} Emit bounds checks always, never, or respect @inbounds declarations ($)\n--math-mode={ieee|user*} Always follow ieee floating point semantics or respect @fastmath declarations\n--polly={yes*|no} Enable or disable the polyhedral optimizer Polly (overrides @polly declaration)\n--code-coverage[={none*|user|all}] Count executions of source lines (omitting setting is equivalent to user)\n--code-coverage=@<path> Count executions but only in files that fall under the given file path/directory. The @ prefix is required to select this option. A @ with no path will track the current directory.\n--code-coverage=tracefile.info Append coverage information to the LCOV tracefile (filename supports format tokens).\n--track-allocation[={none*|user|all}] Count bytes allocated by each source line (omitting setting is equivalent to \"user\")\n--track-allocation=@<path> Count bytes but only in files that fall under the given file path/directory. The @ prefix is required to select this option. A @ with no path will track the current directory.\n--task-metrics={yes|no*} Enable the collection of per-task metrics\n--bug-report=KIND Launch a bug report session. It can be used to start a REPL, run a script, or evaluate expressions. It first tries to use BugReporting.jl installed in current environment and falls back to the latest compatible BugReporting.jl if not. For more information, see --bug-report=help.\n--heap-size-hint=<size> Forces garbage collection if memory usage is higher than the given value. The value may be specified as a number of bytes, optionally in units of KB, MB, GB, or TB, or as a percentage of physical memory with %. See Memory Management and Garbage Collection for more details.\n--compile={yes*|no|all|min} Enable or disable JIT compiler, or request exhaustive or minimal compilation\n--output-o <name> Generate an object file (including system image data)\n--output-ji <name> Generate a system image data file (.ji)\n--strip-metadata Remove docstrings and source location info from system image\n--strip-ir Remove IR (intermediate representation) of compiled functions\n--output-unopt-bc <name> Generate unoptimized LLVM bitcode (.bc)\n--output-bc <name> Generate LLVM bitcode (.bc)\n--output-asm <name> Generate an assembly file (.s)\n--output-incremental={yes|no*} Generate an incremental output file (rather than complete)\n--trace-compile={stderr|name} Print precompile statements for methods compiled during execution or save to stderr or a path. Methods that were recompiled are printed in yellow or with a trailing comment if color is not supported\n--trace-compile-timing If --trace-compile is enabled show how long each took to compile in ms\n--trace-dispatch={stderr|name} Print precompile statements for methods dispatched during execution or save to stderr or a path.\n--trace-eval[={no*|loc|full}] Show top-level expressions being evaluated. loc shows location info only, full shows full expressions (omitting setting is equivalent to loc). Only shows the outermost expression being evaluated, not internal function calls. See also Base.TRACE_EVAL.\n--image-codegen Force generate code in imaging mode\n--permalloc-pkgimg={yes|no*} Copy the data section of package images into memory\n--trim={no*|safe|unsafe|unsafe-warn} Build a sysimage including only code provably reachable from methods marked by calling entrypoint. The three non-default options differ in how they handle dynamic call sites. In safe mode, such sites result in compile-time errors. In unsafe mode, such sites are allowed but the resulting binary might be missing needed code and can throw runtime errors. With unsafe-warn, such sites will trigger warnings at compile-time and might error at runtime.\n\nOptions that have the form --option={...} can be specified either as --option=value or as --option value. For example, julia --banner=no is equivalent to julia --banner no. This is especially relevant for options that take a filename for output, because forgetting to specifying the argument for (say) --trace-compile will cause the option following it to be interpreted as the filename, possibly unintentionally overwriting it.\n\nNote that options of the form --option[=...] can not be specified as --option value, but only as --option=value (or simply --option, when no argument is provided).\n\ncompat: Julia 1.1\nIn Julia 1.0, the default --project=@. option did not search up from the root\ndirectory of a Git repository for the Project.toml file. From Julia 1.1 forward, it\ndoes."},{"title":"Tar","page":"Tar","location":"stdlib/Tar.html","category":"section","text":"The Tar module provides a simple interface for handling tar archives, including creation of\narchives, extraction of selected files from an archive, and access to metadata."},{"title":"Tar","page":"Tar","location":"stdlib/Tar.html#Tar","category":"section","text":""},{"title":"Tar.create","page":"Tar","location":"stdlib/Tar.html#Tar.create","category":"function","text":"create(\n    [ predicate, ] dir, [ tarball ];\n    [ skeleton, ] [ portable = false ]\n) -> tarball\n\n    predicate :: String --> Bool\n    dir       :: AbstractString\n    tarball   :: Union{AbstractString, AbstractCmd, IO}\n    skeleton  :: Union{AbstractString, AbstractCmd, IO}\n    portable  :: Bool\n\nCreate a tar archive (\"tarball\") of the directory dir. The resulting archive\nis written to the path tarball or if no path is specified, a temporary path is\ncreated and returned by the function call. If tarball is an IO object then the\ntarball content is written to that handle instead (the handle is left open).\n\nIf a predicate function is passed, it is called on each system path that is\nencountered while recursively searching dir and path is only included in the\ntarball if predicate(path) is true. If predicate(path) returns false for a\ndirectory, then the directory is excluded entirely: nothing under that directory\nwill be included in the archive.\n\nIf the skeleton keyword is passed then the file or IO handle given is used as\na \"skeleton\" to generate the tarball. You create a skeleton file by passing the\nskeleton keyword to the extract command. If create is called with that\nskeleton file and the extracted files haven't changed, an identical tarball is\nrecreated. The skeleton and predicate arguments cannot be used together.\n\nIf the portable flag is true then path names are checked for validity on\nWindows, which ensures that they don't contain illegal characters or have names\nthat are reserved. See https://stackoverflow.com/a/31976060/659248 for details.\n\n\n\n\n\n"},{"title":"Tar.extract","page":"Tar","location":"stdlib/Tar.html#Tar.extract","category":"function","text":"extract(\n    [ predicate, ] tarball, [ dir ];\n    [ skeleton = <none>, ]\n    [ copy_symlinks = <auto>, ]\n    [ set_permissions = true, ]\n) -> dir\n\n    predicate       :: Header --> Bool\n    tarball         :: Union{AbstractString, AbstractCmd, IO}\n    dir             :: AbstractString\n    skeleton        :: Union{AbstractString, AbstractCmd, IO}\n    copy_symlinks   :: Bool\n    set_permissions :: Bool\n\nExtract a tar archive (\"tarball\") located at the path tarball into the\ndirectory dir. If tarball is an IO object instead of a path, then the\narchive contents will be read from that IO stream. The archive is extracted to\ndir which must either be an existing empty directory or a non-existent path\nwhich can be created as a new directory. If dir is not specified, the archive\nis extracted into a temporary directory which is returned by extract.\n\nIf a predicate function is passed, it is called on each Header object that\nis encountered while extracting tarball and the entry is only extracted if the\npredicate(hdr) is true. This can be used to selectively extract only parts of\nan archive, to skip entries that cause extract to throw an error, or to record\nwhat is extracted during the extraction process.\n\nBefore it is passed to the predicate function, the Header object is somewhat\nmodified from the raw header in the tarball: the path field is normalized to\nremove . entries and replace multiple consecutive slashes with a single slash.\nIf the entry has type :hardlink, the link target path is normalized the same\nway so that it will match the path of the target entry; the size field is set to\nthe size of the target path (which must be an already-seen file).\n\nIf the skeleton keyword is passed then a \"skeleton\" of the extracted tarball\nis written to the file or IO handle given. This skeleton file can be used to\nrecreate an identical tarball by passing the skeleton keyword to the create\nfunction. The skeleton and predicate arguments cannot be used together.\n\nIf copy_symlinks is true then instead of extracting symbolic links as such,\nthey will be extracted as copies of what they link to if they are internal to\nthe tarball and if it is possible to do so. Non-internal symlinks, such as a\nlink to /etc/passwd will not be copied. Symlinks which are in any way cyclic\nwill also not be copied and will instead be skipped. By default, extract will\ndetect whether symlinks can be created in dir or not and will automatically\ncopy symlinks if they cannot be created.\n\nIf set_permissions is false, no permissions are set on the extracted files.\n\n\n\n\n\n"},{"title":"Tar.list","page":"Tar","location":"stdlib/Tar.html#Tar.list","category":"function","text":"list(tarball; [ strict = true ]) -> Vector{Header}\nlist(callback, tarball; [ strict = true ])\n\n    callback  :: Header, [ <data> ] --> Any\n    tarball   :: Union{AbstractString, AbstractCmd, IO}\n    strict    :: Bool\n\nList the contents of a tar archive (\"tarball\") located at the path tarball. If\ntarball is an IO handle, read the tar contents from that stream. Returns a\nvector of Header structs. See Header for details.\n\nIf a callback is provided then instead of returning a vector of headers, the\ncallback is called on each Header. This can be useful if the number of items\nin the tarball is large or if you want examine items prior to an error in the\ntarball. If the callback function can accept a second argument of either type\nVector{UInt8} or Vector{Pair{Symbol, String}} then it will be called with a\nrepresentation of the raw header data either as a single byte vector or as a\nvector of pairs mapping field names to the raw data for that field (if these\nfields are concatenated together, the result is the raw data of the header).\n\nBy default list will error if it encounters any tarball contents which the\nextract function would refuse to extract. With strict=false it will skip\nthese checks and list all the the contents of the tar file whether extract\nwould extract them or not. Beware that malicious tarballs can do all sorts of\ncrafty and unexpected things to try to trick you into doing something bad.\n\nIf the tarball argument is a skeleton file (see extract and create) then\nlist will detect that from the file header and appropriately list or iterate\nthe headers of the skeleton file.\n\n\n\n\n\n"},{"title":"Tar.rewrite","page":"Tar","location":"stdlib/Tar.html#Tar.rewrite","category":"function","text":"rewrite(\n    [ predicate, ] old_tarball, [ new_tarball ];\n    [ portable = false, ]\n) -> new_tarball\n\n    predicate   :: Header --> Bool\n    old_tarball :: Union{AbstractString, AbstractCmd, IO}\n    new_tarball :: Union{AbstractString, AbstractCmd, IO}\n    portable    :: Bool\n\nRewrite old_tarball to the standard format that create generates, while also\nchecking that it doesn't contain anything that would cause extract to raise an\nerror. This is functionally equivalent to doing\n\nTar.create(Tar.extract(predicate, old_tarball), new_tarball)\n\nHowever, it never extracts anything to disk and instead uses the seek function\nto navigate the old tarball's data. If no new_tarball argument is passed, the\nnew tarball is written to a temporary file whose path is returned.\n\nIf a predicate function is passed, it is called on each Header object that\nis encountered while extracting old_tarball and the entry is skipped unless\npredicate(hdr) is true. This can be used to selectively rewrite only parts of\nan archive, to skip entries that would cause extract to throw an error, or to\nrecord what content is encountered during the rewrite process.\n\nBefore it is passed to the predicate function, the Header object is somewhat\nmodified from the raw header in the tarball: the path field is normalized to\nremove . entries and replace multiple consecutive slashes with a single slash.\nIf the entry has type :hardlink, the link target path is normalized the same\nway so that it will match the path of the target entry; the size field is set to\nthe size of the target path (which must be an already-seen file).\n\nIf the portable flag is true then path names are checked for validity on\nWindows, which ensures that they don't contain illegal characters or have names\nthat are reserved. See https://stackoverflow.com/a/31976060/659248 for details.\n\n\n\n\n\n"},{"title":"Tar.tree_hash","page":"Tar","location":"stdlib/Tar.html#Tar.tree_hash","category":"function","text":"tree_hash([ predicate, ] tarball;\n          [ algorithm = \"git-sha1\", ]\n          [ skip_empty = false ]) -> hash::String\n\n    predicate  :: Header --> Bool\n    tarball    :: Union{AbstractString, AbstractCmd, IO}\n    algorithm  :: AbstractString\n    skip_empty :: Bool\n\nCompute a tree hash value for the file tree that the tarball contains. By\ndefault, this uses git's tree hashing algorithm with the SHA1 secure hash\nfunction (like current versions of git). This means that for any tarball whose\nfile tree git can represent—i.e. one with only files, symlinks and non-empty\ndirectories—the hash value computed by this function will be the same as the\nhash value git would compute for that file tree. Note that tarballs can\nrepresent file trees with empty directories, which git cannot store, and this\nfunction can generate hashes for those, which will, by default (see skip_empty\nbelow for how to change this behavior), differ from the hash of a tarball which\nomits those empty directories. In short, the hash function agrees with git on\nall trees which git can represent, but extends (in a consistent way) the domain\nof hashable trees to other trees which git cannot represent.\n\nIf a predicate function is passed, it is called on each Header object that\nis encountered while processing tarball and an entry is only hashed if\npredicate(hdr) is true. This can be used to selectively hash only parts of an\narchive, to skip entries that cause extract to throw an error, or to record\nwhat is extracted during the hashing process.\n\nBefore it is passed to the predicate function, the Header object is somewhat\nmodified from the raw header in the tarball: the path field is normalized to\nremove . entries and replace multiple consecutive slashes with a single slash.\nIf the entry has type :hardlink, the link target path is normalized the same\nway so that it will match the path of the target entry; the size field is set to\nthe size of the target path (which must be an already-seen file).\n\nCurrently supported values for algorithm are git-sha1 (the default) and\ngit-sha256, which uses the same basic algorithm as git-sha1 but replaces the\nSHA1 hash function with SHA2-256, the hash function that git will transition to\nusing in the future (due to known attacks on SHA1). Support for other file tree\nhashing algorithms may be added in the future.\n\nThe skip_empty option controls whether directories in the tarball which\nrecursively contain no files or symlinks are included in the hash or ignored.\nIn general, if you are hashing the content of a tarball or a file tree, you care\nabout all directories, not just non-empty ones, so including these in the\ncomputed hash is the default. So why does this function even provide the option\nto skip empty directories? Because git refuses to store empty directories and\nwill ignore them if you try to add them to a repo. So if you compute a reference\ntree hash by by adding files to a git repo and then asking git for the tree\nhash, the hash value that you get will match the hash value computed by\ntree_hash with skip_empty=true. In other words, this option allows\ntree_hash to emulate how git would hash a tree with empty directories. If you\nare hashing trees that may contain empty directories (i.e. do not come from a\ngit repo), however, it is recommended that you hash them using a tool (such as\nthis one) that does not ignore empty directories.\n\n\n\n\n\n"},{"title":"Tar.Header","page":"Tar","location":"stdlib/Tar.html#Tar.Header","category":"type","text":"The Header type is a struct representing the essential metadata for a single\nrecord in a tar file with this definition:\n\nstruct Header\n    path :: String # path relative to the root\n    type :: Symbol # type indicator (see below)\n    mode :: UInt16 # mode/permissions (best viewed in octal)\n    size :: Int64  # size of record data in bytes\n    link :: String # target path of a symlink\nend\n\nTypes are represented with the following symbols: file, hardlink, symlink,\nchardev, blockdev, directory, fifo, or for unknown types, the typeflag\ncharacter as a symbol. Note that extract refuses to extract records\ntypes other than file, symlink and directory; list will only\nlist other kinds of records if called with strict=false.\n\nThe tar format includes various other metadata about records, including user and\ngroup IDs, user and group names, and timestamps. The Tar package, by design,\ncompletely ignores these. When creating tar files, these fields are always set\nto zero/empty. When reading tar files, these fields are ignored aside from\nverifying header checksums for each header record for all fields.\n\n\n\n\n\n"},{"title":"History of changes to the compiler","page":"History of changes to the compiler","location":"devdocs/compiler_changes.html#History-of-changes-to-the-compiler","category":"section","text":"The Julia compiler is not part of the public interface of Julia's Core, and may change in non-breaking Julia releases. This page lists breaking changes introduced to the compiler to aid in adapting to those changes, intended for packages that do interface with the compiler. It is maintained on a best-effort basis and may be incomplete."},{"title":"v1.12","page":"History of changes to the compiler","location":"devdocs/compiler_changes.html#v1.12","category":"section","text":""},{"title":"Changes to the IRCode type","page":"History of changes to the compiler","location":"devdocs/compiler_changes.html#Changes-to-the-IRCode-type","category":"section","text":"The linetable field of IRCode has been removed, and the source line information is now available in a different format in the debuginfo field. (#52415)\n\nRelated to the above, the verify_linetable function changed its signature from verify_linetable(::Vector{Core.LineInfoNode}) to verify_linetable(::DebugInfoStream, nstmts::Int64), the second argument being the number of statements.\n\nIRCode now has a valid_worlds field, to explicitly communicate which worlds are\nto be considered for type inference and optimization purposes. As 1.12 introduced world-age\npartitioned bindings, this information is key to properly infer through global bindings.\nAn upper bound that is not constrained enough may lead to a failure to accurately infer and optimize these."},{"title":"InstructionStream constructors have gotten stricter","page":"History of changes to the compiler","location":"devdocs/compiler_changes.html#InstructionStream-constructors-have-gotten-stricter","category":"section","text":"The constructor for InstructionStream now requires the arguments to be of exactly the correct types. The fields haven't changed, but for instance you need to cast the second argument called type to be a Vector{Any} instead of being able to pass in something like a Vector{Type} and relying on an automatic cast."},{"title":"CodeInstances replacing certain uses of MethodInstances","page":"History of changes to the compiler","location":"devdocs/compiler_changes.html#CodeInstances-replacing-certain-uses-of-MethodInstances","category":"section","text":"CodeInstance has gradually replaced MethodInstance in more and more places, over several\nextensive PRs. CodeInstance holds the cached results of inference, and usually end up stored in\nthe .cache field of their parent MethodInstances (with the .next field of CodeInstance\nallowing a linked list to be formed by holding further CodeInstances).\n\nOne notable change is that the first argument to invoke expressions is now a CodeInstance\ninstead of a MethodInstance.\n\nThe parent MethodInstance of a CodeInstance may be accessed with Compiler.get_ci_mi(code_instance)."},{"title":"SpecInfo replaces MethodInfo","page":"History of changes to the compiler","location":"devdocs/compiler_changes.html#SpecInfo-replaces-MethodInfo","category":"section","text":"MethodInfo was renamed to SpecInfo, and two fields nargs::Int and isva::Bool have been prepended to it, indicating how many arguments a specialization takes, and whether its signature is variadic (of the form f(x...)). (#55976)"},{"title":"Changes to OpaqueClosures","page":"History of changes to the compiler","location":"devdocs/compiler_changes.html#Changes-to-OpaqueClosures","category":"section","text":"OpaqueClosure now requires the first argument type of its source IRCode to be the type of\nits environment (passed through env...), such as Tuple{Int, Float64} or Tuple{} for no captures. (#54458)"},{"title":"Unicode","page":"Unicode","location":"stdlib/Unicode.html#Unicode","category":"section","text":"The Unicode module provides essential functionality for managing Unicode characters and strings.\nIt includes validation, category determination, normalization, case transformation, and grapheme segmentation, enabling effective Unicode data handling."},{"title":"Unicode","page":"Unicode","location":"stdlib/Unicode.html#Unicode","category":"module","text":"The Unicode module provides essential functionality for managing Unicode characters and strings.\nIt includes validation, category determination, normalization, case transformation, and grapheme segmentation,\nenabling effective Unicode data handling.\n\n\n\n\n\n"},{"title":"Unicode.julia_chartransform","page":"Unicode","location":"stdlib/Unicode.html#Unicode.julia_chartransform","category":"function","text":"Unicode.julia_chartransform(c::Union{Char,Integer})\n\nMap the Unicode character (Char) or codepoint (Integer) c to the corresponding\n\"equivalent\" character or codepoint, respectively, according to the custom equivalence\nused within the Julia parser (in addition to NFC normalization).\n\nFor example, 'µ' (U+00B5 micro) is treated as equivalent to 'μ' (U+03BC mu) by\nJulia's parser, so julia_chartransform performs this transformation while leaving\nother characters unchanged:\n\njulia> Unicode.julia_chartransform('µ')\n'μ': Unicode U+03BC (category Ll: Letter, lowercase)\n\njulia> Unicode.julia_chartransform('x')\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\njulia_chartransform is mainly useful for passing to the Unicode.normalize\nfunction in order to mimic the normalization used by the Julia parser:\n\njulia> s = \"µö\"\n\"µö\"\n\njulia> s2 = Unicode.normalize(s, compose=true, stable=true, chartransform=Unicode.julia_chartransform)\n\"μö\"\n\njulia> collect(s2)\n2-element Vector{Char}:\n 'μ': Unicode U+03BC (category Ll: Letter, lowercase)\n 'ö': Unicode U+00F6 (category Ll: Letter, lowercase)\n\njulia> s2 == string(Meta.parse(s))\ntrue\n\ncompat: Julia 1.8\nThis function was introduced in Julia 1.8.\n\n\n\n\n\n"},{"title":"Unicode.isassigned","page":"Unicode","location":"stdlib/Unicode.html#Unicode.isassigned","category":"function","text":"Unicode.isassigned(c)::Bool\n\nReturn true if the given char or integer is an assigned Unicode code point.\n\nExamples\n\njulia> Unicode.isassigned(101)\ntrue\n\njulia> Unicode.isassigned('\\x01')\ntrue\n\n\n\n\n\n"},{"title":"Unicode.isequal_normalized","page":"Unicode","location":"stdlib/Unicode.html#Unicode.isequal_normalized","category":"function","text":"isequal_normalized(s1::AbstractString, s2::AbstractString; casefold=false, stripmark=false, chartransform=identity)\n\nReturn whether s1 and s2 are canonically equivalent Unicode strings.   If casefold=true,\nignores case (performs Unicode case-folding); if stripmark=true, strips diacritical marks\nand other combining characters.\n\nAs with Unicode.normalize, you can also pass an arbitrary\nfunction via the chartransform keyword (mapping Integer codepoints to codepoints)\nto perform custom normalizations, such as Unicode.julia_chartransform.\n\ncompat: Julia 1.8\nThe isequal_normalized function was added in Julia 1.8.\n\nExamples\n\nFor example, the string \"noël\" can be constructed in two canonically equivalent ways\nin Unicode, depending on whether \"ë\" is formed from a single codepoint U+00EB or\nfrom the ASCII character 'e' followed by the U+0308 combining-diaeresis character.\n\njulia> s1 = \"noël\"\n\"noël\"\n\njulia> s2 = \"noël\"\n\"noël\"\n\njulia> s1 == s2\nfalse\n\njulia> isequal_normalized(s1, s2)\ntrue\n\njulia> isequal_normalized(s1, \"noel\", stripmark=true)\ntrue\n\njulia> isequal_normalized(s1, \"NOËL\", casefold=true)\ntrue\n\n\n\n\n\n"},{"title":"Unicode.normalize","page":"Unicode","location":"stdlib/Unicode.html#Unicode.normalize","category":"function","text":"Unicode.normalize(s::AbstractString; keywords...)\nUnicode.normalize(s::AbstractString, normalform::Symbol)\n\nNormalize the string s. By default, canonical composition (compose=true) is performed without ensuring\nUnicode versioning stability (compat=false), which produces the shortest possible equivalent string\nbut may introduce composition characters not present in earlier Unicode versions.\n\nAlternatively, one of the four \"normal forms\" of the Unicode standard can be specified:\nnormalform can be :NFC, :NFD, :NFKC, or :NFKD.  Normal forms C\n(canonical composition) and D (canonical decomposition) convert different visually identical\nrepresentations of the same abstract string into a single canonical form, with form C being\nmore compact.  Normal forms KC and KD additionally canonicalize \"compatibility equivalents\":\nthey convert characters that are abstractly similar but visually distinct into a single\ncanonical choice (e.g. they expand ligatures into the individual characters), with form KC\nbeing more compact.\n\nAlternatively, finer control and additional transformations may be obtained by calling\nUnicode.normalize(s; keywords...), where any number of the following boolean keywords\noptions (which all default to false except for compose) are specified:\n\ncompose=false: do not perform canonical composition\ndecompose=true: do canonical decomposition instead of canonical composition\n(compose=true is ignored if present)\ncompat=true: compatibility equivalents are canonicalized\ncasefold=true: perform Unicode case folding, e.g. for case-insensitive string comparison\nnewline2lf=true, newline2ls=true, or newline2ps=true: convert various newline\nsequences (LF, CRLF, CR, NEL) into a linefeed (LF), line-separation (LS), or\nparagraph-separation (PS) character, respectively\nstripmark=true: strip diacritical marks (e.g. accents)\nstripignore=true: strip Unicode's \"default ignorable\" characters (e.g. the soft hyphen\nor the left-to-right marker)\nstripcc=true: strip control characters; horizontal tabs and form feeds are converted to\nspaces; newlines are also converted to spaces unless a newline-conversion flag was\nspecified\nrejectna=true: throw an error if unassigned code points are found\nstable=true: enforce Unicode versioning stability (never introduce characters missing from earlier Unicode versions)\n\nYou can also use the chartransform keyword (which defaults to identity) to pass an arbitrary\nfunction mapping Integer codepoints to codepoints, which is called on each\ncharacter in s as it is processed, in order to perform arbitrary additional normalizations.\nFor example, by passing chartransform=Unicode.julia_chartransform, you can apply a few Julia-specific\ncharacter normalizations that are performed by Julia when parsing identifiers (in addition to\nNFC normalization: compose=true, stable=true).\n\nFor example, NFKC corresponds to the options compose=true, compat=true, stable=true.\n\nExamples\n\njulia> \"é\" == Unicode.normalize(\"é\") #LHS: Unicode U+00e9, RHS: U+0065 & U+0301\ntrue\n\njulia> \"μ\" == Unicode.normalize(\"µ\", compat=true) #LHS: Unicode U+03bc, RHS: Unicode U+00b5\ntrue\n\njulia> Unicode.normalize(\"JuLiA\", casefold=true)\n\"julia\"\n\njulia> Unicode.normalize(\"JúLiA\", stripmark=true)\n\"JuLiA\"\n\ncompat: Julia 1.8\nThe chartransform keyword argument requires Julia 1.8.\n\n\n\n\n\n"},{"title":"Unicode.graphemes","page":"Unicode","location":"stdlib/Unicode.html#Unicode.graphemes","category":"function","text":"graphemes(s::AbstractString)::GraphemeIterator\n\nReturn an iterator over substrings of s that correspond to the extended graphemes in the\nstring, as defined by Unicode UAX #29. (Roughly, these are what users would perceive as\nsingle characters, even though they may contain more than one codepoint; for example a\nletter combined with an accent mark is a single grapheme.)\n\n\n\n\n\ngraphemes(s::AbstractString, m:n)::SubString\n\nReturns a SubString of s consisting of the m-th\nthrough n-th graphemes of the string s, where the second\nargument m:n is an integer-valued AbstractUnitRange.\n\nLoosely speaking, this corresponds to the m:n-th user-perceived\n\"characters\" in the string.  For example:\n\njulia> s = graphemes(\"exposé\", 3:6)\n\"posé\"\n\njulia> collect(s)\n5-element Vector{Char}:\n 'p': ASCII/Unicode U+0070 (category Ll: Letter, lowercase)\n 'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)\n 's': ASCII/Unicode U+0073 (category Ll: Letter, lowercase)\n 'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n '́': Unicode U+0301 (category Mn: Mark, nonspacing)\n\nThis consists of the 3rd to 7th codepoints (Chars) in \"exposé\",\nbecause the grapheme \"é\" is actually two Unicode codepoints\n(an 'e' followed by an acute-accent combining character U+0301).\n\nBecause finding grapheme boundaries requires iteration over the\nstring contents, the graphemes(s, m:n) function requires time\nproportional to the length of the string (number of codepoints)\nbefore the end of the substring.\n\ncompat: Julia 1.9\nThe m:n argument of graphemes requires Julia 1.9.\n\n\n\n\n\n"},{"title":"Eval of Julia code","page":"Eval of Julia code","location":"devdocs/eval.html#Eval-of-Julia-code","category":"section","text":"One of the hardest parts about learning how the Julia Language runs code is learning how all of\nthe pieces work together to execute a block of code.\n\nEach chunk of code typically makes a trip through many steps with potentially unfamiliar names,\nsuch as (in no particular order): flisp, AST, C++, LLVM, eval, typeinf, macroexpand, sysimg\n(or system image), bootstrapping, compile, parse, execute, JIT, interpret, box, unbox, intrinsic\nfunction, and primitive function, before turning into the desired result (hopefully).\n\nsidebar: Definitions\nREPL\nREPL stands for Read-Eval-Print Loop. It's just what we call the command line environment for\nshort.\nAST\nAbstract Syntax Tree. The AST is the digital representation of the code structure. In this form\nthe code has been tokenized for meaning so that it is more suitable for manipulation and execution.\n\n(Image: Diagram of the compiler flow)"},{"title":"Julia Execution","page":"Eval of Julia code","location":"devdocs/eval.html#Julia-Execution","category":"section","text":"The 10,000 foot view of the whole process is as follows:\n\nThe user starts julia.\nThe C function main() from cli/loader_exe.c gets called. This function processes the command line\narguments, filling in the jl_options struct and setting the variable ARGS. It then initializes\nJulia (by calling julia_init in init.c,\nwhich may load a previously compiled sysimg). Finally, it passes off control to Julia\nby calling Base._start().\nWhen _start() takes over control, the subsequent sequence of commands depends on the command\nline arguments given. For example, if a filename was supplied, it will proceed to execute that\nfile. Otherwise, it will start an interactive REPL.\nSkipping the details about how the REPL interacts with the user, let's just say the program ends\nup with a block of code that it wants to run.\nIf the block of code to run is in a file, jl_load(char *filename)\ngets invoked to load the file and parse it. Each fragment of code is then passed to eval\nto execute.\nEach fragment of code (or AST), is handed off to eval() to turn into results.\neval() takes each code fragment and tries to run it in jl_toplevel_eval_flex().\njl_toplevel_eval_flex() decides whether the code is a \"toplevel\" action (such as using or\nmodule), which would be invalid inside a function. If so, it passes off the code to the toplevel\ninterpreter.\njl_toplevel_eval_flex() then expands the code to eliminate any macros and to \"lower\"\nthe AST to make it simpler to execute.\njl_toplevel_eval_flex() then uses some simple heuristics to decide whether to JIT compile the\n AST or to interpret it directly.\nThe bulk of the work to interpret code is handled by eval in interpreter.c.\nIf instead, the code is compiled, the bulk of the work is handled by codegen.cpp. Whenever a\n Julia function is called for the first time with a given set of argument types, type inference\n will be run on that function. This information is used by the codegen step to generate\n faster code.\nEventually, the user quits the REPL, or the end of the program is reached, and the _start()\n method returns.\nJust before exiting, main() calls jl_atexit_hook(exit_code).\n This calls Base._atexit() (which calls any functions registered to atexit() inside\n Julia). Then it calls jl_gc_run_all_finalizers().\n Finally, it gracefully cleans up all libuv handles and waits for them to flush and close."},{"title":"Parsing","page":"Eval of Julia code","location":"devdocs/eval.html#dev-parsing","category":"section","text":"By default, Julia uses JuliaSyntax.jl to produce the\nAST. Historically, it used a small lisp program written in femtolisp, the source-code for which is\ndistributed inside Julia in src/flisp.\nIf the JULIA_USE_FLISP_PARSER environment variable is set to 1, the old parser will be used\ninstead."},{"title":"Macro Expansion","page":"Eval of Julia code","location":"devdocs/eval.html#dev-macro-expansion","category":"section","text":"When eval() encounters a macro, it expands that AST node before attempting to evaluate\nthe expression. Macro expansion involves a handoff from eval() (in Julia), to the parser\nfunction jl_macroexpand() (written in flisp) to the Julia macro itself (written in - what\nelse - Julia) via fl_invoke_julia_macro(), and back.\n\nTypically, macro expansion is invoked as a first step during a call to Meta.lower()/Core._lower(),\nalthough it can also be invoked directly by a call to macroexpand()/jl_macroexpand()."},{"title":"Type Inference","page":"Eval of Julia code","location":"devdocs/eval.html#dev-type-inference","category":"section","text":"Type inference is implemented in Julia by typeinf() in compiler/typeinfer.jl.\nType inference is the process of examining a Julia function and determining bounds for the types\nof each of its variables, as well as bounds on the type of the return value from the function.\nThis enables many future optimizations, such as unboxing of known immutable values, and compile-time\nhoisting of various run-time operations such as computing field offsets and function pointers.\nType inference may also include other steps such as constant propagation and inlining.\n\nsidebar: More Definitions\nJIT\nJust-In-Time Compilation The process of generating native-machine code into memory right when\nit is needed.\nLLVM\nLow-Level Virtual Machine (a compiler) The Julia JIT compiler is a program/library called libLLVM.\nCodegen in Julia refers both to the process of taking a Julia AST and turning it into LLVM instructions,\nand the process of LLVM optimizing that and turning it into native assembly instructions.\nC++\nThe programming language that LLVM is implemented in, which means that codegen is also implemented\nin this language. The rest of Julia's library is implemented in C, in part because its smaller\nfeature set makes it more usable as a cross-language interface layer.\nbox\nThis term is used to describe the process of taking a value and allocating a wrapper around the\ndata that is tracked by the garbage collector (gc) and is tagged with the object's type.\nunbox\nThe reverse of boxing a value. This operation enables more efficient manipulation of data when\nthe type of that data is fully known at compile-time (through type inference).\ngeneric function\nA Julia function composed of multiple \"methods\" that are selected for dynamic dispatch based on\nthe argument type-signature\nanonymous function or \"method\"\nA Julia function without a name and without type-dispatch capabilities\nprimitive function\nA function implemented in C but exposed in Julia as a named function \"method\" (albeit without\ngeneric function dispatch capabilities, similar to a anonymous function)\nintrinsic function\nA low-level operation exposed as a function in Julia. These pseudo-functions implement operations\non raw bits such as add and sign extend that cannot be expressed directly in any other way. Since\nthey operate on bits directly, they must be compiled into a function and surrounded by a call\nto Core.Intrinsics.box(T, ...) to reassign type information to the value."},{"title":"JIT Code Generation","page":"Eval of Julia code","location":"devdocs/eval.html#dev-codegen","category":"section","text":"Codegen is the process of turning a Julia AST into native machine code.\n\nThe JIT environment is initialized by an early call to jl_init_codegen in codegen.cpp.\n\nOn demand, a Julia method is converted into a native function by the function emit_function(jl_method_instance_t*).\n(note, when using the MCJIT (in LLVM v3.4+), each function must be JIT into a new module.) This\nfunction recursively calls emit_expr() until the entire function has been emitted.\n\nMuch of the remaining bulk of this file is devoted to various manual optimizations of specific\ncode patterns. For example, emit_known_call() knows how to inline many of the primitive functions\n(defined in builtins.c) for various\ncombinations of argument types.\n\nOther parts of codegen are handled by various helper files:\n\ndebuginfo.cpp\nHandles backtraces for JIT functions\nccall.cpp\nHandles the ccall and llvmcall FFI, along with various abi_*.cpp files\nintrinsics.cpp\nHandles the emission of various low-level intrinsic functions\n\nsidebar: Bootstrapping\nThe process of creating a new system image is called \"bootstrapping\".The etymology of this word comes from the phrase \"pulling oneself up by the bootstraps\", and\nrefers to the idea of starting from a very limited set of available functions and definitions\nand ending with the creation of a full-featured environment."},{"title":"System Image","page":"Eval of Julia code","location":"devdocs/eval.html#dev-sysimg","category":"section","text":"The system image is a precompiled archive of a set of Julia files. The sys.ji file distributed\nwith Julia is one such system image, generated by executing the file sysimg.jl,\nand serializing the resulting environment (including Types, Functions, Modules, and all other\ndefined values) into a file. Therefore, it contains a frozen version of the Main, Core, and\nBase modules (and whatever else was in the environment at the end of bootstrapping). This serializer/deserializer\nis implemented by jl_save_system_image/jl_restore_system_image in staticdata.c.\n\nIf there is no sysimg file (jl_options.image_file == NULL), this also implies that --build\nwas given on the command line, so the final result should be a new sysimg file. During Julia initialization,\nminimal Core and Main modules are created. Then a file named boot.jl is evaluated from the\ncurrent directory. Julia then evaluates any file given as a command line argument until it reaches\nthe end. Finally, it saves the resulting environment to a \"sysimg\" file for use as a starting\npoint for a future Julia run."},{"title":"Writing jldoctests","page":"Writing jldoctests","location":"devdocs/contributing/jldoctests.html#writing-jldoctests","category":"section","text":"This page describes how to write and maintain jldoctest blocks in the documentation. Following these guidelines helps keep doctests reliable and easy to read."},{"title":"Filters","page":"Writing jldoctests","location":"devdocs/contributing/jldoctests.html#Filters","category":"section","text":"Use filter = whenever output contains text that might vary across runs.\nThe following are common situations where this may happen:\n\nThe output contains arrays with undefined memory (e.g. from undef or similar)\nThe output contains random numbers\nThe output contains timing information\nThe output contains file system paths"},{"title":"Common filter sequences","page":"Writing jldoctests","location":"devdocs/contributing/jldoctests.html#Common-filter-sequences","category":"section","text":"The documentation relies on several recurring patterns:\n\nr\"int.jl:\\\\d+\" — remove line numbers from introspection macros.\nr\"Stacktrace:(\\\\n \\\\[0-9]+\\\\].*)*\" — hide stack traces when illustrating\nerrors.\nr\"Closest candidates.*\\\\n  .*\" — skip the method suggestions printed by\nMethodError.\nr\"@ .*\" — strip file locations from the output of methods or\n@which.\nr\"\\\\@world\\\\(MyStruct, \\\\d+:\\\\d+\\\\)\" — filter world age numbers.\nr\"with \\\\d+ methods\" — ignore method counts when redefining functions.\nr\"[0-9\\\\.]+ seconds \\\\(.*?\\\\)\" — remove timing output with memory\ninformation.\nr\"[0-9\\\\.]+ seconds\" — remove simple timing results.\nr\"[0-9\\\\.]+\" — filter digits from names such as anonymous functions.\nr\"([A-B] [0-5])\" and r\"[A-B] [X-Z] [0-5]\" — account for non-deterministic\nprocess output.\nr\"(world\\\\nhello|hello\\\\nworld)\" — allow either ordering of interleaved\noutput.\n\nIf none of these match your situation, craft a regular expression that\nremoves the varying text. Using filters keeps doctests stable across\nplatforms and Julia versions.\n\nnote: Double escaping in docstrings\nWhen writing regex filters inside docstrings, remember to double escape\nbackslashes. For example, use r\"[\\\\d\\\\.]+\" instead of r\"[\\d\\.]+\".\nThis is necessary because the docstring itself processes escape sequences\nbefore the regex is created."},{"title":"Setup code","page":"Writing jldoctests","location":"devdocs/contributing/jldoctests.html#Setup-code","category":"section","text":"Small setup expressions may be placed inline using the setup = option:\n\n```jldoctest; setup = :(using InteractiveUtils)\n...\n```\n\nFor longer setup code or if multiple blocks require the same environment, use the\nDocTestSetup meta block:\n\n```@meta\nDocTestSetup = :(import Random; Random.seed!(1234))\n```\n\nand disable it afterwards with\n\n```@meta\nDocTestSetup = nothing\n```"},{"title":"Teardown code","page":"Writing jldoctests","location":"devdocs/contributing/jldoctests.html#Teardown-code","category":"section","text":"If you need teardown code (e.g. to delete created temporary files or to reset\nthe current directory), you can use the teardown = option:\n\n```jldoctest; setup = :(oldpath = pwd(); cd(mktempdir())), teardown = :(cd(oldpath))\n...\n```"},{"title":"Maintaining state between snippets","page":"Writing jldoctests","location":"devdocs/contributing/jldoctests.html#Maintaining-state-between-snippets","category":"section","text":"Related doctest blocks can share state by giving them the same label after the\njldoctest keyword. The manual uses this pattern to demonstrate mutation:\n\n```jldoctest mutation_vs_rebind\njulia> a = [1,2,3]\n...\n```\n\nand later\n\n```jldoctest mutation_vs_rebind\njulia> a[1] = 42\n...\n```\n\nBlocks with the same name execute sequentially during doctesting, so variables\ncreated in the first block remain available in the following ones.\n\nWhen a snippet needs to preserve its result for later examples, give it a label\nand reuse that label. This avoids repeating setup code and mirrors a REPL\nsession more closely."},{"title":"Further reading","page":"Writing jldoctests","location":"devdocs/contributing/jldoctests.html#Further-reading","category":"section","text":"For a complete reference of doctest syntax, see the corresponding Documenter.jl docs."},{"title":"Sorting and Related Functions","page":"Sorting and Related Functions","location":"base/sort.html#Sorting-and-Related-Functions","category":"section","text":"Julia has an extensive, flexible API for sorting and interacting with already-sorted arrays\nof values. By default, Julia picks reasonable algorithms and sorts in ascending order:\n\njulia> sort([2,3,1])\n3-element Vector{Int64}:\n 1\n 2\n 3\n\nYou can sort in reverse order as well:\n\njulia> sort([2,3,1], rev=true)\n3-element Vector{Int64}:\n 3\n 2\n 1\n\nsort constructs a sorted copy leaving its input unchanged. Use the \"bang\" version of\nthe sort function to mutate an existing array:\n\njulia> a = [2,3,1];\n\njulia> sort!(a);\n\njulia> a\n3-element Vector{Int64}:\n 1\n 2\n 3\n\nInstead of directly sorting an array, you can compute a permutation of the array's\nindices that puts the array into sorted order:\n\njulia> v = [0.297288, 0.382396, -0.597634, -0.0104452, -0.839027]\n5-element Vector{Float64}:\n  0.297288\n  0.382396\n -0.597634\n -0.0104452\n -0.839027\n\njulia> p = sortperm(v)\n5-element Vector{Int64}:\n 5\n 3\n 4\n 1\n 2\n\njulia> v[p]\n5-element Vector{Float64}:\n -0.839027\n -0.597634\n -0.0104452\n  0.297288\n  0.382396\n\nArrays can be sorted according to an arbitrary transformation of their values:\n\njulia> sort(v, by=abs)\n5-element Vector{Float64}:\n -0.0104452\n  0.297288\n  0.382396\n -0.597634\n -0.839027\n\nOr in reverse order by a transformation:\n\njulia> sort(v, by=abs, rev=true)\n5-element Vector{Float64}:\n -0.839027\n -0.597634\n  0.382396\n  0.297288\n -0.0104452\n\nIf needed, the sorting algorithm can be chosen:\n\njulia> sort(v, alg=InsertionSort)\n5-element Vector{Float64}:\n -0.839027\n -0.597634\n -0.0104452\n  0.297288\n  0.382396\n\nAll the sorting and order related functions rely on a \"less than\" relation defining a\nstrict weak order\non the values to be manipulated. The isless function is invoked by default, but the\nrelation can be specified via the lt keyword, a function that takes two array elements\nand returns true if and only if the first argument is \"less than\" the second. See\nsort! and Alternate Orderings for more information."},{"title":"Sorting Functions","page":"Sorting and Related Functions","location":"base/sort.html#Sorting-Functions","category":"section","text":""},{"title":"Order-Related Functions","page":"Sorting and Related Functions","location":"base/sort.html#Order-Related-Functions","category":"section","text":""},{"title":"Sorting Algorithms","page":"Sorting and Related Functions","location":"base/sort.html#Sorting-Algorithms","category":"section","text":"There are currently four sorting algorithms publicly available in base Julia:\n\nInsertionSort\nQuickSort\nPartialQuickSort(k)\nMergeSort\n\nBy default, the sort family of functions uses stable sorting algorithms that are fast\non most inputs. The exact algorithm choice is an implementation detail to allow for\nfuture performance improvements. Currently, a hybrid of RadixSort, ScratchQuickSort,\nInsertionSort, and CountingSort is used based on input type, size, and composition.\nImplementation details are subject to change but currently available in the extended help\nof ??Base.DEFAULT_STABLE and the docstrings of internal sorting algorithms listed there.\n\nYou can explicitly specify your preferred algorithm with the alg keyword\n(e.g. sort!(v, alg=PartialQuickSort(10:20))) or reconfigure the default sorting algorithm\nfor custom types by adding a specialized method to the Base.Sort.defalg function.\nFor example, InlineStrings.jl\ndefines the following method:\n\nBase.Sort.defalg(::AbstractArray{<:Union{SmallInlineStrings, Missing}}) = InlineStringSort\n\ncompat: Julia 1.9\nThe default sorting algorithm (returned by Base.Sort.defalg) is guaranteed to\nbe stable since Julia 1.9. Previous versions had unstable edge cases when\nsorting numeric arrays."},{"title":"Alternate Orderings","page":"Sorting and Related Functions","location":"base/sort.html#Alternate-Orderings","category":"section","text":"By default, sort, searchsorted, and related functions use isless to compare\ntwo elements in order to determine which should come first. The\nBase.Order.Ordering abstract type provides a mechanism for defining alternate\norderings on the same set of elements: when calling a sorting function like\nsort!, an instance of Ordering can be provided with the keyword argument order.\n\nInstances of Ordering define an order through the Base.Order.lt\nfunction, which works as a generalization of isless.\nThis function's behavior on custom Orderings must satisfy all the conditions of a\nstrict weak order.\nSee sort! for details and examples of valid and invalid lt functions."},{"title":"Base.sort!","page":"Sorting and Related Functions","location":"base/sort.html#Base.sort!","category":"function","text":"sort!(A; dims::Integer, alg::Base.Sort.Algorithm=Base.Sort.defalg(A), lt=isless, by=identity, rev::Bool=false, order::Base.Order.Ordering=Base.Order.Forward)\n\nSort the multidimensional array A along dimension dims.\nSee the one-dimensional version of sort! for a description of\npossible keyword arguments.\n\nTo sort slices of an array, refer to sortslices.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\nExamples\n\njulia> A = [4 3; 1 2]\n2×2 Matrix{Int64}:\n 4  3\n 1  2\n\njulia> sort!(A, dims = 1); A\n2×2 Matrix{Int64}:\n 1  2\n 4  3\n\njulia> sort!(A, dims = 2); A\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\n\n\n\n\nsort!(v; alg::Base.Sort.Algorithm=Base.Sort.defalg(v), lt=isless, by=identity, rev::Bool=false, order::Base.Order.Ordering=Base.Order.Forward)\n\nMutate the vector v so that it is sorted.\n\nA stable algorithm is used by default: the ordering of elements that\ncompare equal is preserved. A specific algorithm can be selected via the\nalg keyword (see Sorting Algorithms for available algorithms).\n\nElements are first transformed with the function by and then compared\naccording to either the function lt or the ordering order. Finally, the\nresulting order is reversed if rev=true (this preserves forward stability:\nelements that compare equal are not reversed). The current implementation applies\nthe by transformation before each comparison rather than once per element.\n\nPassing an lt other than isless along with an order other than\nBase.Order.Forward or Base.Order.Reverse is not permitted,\notherwise all options are independent and can be used together in all possible\ncombinations. Note that order can also include a \"by\" transformation, in\nwhich case it is applied after that defined with the by keyword. For more\ninformation on order values see the documentation on [Alternate\nOrderings](@ref).\n\nRelations between two elements are defined as follows (with \"less\" and\n\"greater\" exchanged when rev=true):\n\nx is less than y if lt(by(x), by(y)) (or Base.Order.lt(order, by(x), by(y))) yields true.\nx is greater than y if y is less than x.\nx and y are equivalent if neither is less than the other (\"incomparable\"\nis sometimes used as a synonym for \"equivalent\").\n\nThe result of sort! is sorted in the sense that every element is greater than\nor equivalent to the previous one.\n\nThe lt function must define a strict weak order, that is, it must be\n\nirreflexive: lt(x, x) always yields false,\nasymmetric: if lt(x, y) yields true then lt(y, x) yields false,\ntransitive: lt(x, y) && lt(y, z) implies lt(x, z),\ntransitive in equivalence: !lt(x, y) && !lt(y, x) and !lt(y, z) && !lt(z, y) together imply !lt(x, z) && !lt(z, x). In words: if x and y are\nequivalent and y and z are equivalent then x and z must be\nequivalent.\n\nFor example < is a valid lt function for Int values but ≤ is not: it\nviolates irreflexivity. For Float64 values even < is invalid as it violates\nthe fourth condition: 1.0 and NaN are equivalent and so are NaN and 2.0\nbut 1.0 and 2.0 are not equivalent.\n\nSee also sort, sortperm, sortslices,\npartialsort!, partialsortperm, issorted,\nsearchsorted, insorted, Base.Order.ord.\n\nExamples\n\njulia> v = [3, 1, 2]; sort!(v); v\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> v = [3, 1, 2]; sort!(v, rev = true); v\n3-element Vector{Int64}:\n 3\n 2\n 1\n\njulia> v = [(1, \"c\"), (3, \"a\"), (2, \"b\")]; sort!(v, by = x -> x[1]); v\n3-element Vector{Tuple{Int64, String}}:\n (1, \"c\")\n (2, \"b\")\n (3, \"a\")\n\njulia> v = [(1, \"c\"), (3, \"a\"), (2, \"b\")]; sort!(v, by = x -> x[2]); v\n3-element Vector{Tuple{Int64, String}}:\n (3, \"a\")\n (2, \"b\")\n (1, \"c\")\n\njulia> sort(0:3, by=x->x-2, order=Base.Order.By(abs))\n4-element Vector{Int64}:\n 2\n 1\n 3\n 0\n\njulia> sort(0:3, by=x->x-2, order=Base.Order.By(abs)) == sort(0:3, by=x->abs(x-2))\ntrue\n\njulia> sort([2, NaN, 1, NaN, 3]) # correct sort with default lt=isless\n5-element Vector{Float64}:\n   1.0\n   2.0\n   3.0\n NaN\n NaN\n\njulia> sort([2, NaN, 1, NaN, 3], lt=<) # wrong sort due to invalid lt. This behavior is undefined.\n5-element Vector{Float64}:\n   2.0\n NaN\n   1.0\n NaN\n   3.0\n\n\n\n\n\n"},{"title":"Base.sort","page":"Sorting and Related Functions","location":"base/sort.html#Base.sort","category":"function","text":"sort(A; dims::Integer, alg::Base.Sort.Algorithm=Base.Sort.defalg(A), lt=isless, by=identity, rev::Bool=false, order::Base.Order.Ordering=Base.Order.Forward)\n\nSort a multidimensional array A along the given dimension.\nSee sort! for a description of possible\nkeyword arguments.\n\nTo sort slices of an array, refer to sortslices.\n\nExamples\n\njulia> A = [4 3; 1 2]\n2×2 Matrix{Int64}:\n 4  3\n 1  2\n\njulia> sort(A, dims = 1)\n2×2 Matrix{Int64}:\n 1  2\n 4  3\n\njulia> sort(A, dims = 2)\n2×2 Matrix{Int64}:\n 3  4\n 1  2\n\n\n\n\n\nsort(v; alg::Base.Sort.Algorithm=Base.Sort.defalg(v), lt=isless, by=identity, rev::Bool=false, order::Base.Order.Ordering=Base.Order.Forward)\nsort(v::NTuple; kws...)::NTuple\n\nVariant of sort! that returns a sorted copy of v leaving v itself unmodified.\n\nWhen calling sort on the keys or `values of a dictionary, v is\ncollected and then sorted.\n\ncompat: Julia 1.12\nSorting NTuples requires Julia 1.12 or later.\n\ncompat: Julia 1.13\nSorting keys sets and values iterators requires Julia 1.13 or later.\n\nExamples\n\njulia> v = [3, 1, 2];\n\njulia> sort(v)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> v\n3-element Vector{Int64}:\n 3\n 1\n 2\n\njulia> sort(values(Dict('a'=>2, 'b'=>1)))\n2-element Vector{Int64}:\n 1\n 2\n\n\n\n\n\n"},{"title":"Base.sortperm","page":"Sorting and Related Functions","location":"base/sort.html#Base.sortperm","category":"function","text":"sortperm(A; alg::Base.Sort.Algorithm=Base.Sort.DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Base.Order.Ordering=Base.Order.Forward, [dims::Integer])\n\nReturn a permutation vector or array I that puts A[I] in sorted order along the given dimension.\nIf A has more than one dimension, then the dims keyword argument must be specified. The order is specified\nusing the same keywords as sort!. The permutation is guaranteed to be stable even\nif the sorting algorithm is unstable: the indices of equal elements will appear in\nascending order.\n\nSee also sortperm!, partialsortperm, invperm, indexin.\nTo sort slices of an array, refer to sortslices.\n\ncompat: Julia 1.9\nThe method accepting dims requires at least Julia 1.9.\n\nExamples\n\njulia> v = [3, 1, 2];\n\njulia> p = sortperm(v)\n3-element Vector{Int64}:\n 2\n 3\n 1\n\njulia> v[p]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> A = [8 7; 5 6]\n2×2 Matrix{Int64}:\n 8  7\n 5  6\n\njulia> sortperm(A, dims = 1)\n2×2 Matrix{Int64}:\n 2  4\n 1  3\n\njulia> sortperm(A, dims = 2)\n2×2 Matrix{Int64}:\n 3  1\n 2  4\n\n\n\n\n\n"},{"title":"Base.Sort.InsertionSort","page":"Sorting and Related Functions","location":"base/sort.html#Base.Sort.InsertionSort","category":"constant","text":"InsertionSort\n\nUse the insertion sort algorithm.\n\nInsertion sort traverses the collection one element at a time, inserting\neach element into its correct, sorted position in the output vector.\n\nCharacteristics:\n\nstable: preserves the ordering of elements that compare equal\n\n(e.g. \"a\" and \"A\" in a sort of letters that ignores case).\n\nin-place in memory.\nquadratic performance in the number of elements to be sorted:\n\nit is well-suited to small collections but should not be used for large ones.\n\n\n\n\n\n"},{"title":"Base.Sort.MergeSort","page":"Sorting and Related Functions","location":"base/sort.html#Base.Sort.MergeSort","category":"constant","text":"MergeSort\n\nIndicate that a sorting function should use the merge sort\nalgorithm. Merge sort divides the collection into\nsubcollections and repeatedly merges them, sorting each\nsubcollection at each step, until the entire\ncollection has been recombined in sorted form.\n\nCharacteristics:\n\nstable: preserves the ordering of elements that compare\nequal (e.g. \"a\" and \"A\" in a sort of letters that ignores\ncase).\nnot in-place in memory.\ndivide-and-conquer sort strategy.\ngood performance for large collections but typically not quite as\nfast as QuickSort.\n\n\n\n\n\n"},{"title":"Base.Sort.QuickSort","page":"Sorting and Related Functions","location":"base/sort.html#Base.Sort.QuickSort","category":"constant","text":"QuickSort\n\nIndicate that a sorting function should use the quick sort\nalgorithm, which is not stable.\n\nCharacteristics:\n\nnot stable: does not preserve the ordering of elements that\ncompare equal (e.g. \"a\" and \"A\" in a sort of letters that\nignores case).\nin-place in memory.\ndivide-and-conquer: sort strategy similar to MergeSort.\ngood performance for large collections.\n\n\n\n\n\n"},{"title":"Base.Sort.PartialQuickSort","page":"Sorting and Related Functions","location":"base/sort.html#Base.Sort.PartialQuickSort","category":"type","text":"PartialQuickSort{T <: Union{Integer,OrdinalRange}}\n\nIndicate that a sorting function should use the partial quick sort algorithm.\nPartialQuickSort(k) is like QuickSort, but is only required to find and\nsort the elements that would end up in v[k] were v fully sorted.\n\nCharacteristics:\n\nnot stable: does not preserve the ordering of elements that\ncompare equal (e.g. \"a\" and \"A\" in a sort of letters that\nignores case).\nin-place in memory.\ndivide-and-conquer: sort strategy similar to MergeSort.\n\nNote that PartialQuickSort(k) does not necessarily sort the whole array. For example,\n\njulia> x = rand(100);\n\njulia> k = 50:100;\n\njulia> s1 = sort(x; alg=QuickSort);\n\njulia> s2 = sort(x; alg=PartialQuickSort(k));\n\njulia> map(issorted, (s1, s2))\n(true, false)\n\njulia> map(x->issorted(x[k]), (s1, s2))\n(true, true)\n\njulia> s1[k] == s2[k]\ntrue\n\n\n\n\n\n"},{"title":"Base.Sort.sortperm!","page":"Sorting and Related Functions","location":"base/sort.html#Base.Sort.sortperm!","category":"function","text":"sortperm!(ix, A; alg::Base.Sort.Algorithm=Base.Sort.DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Base.Order.Ordering=Base.Order.Forward, [dims::Integer])\n\nLike sortperm, but accepts a preallocated index vector or array ix with the same axes as A.\nix is initialized to contain the values LinearIndices(A).\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\ncompat: Julia 1.9\nThe method accepting dims requires at least Julia 1.9.\n\nExamples\n\njulia> v = [3, 1, 2]; p = zeros(Int, 3);\n\njulia> sortperm!(p, v); p\n3-element Vector{Int64}:\n 2\n 3\n 1\n\njulia> v[p]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> A = [8 7; 5 6]; p = zeros(Int,2, 2);\n\njulia> sortperm!(p, A; dims=1); p\n2×2 Matrix{Int64}:\n 2  4\n 1  3\n\njulia> sortperm!(p, A; dims=2); p\n2×2 Matrix{Int64}:\n 3  1\n 2  4\n\n\n\n\n\n"},{"title":"Base.sortslices","page":"Sorting and Related Functions","location":"base/sort.html#Base.sortslices","category":"function","text":"sortslices(A; dims, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\n\nSort slices of an array A. The required keyword argument dims must\nbe either an integer or a tuple of integers. It specifies the\ndimension(s) over which the slices are sorted.\n\nE.g., if A is a matrix, dims=1 will sort rows, dims=2 will sort columns.\nNote that the default comparison function on one dimensional slices sorts\nlexicographically.\n\nFor the remaining keyword arguments, see the documentation of sort!.\n\nExamples\n\njulia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1) # Sort rows\n3×3 Matrix{Int64}:\n -1   6  4\n  7   3  5\n  9  -2  8\n\njulia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, lt=(x,y)->isless(x[2],y[2]))\n3×3 Matrix{Int64}:\n  9  -2  8\n  7   3  5\n -1   6  4\n\njulia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, rev=true)\n3×3 Matrix{Int64}:\n  9  -2  8\n  7   3  5\n -1   6  4\n\njulia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2) # Sort columns\n3×3 Matrix{Int64}:\n  3   5  7\n -1  -4  6\n -2   8  9\n\njulia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, alg=InsertionSort, lt=(x,y)->isless(x[2],y[2]))\n3×3 Matrix{Int64}:\n  5   3  7\n -4  -1  6\n  8  -2  9\n\njulia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, rev=true)\n3×3 Matrix{Int64}:\n 7   5   3\n 6  -4  -1\n 9   8  -2\n\nHigher dimensions\n\nsortslices extends naturally to higher dimensions. E.g., if A is a\na 2x2x2 array, sortslices(A, dims=3) will sort slices within the 3rd dimension,\npassing the 2x2 slices A[:, :, 1] and A[:, :, 2] to the comparison function.\nNote that while there is no default order on higher-dimensional slices, you may\nuse the by or lt keyword argument to specify such an order.\n\nIf dims is a tuple, the order of the dimensions in dims is\nrelevant and specifies the linear order of the slices. E.g., if A is three\ndimensional and dims is (1, 2), the orderings of the first two dimensions\nare re-arranged such that the slices (of the remaining third dimension) are sorted.\nIf dims is (2, 1) instead, the same slices will be taken,\nbut the result order will be row-major instead.\n\nHigher dimensional examples\n\njulia> A = [4 3; 2 1 ;;; 'A' 'B'; 'C' 'D']\n2×2×2 Array{Any, 3}:\n[:, :, 1] =\n 4  3\n 2  1\n\n[:, :, 2] =\n 'A'  'B'\n 'C'  'D'\n\njulia> sortslices(A, dims=(1,2))\n2×2×2 Array{Any, 3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 'D'  'B'\n 'C'  'A'\n\njulia> sortslices(A, dims=(2,1))\n2×2×2 Array{Any, 3}:\n[:, :, 1] =\n 1  2\n 3  4\n\n[:, :, 2] =\n 'D'  'C'\n 'B'  'A'\n\njulia> sortslices(reshape([5; 4; 3; 2; 1], (1,1,5)), dims=3, by=x->x[1,1])\n1×1×5 Array{Int64, 3}:\n[:, :, 1] =\n 1\n\n[:, :, 2] =\n 2\n\n[:, :, 3] =\n 3\n\n[:, :, 4] =\n 4\n\n[:, :, 5] =\n 5\n\n\n\n\n\n"},{"title":"Base.issorted","page":"Sorting and Related Functions","location":"base/sort.html#Base.issorted","category":"function","text":"issorted(itr, lt=isless, by=identity, rev::Bool=false, order::Base.Order.Ordering=Base.Order.Forward)\n\nTest whether a collection is in sorted order. The keywords modify what\norder is considered sorted, as described in the sort! documentation.\n\nExamples\n\njulia> issorted([1, 2, 3])\ntrue\n\njulia> issorted([(1, \"b\"), (2, \"a\")], by = x -> x[1])\ntrue\n\njulia> issorted([(1, \"b\"), (2, \"a\")], by = x -> x[2])\nfalse\n\njulia> issorted([(1, \"b\"), (2, \"a\")], by = x -> x[2], rev=true)\ntrue\n\njulia> issorted([1, 2, -2, 3], by=abs)\ntrue\n\n\n\n\n\n"},{"title":"Base.Sort.searchsorted","page":"Sorting and Related Functions","location":"base/sort.html#Base.Sort.searchsorted","category":"function","text":"searchsorted(v, x; by=identity, lt=isless, rev=false)\n\nReturn the range of indices in v where values are equivalent to x, or an\nempty range located at the insertion point if v does not contain values\nequivalent to x. The vector v must be sorted according to the order defined\nby the keywords. Refer to sort! for the meaning of the keywords and\nthe definition of equivalence. Note that the by function is applied to the\nsearched value x as well as the values in v.\n\nThe range is generally found using binary search, but there are optimized\nimplementations for some inputs.\n\nSee also: searchsortedfirst, sort!, insorted, findall.\n\nExamples\n\njulia> searchsorted([1, 2, 4, 5, 5, 7], 4) # single match\n3:3\n\njulia> searchsorted([1, 2, 4, 5, 5, 7], 5) # multiple matches\n4:5\n\njulia> searchsorted([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle\n3:2 (empty range)\n\njulia> searchsorted([1, 2, 4, 5, 5, 7], 9) # no match, insert at end\n7:6 (empty range)\n\njulia> searchsorted([1, 2, 4, 5, 5, 7], 0) # no match, insert at start\n1:0 (empty range)\n\njulia> searchsorted([1=>\"one\", 2=>\"two\", 2=>\"two\", 4=>\"four\"], 2=>\"two\", by=first) # compare the keys of the pairs\n2:3\n\n\n\n\n\n"},{"title":"Base.Sort.searchsortedfirst","page":"Sorting and Related Functions","location":"base/sort.html#Base.Sort.searchsortedfirst","category":"function","text":"searchsortedfirst(v, x; by=identity, lt=isless, rev=false)\n\nReturn the index of the first value in v that is not ordered before x.\nIf all values in v are ordered before x, return lastindex(v) + 1.\n\nThe vector v must be sorted according to the order defined by the keywords.\ninsert!ing x at the returned index will maintain the sorted order.\nRefer to sort! for the meaning and use of the keywords.\nNote that the by function is applied to the searched value x as well as the\nvalues in v.\n\nThe index is generally found using binary search, but there are optimized\nimplementations for some inputs.\n\nSee also: searchsortedlast, searchsorted, findfirst.\n\nExamples\n\njulia> searchsortedfirst([1, 2, 4, 5, 5, 7], 4) # single match\n3\n\njulia> searchsortedfirst([1, 2, 4, 5, 5, 7], 5) # multiple matches\n4\n\njulia> searchsortedfirst([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle\n3\n\njulia> searchsortedfirst([1, 2, 4, 5, 5, 7], 9) # no match, insert at end\n7\n\njulia> searchsortedfirst([1, 2, 4, 5, 5, 7], 0) # no match, insert at start\n1\n\njulia> searchsortedfirst([1=>\"one\", 2=>\"two\", 4=>\"four\"], 3=>\"three\", by=first) # compare the keys of the pairs\n3\n\n\n\n\n\n"},{"title":"Base.Sort.searchsortedlast","page":"Sorting and Related Functions","location":"base/sort.html#Base.Sort.searchsortedlast","category":"function","text":"searchsortedlast(v, x; by=identity, lt=isless, rev=false)\n\nReturn the index of the last value in v that is not ordered after x.\nIf all values in v are ordered after x, return firstindex(v) - 1.\n\nThe vector v must be sorted according to the order defined by the keywords.\ninsert!ing x immediately after the returned index will maintain the sorted order.\nRefer to sort! for the meaning and use of the keywords.\nNote that the by function is applied to the searched value x as well as the\nvalues in v.\n\nThe index is generally found using binary search, but there are optimized\nimplementations for some inputs\n\nExamples\n\njulia> searchsortedlast([1, 2, 4, 5, 5, 7], 4) # single match\n3\n\njulia> searchsortedlast([1, 2, 4, 5, 5, 7], 5) # multiple matches\n5\n\njulia> searchsortedlast([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle\n2\n\njulia> searchsortedlast([1, 2, 4, 5, 5, 7], 9) # no match, insert at end\n6\n\njulia> searchsortedlast([1, 2, 4, 5, 5, 7], 0) # no match, insert at start\n0\n\njulia> searchsortedlast([1=>\"one\", 2=>\"two\", 4=>\"four\"], 3=>\"three\", by=first) # compare the keys of the pairs\n2\n\n\n\n\n\n"},{"title":"Base.Sort.insorted","page":"Sorting and Related Functions","location":"base/sort.html#Base.Sort.insorted","category":"function","text":"insorted(x, v; by=identity, lt=isless, rev=false)::Bool\n\nDetermine whether a vector v contains any value equivalent to x.\nThe vector v must be sorted according to the order defined by the keywords.\nRefer to sort! for the meaning of the keywords and the definition of\nequivalence. Note that the by function is applied to the searched value x\nas well as the values in v.\n\nThe check is generally done using binary search, but there are optimized\nimplementations for some inputs.\n\nSee also in.\n\nExamples\n\njulia> insorted(4, [1, 2, 4, 5, 5, 7]) # single match\ntrue\n\njulia> insorted(5, [1, 2, 4, 5, 5, 7]) # multiple matches\ntrue\n\njulia> insorted(3, [1, 2, 4, 5, 5, 7]) # no match\nfalse\n\njulia> insorted(9, [1, 2, 4, 5, 5, 7]) # no match\nfalse\n\njulia> insorted(0, [1, 2, 4, 5, 5, 7]) # no match\nfalse\n\njulia> insorted(2=>\"TWO\", [1=>\"one\", 2=>\"two\", 4=>\"four\"], by=first) # compare the keys of the pairs\ntrue\n\ncompat: Julia 1.6\ninsorted was added in Julia 1.6.\n\n\n\n\n\n"},{"title":"Base.Sort.partialsort!","page":"Sorting and Related Functions","location":"base/sort.html#Base.Sort.partialsort!","category":"function","text":"partialsort!(v, k; by=identity, lt=isless, rev=false, order::Base.Order.Ordering=Base.Order.Forward)\n\nMutate the vector v so that the value at index k (or\nrange of adjacent values if k is a range) occurs\nat the position where it would appear if the array were fully sorted. If k is a single\nindex, that value is returned; if k is a range, an array of values at those indices is\nreturned. Note that partialsort! may not fully sort the input array.\n\nFor the keyword arguments, see the documentation of sort!.\n\nExamples\n\njulia> a = [1, 2, 4, 3, 4]\n5-element Vector{Int64}:\n 1\n 2\n 4\n 3\n 4\n\njulia> partialsort!(a, 4)\n4\n\njulia> a\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 4\n\njulia> a = [1, 2, 4, 3, 4]\n5-element Vector{Int64}:\n 1\n 2\n 4\n 3\n 4\n\njulia> partialsort!(a, 4, rev=true)\n2\n\njulia> a\n5-element Vector{Int64}:\n 4\n 4\n 3\n 2\n 1\n\n\n\n\n\n"},{"title":"Base.Sort.partialsort","page":"Sorting and Related Functions","location":"base/sort.html#Base.Sort.partialsort","category":"function","text":"partialsort(v, k, by=identity, lt=isless, rev=false, order::Base.Order.Ordering=Base.Order.Forward)\n\nVariant of partialsort! that copies v before partially sorting it, thereby returning the\nsame thing as partialsort! but leaving v unmodified.\n\n\n\n\n\n"},{"title":"Base.Sort.partialsortperm","page":"Sorting and Related Functions","location":"base/sort.html#Base.Sort.partialsortperm","category":"function","text":"partialsortperm(v, k; by=identity, lt=isless, rev=false)\n\nReturn a partial permutation I of the vector v, so that v[I] returns values of a fully\nsorted version of v at index k. If k is a range, a vector of indices is returned; if\nk is an integer, a single index is returned. The order is specified using the same\nkeywords as sort!. The permutation is stable: the indices of equal elements\nwill appear in ascending order.\n\nThis function is equivalent to, but more efficient than, calling sortperm(...)[k].\n\nExamples\n\njulia> v = [3, 1, 2, 1];\n\njulia> v[partialsortperm(v, 1)]\n1\n\njulia> p = partialsortperm(v, 1:3)\n3-element view(::Vector{Int64}, 1:3) with eltype Int64:\n 2\n 4\n 3\n\njulia> v[p]\n3-element Vector{Int64}:\n 1\n 1\n 2\n\n\n\n\n\n"},{"title":"Base.Sort.partialsortperm!","page":"Sorting and Related Functions","location":"base/sort.html#Base.Sort.partialsortperm!","category":"function","text":"partialsortperm!(ix, v, k; by=identity, lt=isless, rev=false)\n\nLike partialsortperm, but accepts a preallocated index vector ix the same size as\nv, which is used to store (a permutation of) the indices of v.\n\nix is initialized to contain the indices of v.\n\n(Typically, the indices of v will be 1:length(v), although if v has an alternative array type\nwith non-one-based indices, such as an OffsetArray, ix must share those same indices)\n\nUpon return, ix is guaranteed to have the indices k in their sorted positions, such that\n\npartialsortperm!(ix, v, k);\nv[ix[k]] == partialsort(v, k)\n\nThe return value is the kth element of ix if k is an integer, or view into ix if k is\na range.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nExamples\n\njulia> v = [3, 1, 2, 1];\n\njulia> ix = Vector{Int}(undef, 4);\n\njulia> partialsortperm!(ix, v, 1)\n2\n\njulia> ix = [1:4;];\n\njulia> partialsortperm!(ix, v, 2:3)\n2-element view(::Vector{Int64}, 2:3) with eltype Int64:\n 4\n 3\n\n\n\n\n\n"},{"title":"Base.Order.Ordering","page":"Sorting and Related Functions","location":"base/sort.html#Base.Order.Ordering","category":"type","text":"Base.Order.Ordering\n\nAbstract type which represents a strict weak order on some set of elements. See\nsort! for more.\n\nUse Base.Order.lt to compare two elements according to the ordering.\n\n\n\n\n\n"},{"title":"Base.Order.lt","page":"Sorting and Related Functions","location":"base/sort.html#Base.Order.lt","category":"function","text":"lt(o::Ordering, a, b)::Bool\n\nTest whether a is less than b according to the ordering o.\n\n\n\n\n\n"},{"title":"Base.Order.ord","page":"Sorting and Related Functions","location":"base/sort.html#Base.Order.ord","category":"function","text":"ord(lt, by, rev::Union{Bool, Nothing}, order::Ordering=Forward)\n\nConstruct an Ordering object from the same arguments used by\nsort!.\nElements are first transformed by the function by (which may be\nidentity) and are then compared according to either the function lt\nor an existing ordering order. lt should be isless or a function\nthat obeys the same rules as the lt parameter of sort!. Finally,\nthe resulting order is reversed if rev=true.\n\nPassing an lt other than isless along with an order other than\nBase.Order.Forward or Base.Order.Reverse is not permitted,\notherwise all options are independent and can be used together in all possible\ncombinations.\n\n\n\n\n\n"},{"title":"Base.Order.Forward","page":"Sorting and Related Functions","location":"base/sort.html#Base.Order.Forward","category":"constant","text":"Base.Order.Forward\n\nDefault ordering according to isless.\n\n\n\n\n\n"},{"title":"Base.Order.ReverseOrdering","page":"Sorting and Related Functions","location":"base/sort.html#Base.Order.ReverseOrdering","category":"type","text":"ReverseOrdering(fwd::Ordering=Forward)\n\nA wrapper which reverses an ordering.\n\nFor a given Ordering o, the following holds for all  a, b:\n\nlt(ReverseOrdering(o), a, b) == lt(o, b, a)\n\n\n\n\n\n"},{"title":"Base.Order.Reverse","page":"Sorting and Related Functions","location":"base/sort.html#Base.Order.Reverse","category":"constant","text":"Base.Order.Reverse\n\nReverse ordering according to isless.\n\n\n\n\n\n"},{"title":"Base.Order.By","page":"Sorting and Related Functions","location":"base/sort.html#Base.Order.By","category":"type","text":"By(by, order::Ordering=Forward)\n\nOrdering which applies order to elements after they have been transformed\nby the function by.\n\n\n\n\n\n"},{"title":"Base.Order.Lt","page":"Sorting and Related Functions","location":"base/sort.html#Base.Order.Lt","category":"type","text":"Lt(lt)\n\nOrdering that calls lt(a, b) to compare elements. lt must\nobey the same rules as the lt parameter of sort!.\n\n\n\n\n\n"},{"title":"Base.Order.Perm","page":"Sorting and Related Functions","location":"base/sort.html#Base.Order.Perm","category":"type","text":"Perm(order::Ordering, data::AbstractVector)\n\nOrdering on the indices of data where i is less than j if data[i] is\nless than data[j] according to order. In the case that data[i] and\ndata[j] are equal, i and j are compared by numeric value.\n\n\n\n\n\n"},{"title":"Arrays with custom indices","page":"Arrays with custom indices","location":"devdocs/offset-arrays.html#man-custom-indices","category":"section","text":"Conventionally, Julia's\narrays are indexed starting at 1, whereas some other languages start numbering at 0, and yet others\n(e.g., Fortran) allow you to specify arbitrary starting indices. While there is much merit in\npicking a standard (i.e., 1 for Julia), there are some algorithms which simplify considerably\nif you can index outside the range 1:size(A,d) (and not just 0:size(A,d)-1, either).\nTo facilitate such computations, Julia supports arrays with arbitrary indices.\n\nThe purpose of this page is to address the question, \"what do I have to do to support such arrays\nin my own code?\"  First, let's address the simplest case: if you know that your code will never\nneed to handle arrays with unconventional indexing, hopefully the answer is \"nothing.\" Old code,\non conventional arrays, should function essentially without alteration as long as it was using\nthe exported interfaces of Julia.\nIf you find it more convenient to just force your users to supply traditional arrays where indexing starts at one, you can add\n\nBase.require_one_based_indexing(arrays...)\n\nwhere arrays... is a list of the array objects that you wish to check for anything that\nviolates 1-based indexing."},{"title":"Generalizing existing code","page":"Arrays with custom indices","location":"devdocs/offset-arrays.html#Generalizing-existing-code","category":"section","text":"As an overview, the steps are:\n\nreplace many uses of size with axes\nreplace 1:length(A) with eachindex(A), or in some cases LinearIndices(A)\nreplace explicit allocations like Array{Int}(undef, size(B)) with similar(Array{Int}, axes(B))\n\nThese are described in more detail below."},{"title":"Things to watch out for","page":"Arrays with custom indices","location":"devdocs/offset-arrays.html#Things-to-watch-out-for","category":"section","text":"Because unconventional indexing breaks many people's assumptions that all arrays start indexing with 1, there is always the chance that using such arrays will trigger errors.\nThe most\nfrustrating bugs would be incorrect results or segfaults (total crashes of Julia).\nFor example,\nconsider the following function:\n\nfunction mycopy!(dest::AbstractVector, src::AbstractVector)\n    length(dest) == length(src) || throw(DimensionMismatch(\"vectors must match\"))\n    # OK, now we're safe to use @inbounds, right? (not anymore!)\n    for i = 1:length(src)\n        @inbounds dest[i] = src[i]\n    end\n    dest\nend\n\nThis code implicitly assumes that vectors are indexed from 1; if dest starts at a different index than src, there is a chance that this code would trigger a segfault.\n(If you do get segfaults, to help locate\nthe cause try running julia with the option --check-bounds=yes.)"},{"title":"Using axes for bounds checks and loop iteration","page":"Arrays with custom indices","location":"devdocs/offset-arrays.html#Using-axes-for-bounds-checks-and-loop-iteration","category":"section","text":"axes(A) (reminiscent of size(A)) returns a tuple of AbstractUnitRange{<:Integer} objects, specifying\nthe range of valid indices along each dimension of A. When A has unconventional indexing,\nthe ranges may not start at 1. If you just want the range for a particular dimension d, there\nis axes(A, d).\n\nBase implements a custom range type, OneTo, where OneTo(n) means the same thing as 1:n but\nin a form that guarantees (via the type system) that the lower index is 1. For any new AbstractArray\ntype, this is the default returned by axes, and it indicates that this array type uses \"conventional\"\n1-based indexing.\n\nFor bounds checking, note that there are dedicated functions checkbounds and checkindex which\ncan sometimes simplify such tests."},{"title":"Linear indexing (LinearIndices)","page":"Arrays with custom indices","location":"devdocs/offset-arrays.html#Linear-indexing-(LinearIndices)","category":"section","text":"Some algorithms are most conveniently (or efficiently) written in terms of a single linear index, A[i] even if A is multi-dimensional. Regardless of the array's native indices, linear indices always range from 1:length(A). However, this raises an ambiguity for one-dimensional arrays (a.k.a., AbstractVector): does v[i] mean linear indexing , or Cartesian indexing with the array's native indices?\n\nFor this reason, your best option may be to iterate over the array with eachindex(A), or, if you require the indices to be sequential integers, to get the index range by calling LinearIndices(A). This will return axes(A, 1) if A is an AbstractVector, and the equivalent of 1:length(A) otherwise.\n\nBy this definition, 1-dimensional arrays always use Cartesian indexing with the array's native indices. To help enforce this, it's worth noting that the index conversion functions will throw an error if shape indicates a 1-dimensional array with unconventional indexing (i.e., is a Tuple{UnitRange} rather than a tuple of OneTo). For arrays with conventional indexing, these functions continue to work the same as always.\n\nUsing axes and LinearIndices, here is one way you could rewrite mycopy!:\n\nfunction mycopy!(dest::AbstractVector, src::AbstractVector)\n    axes(dest) == axes(src) || throw(DimensionMismatch(\"vectors must match\"))\n    for i in LinearIndices(src)\n        @inbounds dest[i] = src[i]\n    end\n    dest\nend"},{"title":"Allocating storage using generalizations of similar","page":"Arrays with custom indices","location":"devdocs/offset-arrays.html#Allocating-storage-using-generalizations-of-similar","category":"section","text":"Storage is often allocated with Array{Int}(undef, dims) or similar(A, args...). When the result needs\nto match the indices of some other array, this may not always suffice. The generic replacement\nfor such patterns is to use similar(storagetype, shape).  storagetype indicates the kind of\nunderlying \"conventional\" behavior you'd like, e.g., Array{Int} or BitArray or even dims->zeros(Float32, dims)\n(which would allocate an all-zeros array). shape is a tuple of Integer or\nAbstractUnitRange values, specifying the indices that you want the result to use. Note that\na convenient way of producing an all-zeros array that matches the indices of A is simply zeros(A).\n\nLet's walk through a couple of explicit examples. First, if A has conventional indices, then\nsimilar(Array{Int}, axes(A)) would end up calling Array{Int}(undef, size(A)), and thus return\nan array. If A is an AbstractArray type with unconventional indexing, then similar(Array{Int}, axes(A))\nshould return something that \"behaves like\" an Array{Int} but with a shape (including indices)\nthat matches A.  (The most obvious implementation is to allocate an Array{Int}(undef, size(A)) and\nthen \"wrap\" it in a type that shifts the indices.)\n\nNote also that similar(Array{Int}, (axes(A, 2),)) would allocate an AbstractVector{Int}\n(i.e., 1-dimensional array) that matches the indices of the columns of A."},{"title":"Writing custom array types with non-1 indexing","page":"Arrays with custom indices","location":"devdocs/offset-arrays.html#Writing-custom-array-types-with-non-1-indexing","category":"section","text":"Most of the methods you'll need to define are standard for any AbstractArray type, see Abstract Arrays.\nThis page focuses on the steps needed to define unconventional indexing."},{"title":"Custom AbstractUnitRange types","page":"Arrays with custom indices","location":"devdocs/offset-arrays.html#Custom-AbstractUnitRange-types","category":"section","text":"If you're writing a non-1 indexed array type, you will want to specialize axes so it returns\na UnitRange, or (perhaps better) a custom AbstractUnitRange. The advantage of a custom type\nis that it \"signals\" the allocation type for functions like similar. If we're writing an array\ntype for which indexing will start at 0, we likely want to begin by creating a new AbstractUnitRange,\nZeroRange, where ZeroRange(n) is equivalent to 0:n-1.\n\nIn general, you should probably not export ZeroRange from your package: there may be other\npackages that implement their own ZeroRange, and having multiple distinct ZeroRange types\nis (perhaps counterintuitively) an advantage: ModuleA.ZeroRange indicates that similar should\ncreate a ModuleA.ZeroArray, whereas ModuleB.ZeroRange indicates a ModuleB.ZeroArray type.\n This design allows peaceful coexistence among many different custom array types.\n\nNote that the Julia package CustomUnitRanges.jl\ncan sometimes be used to avoid the need to write your own ZeroRange type."},{"title":"Specializing axes","page":"Arrays with custom indices","location":"devdocs/offset-arrays.html#Specializing-axes","category":"section","text":"Once you have your AbstractUnitRange type, then specialize axes:\n\nBase.axes(A::ZeroArray) = map(n->ZeroRange(n), A.size)\n\nwhere here we imagine that ZeroArray has a field called size (there would be other ways to\nimplement this).\n\nIn some cases, the fallback definition for axes(A, d):\n\naxes(A::AbstractArray{T,N}, d) where {T,N} = d <= N ? axes(A)[d] : OneTo(1)\n\nmay not be what you want: you may need to specialize it to return something other than OneTo(1)\nwhen d > ndims(A). Likewise, in Base there is a dedicated function axes1 which is equivalent\nto axes(A, 1) but which avoids checking (at runtime) whether ndims(A) > 0. (This is purely\na performance optimization.)  It is defined as:\n\naxes1(A::AbstractArray{T,0}) where {T} = OneTo(1)\naxes1(A::AbstractArray) = axes(A)[1]\n\nIf the first of these (the zero-dimensional case) is problematic for your custom array type, be\nsure to specialize it appropriately."},{"title":"Specializing similar","page":"Arrays with custom indices","location":"devdocs/offset-arrays.html#Specializing-similar","category":"section","text":"Given your custom ZeroRange type, then you should also add the following two specializations\nfor similar:\n\nfunction Base.similar(A::AbstractArray, T::Type, shape::Tuple{ZeroRange,Vararg{ZeroRange}})\n    # body\nend\n\nfunction Base.similar(f::Union{Function,DataType}, shape::Tuple{ZeroRange,Vararg{ZeroRange}})\n    # body\nend\n\nBoth of these should allocate your custom array type."},{"title":"Specializing reshape","page":"Arrays with custom indices","location":"devdocs/offset-arrays.html#Specializing-reshape","category":"section","text":"Optionally, define a method\n\nBase.reshape(A::AbstractArray, shape::Tuple{ZeroRange,Vararg{ZeroRange}}) = ...\n\nand you can reshape an array so that the result has custom indices."},{"title":"For objects that mimic AbstractArray but are not subtypes","page":"Arrays with custom indices","location":"devdocs/offset-arrays.html#For-objects-that-mimic-AbstractArray-but-are-not-subtypes","category":"section","text":"has_offset_axes depends on having axes defined for the objects you call it on. If there is\nsome reason you don't have an axes method defined for your object, consider defining a method\n\nBase.has_offset_axes(obj::MyNon1IndexedArraylikeObject) = true\n\nThis will allow code that assumes 1-based indexing to detect a problem\nand throw a helpful error, rather than returning incorrect results or\nsegfaulting julia."},{"title":"Catching errors","page":"Arrays with custom indices","location":"devdocs/offset-arrays.html#Catching-errors","category":"section","text":"If your new array type triggers errors in other code, one helpful debugging step can be to comment out @boundscheck in your getindex and setindex! implementation.\nThis will ensure that every element access checks bounds. Or, restart julia with --check-bounds=yes.\n\nIn some cases it may also be helpful to temporarily disable size and length for your new array type,\nsince code that makes incorrect assumptions frequently uses these functions."},{"title":"Interfaces","page":"Interfaces","location":"manual/interfaces.html#Interfaces","category":"section","text":"A lot of the power and extensibility in Julia comes from a collection of informal interfaces.\n By extending a few specific methods to work for a custom type, objects of that type not only\nreceive those functionalities, but they are also able to be used in other methods that are written\nto generically build upon those behaviors."},{"title":"Iteration","page":"Interfaces","location":"manual/interfaces.html#man-interface-iteration","category":"section","text":"There are two methods that are always required:\n\nRequired method Brief description\niterate(iter) Returns either a tuple of the first item and initial state or nothing if empty\niterate(iter, state) Returns either a tuple of the next item and next state or nothing if no items remain\n\nThere are several more methods that should be defined in some circumstances.\nPlease note that you should always define at least one of Base.IteratorSize(IterType) and length(iter) because the default definition of Base.IteratorSize(IterType) is Base.HasLength().\n\nMethod When should this method be defined? Default definition Brief description\nBase.IteratorSize(IterType) If default is not appropriate Base.HasLength() One of Base.HasLength(), Base.HasShape{N}(), Base.IsInfinite(), or Base.SizeUnknown() as appropriate\nlength(iter) If Base.IteratorSize() returns Base.HasLength() or Base.HasShape{N}() (undefined) The number of items, if known\nsize(iter, [dim]) If Base.IteratorSize() returns Base.HasShape{N}() (undefined) The number of items in each dimension, if known\nBase.IteratorEltype(IterType) If default is not appropriate Base.HasEltype() Either Base.EltypeUnknown() or Base.HasEltype() as appropriate\neltype(IterType) If default is not appropriate Any The type of the first entry of the tuple returned by iterate()\nBase.isdone(iter, [state]) Must be defined if iterator is stateful missing Fast-path hint for iterator completion. If not defined for a stateful iterator then functions that check for done-ness, like isempty() and zip(), may mutate the iterator and cause buggy behaviour!\n\nSequential iteration is implemented by the iterate function. Instead\nof mutating objects as they are iterated over, Julia iterators may keep track\nof the iteration state externally from the object. The return value from iterate\nis always either a tuple of a value and a state, or nothing if no elements remain.\nThe state object will be passed back to the iterate function on the next iteration\nand is generally considered an implementation detail private to the iterable object.\n\nAny object that defines this function is iterable and can be used in the many functions that rely upon iteration.\nIt can also be used directly in a for loop since the syntax:\n\nfor item in iter   # or  \"for item = iter\"\n    # body\nend\n\nis translated into:\n\nnext = iterate(iter)\nwhile next !== nothing\n    (item, state) = next\n    # body\n    next = iterate(iter, state)\nend\n\nA simple example is an iterable sequence of square numbers with a defined length:\n\njulia> struct Squares\n           count::Int\n       end\n\njulia> Base.iterate(S::Squares, state=1) = state > S.count ? nothing : (state*state, state+1)\n\nWith only iterate definition, the Squares type is already pretty powerful.\nWe can iterate over all the elements:\n\njulia> for item in Squares(7)\n           println(item)\n       end\n1\n4\n9\n16\n25\n36\n49\n\nWe can use many of the builtin methods that work with iterables,\nlike in or sum:\n\njulia> 25 in Squares(10)\ntrue\n\njulia> sum(Squares(100))\n338350\n\nThere are a few more methods we can extend to give Julia more information about this iterable\ncollection. We know that the elements in a Squares sequence will always be Int. By extending\nthe eltype method, we can give that information to Julia and help it make more specialized\ncode in the more complicated methods. We also know the number of elements in our sequence, so\nwe can extend length, too:\n\njulia> Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type\n\njulia> Base.length(S::Squares) = S.count\n\nNow, when we ask Julia to collect all the elements into an array it can preallocate a Vector{Int}\nof the right size instead of naively push!ing each element into a Vector{Any}:\n\njulia> collect(Squares(4))\n4-element Vector{Int64}:\n  1\n  4\n  9\n 16\n\nWhile we can rely upon generic implementations, we can also extend specific methods where we know\nthere is a simpler algorithm. For example, there's a formula to compute the sum of squares, so\nwe can override the generic iterative version with a more performant solution:\n\njulia> Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)\n\njulia> sum(Squares(1803))\n1955361914\n\nThis is a very common pattern throughout Julia Base: a small set of required methods\ndefine an informal interface that enable many fancier behaviors. In some cases, types will want\nto additionally specialize those extra behaviors when they know a more efficient algorithm can\nbe used in their specific case.\n\nIt is also often useful to allow iteration over a collection in reverse order\nby iterating over Iterators.reverse(iterator). To actually support\nreverse-order iteration, however, an iterator\ntype T needs to implement iterate for Iterators.Reverse{T}.\n(Given r::Iterators.Reverse{T}, the underling iterator of type T is r.itr.)\nIn our Squares example, we would implement Iterators.Reverse{Squares} methods:\n\njulia> Base.iterate(rS::Iterators.Reverse{Squares}, state=rS.itr.count) = state < 1 ? nothing : (state*state, state-1)\n\njulia> collect(Iterators.reverse(Squares(4)))\n4-element Vector{Int64}:\n 16\n  9\n  4\n  1"},{"title":"Indexing","page":"Interfaces","location":"manual/interfaces.html#Indexing","category":"section","text":"Methods to implement Brief description\ngetindex(X, i) X[i], indexed access, non-scalar i should allocate a copy\nsetindex!(X, v, i) X[i] = v, indexed assignment\nfirstindex(X) The first index, used in X[begin]\nlastindex(X) The last index, used in X[end]\n\nFor the Squares iterable above, we can easily compute the ith element of the sequence by squaring\nit. We can expose this as an indexing expression S[i]. To opt into this behavior, Squares\nsimply needs to define getindex:\n\njulia> function Base.getindex(S::Squares, i::Int)\n           1 <= i <= S.count || throw(BoundsError(S, i))\n           return i*i\n       end\n\njulia> Squares(100)[23]\n529\n\nAdditionally, to support the syntax S[begin] and S[end], we must define firstindex and\nlastindex to specify the first and last valid indices, respectively:\n\njulia> Base.firstindex(S::Squares) = 1\n\njulia> Base.lastindex(S::Squares) = length(S)\n\njulia> Squares(23)[end]\n529\n\nFor multi-dimensional begin/end indexing as in a[3, begin, 7], for example,\nyou should define firstindex(a, dim) and lastindex(a, dim)\n(which default to calling first and last on axes(a, dim), respectively).\n\nNote, though, that the above only defines getindex with one integer index. Indexing with\nanything other than an Int will throw a MethodError saying that there was no matching method.\nIn order to support indexing with ranges or vectors of Ints, separate methods must be written:\n\njulia> Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]\n\njulia> Base.getindex(S::Squares, I) = [S[i] for i in I]\n\njulia> Squares(10)[[3,4.,5]]\n3-element Vector{Int64}:\n  9\n 16\n 25\n\nWhile this is starting to support more of the indexing operations supported by some of the builtin types,\nthere's still quite a number of behaviors missing. This Squares sequence is starting to look\nmore and more like a vector as we've added behaviors to it. Instead of defining all these behaviors\nourselves, we can officially define it as a subtype of an AbstractArray."},{"title":"Abstract Arrays","page":"Interfaces","location":"manual/interfaces.html#man-interface-array","category":"section","text":"Methods to implement  Brief description\nsize(A)  Returns a tuple containing the dimensions of A\ngetindex(A, i::Int)  (if IndexLinear) Linear scalar indexing\ngetindex(A, I::Vararg{Int, N})  (if IndexCartesian, where N = ndims(A)) N-dimensional scalar indexing\nOptional methods Default definition Brief description\nIndexStyle(::Type) IndexCartesian() Returns either IndexLinear() or IndexCartesian(). See the description below.\nsetindex!(A, v, i::Int)  (if IndexLinear) Scalar indexed assignment\nsetindex!(A, v, I::Vararg{Int, N})  (if IndexCartesian, where N = ndims(A)) N-dimensional scalar indexed assignment\ngetindex(A, I...) defined in terms of scalar getindex Multidimensional and nonscalar indexing\nsetindex!(A, X, I...) defined in terms of scalar setindex! Multidimensional and nonscalar indexed assignment\niterate defined in terms of scalar getindex Iteration\nlength(A) prod(size(A)) Number of elements\nsimilar(A) similar(A, eltype(A), size(A)) Return a mutable array with the same shape and element type\nsimilar(A, ::Type{S}) similar(A, S, size(A)) Return a mutable array with the same shape and the specified element type\nsimilar(A, dims::Dims) similar(A, eltype(A), dims) Return a mutable array with the same element type and size dims\nsimilar(A, ::Type{S}, dims::Dims) Array{S}(undef, dims) Return a mutable array with the specified element type and size\nNon-traditional indices Default definition Brief description\naxes(A) map(OneTo, size(A)) Return a tuple of AbstractUnitRange{<:Integer} of valid indices. The axes should be their own axes, that is axes.(axes(A),1) == axes(A) should be satisfied.\nsimilar(A, ::Type{S}, inds) similar(A, S, Base.to_shape(inds)) Return a mutable array with the specified indices inds (see below)\nsimilar(T::Union{Type,Function}, inds) T(Base.to_shape(inds)) Return an array similar to T with the specified indices inds (see below)\n\nIf a type is defined as a subtype of AbstractArray, it inherits a very large set of rich behaviors\nincluding iteration and multidimensional indexing built on top of single-element access. See\nthe arrays manual page and the Julia Base section for more supported methods.\n\nA key part in defining an AbstractArray subtype is IndexStyle. Since indexing is\nsuch an important part of an array and often occurs in hot loops, it's important to make both\nindexing and indexed assignment as efficient as possible. Array data structures are typically\ndefined in one of two ways: either it most efficiently accesses its elements using just one index\n(linear indexing) or it intrinsically accesses the elements with indices specified for every dimension.\n These two modalities are identified by Julia as IndexLinear() and IndexCartesian().\n Converting a linear index to multiple indexing subscripts is typically very expensive, so this\nprovides a traits-based mechanism to enable efficient generic code for all array types.\n\nThis distinction determines which scalar indexing methods the type must define. IndexLinear()\narrays are simple: just define getindex(A::ArrayType, i::Int). When the array is subsequently\nindexed with a multidimensional set of indices, the fallback getindex(A::AbstractArray, I...)\nefficiently converts the indices into one linear index and then calls the above method. IndexCartesian()\narrays, on the other hand, require methods to be defined for each supported dimensionality with\nndims(A) Int indices. For example, SparseMatrixCSC from the SparseArrays standard\nlibrary module, only supports two dimensions, so it just defines\ngetindex(A::SparseMatrixCSC, i::Int, j::Int). The same holds for setindex!.\n\nReturning to the sequence of squares from above, we could instead define it as a subtype of an\nAbstractVector{Int}:\n\njulia> struct SquaresVector <: AbstractVector{Int}\n           count::Int\n       end\n\njulia> Base.size(S::SquaresVector) = (S.count,)\n\njulia> Base.IndexStyle(::Type{<:SquaresVector}) = IndexLinear()\n\njulia> Base.getindex(S::SquaresVector, i::Int) = i*i\n\nNote that it's very important to specify the two parameters of the AbstractArray; the first\ndefines the eltype, and the second defines the ndims. That supertype and those three\nmethods are all it takes for SquaresVector to be an iterable, indexable, and completely functional\narray:\n\njulia> s = SquaresVector(4)\n4-element SquaresVector:\n  1\n  4\n  9\n 16\n\njulia> s[s .> 8]\n2-element Vector{Int64}:\n  9\n 16\n\njulia> s + s\n4-element Vector{Int64}:\n  2\n  8\n 18\n 32\n\njulia> sin.(s)\n4-element Vector{Float64}:\n  0.8414709848078965\n -0.7568024953079282\n  0.4121184852417566\n -0.2879033166650653\n\nAs a more complicated example, let's define our own toy N-dimensional sparse-like array type built\non top of Dict:\n\njulia> struct SparseArray{T,N} <: AbstractArray{T,N}\n           data::Dict{NTuple{N,Int}, T}\n           dims::NTuple{N,Int}\n       end\n\njulia> SparseArray(::Type{T}, dims::Int...) where {T} = SparseArray(T, dims);\n\njulia> SparseArray(::Type{T}, dims::NTuple{N,Int}) where {T,N} = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);\n\njulia> Base.size(A::SparseArray) = A.dims\n\njulia> Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)\n\njulia> Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))\n\njulia> Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)\n\nNotice that this is an IndexCartesian array, so we must manually define getindex and setindex!\nat the dimensionality of the array. Unlike the SquaresVector, we are able to define setindex!,\nand so we can mutate the array:\n\njulia> A = SparseArray(Float64, 3, 3)\n3×3 SparseArray{Float64, 2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia> fill!(A, 2)\n3×3 SparseArray{Float64, 2}:\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n\njulia> A[:] = 1:length(A); A\n3×3 SparseArray{Float64, 2}:\n 1.0  4.0  7.0\n 2.0  5.0  8.0\n 3.0  6.0  9.0\n\nThe result of indexing an AbstractArray can itself be an array (for instance when indexing by\nan AbstractRange). The AbstractArray fallback methods use similar to allocate an Array\nof the appropriate size and element type, which is filled in using the basic indexing method described\nabove. However, when implementing an array wrapper you often want the result to be wrapped as\nwell:\n\njulia> A[1:2,:]\n2×3 SparseArray{Float64, 2}:\n 1.0  4.0  7.0\n 2.0  5.0  8.0\n\nIn this example it is accomplished by defining Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where T\nto create the appropriate wrapped array. (Note that while similar supports 1- and 2-argument\nforms, in most case you only need to specialize the 3-argument form.) For this to work it's important\nthat SparseArray is mutable (supports setindex!). Defining similar, getindex and\nsetindex! for SparseArray also makes it possible to copy the array:\n\njulia> copy(A)\n3×3 SparseArray{Float64, 2}:\n 1.0  4.0  7.0\n 2.0  5.0  8.0\n 3.0  6.0  9.0\n\nIn addition to all the iterable and indexable methods from above, these types can also interact\nwith each other and use most of the methods defined in Julia Base for AbstractArrays:\n\njulia> A[SquaresVector(3)]\n3-element SparseArray{Float64, 1}:\n 1.0\n 4.0\n 9.0\n\njulia> sum(A)\n45.0\n\nIf you are defining an array type that allows non-traditional indexing (indices that start at\nsomething other than 1), you should specialize axes. You should also specialize similar\nso that the dims argument (ordinarily a Dims size-tuple) can accept AbstractUnitRange objects,\nperhaps range-types Ind of your own design. For more information, see\nArrays with custom indices."},{"title":"Strided Arrays","page":"Interfaces","location":"manual/interfaces.html#man-interface-strided-arrays","category":"section","text":"Methods to implement  Brief description\nstrides(A)  Return the distance in memory (in number of elements) between adjacent elements in each dimension as a tuple. If A is an AbstractArray{T,0}, this should return an empty tuple.\nBase.unsafe_convert(::Type{Ptr{T}}, Base.cconvert(Ptr{T}, A))  Return the native address of an array.\nBase.elsize(::Type{<:A})  Return the stride (in number of bytes) between consecutive elements in the array.\nOptional methods Default definition Brief description\nstride(A, i::Int) strides(A)[i] Return the distance in memory (in number of elements) between adjacent elements in dimension i.\nBase.cconvert(::Type{Ptr{T}}, A) A Return an object that can be converted to the native address of the array with Base.unsafe_convert\n\nA strided array is a subtype of AbstractArray whose entries are stored in memory with fixed strides.\nProvided the element type of the array is compatible with BLAS, a strided array can utilize BLAS and LAPACK routines\nfor more efficient linear algebra routines. A typical example of a user-defined strided array is one\nthat wraps a standard Array with additional structure.\n\nWarning: do not implement these methods if the underlying storage is not actually strided, as it\nmay lead to incorrect results or segmentation faults.\n\nThe following function demonstrates how an element at indices I in a strided array A can be accessed.\nThis function assumes the element type isbitstype and the indices are inbounds.\n\njulia> function unsafe_strided_getindex(A::AbstractArray{T,N}, I::Vararg{Int, N})::T where {T, N}\n           A_cconv = Base.cconvert(Ptr{T}, A)\n           GC.@preserve A_cconv begin\n               A_ptr = Base.unsafe_convert(Ptr{T}, A_cconv)\n               for d in 1:N\n                   stride_in_bytes = stride(A, d) * Base.elsize(typeof(A))\n                   first_idx = first(axes(A, d))\n                   A_ptr += (I[d] - first_idx) * stride_in_bytes\n               end\n               unsafe_load(A_ptr)\n           end\n       end;\n\njulia> A = [1 5; 2 6; 3 7; 4 8];\n\njulia> unsafe_strided_getindex(A, 3, 2)\n7\n\njulia> V = view(A, 1:2:3, 1:2);\n\njulia> unsafe_strided_getindex(V, 2, 2)\n7\n\nHere are some examples to demonstrate which type of arrays are strided and which are not:\n\n1:5   # not strided (there is no storage associated with this array.)\nVector(1:5)  # is strided with strides (1,)\nA = [1 5; 2 6; 3 7; 4 8]  # is strided with strides (1,4)\nV = view(A, 1:2, :)   # is strided with strides (1,4)\nV = view(A, 1:2:3, 1:2)   # is strided with strides (2,4)\nV = view(A, [1,2,4], :)   # is not strided, as the spacing between rows is not fixed."},{"title":"Customizing broadcasting","page":"Interfaces","location":"manual/interfaces.html#man-interfaces-broadcasting","category":"section","text":"Methods to implement Brief description\nBase.BroadcastStyle(::Type{SrcType}) = SrcStyle() Broadcasting behavior of SrcType\nBase.similar(bc::Broadcasted{DestStyle}, ::Type{ElType}) Allocation of output container\nOptional methods \nBase.BroadcastStyle(::Style1, ::Style2) = Style12() Precedence rules for mixing styles\nBase.axes(x) Declaration of the indices of x, as per axes(x).\nBase.broadcastable(x) Convert x to an object that has axes and supports indexing\nBypassing default machinery \nBase.copy(bc::Broadcasted{DestStyle}) Custom implementation of broadcast\nBase.copyto!(dest, bc::Broadcasted{DestStyle}) Custom implementation of broadcast!, specializing on DestStyle\nBase.copyto!(dest::DestType, bc::Broadcasted{Nothing}) Custom implementation of broadcast!, specializing on DestType\nBase.Broadcast.broadcasted(f, args...) Override the default lazy behavior within a fused expression\nBase.Broadcast.instantiate(bc::Broadcasted{DestStyle}) Override the computation of the lazy broadcast's axes\n\nBroadcasting is triggered by an explicit call to broadcast or broadcast!, or implicitly by\n\"dot\" operations like A .+ b or f.(x, y). Any object that has axes and supports\nindexing can participate as an argument in broadcasting, and by default the result is stored\nin an Array. This basic framework is extensible in three major ways:\n\nEnsuring that all arguments support broadcast\nSelecting an appropriate output array for the given set of arguments\nSelecting an efficient implementation for the given set of arguments\n\nNot all types support axes and indexing, but many are convenient to allow in broadcast.\nThe Base.broadcastable function is called on each argument to broadcast, allowing\nit to return something different that supports axes and indexing. By\ndefault, this is the identity function for all AbstractArrays and Numbers — they already\nsupport axes and indexing.\n\nIf a type is intended to act like a \"0-dimensional scalar\" (a single object) rather than as a\ncontainer for broadcasting, then the following method should be defined:\n\nBase.broadcastable(o::MyType) = Ref(o)\n\nthat returns the argument wrapped in a 0-dimensional Ref container. For example, such a wrapper\nmethod is defined for types themselves, functions, special singletons like missing and nothing, and dates.\n\nCustom array-like types can specialize\nBase.broadcastable to define their shape, but they should follow the convention that\ncollect(Base.broadcastable(x)) == collect(x). A notable exception is AbstractString;\nstrings are special-cased to behave as scalars for the purposes of broadcast even though\nthey are iterable collections of their characters (see Strings for more).\n\nThe next two steps (selecting the output array and implementation) are dependent upon\ndetermining a single answer for a given set of arguments. Broadcast must take all the varied\ntypes of its arguments and collapse them down to just one output array and one\nimplementation. Broadcast calls this single answer a \"style\". Every broadcastable object\neach has its own preferred style, and a promotion-like system is used to combine these\nstyles into a single answer — the \"destination style\"."},{"title":"Broadcast Styles","page":"Interfaces","location":"manual/interfaces.html#Broadcast-Styles","category":"section","text":"Base.BroadcastStyle is the abstract type from which all broadcast styles are derived. When used as a\nfunction it has two possible forms, unary (single-argument) and binary. The unary variant states\nthat you intend to implement specific broadcasting behavior and/or output type, and do not wish to\nrely on the default fallback Broadcast.DefaultArrayStyle.\n\nTo override these defaults, you can define a custom BroadcastStyle for your object:\n\nstruct MyStyle <: Broadcast.BroadcastStyle end\nBase.BroadcastStyle(::Type{<:MyType}) = MyStyle()\n\nIn some cases it might be convenient not to have to define MyStyle, in which case you can\nleverage one of the general broadcast wrappers:\n\nBase.BroadcastStyle(::Type{<:MyType}) = Broadcast.Style{MyType}() can be\nused for arbitrary types.\nBase.BroadcastStyle(::Type{<:MyType}) = Broadcast.ArrayStyle{MyType}() is preferred\nif MyType is an AbstractArray.\nFor AbstractArrays that only support a certain dimensionality, create a subtype of Broadcast.AbstractArrayStyle{N} (see below).\n\nWhen your broadcast operation involves several arguments, individual argument styles get\ncombined to determine a single DestStyle that controls the type of the output container.\nFor more details, see below."},{"title":"Selecting an appropriate output array","page":"Interfaces","location":"manual/interfaces.html#Selecting-an-appropriate-output-array","category":"section","text":"The broadcast style is computed for every broadcasting operation to allow for\ndispatch and specialization. The actual allocation of the result array is\nhandled by similar, using the Broadcasted object as its first argument.\n\nBase.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})\n\nThe fallback definition is\n\nsimilar(bc::Broadcasted{DefaultArrayStyle{N}}, ::Type{ElType}) where {N,ElType} =\n    similar(Array{ElType}, axes(bc))\n\nHowever, if needed you can specialize on any or all of these arguments. The final argument\nbc is a lazy representation of a (potentially fused) broadcast operation, a Broadcasted\nobject. For these purposes, the most important fields of the wrapper are\nf and args, describing the function and argument list, respectively. Note that the argument\nlist can — and often does — include other nested Broadcasted wrappers.\n\nFor a complete example, let's say you have created a type, ArrayAndChar, that stores an\narray and a single character:\n\nstruct ArrayAndChar{T,N} <: AbstractArray{T,N}\n    data::Array{T,N}\n    char::Char\nend\nBase.size(A::ArrayAndChar) = size(A.data)\nBase.getindex(A::ArrayAndChar{T,N}, inds::Vararg{Int,N}) where {T,N} = A.data[inds...]\nBase.setindex!(A::ArrayAndChar{T,N}, val, inds::Vararg{Int,N}) where {T,N} = A.data[inds...] = val\nBase.showarg(io::IO, A::ArrayAndChar, toplevel) = print(io, typeof(A), \" with char '\", A.char, \"'\")\n\nYou might want broadcasting to preserve the char \"metadata\". First we define\n\nBase.BroadcastStyle(::Type{<:ArrayAndChar}) = Broadcast.ArrayStyle{ArrayAndChar}()\n\nThis means we must also define a corresponding similar method:\n\nfunction Base.similar(bc::Broadcast.Broadcasted{Broadcast.ArrayStyle{ArrayAndChar}}, ::Type{ElType}) where ElType\n    # Scan the inputs for the ArrayAndChar:\n    A = find_aac(bc)\n    # Use the char field of A to create the output\n    ArrayAndChar(similar(Array{ElType}, axes(bc)), A.char)\nend\n\n\"`A = find_aac(As)` returns the first ArrayAndChar among the arguments.\"\nfind_aac(bc::Base.Broadcast.Broadcasted) = find_aac(bc.args)\nfind_aac(args::Tuple) = find_aac(find_aac(args[1]), Base.tail(args))\nfind_aac(x) = x\nfind_aac(::Tuple{}) = nothing\nfind_aac(a::ArrayAndChar, rest) = a\nfind_aac(::Any, rest) = find_aac(rest)\n\nFrom these definitions, one obtains the following behavior:\n\njulia> a = ArrayAndChar([1 2; 3 4], 'x')\n2×2 ArrayAndChar{Int64, 2} with char 'x':\n 1  2\n 3  4\n\njulia> a .+ 1\n2×2 ArrayAndChar{Int64, 2} with char 'x':\n 2  3\n 4  5\n\njulia> a .+ [5,10]\n2×2 ArrayAndChar{Int64, 2} with char 'x':\n  6   7\n 13  14"},{"title":"Extending broadcast with custom implementations","page":"Interfaces","location":"manual/interfaces.html#extending-in-place-broadcast","category":"section","text":"In general, a broadcast operation is represented by a lazy Broadcasted container that holds onto\nthe function to be applied alongside its arguments. Those arguments may themselves be more nested\nBroadcasted containers, forming a large expression tree to be evaluated. A nested tree of\nBroadcasted containers is directly constructed by the implicit dot syntax; 5 .+ 2.*x is\ntransiently represented by Broadcasted(+, 5, Broadcasted(*, 2, x)), for example. This is\ninvisible to users as it is immediately realized through a call to copy, but it is this container\nthat provides the basis for broadcast's extensibility for authors of custom types. The built-in\nbroadcast machinery will then determine the result type and size based upon the arguments, allocate\nit, and then finally copy the realization of the Broadcasted object into it with a default\ncopyto!(::AbstractArray, ::Broadcasted) method. The built-in fallback broadcast and\nbroadcast! methods similarly construct a transient Broadcasted representation of the operation\nso they can follow the same codepath. This allows custom array implementations to\nprovide their own copyto! specialization to customize and\noptimize broadcasting. This is again determined by the computed broadcast style. This is such\nan important part of the operation that it is stored as the first type parameter of the\nBroadcasted type, allowing for dispatch and specialization.\n\nFor some types, the machinery to \"fuse\" operations across nested levels of broadcasting\nis not available or could be done more efficiently incrementally. In such cases, you may\nneed or want to evaluate x .* (x .+ 1) as if it had been\nwritten broadcast(*, x, broadcast(+, x, 1)), where the inner operation is evaluated before\ntackling the outer operation. This sort of eager operation is directly supported by a bit\nof indirection; instead of directly constructing Broadcasted objects, Julia lowers the\nfused expression x .* (x .+ 1) to Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1)). Now,\nby default, broadcasted just calls the Broadcasted constructor to create the lazy representation\nof the fused expression tree, but you can choose to override it for a particular combination\nof function and arguments.\n\nAs an example, the builtin AbstractRange objects use this machinery to optimize pieces\nof broadcasted expressions that can be eagerly evaluated purely in terms of the start,\nstep, and length (or stop) instead of computing every single element. Just like all the\nother machinery, broadcasted also computes and exposes the combined broadcast style of its\narguments, so instead of specializing on broadcasted(f, args...), you can specialize on\nbroadcasted(::DestStyle, f, args...) for any combination of style, function, and arguments.\n\nFor example, the following definition supports the negation of ranges:\n\nbroadcasted(::DefaultArrayStyle{1}, ::typeof(-), r::OrdinalRange) = range(-first(r), step=-step(r), length=length(r))"},{"title":"Extending in-place broadcasting","page":"Interfaces","location":"manual/interfaces.html#extending-in-place-broadcast-2","category":"section","text":"In-place broadcasting can be supported by defining the appropriate copyto!(dest, bc::Broadcasted)\nmethod. Because you might want to specialize either on dest or the specific subtype of bc,\nto avoid ambiguities between packages we recommend the following convention.\n\nIf you wish to specialize on a particular style DestStyle, define a method for\n\ncopyto!(dest, bc::Broadcasted{DestStyle})\n\nOptionally, with this form you can also specialize on the type of dest.\n\nIf instead you want to specialize on the destination type DestType without specializing\non DestStyle, then you should define a method with the following signature:\n\ncopyto!(dest::DestType, bc::Broadcasted{Nothing})\n\nThis leverages a fallback implementation of copyto! that converts the wrapper into a\nBroadcasted{Nothing}. Consequently, specializing on DestType has lower precedence than\nmethods that specialize on DestStyle.\n\nSimilarly, you can completely override out-of-place broadcasting with a copy(::Broadcasted)\nmethod."},{"title":"Working with Broadcasted objects","page":"Interfaces","location":"manual/interfaces.html#Working-with-Broadcasted-objects","category":"section","text":"In order to implement such a copy or copyto!, method, of course, you must\nwork with the Broadcasted wrapper to compute each element. There are two main\nways of doing so:\n\nBroadcast.flatten recomputes the potentially nested operation into a single\nfunction and flat list of arguments. You are responsible for implementing the\nbroadcasting shape rules yourself, but this may be helpful in limited situations.\nIterating over the CartesianIndices of the axes(::Broadcasted) and using\nindexing with the resulting CartesianIndex object to compute the result."},{"title":"Writing binary broadcasting rules","page":"Interfaces","location":"manual/interfaces.html#writing-binary-broadcasting-rules","category":"section","text":"The precedence rules are defined by binary BroadcastStyle calls:\n\nBase.BroadcastStyle(::Style1, ::Style2) = Style12()\n\nwhere Style12 is the BroadcastStyle you want to choose for outputs involving\narguments of Style1 and Style2. For example,\n\nBase.BroadcastStyle(::Broadcast.Style{Tuple}, ::Broadcast.AbstractArrayStyle{0}) = Broadcast.Style{Tuple}()\n\nindicates that Tuple \"wins\" over zero-dimensional arrays (the output container will be a tuple).\nIt is worth noting that you do not need to (and should not) define both argument orders\nof this call; defining one is sufficient no matter what order the user supplies the arguments in.\n\nFor AbstractArray types, defining a BroadcastStyle supersedes the fallback choice,\nBroadcast.DefaultArrayStyle. DefaultArrayStyle and the abstract supertype, AbstractArrayStyle, store the dimensionality as a type parameter to support specialized\narray types that have fixed dimensionality requirements.\n\nDefaultArrayStyle \"loses\" to any other\nAbstractArrayStyle that has been defined because of the following methods:\n\nBroadcastStyle(a::AbstractArrayStyle{Any}, ::DefaultArrayStyle) = a\nBroadcastStyle(a::AbstractArrayStyle{N}, ::DefaultArrayStyle{N}) where N = a\nBroadcastStyle(a::AbstractArrayStyle{M}, ::DefaultArrayStyle{N}) where {M,N} =\n    typeof(a)(Val(max(M, N)))\n\nYou do not need to write binary BroadcastStyle\nrules unless you want to establish precedence for\ntwo or more non-DefaultArrayStyle types.\n\nIf your array type does have fixed dimensionality requirements, then you should\nsubtype AbstractArrayStyle. For example, the sparse array code has the following definitions:\n\nstruct SparseVecStyle <: Broadcast.AbstractArrayStyle{1} end\nstruct SparseMatStyle <: Broadcast.AbstractArrayStyle{2} end\nBase.BroadcastStyle(::Type{<:SparseVector}) = SparseVecStyle()\nBase.BroadcastStyle(::Type{<:SparseMatrixCSC}) = SparseMatStyle()\n\nWhenever you subtype AbstractArrayStyle, you also need to define rules for combining\ndimensionalities, by creating a constructor for your style that takes a Val(N) argument.\nFor example:\n\nSparseVecStyle(::Val{0}) = SparseVecStyle()\nSparseVecStyle(::Val{1}) = SparseVecStyle()\nSparseVecStyle(::Val{2}) = SparseMatStyle()\nSparseVecStyle(::Val{N}) where N = Broadcast.DefaultArrayStyle{N}()\n\nThese rules indicate that the combination of a SparseVecStyle with 0- or 1-dimensional arrays\nyields another SparseVecStyle, that its combination with a 2-dimensional array\nyields a SparseMatStyle, and anything of higher dimensionality falls back to the dense arbitrary-dimensional framework.\nThese rules allow broadcasting to keep the sparse representation for operations that result\nin one or two dimensional outputs, but produce an Array for any other dimensionality."},{"title":"Instance Properties","page":"Interfaces","location":"manual/interfaces.html#man-instance-properties","category":"section","text":"Methods to implement Default definition Brief description\npropertynames(x::ObjType, private::Bool=false) fieldnames(typeof(x)) Return a tuple of the properties (x.property) of an object x. If private=true, also return property names intended to be kept as private\ngetproperty(x::ObjType, s::Symbol) getfield(x, s) Return property s of x. x.s calls getproperty(x, :s).\nsetproperty!(x::ObjType, s::Symbol, v) setfield!(x, s, v) Set property s of x to v. x.s = v calls setproperty!(x, :s, v). Should return v.\n\nSometimes, it is desirable to change how the end-user interacts with the fields of an object.\nInstead of granting direct access to type fields, an extra layer of abstraction between\nthe user and the code can be provided by overloading object.field. Properties are what the\nuser sees of the object, fields what the object actually is.\n\nBy default, properties and fields are the same. However, this behavior can be changed.\nFor example, take this representation of a point in a plane in polar coordinates:\n\njulia> mutable struct Point\n           r::Float64\n           ϕ::Float64\n       end\n\njulia> p = Point(7.0, pi/4)\nPoint(7.0, 0.7853981633974483)\n\nAs described in the table above dot access p.r is the same as getproperty(p, :r) which is by default the same as getfield(p, :r):\n\njulia> propertynames(p)\n(:r, :ϕ)\n\njulia> getproperty(p, :r), getproperty(p, :ϕ)\n(7.0, 0.7853981633974483)\n\njulia> p.r, p.ϕ\n(7.0, 0.7853981633974483)\n\njulia> getfield(p, :r), getproperty(p, :ϕ)\n(7.0, 0.7853981633974483)\n\nHowever, we may want users to be unaware that Point stores the coordinates as r and ϕ (fields),\nand instead interact with x and y (properties). The methods in the first column can be\ndefined to add new functionality:\n\njulia> Base.propertynames(::Point, private::Bool=false) = private ? (:x, :y, :r, :ϕ) : (:x, :y)\n\njulia> function Base.getproperty(p::Point, s::Symbol)\n           if s === :x\n               return getfield(p, :r) * cos(getfield(p, :ϕ))\n           elseif s === :y\n               return getfield(p, :r) * sin(getfield(p, :ϕ))\n           else\n               # This allows accessing fields with p.r and p.ϕ\n               return getfield(p, s)\n           end\n       end\n\njulia> function Base.setproperty!(p::Point, s::Symbol, f)\n           if s === :x\n               y = p.y\n               setfield!(p, :r, sqrt(f^2 + y^2))\n               setfield!(p, :ϕ, atan(y, f))\n               return f\n           elseif s === :y\n               x = p.x\n               setfield!(p, :r, sqrt(x^2 + f^2))\n               setfield!(p, :ϕ, atan(f, x))\n               return f\n           else\n               # This allow modifying fields with p.r and p.ϕ\n               return setfield!(p, s, f)\n           end\n       end\n\nIt is important that getfield and setfield are used inside getproperty and setproperty! instead of the dot syntax,\nsince the dot syntax would make the functions recursive which can lead to type inference issues. We can now\ntry out the new functionality:\n\njulia> propertynames(p)\n(:x, :y)\n\njulia> p.x\n4.949747468305833\n\njulia> p.y = 4.0\n4.0\n\njulia> p.r\n6.363961030678928\n\nFinally, it is worth noting that adding instance properties like this is quite\nrarely done in Julia and should in general only be done if there is a good\nreason for doing so."},{"title":"Rounding","page":"Interfaces","location":"manual/interfaces.html#man-rounding-interface","category":"section","text":"Methods to implement Default definition Brief description\nround(x::ObjType, r::RoundingMode) none Round x and return the result. If possible, round should return an object of the same type as x\nround(T::Type, x::ObjType, r::RoundingMode) convert(T, round(x, r)) Round x, returning the result as a T\n\nTo support rounding on a new type it is typically sufficient to define the single method\nround(x::ObjType, r::RoundingMode). The passed rounding mode determines in which direction\nthe value should be rounded. The most commonly used rounding modes are RoundNearest,\nRoundToZero, RoundDown, and RoundUp, as these rounding modes are used in the\ndefinitions of the one argument round, method, and trunc, floor, and ceil,\nrespectively.\n\nIn some cases, it is possible to define a three-argument round method that is more\naccurate or performant than the two-argument method followed by conversion. In this case it\nis acceptable to define the three argument method in addition to the two argument method.\nIf it is impossible to represent the rounded result as an object of the type T,\nthen the three argument method should throw an InexactError.\n\nFor example, if we have an Interval type which represents a range of possible values\nsimilar to https://github.com/JuliaPhysics/Measurements.jl, we may define rounding on that\ntype with the following\n\njulia> struct Interval{T}\n           min::T\n           max::T\n       end\n\njulia> Base.round(x::Interval, r::RoundingMode) = Interval(round(x.min, r), round(x.max, r))\n\njulia> x = Interval(1.7, 2.2)\nInterval{Float64}(1.7, 2.2)\n\njulia> round(x)\nInterval{Float64}(2.0, 2.0)\n\njulia> floor(x)\nInterval{Float64}(1.0, 2.0)\n\njulia> ceil(x)\nInterval{Float64}(2.0, 3.0)\n\njulia> trunc(x)\nInterval{Float64}(1.0, 2.0)"},{"title":"Future","page":"Future","location":"stdlib/Future.html#Future","category":"section","text":"The Future module implements future behavior of already existing functions,\nwhich will replace the current version in a future release of Julia."},{"title":"Future.copy!","page":"Future","location":"stdlib/Future.html#Future.copy!","category":"function","text":"Future.copy!(dst, src) -> dst\n\nCopy src into dst.\n\ncompat: Julia 1.1\nThis function has moved to Base with Julia 1.1, consider using copy!(dst, src) instead.\nFuture.copy! will be deprecated in the future.\n\n\n\n\n\n"},{"title":"Future.randjump","page":"Future","location":"stdlib/Future.html#Future.randjump","category":"function","text":"randjump(r::MersenneTwister, steps::Integer)::MersenneTwister\n\nCreate an initialized MersenneTwister object, whose state is moved forward\n(without generating numbers) from r by steps steps.\nOne such step corresponds to the generation of two Float64 numbers.\nFor each different value of steps, a large polynomial has to be generated internally.\nOne is already pre-computed for steps=big(10)^20.\n\n\n\n\n\n"},{"title":"Modules","page":"Modules","location":"manual/modules.html#modules","category":"section","text":"Modules in Julia help organize code into coherent units. They are delimited syntactically inside\nmodule NameOfModule ... end, and have the following features:\n\nModules are separate namespaces, each introducing a new global scope. This is useful, because it\nallows the same name to be used for different functions or global variables without conflict, as long as they are in separate modules.\nModules have facilities for detailed namespace management: each defines a set of names it\nexports and marks as public, and can import names from other modules with using and\nimport (we explain these below).\nModules can be precompiled for faster loading, and may contain code for runtime initialization.\n\nTypically, in larger Julia packages you will see module code organized into files, eg\n\nmodule SomeModule\n\n# export, public, using, import statements are usually here; we discuss these below\n\ninclude(\"file1.jl\")\ninclude(\"file2.jl\")\n\nend\n\nFiles and file names are mostly unrelated to modules; modules are associated only with module\nexpressions. One can have multiple files per module, and multiple modules per file. include\nbehaves as if the contents of the source file were evaluated in the global scope of the\nincluding module. In this chapter, we use short and simplified examples, so we won't use include.\n\nThe recommended style is not to indent the body of the module, since that would typically lead to\nwhole files being indented. Also, it is common to use UpperCamelCase for module names (just like\ntypes), and use the plural form if applicable, especially if the module contains a similarly named\nidentifier, to avoid name clashes. For example,\n\nmodule FastThings\n\nstruct FastThing\n    ...\nend\n\nend"},{"title":"Namespace management","page":"Modules","location":"manual/modules.html#namespace-management","category":"section","text":"Namespace management refers to the facilities the language offers for making names in a module\navailable in other modules. We discuss the related concepts and functionality below in detail."},{"title":"Qualified names","page":"Modules","location":"manual/modules.html#Qualified-names","category":"section","text":"Names for functions, variables and types in the global scope like sin, ARGS, and\nUnitRange always belong to a module, called the parent module, which can be found\ninteractively with parentmodule, for example\n\njulia> parentmodule(UnitRange)\nBase\n\nOne can also refer to these names outside their parent module by prefixing them with their module,\neg Base.UnitRange. This is called a qualified name. The parent module may be accessible using a\nchain of submodules like Base.Math.sin, where Base.Math is called the module path.\nDue to syntactic ambiguities, qualifying a name that contains only symbols, such as an operator,\nrequires inserting a colon, e.g. Base.:+. A small number of operators additionally require\nparentheses, e.g. Base.:(==).\n\nIf a name is qualified, then it is always accessible, and in case of a function, it can also have\nmethods added to it by using the qualified name as the function name.\n\nWithin a module, a variable name can be “reserved” without assigning to it by declaring it as\nglobal x. This prevents name conflicts for globals initialized after load time. The syntax\nM.x = y does not work to assign a global in another module; global assignment is always\nmodule-local."},{"title":"Export lists","page":"Modules","location":"manual/modules.html#Export-lists","category":"section","text":"Names (referring to functions, types, global variables, and constants) can be added to the\nexport list of a module with export: these are the symbols that are imported when using the module. Typically, they are at or near the top of the module definition\nso that readers of the source code can find them easily, as in\n\njulia> module NiceStuff\n       export nice, DOG\n       struct Dog end      # singleton type, not exported\n       const DOG = Dog()   # named instance, exported\n       nice(x) = \"nice $x\" # function, exported\n       end;\n\n\nbut this is just a style suggestion — a module can have multiple export statements in arbitrary\nlocations.\n\nIt is common to export names which form part of the API (application programming interface). In\nthe above code, the export list suggests that users should use nice and DOG. However, since\nqualified names always make identifiers accessible, this is just an option for organizing APIs:\nunlike other languages, Julia has no facilities for truly hiding module internals.\n\nAlso, some modules don't export names at all. This is usually done if they use common\nwords, such as derivative, in their API, which could easily clash with the export lists of other\nmodules. We will see how to manage name clashes below.\n\nTo mark a name as public without exporting it into the namespace of folks who call using NiceStuff,\none can use public instead of export. This marks the public name(s) as part of the public API,\nbut does not have any namespace implications. The public keyword is only available in Julia 1.11\nand above. To maintain compatibility with Julia 1.10 and below, use the @compat macro from the\nCompat package, or the version-aware construct\n\nVERSION >= v\"1.11.0-DEV.469\" && eval(Meta.parse(\"public a, b, c\"))\n\nexport is a keyword wherever it occurs whereas the public keyword is currently limited to the\nsyntactic top level within a file or module. This limitation exists for compatibility reasons,\nas public was introduced as a new keyword in Julia 1.11 while export has existed since Julia\n1.0. However, this restriction on public may be lifted in future releases, so do not use public\nas an identifier."},{"title":"Standalone using and import","page":"Modules","location":"manual/modules.html#Standalone-using-and-import","category":"section","text":"For interactive use, the most common way of loading a module is using ModuleName. This [loads](@ref\ncode-loading) the code associated with ModuleName, and brings\n\nthe module name\nand the elements of the export list into the surrounding global namespace.\n\nTechnically, the statement using ModuleName means that a module called ModuleName will be\navailable for resolving names as needed. When a global variable is encountered that has no\ndefinition in the current module, the system will search for it among variables exported by ModuleName\nand use it if it is found there. This means that all uses of that global within the current\nmodule will resolve to the definition of that variable in ModuleName.\n\nTo load a module from a package, the statement using ModuleName can be used.\nTo load a module from a locally defined module, a dot needs to be added before the module name like using .ModuleName.\n\nTo continue with our example,\n\njulia> using .NiceStuff\n\nwould load the above code, making NiceStuff (the module name), DOG and nice available. Dog is not on the export list, but it can be accessed if the name is qualified with the module path (which here is just the module name) as NiceStuff.Dog.\n\nImportantly, using ModuleName is the only form for which export lists matter at all.\n\nIn contrast,\n\njulia> import .NiceStuff\n\nbrings only the module name into scope. Users would need to use NiceStuff.DOG, NiceStuff.Dog, and NiceStuff.nice to access its contents.\nAs we will see in the next section import .NiceStuff is equivalent to using .NiceStuff: NiceStuff. Usually, import ModuleName or using ModuleName: ModuleName is used in contexts when the user wants to keep the namespace clean.\n\nYou can combine multiple using and import statements of the same kind in a comma-separated expression, e.g.\n\njulia> using LinearAlgebra, Random"},{"title":"using and import with specific identifiers, and adding methods","page":"Modules","location":"manual/modules.html#using-and-import-with-specific-identifiers,-and-adding-methods","category":"section","text":"When using ModuleName: or import ModuleName: is followed by a comma-separated list of names, the module is loaded, but only those specific names are brought into the namespace by the statement. For example,\n\njulia> using .NiceStuff: nice, DOG\n\nwill import the names nice and DOG.\n\nImportantly, the module name NiceStuff will not be in the namespace. If you want to make it accessible, you have to list it explicitly, as\n\njulia> using .NiceStuff: nice, DOG, NiceStuff\n\nWhen two or more packages/modules export a name and that name does not refer to the\nsame thing in each of the packages, and the packages are loaded via using without\nan explicit list of names, it is an error to reference that name without qualification.\nIt is thus recommended that code intended to be forward-compatible with future versions\nof its dependencies and of Julia, e.g., code in released packages, list the names it\nuses from each loaded package, e.g., using Foo: Foo, f rather than using Foo.\n\nJulia has two forms for seemingly the same thing because only import ModuleName: f allows adding methods to f\nwithout a module path.\nThat is to say, the following example will give an error:\n\njulia> using .NiceStuff: nice\n\njulia> struct Cat end\n\njulia> nice(::Cat) = \"nice 😸\"\nERROR: invalid method definition in Main: function NiceStuff.nice must be explicitly imported to be extended\nStacktrace:\n [1] top-level scope\n   @ none:1\n\nThis error prevents accidentally adding methods to functions in other modules that you only intended to use.\n\nThere are two ways to deal with this. You can always qualify function names with a module path:\n\njulia> using .NiceStuff\n\njulia> struct Cat end\n\njulia> NiceStuff.nice(::Cat) = \"nice 😸\"\n\nAlternatively, you can import the specific function name:\n\njulia> import .NiceStuff: nice\n\njulia> struct Mouse end\n\njulia> nice(::Mouse) = \"nice 🐭\"\nnice (generic function with 3 methods)\n\nWhich one you choose is a matter of style. The first form makes it clear that you are adding a\nmethod to a function in another module (remember, that the imports and the method definition may be\nin separate files), while the second one is shorter, which is especially convenient if you are\ndefining multiple methods.\n\nOnce a variable is made visible via using or import, a module may not create its own variable\nwith the same name. Imported variables are read-only; assigning to a global variable always affects\na variable owned by the current module, or else raises an error."},{"title":"Renaming with as","page":"Modules","location":"manual/modules.html#Renaming-with-as","category":"section","text":"An identifier brought into scope by import or using can be renamed with the keyword as.\nThis is useful for working around name conflicts as well as for shortening names.\nFor example, Base exports the function name read, but the CSV.jl package also provides CSV.read.\nIf we are going to invoke CSV reading many times, it would be convenient to drop the CSV. qualifier.\nBut then it is ambiguous whether we are referring to Base.read or CSV.read:\n\njulia> read;\n\njulia> import CSV: read\nWARNING: ignoring conflicting import of CSV.read into Main\n\nRenaming provides a solution:\n\njulia> import CSV: read as rd\n\nImported packages themselves can also be renamed:\n\nimport BenchmarkTools as BT\n\nas works with using only when a single identifier is brought into scope.\nFor example using CSV: read as rd works, but using CSV as C does not, since it operates\non all of the exported names in CSV."},{"title":"Mixing multiple using and import statements","page":"Modules","location":"manual/modules.html#Mixing-multiple-using-and-import-statements","category":"section","text":"When multiple using or import statements of any of the forms above are used, their effect is combined in the order they appear.\nFor example,\n\njulia> using .NiceStuff         # exported names and the module name\n\njulia> import .NiceStuff: nice  # allows adding methods to unqualified functions\n\n\nwould bring all the exported names of NiceStuff and the module name itself into scope, and also\nallow adding methods to nice without prefixing it with a module name."},{"title":"Handling name conflicts","page":"Modules","location":"manual/modules.html#Handling-name-conflicts","category":"section","text":"Consider the situation where two (or more) packages export the same name, as in\n\njulia> module A\n       export f\n       f() = 1\n       end\nA\njulia> module B\n       export f\n       f() = 2\n       end\nB\n\nThe statement using .A, .B works, but when you try to call f, you get an error with a hint\n\njulia> using .A, .B\n\njulia> f\nERROR: UndefVarError: `f` not defined in `Main`\nHint: It looks like two or more modules export different bindings with this name, resulting in ambiguity. Try explicitly importing it from a particular module, or qualifying the name with the module it should come from.\n\nHere, Julia cannot decide which f you are referring to, so you have to make a choice. The following solutions are commonly used:\n\nSimply proceed with qualified names like A.f and B.f. This makes the context clear to the reader of your code, especially if f just happens to coincide but has different meaning in various packages. For example, degree has various uses in mathematics, the natural sciences, and in everyday life, and these meanings should be kept separate.\nUse the as keyword above to rename one or both identifiers, eg\njulia> using .A: f as f\n\njulia> using .B: f as g\n\nwould make B.f available as g. Here, we are assuming that you did not use using A before,\nwhich would have brought f into the namespace.\nWhen the names in question do share a meaning, it is common for one module to import it from another, or have a lightweight “base” package with the sole function of defining an interface like this, which can be used by other packages. It is conventional to have such package names end in ...Base (which has nothing to do with Julia's Base module)."},{"title":"Precedence order of definitions","page":"Modules","location":"manual/modules.html#Precedence-order-of-definitions","category":"section","text":"There are in general four kinds of binding definitions:\n\nThose provided via implicit import through using M\nThose provided via explicit import (e.g. using M: x, import M: x)\nThose declared implicitly as global (via global x without type specification)\nThose declared explicitly using definition syntax (const, global x::T, struct, etc.)\n\nSyntactically, we divide these into three precedence levels (from weakest to strongest)\n\nImplicit imports\nImplicit declarations\nExplicit declarations and imports\n\nIn general, we permit replacement of weaker bindings by stronger ones:\n\njulia> module M1; const x = 1; export x; end\nMain.M1\n\njulia> using .M1\n\njulia> x # Implicit import from M1\n1\n\njulia> begin; f() = (global x; x = 1) end\n\njulia> x # Implicit declaration\nERROR: UndefVarError: `x` not defined in `Main`\nSuggestion: add an appropriate import or assignment. This global was declared but not assigned.\n\njulia> const x = 2 # Explicit declaration\n2\n\nHowever, within the explicit precedence level, replacement is syntactically disallowed:\n\njulia> module M1; const x = 1; export x; end\nMain.M1\n\njulia> import .M1: x\n\njulia> const x = 2\nERROR: cannot declare Main.x constant; it was already declared as an import\nStacktrace:\n [1] top-level scope\n   @ REPL[3]:1\n\nor ignored:\n\njulia> const y = 2\n2\n\njulia> import .M1: x as y\nWARNING: import of M1.x into Main conflicts with an existing identifier; ignored.\n\nThe resolution of an implicit binding depends on the set of all using'd modules visible\nin the current world age. See the manual chapter on world age for more\ndetails."},{"title":"Default top-level definitions and bare modules","page":"Modules","location":"manual/modules.html#Default-top-level-definitions-and-bare-modules","category":"section","text":"Modules automatically contain using Core, using Base, and definitions of the eval\nand include functions, which evaluate expressions/files within the global scope of that\nmodule.\n\nIf these default definitions are not wanted, modules can be defined using the keyword\nbaremodule instead (note: Core is still imported). In terms of\nbaremodule, a standard module looks like this:\n\nbaremodule Mod\n\nusing Base\n\neval(x) = Core.eval(Mod, x)\ninclude(p) = Base.include(Mod, p)\n\n...\n\nend\n\nIf even Core is not wanted, a module that imports nothing and defines no names at all can be defined with Module(:YourNameHere, false, false) and code can be evaluated into it with @eval or Core.eval:\n\njulia> arithmetic = Module(:arithmetic, false, false)\nMain.arithmetic\n\njulia> @eval arithmetic add(x, y) = $(+)(x, y)\nadd (generic function with 1 method)\n\njulia> arithmetic.add(12, 13)\n25"},{"title":"Standard modules","page":"Modules","location":"manual/modules.html#Standard-modules","category":"section","text":"There are three important standard modules:\n\nCore contains all functionality \"built into\" the language.\nBase contains basic functionality that is useful in almost all cases.\nMain is the top-level module and the current module, when Julia is started.\n\nnote: Standard library modules\nBy default Julia ships with some standard library modules. These behave like regular\nJulia packages except that you don't need to install them explicitly. For example,\nif you wanted to perform some unit testing, you could load the Test standard library\nas follows:using Test"},{"title":"Submodules and relative paths","page":"Modules","location":"manual/modules.html#Submodules-and-relative-paths","category":"section","text":"Modules can contain submodules, nesting the same syntax module ... end. They can be used to introduce separate namespaces, which can be helpful for organizing complex codebases. Note that each module introduces its own scope, so submodules do not automatically “inherit” names from their parent.\n\nIt is recommended that submodules refer to other modules within the enclosing parent module (including the latter) using relative module qualifiers in using and import statements. A relative module qualifier starts with a period (.), which corresponds to the current module, and each successive . leads to the parent of the current module. This should be followed by modules if necessary, and eventually the actual name to access, all separated by .s. As a special case, however, referring to the module root can be written without ., avoiding the need to count the depth to reach that module.\n\nConsider the following example, where the submodule SubA defines a function, which is then extended in its “sibling” module:\n\njulia> module ParentModule\n       module SubA\n       export add_D  # exported interface\n       const D = 3\n       add_D(x) = x + D\n       end\n       using .SubA  # brings `add_D` into the namespace\n       export add_D # export it from ParentModule too\n       module SubB\n       import ..SubA: add_D # relative path for a “sibling” module\n       # import ParentModule.SubA: add_D # when in a package, such as when this is loaded by using or import, this would be equivalent to the previous import, but not at the REPL\n       struct Infinity end\n       add_D(x::Infinity) = x\n       end\n       end;\n\n\nYou may see code in packages, which, in a similar situation, uses import without the .:\n\njulia> import ParentModule.SubA: add_D\nERROR: ArgumentError: Package ParentModule not found in current path.\n\nHowever, since this operates through code loading, it only works if ParentModule is in a package in a file. If ParentModule was defined at the REPL, it is necessary to use use relative paths:\n\njulia> import .ParentModule.SubA: add_D\n\n\nNote that the order of definitions also matters if you are evaluating values. Consider\n\nmodule TestPackage\n\nexport x, y\n\nx = 0\n\nmodule Sub\nusing ..TestPackage\nz = y # ERROR: UndefVarError: `y` not defined in `Main`\nend\n\ny = 1\n\nend\n\nwhere Sub is trying to use TestPackage.y before it was defined, so it does not have a value.\n\nFor similar reasons, you cannot use a cyclic ordering:\n\nmodule A\n\nmodule B\nusing ..C # ERROR: UndefVarError: `C` not defined in `Main.A`\nend\n\nmodule C\nusing ..B\nend\n\nend"},{"title":"Module initialization and precompilation","page":"Modules","location":"manual/modules.html#Module-initialization-and-precompilation","category":"section","text":"Large modules can take several seconds to load because executing all of the statements in a module\noften involves compiling a large amount of code.\nJulia creates precompiled caches of the module to reduce this time.\n\nPrecompiled module files (sometimes called \"cache files\") are created and used automatically when import or using loads a module. If the cache file(s) do not yet exist, the module will be compiled and saved for future reuse. You can also manually call Base.compilecache(Base.identify_package(\"modulename\")) to create these files without loading the module. The resulting\ncache files will be stored in the compiled subfolder of DEPOT_PATH[1]. If nothing about your system changes,\nsuch cache files will be used when you load the module with import or using.\n\nPrecompilation cache files store definitions of modules, types, methods, and constants. They may also store method specializations and the code generated for them, but this typically requires that the developer add explicit precompile directives or execute workloads that force compilation during the package build.\n\nHowever, if you update the module's dependencies or change its source code, the module is automatically\nrecompiled upon using or import. Dependencies are modules it\nimports, the Julia build, files it includes, or explicit dependencies declared by include_dependency(path)\nin the module file(s).\n\nFor file dependencies loaded by include, a change is determined by examining whether the\nfile size (fsize) or content (condensed into a hash) is unchanged.\nFor file dependencies loaded by include_dependency a change is determined by examining whether the modification time (mtime)\nis unchanged, or equal to the modification time truncated to the nearest second\n(to accommodate systems that can't copy mtime with sub-second accuracy).\nIt also takes into account whether the path to the file chosen\nby the search logic in require matches the path that had created the precompile file. It also takes\ninto account the set of dependencies already loaded into the current process and won't recompile those\nmodules, even if their files change or disappear, in order to avoid creating incompatibilities between\nthe running system and the precompile cache.\nFinally, it takes account of changes in any compile-time preferences.\n\nIf you know that a module is not safe to precompile\n(for example, for one of the reasons described below), you should\nput __precompile__(false) in the module file (typically placed at the top).\nThis will cause Base.compilecache to throw an error, and will cause using / import to load it\ndirectly into the current process and skip the precompile and caching.\nThis also thereby prevents the module from being imported by any other precompiled module.\n\nYou may need to be aware of certain behaviors inherent in the creation of incremental shared libraries\nwhich may require care when writing your module. For example, external state is not preserved.\nTo accommodate this, explicitly separate any initialization steps that must occur at runtime\nfrom steps that can occur at compile time.\nFor this purpose, Julia allows you to define an __init__() function in your module that executes\nany initialization steps that must occur at runtime.\nThis function will not be called during compilation (--output-*).\nEffectively, you can assume it will be run exactly once in the lifetime of the code.\nYou may, of course, call it manually if necessary, but the default is to assume this function deals with computing\nstate for the local machine, which does not need to be – or even should not be – captured\nin the compiled image. It will be called after the module is loaded into a process, including\nif it is being loaded into an incremental compile (--output-incremental=yes), but not if it\nis being loaded into a full-compilation process.\n\nIn particular, if you define a function __init__() in a module, then Julia will call __init__()\nimmediately after the module is loaded (e.g., by import, using, or require) at runtime\nfor the first time (i.e., __init__ is only called once, and only after all statements in the\nmodule have been executed). Because it is called after the module is fully imported, any submodules\nor other imported modules have their __init__ functions called before the __init__ of\nthe enclosing module. This is also synchronized across threads, so that code can safely rely upon\nthis ordering of effects, such that all __init__ will have run, in dependency ordering,\nbefore the using result is completed. They may run concurrently with other __init__\nmethods which are not dependencies however, so be careful when accessing any shared state\noutside the current module to use locks when needed.\n\nTwo typical uses of __init__ are calling runtime initialization functions of external C libraries\nand initializing global constants that involve pointers returned by external libraries. For example,\nsuppose that we are calling a C library libfoo that requires us to call a foo_init() initialization\nfunction at runtime. Suppose that we also want to define a global constant foo_data_ptr that\nholds the return value of a void *foo_data() function defined by libfoo – this constant must\nbe initialized at runtime (not at compile time) because the pointer address will change from run\nto run. You could accomplish this by defining the following __init__ function in your module:\n\nconst foo_data_ptr = Ref{Ptr{Cvoid}}(0)\nfunction __init__()\n    ccall((:foo_init, :libfoo), Cvoid, ())\n    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())\n    nothing\nend\n\nNotice that it is perfectly possible to define a global inside a function like __init__; this\nis one of the advantages of using a dynamic language. But by making it a constant at global scope,\nwe can ensure that the type is known to the compiler and allow it to generate better optimized\ncode. Obviously, any other globals in your module that depends on foo_data_ptr would also have\nto be initialized in __init__.\n\nConstants involving most Julia objects that are not produced by ccall do not need to be placed\nin __init__: their definitions can be precompiled and loaded from the cached module image. This\nincludes complicated heap-allocated objects like arrays. However, any routine that returns a raw\npointer value must be called at runtime for precompilation to work (Ptr objects will turn into\nnull pointers unless they are hidden inside an isbits object). This includes the return values\nof the Julia functions @cfunction and pointer.\n\nWhen using precompilation, it is important to keep a clear sense of the distinction between the\ncompilation phase and the execution phase. In this mode, it will often be much more clearly apparent\nthat Julia is a compiler which allows execution of arbitrary Julia code, not a standalone interpreter\nthat also generates compiled code.\n\nOther known potential failure scenarios include:\n\nGlobal counters (for example, for attempting to uniquely identify objects). Consider the following\ncode snippet:\nmutable struct UniquedById\n    myid::Int\n    let counter = 0\n        UniquedById() = new(counter += 1)\n    end\nend\nwhile the intent of this code was to give every instance a unique id, the counter value is recorded\nat the end of compilation. All subsequent usages of this incrementally compiled module will start\nfrom that same counter value.\nNote that objectid (which works by hashing the memory pointer) has similar issues (see notes\non Dict usage below).\nOne alternative is to use a macro to capture @__MODULE__ and store it alone with the current counter value,\nhowever, it may be better to redesign the code to not depend on this global state.\nAssociative collections (such as Dict and Set) need to be re-hashed in __init__. (In the\nfuture, a mechanism may be provided to register an initializer function.)\nDepending on compile-time side-effects persisting through load-time. Example include: modifying\narrays or other variables in other Julia modules; maintaining handles to open files or devices;\nstoring pointers to other system resources (including memory);\nCreating accidental \"copies\" of global state from another module, by referencing it directly instead\nof via its lookup path. For example, (in global scope):\n#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#\n# instead use accessor functions:\ngetstdout() = Base.stdout #= best option =#\n# or move the assignment into the runtime:\n__init__() = global mystdout = Base.stdout #= also works =#\n\nSeveral additional restrictions are placed on the operations that can be done while precompiling\ncode to help the user avoid other wrong-behavior situations:\n\nCalling eval to cause a side-effect in another module. This will also cause a warning to be\nemitted when the incremental precompile flag is set.\nglobal const statements from local scope after __init__() has been started (see issue #12010\nfor plans to add an error for this)\nReplacing a module is a runtime error while doing an incremental precompile.\n\nA few other points to be aware of:\n\nNo code reload / cache invalidation is performed after changes are made to the source files themselves,\n(including by Pkg.update), and no cleanup is done after Pkg.rm\nThe memory sharing behavior of a reshaped array is disregarded by precompilation (each view gets\nits own copy)\nExpecting the filesystem to be unchanged between compile-time and runtime e.g. @__FILE__/source_path()\nto find resources at runtime, or the BinDeps @checked_lib macro. Sometimes this is unavoidable.\nHowever, when possible, it can be good practice to copy resources into the module at compile-time\nso they won't need to be found at runtime.\nWeakRef objects and finalizers are not currently handled properly by the serializer (this will\nbe fixed in an upcoming release).\nIt is usually best to avoid capturing references to instances of internal metadata objects such\nas Method, MethodInstance, MethodTable, TypeMapLevel, TypeMapEntry and fields of those objects,\nas this can confuse the serializer and may not lead to the outcome you desire. It is not necessarily\nan error to do this, but you simply need to be prepared that the system will try to copy some\nof these and to create a single unique instance of others.\n\nIt is sometimes helpful during module development to turn off incremental precompilation.\nThe command line flag --compiled-modules={yes|no|existing} enables you to toggle module\nprecompilation on and off. When Julia is started with --compiled-modules=no the serialized\nmodules in the compile cache are ignored when loading modules and module dependencies. In\nsome cases, you may want to load existing precompiled modules, but not create new ones. This\ncan be done by starting Julia with --compiled-modules=existing. More fine-grained control\nis available with --pkgimages={yes|no|existing}, which only affects native-code storage\nduring precompilation. Base.compilecache can still be called manually. The state of this\ncommand line flag is passed to Pkg.build to disable automatic precompilation triggering\nwhen installing, updating, and explicitly building packages.\n\nYou can also debug some precompilation failures with environment variables. Setting\nJULIA_VERBOSE_LINKING=true may help resolve failures in linking shared libraries of\ncompiled native code. See the Developer Documentation part of the Julia manual, where\nyou will find further details in the section documenting Julia's internals under \"Package\nImages\"."},{"title":"Single- and multi-dimensional Arrays","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#man-multi-dim-arrays","category":"section","text":"Julia, like most technical computing languages, provides a first-class array implementation. Most\ntechnical computing languages pay a lot of attention to their array implementation at the expense\nof other containers. Julia does not treat arrays in any special way. The array library is implemented\nalmost completely in Julia itself, and derives its performance from the compiler, just like any\nother code written in Julia. As such, it's also possible to define custom array types by inheriting\nfrom AbstractArray. See the manual section on the AbstractArray interface\nfor more details on implementing a custom array type.\n\nAn array is a collection of objects stored in a multi-dimensional grid. Zero-dimensional arrays\nare allowed, see this FAQ entry. In the most general case,\nan array may contain objects of type Any. For most computational purposes, arrays should contain\nobjects of a more specific type, such as Float64 or Int32.\n\nIn general, unlike many other technical computing languages, Julia does not expect programs to\nbe written in a vectorized style for performance. Julia's compiler uses type inference and generates\noptimized code for scalar array indexing, allowing programs to be written in a style that is convenient\nand readable, without sacrificing performance, and using less memory at times.\n\nIn Julia, all arguments to functions are [passed by\nsharing](https://en.wikipedia.org/wiki/Evaluationstrategy#Callby_sharing)\n(i.e. by pointers). Some technical computing languages pass arrays by value, and\nwhile this prevents accidental modification by callees of a value in the caller,\nit makes avoiding unwanted copying of arrays difficult. By convention, a\nfunction name ending with a ! indicates that it will mutate or destroy the\nvalue of one or more of its arguments (compare, for example, sort and sort!).\nCallees must make explicit copies to ensure that they don't modify inputs that\nthey don't intend to change. Many non-mutating functions are implemented by\ncalling a function of the same name with an added ! at the end on an explicit\ncopy of the input, and returning that copy."},{"title":"Basic Functions","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#Basic-Functions","category":"section","text":"Function Description\neltype(A) the type of the elements contained in A\nlength(A) the number of elements in A\nndims(A) the number of dimensions of A\nsize(A) a tuple containing the dimensions of A\nsize(A,n) the size of A along dimension n\naxes(A) a tuple containing the valid indices of A\naxes(A,n) a range expressing the valid indices along dimension n\neachindex(A) an efficient iterator for visiting each position in A\nstride(A,k) the stride (linear index distance between adjacent elements) along dimension k\nstrides(A) a tuple of the strides in each dimension"},{"title":"Construction and Initialization","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#Construction-and-Initialization","category":"section","text":"Many functions for constructing and initializing arrays are provided. In the following list of\nsuch functions, calls with a dims... argument can either take a single tuple of dimension sizes\nor a series of dimension sizes passed as a variable number of arguments. Most of these functions\nalso accept a first input T, which is the element type of the array. If the type T is\nomitted it will default to Float64.\n\nFunction Description\nArray{T}(undef, dims...) an uninitialized dense Array\nzeros(T, dims...) an Array of all zeros\nones(T, dims...) an Array of all ones\ntrues(dims...) a BitArray with all values true\nfalses(dims...) a BitArray with all values false\nreshape(A, dims...) an array containing the same data as A, but with different dimensions\ncopy(A) copy A\ndeepcopy(A) copy A, recursively copying its elements\nsimilar(A, T, dims...) an uninitialized array of the same type as A (dense, sparse, etc.), but with the specified element type and dimensions. The second and third arguments are both optional, defaulting to the element type and dimensions of A if omitted.\nreinterpret(T, A) an array with the same binary data as A, but with element type T\nrand(T, dims...) an Array with random, iid [1] and uniformly distributed values. For floating point types T, the values lie in the half-open interval 0 1).\nrandn(T, dims...) an Array with random, iid and standard normally distributed values\nMatrix{T}(I, m, n) m-by-n identity matrix. Requires using LinearAlgebra for I.\nrange(start, stop, n) a range of n linearly spaced elements from start to stop\nfill!(A, x) fill the array A with the value x\nfill(x, dims...) an Array filled with the value x. In particular, fill(x) constructs a zero-dimensional Array containing x.\n\n[1]: iid, independently and identically distributed.\n\nTo see the various ways we can pass dimensions to these functions, consider the following examples:\n\njulia> zeros(Int8, 2, 3)\n2×3 Matrix{Int8}:\n 0  0  0\n 0  0  0\n\njulia> zeros(Int8, (2, 3))\n2×3 Matrix{Int8}:\n 0  0  0\n 0  0  0\n\njulia> zeros((2, 3))\n2×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\nHere, (2, 3) is a Tuple and the first argument — the element type — is optional, defaulting to Float64."},{"title":"Array literals","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#man-array-literals","category":"section","text":"Arrays can also be directly constructed with square braces; the syntax [A, B, C, ...]\ncreates a one-dimensional array (i.e., a vector) containing the comma-separated arguments as\nits elements. The element type (eltype) of the resulting array is automatically\ndetermined by the types of the arguments inside the braces. If all the arguments are the\nsame type, then that is its eltype. If they all have a common\npromotion type then they get converted to that type using\nconvert and that type is the array's eltype. Otherwise, a heterogeneous array\nthat can hold anything — a Vector{Any} — is constructed; this includes the literal []\nwhere no arguments are given. Array literals can be typed with\nthe syntax T[A, B, C, ...] where T is a type.\n\njulia> [1, 2, 3] # An array of `Int`s\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> promote(1, 2.3, 4//5) # This combination of Int, Float64 and Rational promotes to Float64\n(1.0, 2.3, 0.8)\n\njulia> [1, 2.3, 4//5] # Thus that's the element type of this Array\n3-element Vector{Float64}:\n 1.0\n 2.3\n 0.8\n\njulia> Float32[1, 2.3, 4//5] # Specify element type manually\n3-element Vector{Float32}:\n 1.0\n 2.3\n 0.8\n\njulia> []\nAny[]"},{"title":"Concatenation","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#man-array-concatenation","category":"section","text":"If the arguments inside the square brackets are separated by single semicolons (;) or newlines\ninstead of commas, then their contents are vertically concatenated together instead of\nthe arguments being used as elements themselves.\n\njulia> [1:2, 4:5] # Has a comma, so no concatenation occurs. The ranges are themselves the elements\n2-element Vector{UnitRange{Int64}}:\n 1:2\n 4:5\n\njulia> [1:2; 4:5]\n4-element Vector{Int64}:\n 1\n 2\n 4\n 5\n\njulia> [1:2\n        4:5\n        6]\n5-element Vector{Int64}:\n 1\n 2\n 4\n 5\n 6\n\nSimilarly, if the arguments are separated by tabs or spaces or double semicolons, then their contents are\nhorizontally concatenated together.\n\njulia> [1:2  4:5  7:8]\n2×3 Matrix{Int64}:\n 1  4  7\n 2  5  8\n\njulia> [[1,2]  [4,5]  [7,8]]\n2×3 Matrix{Int64}:\n 1  4  7\n 2  5  8\n\njulia> [1 2 3] # Numbers can also be horizontally concatenated\n1×3 Matrix{Int64}:\n 1  2  3\n\njulia> [1;; 2;; 3;; 4]\n1×4 Matrix{Int64}:\n 1  2  3  4\n\nSingle semicolons (or newlines) and spaces (or tabs) can be combined to concatenate\nboth horizontally and vertically at the same time.\n\njulia> [1 2\n        3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> [zeros(Int, 2, 2) [1; 2]\n        [3 4]            5]\n3×3 Matrix{Int64}:\n 0  0  1\n 0  0  2\n 3  4  5\n\njulia> [[1 1]; 2 3; [4 4]]\n3×2 Matrix{Int64}:\n 1  1\n 2  3\n 4  4\n\nSpaces (and tabs) have a higher precedence than semicolons, performing any horizontal\nconcatenations first and then concatenating the result. Using double semicolons for the\nhorizontal concatenation, on the other hand, performs any vertical concatenations before\nhorizontally concatenating the result.\n\njulia> [zeros(Int, 2, 2) ; [3 4] ;; [1; 2] ; 5]\n3×3 Matrix{Int64}:\n 0  0  1\n 0  0  2\n 3  4  5\n\njulia> [1:2; 4;; 1; 3:4]\n3×2 Matrix{Int64}:\n 1  1\n 2  3\n 4  4\n\nJust as ; and ;; concatenate in the first and second dimension, using more semicolons\nextends this same general scheme. The number of semicolons in the separator specifies the\nparticular dimension, so ;;; concatenates in the third dimension, ;;;; in the 4th, and\nso on. Fewer semicolons take precedence, so the lower dimensions are generally concatenated\nfirst.\n\njulia> [1; 2;; 3; 4;; 5; 6;;;\n        7; 8;; 9; 10;; 11; 12]\n2×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\nLike before, spaces (and tabs) for horizontal concatenation have a higher precedence than\nany number of semicolons. Thus, higher-dimensional arrays can also be written by specifying\ntheir rows first, with their elements textually arranged in a manner similar to their layout:\n\njulia> [1 3 5\n        2 4 6;;;\n        7 9 11\n        8 10 12]\n2×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\njulia> [1 2;;; 3 4;;;; 5 6;;; 7 8]\n1×2×2×2 Array{Int64, 4}:\n[:, :, 1, 1] =\n 1  2\n\n[:, :, 2, 1] =\n 3  4\n\n[:, :, 1, 2] =\n 5  6\n\n[:, :, 2, 2] =\n 7  8\n\njulia> [[1 2;;; 3 4];;;; [5 6];;; [7 8]]\n1×2×2×2 Array{Int64, 4}:\n[:, :, 1, 1] =\n 1  2\n\n[:, :, 2, 1] =\n 3  4\n\n[:, :, 1, 2] =\n 5  6\n\n[:, :, 2, 2] =\n 7  8\n\nAlthough they both mean concatenation in the second dimension, spaces (or tabs) and ;;\ncannot appear in the same array expression unless the double semicolon is simply serving as\na \"line continuation\" character. This allows a single horizontal concatenation to span\nmultiple lines (without the line break being interpreted as a vertical concatenation).\n\njulia> [1 2 ;;\n       3 4]\n1×4 Matrix{Int64}:\n 1  2  3  4\n\nTerminating semicolons may also be used to add trailing length 1 dimensions.\n\njulia> [1;;]\n1×1 Matrix{Int64}:\n 1\n\njulia> [2; 3;;;]\n2×1×1 Array{Int64, 3}:\n[:, :, 1] =\n 2\n 3\n\nMore generally, concatenation can be accomplished through the cat function.\nThese syntaxes are shorthands for function calls that themselves are convenience functions:\n\nSyntax Function Description\n cat concatenate input arrays along dimension(s) k\n[A; B; C; ...] vcat shorthand for cat(A...; dims=1)\n[A B C ...] hcat shorthand for cat(A...; dims=2)\n[A B; C D; ...] hvcat simultaneous vertical and horizontal concatenation\n[A; C;; B; D;;; ...] hvncat simultaneous n-dimensional concatenation, where number of semicolons indicate the dimension to concatenate"},{"title":"Typed array literals","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#man-array-typed-literal","category":"section","text":"An array with a specific element type can be constructed using the syntax T[A, B, C, ...]. This\nwill construct a 1-d array with element type T, initialized to contain elements A, B, C,\netc. For example, Any[x, y, z] constructs a heterogeneous array that can contain any values.\n\nConcatenation syntax can similarly be prefixed with a type to specify the element type of the\nresult.\n\njulia> [[1 2] [3 4]]\n1×4 Matrix{Int64}:\n 1  2  3  4\n\njulia> Int8[[1 2] [3 4]]\n1×4 Matrix{Int8}:\n 1  2  3  4"},{"title":"Comprehensions","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#man-comprehensions","category":"section","text":"Comprehensions provide a general and powerful way to construct arrays. Comprehension syntax is\nsimilar to set construction notation in mathematics:\n\nA = [ F(x, y, ...) for x=rx, y=ry, ... ]\n\nThe meaning of this form is that F(x,y,...) is evaluated with the variables x, y, etc. taking\non each value in their given list of values. Values can be specified as any iterable object, but\nwill commonly be ranges like 1:n or 2:(n-1), or explicit arrays of values like [1.2, 3.4, 5.7].\nThe result is an N-d dense array with dimensions that are the concatenation of the dimensions\nof the variable ranges rx, ry, etc. and each F(x,y,...) evaluation returns a scalar.\n\nThe following example computes a weighted average of the current element and its left and right\nneighbor along a 1-d grid:\n\njulia> x = [4, 8, 2, 6, 10, 10, 2, 8]\n8-element Vector{Int64}:\n  4\n  8\n  2\n  6\n 10\n 10\n  2\n  8\n\njulia> [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]\n6-element Vector{Float64}:\n 5.5\n 4.5\n 6.0\n 9.0\n 8.0\n 5.5\n\nThe resulting array type depends on the types of the computed elements just like array literals do. In order to control the\ntype explicitly, a type can be prepended to the comprehension. For example, we could have requested\nthe result in single precision by writing:\n\nFloat32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]"},{"title":"Generator Expressions","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#man-generators","category":"section","text":"Comprehensions can also be written without the enclosing square brackets, producing an object\nknown as a generator. This object can be iterated to produce values on demand, instead of allocating\nan array and storing them in advance (see Iteration). For example, the following expression\nsums a series without allocating memory:\n\njulia> sum(1/n^2 for n=1:1000)\n1.6439345666815615\n\nWhen writing a generator expression with multiple dimensions inside an argument list, parentheses\nare needed to separate the generator from subsequent arguments:\n\njulia> map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])\nERROR: ParseError:\n# Error @ none:1:44\nmap(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])\n#                                          └ ── invalid iteration spec: expected one of `=` `in` or `∈`\n\nAll comma-separated expressions after for are interpreted as ranges. Adding parentheses lets\nus add a third argument to map:\n\njulia> map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])\n2×2 Matrix{Tuple{Float64, Int64}}:\n (0.5, 1)       (0.333333, 3)\n (0.333333, 2)  (0.25, 4)\n\nGenerators are implemented via inner functions. Just like\ninner functions used elsewhere in the language, variables from the enclosing scope can be\n\"captured\" in the inner function. For example, sum(p[i] - q[i] for i=1:n)\ncaptures the three variables p, q and n from the enclosing scope.\nCaptured variables can present performance challenges; see\nperformance tips.\n\nRanges in generators and comprehensions can depend on previous ranges by writing multiple for\nkeywords:\n\njulia> [(i, j) for i=1:3 for j=1:i]\n6-element Vector{Tuple{Int64, Int64}}:\n (1, 1)\n (2, 1)\n (2, 2)\n (3, 1)\n (3, 2)\n (3, 3)\n\nIn such cases, the result is always 1-d.\n\nGenerated values can be filtered using the if keyword:\n\njulia> [(i, j) for i=1:3 for j=1:i if i+j == 4]\n2-element Vector{Tuple{Int64, Int64}}:\n (2, 2)\n (3, 1)"},{"title":"Indexing","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#man-array-indexing","category":"section","text":"The general syntax for indexing into an n-dimensional array A is:\n\nX = A[I_1, I_2, ..., I_n]\n\nwhere each I_k may be a scalar integer, an array of integers, or any other\nsupported index. This includes\nColon (:) to select all indices within the entire dimension,\nranges of the form a:c or a:b:c to select contiguous or strided\nsubsections, and arrays of booleans to select elements at their true indices.\n\nIf all the indices are scalars, then the result X is a single element from the array A. Otherwise,\nX is an array with the same number of dimensions as the sum of the dimensionalities of all the\nindices.\n\nIf all indices I_k are vectors, for example, then the shape of X would be (length(I_1), length(I_2), ..., length(I_n)),\nwith location i_1, i_2, ..., i_n of X containing the value A[I_1[i_1], I_2[i_2], ..., I_n[i_n]].\n\nExample:\n\njulia> A = reshape(collect(1:16), (2, 2, 2, 2))\n2×2×2×2 Array{Int64, 4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\n[:, :, 2, 1] =\n 5  7\n 6  8\n\n[:, :, 1, 2] =\n  9  11\n 10  12\n\n[:, :, 2, 2] =\n 13  15\n 14  16\n\njulia> A[1, 2, 1, 1] # all scalar indices\n3\n\njulia> A[[1, 2], [1], [1, 2], [1]] # all vector indices\n2×1×2×1 Array{Int64, 4}:\n[:, :, 1, 1] =\n 1\n 2\n\n[:, :, 2, 1] =\n 5\n 6\n\njulia> A[[1, 2], [1], [1, 2], 1] # a mix of index types\n2×1×2 Array{Int64, 3}:\n[:, :, 1] =\n 1\n 2\n\n[:, :, 2] =\n 5\n 6\n\nNote how the size of the resulting array is different in the last two cases.\n\nIf I_1 is changed to a two-dimensional matrix, then X becomes an n+1-dimensional array of\nshape (size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n)). The matrix adds a dimension.\n\nExample:\n\njulia> A = reshape(collect(1:16), (2, 2, 2, 2));\n\njulia> A[[1 2; 1 2]]\n2×2 Matrix{Int64}:\n 1  2\n 1  2\n\njulia> A[[1 2; 1 2], 1, 2, 1]\n2×2 Matrix{Int64}:\n 5  6\n 5  6\n\nThe location i_1, i_2, i_3, ..., i_{n+1} contains the value at A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]].\nAll dimensions indexed with scalars are dropped. For example, if J is an array of indices, then the result of A[2, J, 3] is an\narray with size size(J). Its jth element is populated by A[2, J[j], 3].\n\nAs a special part of this syntax, the end keyword may be used to represent the last index of\neach dimension within the indexing brackets, as determined by the size of the innermost array\nbeing indexed. Indexing syntax without the end keyword is equivalent to a call to getindex:\n\nX = getindex(A, I_1, I_2, ..., I_n)\n\nExample:\n\njulia> x = reshape(1:16, 4, 4)\n4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> x[2:3, 2:end-1]\n2×2 Matrix{Int64}:\n 6  10\n 7  11\n\njulia> x[1, [2 3; 4 1]]\n2×2 Matrix{Int64}:\n  5  9\n 13  1"},{"title":"Indexed Assignment","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#man-indexed-assignment","category":"section","text":"The general syntax for assigning values in an n-dimensional array A is:\n\nA[I_1, I_2, ..., I_n] = X\n\nwhere each I_k may be a scalar integer, an array of integers, or any other\nsupported index. This includes\nColon (:) to select all indices within the entire dimension,\nranges of the form a:c or a:b:c to select contiguous or strided\nsubsections, and arrays of booleans to select elements at their true indices.\n\nIf all indices I_k are integers, then the value in location I_1, I_2, ..., I_n of A is\noverwritten with the value of X, converting to the\neltype of A if necessary.\n\nIf any index I_k is itself an array, then the right hand side X must also be an\narray with the same shape as the result of indexing A[I_1, I_2, ..., I_n] or a vector with\nthe same number of elements. The value in location I_1[i_1], I_2[i_2], ..., I_n[i_n] of\nA is overwritten with the value X[i_1, i_2, ..., i_n], converting if necessary. The\nelement-wise assignment operator .= may be used to broadcast X\nacross the selected locations:\n\nA[I_1, I_2, ..., I_n] .= X\n\nJust as in Indexing, the end keyword may be used\nto represent the last index of each dimension within the indexing brackets, as\ndetermined by the size of the array being assigned into. Indexed assignment\nsyntax without the end keyword is equivalent to a call to\nsetindex!:\n\nsetindex!(A, X, I_1, I_2, ..., I_n)\n\nExample:\n\njulia> x = collect(reshape(1:9, 3, 3))\n3×3 Matrix{Int64}:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> x[3, 3] = -9;\n\njulia> x[1:2, 1:2] = [-1 -4; -2 -5];\n\njulia> x\n3×3 Matrix{Int64}:\n -1  -4   7\n -2  -5   8\n  3   6  -9"},{"title":"Supported index types","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#man-supported-index-types","category":"section","text":"In the expression A[I_1, I_2, ..., I_n], each I_k may be a scalar index, an\narray of scalar indices, or an object that represents an array of scalar\nindices and can be converted to such by to_indices:\n\nA scalar index. By default this includes:\nNon-boolean integers\nCartesianIndex{N}s, which behave like an N-tuple of integers spanning multiple dimensions (see below for more details)\nAn array of scalar indices. This includes:\nVectors and multidimensional arrays of integers\nEmpty arrays like [], which select no elements e.g. A[[]] (not to be confused with A[])\nRanges like a:c or a:b:c, which select contiguous or strided subsections from a to c (inclusive)\nAny custom array of scalar indices that is a subtype of AbstractArray\nArrays of CartesianIndex{N} (see below for more details)\nAn object that represents an array of scalar indices and can be converted to such by to_indices. By default this includes:\nColon() (:), which represents all indices within an entire dimension or across the entire array\nArrays of booleans, which select elements at their true indices (see below for more details)\n\nSome examples:\n\njulia> A = reshape(collect(1:2:18), (3, 3))\n3×3 Matrix{Int64}:\n 1   7  13\n 3   9  15\n 5  11  17\n\njulia> A[4]\n7\n\njulia> A[[2, 5, 8]]\n3-element Vector{Int64}:\n  3\n  9\n 15\n\njulia> A[[1 4; 3 8]]\n2×2 Matrix{Int64}:\n 1   7\n 5  15\n\njulia> A[[]]\nInt64[]\n\njulia> A[1:2:5]\n3-element Vector{Int64}:\n 1\n 5\n 9\n\njulia> A[2, :]\n3-element Vector{Int64}:\n  3\n  9\n 15\n\njulia> A[:, 3]\n3-element Vector{Int64}:\n 13\n 15\n 17\n\njulia> A[:, 3:3]\n3×1 Matrix{Int64}:\n 13\n 15\n 17"},{"title":"Cartesian indices","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#Cartesian-indices","category":"section","text":"The special CartesianIndex{N} object represents a scalar index that behaves\nlike an N-tuple of integers spanning multiple dimensions. For example:\n\njulia> A = reshape(1:32, 4, 4, 2);\n\njulia> A[3, 2, 1]\n7\n\njulia> A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7\ntrue\n\nConsidered alone, this may seem relatively trivial; CartesianIndex simply\ngathers multiple integers together into one object that represents a single\nmultidimensional index. When combined with other indexing forms and iterators\nthat yield CartesianIndexes, however, this can produce very elegant\nand efficient code. See Iteration below, and for some more advanced\nexamples, see [this blog post on multidimensional algorithms and\niteration](https://julialang.org/blog/2016/02/iteration).\n\nArrays of CartesianIndex{N} are also supported. They represent a collection\nof scalar indices that each span N dimensions, enabling a form of indexing\nthat is sometimes referred to as pointwise indexing. For example, it enables\naccessing the diagonal elements from the first \"page\" of A from above:\n\njulia> page = A[:, :, 1]\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> page[[CartesianIndex(1, 1),\n             CartesianIndex(2, 2),\n             CartesianIndex(3, 3),\n             CartesianIndex(4, 4)]]\n4-element Vector{Int64}:\n  1\n  6\n 11\n 16\n\nThis can be expressed much more simply with dot broadcasting\nand by combining it with a normal integer index (instead of extracting the\nfirst page from A as a separate step). It can even be combined with a :\nto extract both diagonals from the two pages at the same time:\n\njulia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), 1]\n4-element Vector{Int64}:\n  1\n  6\n 11\n 16\n\njulia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), :]\n4×2 Matrix{Int64}:\n  1  17\n  6  22\n 11  27\n 16  32\n\nwarning: Warning\nCartesianIndex and arrays of CartesianIndex are not compatible with the\nend keyword to represent the last index of a dimension. Do not use end\nin indexing expressions that may contain either CartesianIndex or arrays thereof."},{"title":"Logical indexing","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#Logical-indexing","category":"section","text":"Often referred to as logical indexing or indexing with a logical mask, indexing\nby a boolean array selects elements at the indices where its values are true.\nIndexing by a boolean vector B is effectively the same as indexing by the\nvector of integers that is returned by findall(B). Similarly, indexing\nby a N-dimensional boolean array is effectively the same as indexing by the\nvector of CartesianIndex{N}s where its values are true. A logical index\nmust be an array of the same shape as the dimension(s) it indexes into, or it\nmust be the only index provided and match the shape of the one-dimensional\nreshaped view of the array it indexes into. It is generally more efficient\nto use boolean arrays as indices directly instead of first calling findall.\n\njulia> x = reshape(1:12, 2, 3, 2)\n2×3×2 reshape(::UnitRange{Int64}, 2, 3, 2) with eltype Int64:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\njulia> x[:, [true false; false true; true false]]\n2×3 Matrix{Int64}:\n 1  5   9\n 2  6  10\n\njulia> mask = map(ispow2, x)\n2×3×2 Array{Bool, 3}:\n[:, :, 1] =\n 1  0  0\n 1  1  0\n\n[:, :, 2] =\n 0  0  0\n 1  0  0\n\njulia> x[mask]\n4-element Vector{Int64}:\n 1\n 2\n 4\n 8\n\njulia> x[vec(mask)] == x[mask] # we can also index with a single Boolean vector\ntrue"},{"title":"Number of indices","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#Number-of-indices","category":"section","text":""},{"title":"Cartesian indexing","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#Cartesian-indexing","category":"section","text":"The ordinary way to index into an N-dimensional array is to use exactly N indices; each\nindex selects the position(s) in its particular dimension. For example, in the three-dimensional\narray A = rand(4, 3, 2), A[2, 3, 1] will select the number in the second row of the third\ncolumn in the first \"page\" of the array. This is often referred to as cartesian indexing."},{"title":"Linear indexing","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#Linear-indexing","category":"section","text":"When exactly one index i is provided, that index no longer represents a location in a\nparticular dimension of the array. Instead, it selects the ith element using the\ncolumn-major iteration order that linearly spans the entire array. This is known as linear\nindexing. It essentially treats the array as though it had been reshaped into a\none-dimensional vector with vec.\n\njulia> A = [2 6; 4 7; 3 1]\n3×2 Matrix{Int64}:\n 2  6\n 4  7\n 3  1\n\njulia> A[5]\n7\n\njulia> vec(A)[5]\n7\n\nA linear index into the array A can be converted to a CartesianIndex for cartesian\nindexing with CartesianIndices(A)[i] (see CartesianIndices), and a set of\nN cartesian indices can be converted to a linear index with\nLinearIndices(A)[i_1, i_2, ..., i_N] (see LinearIndices).\n\njulia> CartesianIndices(A)[5]\nCartesianIndex(2, 2)\n\njulia> LinearIndices(A)[2, 2]\n5\n\nIt's important to note that there's a very large asymmetry in the performance\nof these conversions. Converting a linear index to a set of cartesian indices\nrequires dividing and taking the remainder, whereas going the other way is just\nmultiplies and adds. In modern processors, integer division can be 10-50 times\nslower than multiplication. While some arrays — like Array itself —\nare implemented using a linear chunk of memory and directly use a linear index\nin their implementations, other arrays — like Diagonal — need the\nfull set of cartesian indices to do their lookup (see IndexStyle to\nintrospect which is which).\n\nwarning: Warning\nWhen iterating over all the indices for an array, it is\nbetter to iterate over eachindex(A) instead of 1:length(A).\nNot only will this be faster in cases where A is IndexCartesian,\nbut it will also support arrays with custom indexing, such as OffsetArrays.\nIf only the values are needed, then is better to just iterate the array directly, i.e. for a in A."},{"title":"Omitted and extra indices","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#Omitted-and-extra-indices","category":"section","text":"In addition to linear indexing, an N-dimensional array may be indexed with\nfewer or more than N indices in certain situations.\n\nIndices may be omitted if the trailing dimensions that are not indexed into are\nall length one. In other words, trailing indices can be omitted only if there\nis only one possible value that those omitted indices could be for an in-bounds\nindexing expression. For example, a four-dimensional array with size (3, 4, 2, 1) may be indexed with only three indices as the dimension that gets skipped\n(the fourth dimension) has length one. Note that linear indexing takes\nprecedence over this rule.\n\njulia> A = reshape(1:24, 3, 4, 2, 1)\n3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64:\n[:, :, 1, 1] =\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\n[:, :, 2, 1] =\n 13  16  19  22\n 14  17  20  23\n 15  18  21  24\n\njulia> A[1, 3, 2] # Omits the fourth dimension (length 1)\n19\n\njulia> A[1, 3] # Attempts to omit dimensions 3 & 4 (lengths 2 and 1)\nERROR: BoundsError: attempt to access 3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64 at index [1, 3]\n\njulia> A[19] # Linear indexing\n19\n\nWhen omitting all indices with A[], this semantic provides a simple idiom\nto retrieve the only element in an array and simultaneously ensure that there\nwas only one element.\n\nSimilarly, more than N indices may be provided if all the indices beyond the\ndimensionality of the array are 1 (or more generally are the first and only\nelement of axes(A, d) where d is that particular dimension number). This\nallows vectors to be indexed like one-column matrices, for example:\n\njulia> A = [8, 6, 7]\n3-element Vector{Int64}:\n 8\n 6\n 7\n\njulia> A[2, 1]\n6"},{"title":"Iteration","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#Iteration","category":"section","text":"The recommended ways to iterate over a whole array are\n\nfor a in A\n    # Do something with the element a\nend\n\nfor i in eachindex(A)\n    # Do something with i and/or A[i]\nend\n\nThe first construct is used when you need the value, but not index, of each element. In the second\nconstruct, i will be an Int if A is an array type with fast linear indexing; otherwise,\nit will be a CartesianIndex:\n\njulia> A = rand(4, 3);\n\njulia> B = view(A, 1:3, 2:3);\n\njulia> for i in eachindex(B)\n           @show i\n       end\ni = CartesianIndex(1, 1)\ni = CartesianIndex(2, 1)\ni = CartesianIndex(3, 1)\ni = CartesianIndex(1, 2)\ni = CartesianIndex(2, 2)\ni = CartesianIndex(3, 2)\n\nnote: Note\nIn contrast with for i = 1:length(A), iterating with eachindex provides an efficient way to\niterate over any array type. Besides, this also supports generic arrays with custom indexing such as\nOffsetArrays."},{"title":"Array traits","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#Array-traits","category":"section","text":"If you write a custom AbstractArray type, you can specify that it has fast linear indexing using\n\nBase.IndexStyle(::Type{<:MyArray}) = IndexLinear()\n\nThis setting will cause eachindex iteration over a MyArray to use integers. If you don't\nspecify this trait, the default value IndexCartesian() is used."},{"title":"Array and Vectorized Operators and Functions","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#man-array-and-vectorized-operators-and-functions","category":"section","text":"The following operators are supported for arrays:\n\nUnary arithmetic – -, +\nBinary arithmetic – -, +, *, /, \\, ^\nComparison – ==, !=, ≈ (isapprox), ≉\n\nTo enable convenient vectorization of mathematical and other operations,\nJulia provides the dot syntax f.(args...), e.g. sin.(x)\nor min.(x, y), for elementwise operations over arrays or mixtures of arrays and\nscalars (a Broadcasting operation); these have the additional advantage of\n\"fusing\" into a single loop when combined with other dot calls, e.g. sin.(cos.(x)).\n\nAlso, every binary operator supports a dot version\nthat can be applied to arrays (and combinations of arrays and scalars) in such\nfused broadcasting operations, e.g. z .== sin.(x .* y).\n\nNote that comparisons such as == operate on whole arrays, giving a single boolean\nanswer. Use dot operators like .== for elementwise comparisons. (For comparison\noperations like <, only the elementwise .< version is applicable to arrays.)\n\nAlso notice the difference between max.(a,b), which broadcasts max\nelementwise over a and b, and maximum(a), which finds the largest value within\na. The same relationship holds for min.(a, b) and minimum(a)."},{"title":"Broadcasting","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#Broadcasting","category":"section","text":"It is sometimes useful to perform element-by-element binary operations on arrays of different\nsizes, such as adding a vector to each column of a matrix. An inefficient way to do this would\nbe to replicate the vector to the size of the matrix:\n\njulia> a = [0.2, 0.5]; A = [1.0 1.6 1.05; 1.07 1.36 1.18];\n\njulia> repeat(a, 1, 3) + A\n2×3 Matrix{Float64}:\n 1.2   1.8   1.25\n 1.57  1.86  1.68\n\nThis is wasteful when dimensions get large, so Julia provides broadcast, which expands\nsingleton dimensions in array arguments to match the corresponding dimension in the other array\nwithout using extra memory, and applies the given function elementwise:\n\njulia> broadcast(+, a, A)\n2×3 Matrix{Float64}:\n 1.2   1.8   1.25\n 1.57  1.86  1.68\n\njulia> b = [0.9 0.1]\n1×2 Matrix{Float64}:\n 0.9  0.1\n\njulia> broadcast(+, a, b)\n2×2 Matrix{Float64}:\n 1.1  0.3\n 1.4  0.6\n\nDotted operators such as .+ and .* are equivalent\nto broadcast calls (except that they fuse, as described above). There is also a\nbroadcast! function to specify an explicit destination (which can also\nbe accessed in a fusing fashion by .= assignment). In fact, f.(args...)\nis equivalent to broadcast(f, args...), providing a convenient syntax to broadcast any function\n(dot syntax). Nested \"dot calls\" f.(...) (including calls to .+ etcetera)\nautomatically fuse into a single broadcast call.\n\nAdditionally, broadcast is not limited to arrays (see the function documentation);\nit also handles scalars, tuples and other collections. By default, only some argument types are\nconsidered scalars, including (but not limited to) Numbers, Strings, Symbols, Types, Functions\nand some common singletons like missing and nothing. All other arguments are\niterated over or indexed into elementwise.\n\njulia> convert.(Float32, [1, 2])\n2-element Vector{Float32}:\n 1.0\n 2.0\n\njulia> ceil.(UInt8, [1.2 3.4; 5.6 6.7])\n2×2 Matrix{UInt8}:\n 0x02  0x04\n 0x06  0x07\n\njulia> string.(1:3, \". \", [\"First\", \"Second\", \"Third\"])\n3-element Vector{String}:\n \"1. First\"\n \"2. Second\"\n \"3. Third\"\n\nSometimes, you want a container (like an array) that would normally participate in broadcast to be \"protected\"\nfrom broadcast's behavior of iterating over all of its elements. By placing it inside another container\n(like a single element Tuple) broadcast will treat it as a single value.\n\njulia> ([1, 2, 3], [4, 5, 6]) .+ ([1, 2, 3],)\n([2, 4, 6], [5, 7, 9])\n\njulia> ([1, 2, 3], [4, 5, 6]) .+ tuple([1, 2, 3])\n([2, 4, 6], [5, 7, 9])"},{"title":"Implementation","page":"Single- and multi-dimensional Arrays","location":"manual/arrays.html#Implementation","category":"section","text":"The base array type in Julia is the abstract type AbstractArray{T,N}. It is parameterized by\nthe number of dimensions N and the element type T. AbstractVector and AbstractMatrix are\naliases for the 1-d and 2-d cases. Operations on AbstractArray objects are defined using higher\nlevel operators and functions, in a way that is independent of the underlying storage. These operations\ngenerally work correctly as a fallback for any specific array implementation.\n\nThe AbstractArray type includes anything vaguely array-like, and implementations of it might\nbe quite different from conventional arrays. For example, elements might be computed on request\nrather than stored. However, any concrete AbstractArray{T,N} type should generally implement\nat least size(A) (returning an Int tuple), getindex(A, i) and\ngetindex(A, i1, ..., iN); mutable arrays should also implement setindex!.\nIt is recommended that these operations have nearly constant time complexity, as otherwise some array\nfunctions may be unexpectedly slow. Concrete types should also typically provide a similar(A, T=eltype(A), dims=size(A))\nmethod, which is used to allocate a similar array for copy and other out-of-place\noperations. No matter how an AbstractArray{T,N} is represented internally, T is the type of\nobject returned by integer indexing (A[1, ..., 1], when A is not empty) and N should be\nthe length of the tuple returned by size. For more details on defining custom\nAbstractArray implementations, see the array interface guide in the interfaces chapter.\n\nDenseArray is an abstract subtype of AbstractArray intended to include all arrays where\nelements are stored contiguously in column-major order (see [additional notes in\nPerformance Tips](@ref man-performance-column-major)). The Array type is a specific instance\nof DenseArray;  Vector and Matrix are aliases for the 1-d and 2-d cases.\nVery few operations are implemented specifically for Array beyond those that are required\nfor all AbstractArrays; much of the array library is implemented in a generic\nmanner that allows all custom arrays to behave similarly.\n\nSubArray is a specialization of AbstractArray that performs indexing by\nsharing memory with the original array rather than by copying it. A SubArray\nis created with the view function, which is called the same way as\ngetindex (with an array and a series of index arguments). The result\nof view looks the same as the result of getindex, except the\ndata is left in place. view stores the input index vectors in a\nSubArray object, which can later be used to index the original array\nindirectly. By putting the @views macro in front of an expression or\nblock of code, any array[...] slice in that expression will be converted to\ncreate a SubArray view instead.\n\nBitArrays are space-efficient \"packed\" boolean arrays, which store one bit per boolean value.\nThey can be used similarly to Array{Bool} arrays (which store one byte per boolean value),\nand can be converted to/from the latter via Array(bitarray) and BitArray(array), respectively.\n\nAn array is \"strided\" if it is stored in memory with well-defined spacings (strides) between\nits elements. A strided array with a supported element type may be passed to an external\n(non-Julia) library like BLAS or LAPACK by simply passing its pointer and the\nstride for each dimension. The stride(A, d) is the distance between elements along\ndimension d. For example, the builtin Array returned by rand(5,7,2) has its elements\narranged contiguously in column major order. This means that the stride of the first\ndimension — the spacing between elements in the same column — is 1:\n\njulia> A = rand(5, 7, 2);\n\njulia> stride(A, 1)\n1\n\nThe stride of the second dimension is the spacing between elements in the same row, skipping\nas many elements as there are in a single column (5). Similarly, jumping between the two\n\"pages\" (in the third dimension) requires skipping 5*7 == 35 elements. The strides\nof this array is the tuple of these three numbers together:\n\njulia> strides(A)\n(1, 5, 35)\n\nIn this particular case, the number of elements skipped in memory matches the number of\nlinear indices skipped. This is only the case for contiguous arrays like Array (and\nother DenseArray subtypes) and is not true in general. Views with range indices are a good\nexample of non-contiguous strided arrays; consider V = @view A[1:3:4, 2:2:6, 2:-1:1].\nThis view V refers to the same memory as A but is skipping and re-arranging some of its\nelements. The stride of the first dimension of V is 3 because we're only selecting every\nthird row from our original array:\n\njulia> V = @view A[1:3:4, 2:2:6, 2:-1:1];\n\njulia> stride(V, 1)\n3\n\nThis view is similarly selecting every other column from our original A — and thus it\nneeds to skip the equivalent of two five-element columns when moving between indices in the\nsecond dimension:\n\njulia> stride(V, 2)\n10\n\nThe third dimension is interesting because its order is reversed! Thus to get from the first\n\"page\" to the second one it must go backwards in memory, and so its stride in this\ndimension is negative!\n\njulia> stride(V, 3)\n-35\n\nThis means that the pointer for V is actually pointing into the middle of A's memory\nblock, and it refers to elements both backwards and forwards in memory. See the\ninterface guide for strided arrays for more details on\ndefining your own strided arrays. StridedVector and StridedMatrix are\nconvenient aliases for many of the builtin array types that are considered strided arrays,\nallowing them to dispatch to select specialized implementations that call highly tuned and\noptimized BLAS and LAPACK functions using just the pointer and strides.\n\nIt is worth emphasizing that strides are about offsets in memory rather than indexing. If\nyou are looking to convert between linear (single-index) indexing and cartesian\n(multi-index) indexing, see LinearIndices and CartesianIndices."},{"title":"Linux","page":"Linux","location":"devdocs/build/linux.html#Linux","category":"section","text":"GCC version 4.7 or later is required to build Julia.\nTo use external shared libraries not in the system library search path, set USE_SYSTEM_XXX=1 and LDFLAGS=-Wl,-rpath,/path/to/dir/contains/libXXX.so in Make.user.\nInstead of setting LDFLAGS, putting the library directory into the environment variable LD_LIBRARY_PATH (at both compile and run time) also works.\nThe USE_SYSTEM_* flags should be used with caution. These are meant only for troubleshooting, porting, and packaging, where package maintainers work closely with the Julia developers to make sure that Julia is built correctly. Production use cases should use the officially provided binaries. Issues arising from the use of these flags will generally not be accepted.\nSee also the external dependencies."},{"title":"Architecture Customization","page":"Linux","location":"devdocs/build/linux.html#Architecture-Customization","category":"section","text":"Julia can be built for a non-generic architecture by configuring the ARCH Makefile variable in a Make.user file. See the appropriate section of Make.inc for additional customization options, such as MARCH and JULIA_CPU_TARGET.\n\nFor example, to build for Pentium 4, set MARCH=pentium4 and install the necessary system libraries for linking. On Ubuntu, these may include lib32gfortran-6-dev, lib32gcc1, and lib32stdc++6, among others.\n\nYou can also set MARCH=native in Make.user for a maximum-performance build customized for the current machine CPU."},{"title":"Linux Build Troubleshooting","page":"Linux","location":"devdocs/build/linux.html#Linux-Build-Troubleshooting","category":"section","text":"Problem Possible Solution\nOpenBLAS build failure Set one of the following build options in Make.user and build again: <ul><li> OPENBLAS_TARGET_ARCH=BARCELONA (AMD CPUs) or OPENBLAS_TARGET_ARCH=NEHALEM (Intel CPUs)<ul>Set OPENBLAS_DYNAMIC_ARCH = 0 to disable compiling multiple architectures in a single binary.</ul></li><li> OPENBLAS_NO_AVX2 = 1 disables AVX2 instructions, allowing OpenBLAS to compile with OPENBLAS_DYNAMIC_ARCH = 1 using old versions of binutils </li><li> USE_SYSTEM_BLAS=1 uses the system provided libblas <ul><li>Set LIBBLAS=-lopenblas and LIBBLASNAME=libopenblas to force the use of the system provided OpenBLAS when multiple BLAS versions are installed. </li></ul></li></ul><p> If you get an error that looks like ../kernel/x86_64/dgemm_kernel_4x4_haswell.S:1709: Error: no such instruction: `vpermpd $ 0xb1,%ymm0,%ymm0', then you need to set OPENBLAS_DYNAMIC_ARCH = 0 or OPENBLAS_NO_AVX2 = 1, or you need a newer version of binutils (2.18 or newer). (Issue #7653)</p><p> If the linker cannot find gfortran and you get an error like julia /usr/bin/x86_64-linux-gnu-ld: cannot find -lgfortran, check the path with gfortran -print-file-name=libgfortran.so and use the output to export something similar to this: export LDFLAGS=-L/usr/lib/gcc/x86_64-linux-gnu/8/. See Issue #6150.</p>\nIllegal Instruction error Check if your CPU supports AVX while your OS does not (e.g. through virtualization, as described in this issue)."},{"title":"Custom LLVM Passes","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#Custom-LLVM-Passes","category":"section","text":"Julia has a number of custom LLVM passes. Broadly, they can be classified into passes that are required to be run to maintain Julia semantics, and passes that take advantage of Julia semantics to optimize LLVM IR."},{"title":"Semantic Passes","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#Semantic-Passes","category":"section","text":"These passes are used to transform LLVM IR into code that is legal to be run on a CPU. Their main purpose is to enable simpler IR to be emitted by codegen, which then enables other LLVM passes to optimize common patterns."},{"title":"CPUFeatures","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#CPUFeatures","category":"section","text":"Filename: llvm-cpufeatures.cpp\nClass Name: CPUFeaturesPass\nOpt Name: module(CPUFeatures)\n\nThis pass lowers the julia.cpu.have_fma.(f32|f64) intrinsic to either true or false, depending on the target architecture and target features present on the function. This intrinsic is often used to determine if using algorithms dependent on fast fused multiply-add operations is better than using standard algorithms not dependent on such instructions."},{"title":"DemoteFloat16","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#DemoteFloat16","category":"section","text":"Filename: llvm-demote-float16.cpp\nClassName: DemoteFloat16Pass\nOpt Name function(DemoteFloat16)\n\nThis pass replaces float16 operations with float32 operations on architectures that do not natively support float16 operations. This is done by inserting fpext and fptrunc instructions around any float16 operation. On architectures that do support native float16 operations, this pass is a no-op."},{"title":"LateGCLowering","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#LateGCLowering","category":"section","text":"Filename: llvm-late-gc-lowering.cpp\nClass Name: LateLowerGCPass\nOpt Name: function(LateLowerGCFrame)\n\nThis pass performs most of the GC rooting work required to track pointers between GC safepoints. It also lowers several intrinsics to their corresponding instruction translation, and is permitted to violate the non-integral invariants previously established (pointer_from_objref is lowered to a ptrtoint instruction here). This pass typically occupies the most time out of all the custom Julia passes, due to its dataflow algorithm to minimize the number of objects live at any safepoint."},{"title":"FinalGCLowering","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#FinalGCLowering","category":"section","text":"Filename: llvm-final-gc-lowering.cpp\nClass Name: FinalLowerGCPass\nOpt Name: module(FinalLowerGC)\n\nThis pass lowers a few last intrinsics to their final form targeting functions in the libjulia library. Separating this from LateGCLowering enables other backends (GPU compilation) to supply their own custom lowerings for these intrinsics, enabling the Julia pipeline to be used on those backends as well."},{"title":"RemoveNI","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#RemoveNI","category":"section","text":"Filename: llvm-remove-ni.cpp\nClass Name: RemoveNIPass\nOpt Name: module(RemoveNI)\n\nThis pass removes the non-integral address spaces from the module's datalayout string. This enables the backend to lower Julia's custom address spaces directly to machine code, without a costly rewrite of every pointer operation to address space 0."},{"title":"SIMDLoop","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#SIMDLoop","category":"section","text":"Filename: llvm-simdloop.cpp\nClass Name: LowerSIMDLoopPass\nOpt Name: loop(LowerSIMDLoop)\n\nThis pass acts as the main driver of the @simd annotation. Codegen inserts a !llvm.loopid marker at the back branch of a loop, which this pass uses to identify loops that were originally marked with @simd. Then, this pass looks for a chain of floating point operations that form a reduce and adds the contract and reassoc fast math flags to allow reassociation (and thus vectorization). This pass does not preserve either loop information nor inference correctness, so it may violate Julia semantics in surprising ways. If the loop was annotated with ivdep as well, then the pass marks the loop as having no loop-carried dependencies (the resulting behavior is undefined if the user annotation was incorrect or gets applied to the wrong loop)."},{"title":"LowerPTLS","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#LowerPTLS","category":"section","text":"Filename: llvm-ptls.cpp\nClass Name: LowerPTLSPass\nOpt Name: module(LowerPTLSPass)\n\nThis pass lowers thread-local Julia intrinsics to assembly instructions. Julia relies on thread-local storage for garbage collection and multithreading task scheduling. When compiling code for system images and package images, this pass replaces calls to intrinsics with loads from global variables that are initialized at load time.\n\nIf codegen produces a function with a swiftself argument and calling convention, this pass assumes the swiftself argument is the pgcstack and will replace the intrinsics with that argument. Doing so provides speedups on architectures that have slow thread local storage accesses."},{"title":"RemoveAddrspaces","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#RemoveAddrspaces","category":"section","text":"Filename: llvm-remove-addrspaces.cpp\nClass Name: RemoveAddrspacesPass\nOpt Name: module(RemoveAddrspaces)\n\nThis pass renames pointers in one address space to another address space. This is used to remove Julia-specific address spaces from LLVM IR."},{"title":"RemoveJuliaAddrspaces","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#RemoveJuliaAddrspaces","category":"section","text":"Filename: llvm-remove-addrspaces.cpp\nClass Name: RemoveJuliaAddrspacesPass\nOpt Name: module(RemoveJuliaAddrspaces)\n\nThis pass removes Julia-specific address spaces from LLVM IR. It is mostly used for displaying LLVM IR in a less cluttered format. Internally, it is implemented off the RemoveAddrspaces pass."},{"title":"Multiversioning","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#Multiversioning","category":"section","text":"Filename: llvm-multiversioning.cpp\nClass Name: MultiVersioningPass\nOpt Name: module(JuliaMultiVersioning)\n\nThis pass performs modifications to a module to create functions that are optimized for running on different architectures (see sysimg.md and pkgimg.md for more details). Implementation-wise, it clones functions and applies different target-specific attributes to them to allow the optimizer to use advanced features such as vectorization and instruction scheduling for that platform. It also creates some infrastructure to enable the Julia image loader to select the appropriate version of the function to call based on the architecture the loader is running on. The target-specific attributes are controlled by the julia.mv.specs module flag, which during compilation is derived from the JULIA_CPU_TARGET environment variable. The pass must also be enabled by providing a julia.mv.enable module flag with a value of 1.\n\nwarning: Warning\nUse of llvmcall with multiversioning is dangerous. llvmcall enables access to features not typically exposed by the Julia APIs, and are therefore usually not available on all architectures. If multiversioning is enabled and code generation is requested for a target architecture that does not support the feature required by an llvmcall expression, LLVM will probably error out, likely with an abort and the message LLVM ERROR: Do not know how to split the result of this operator!."},{"title":"GCInvariantVerifier","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#GCInvariantVerifier","category":"section","text":"Filename: llvm-gc-invariant-verifier.cpp\nClass Name: GCInvariantVerifierPass\nOpt Name: module(GCInvariantVerifier)\n\nThis pass is used to verify Julia's invariants about LLVM IR. This includes things such as the nonexistence of ptrtoint in Julia's non-integral address spaces [nislides] and the existence of only blessed addrspacecast instructions (Tracked -> Derived, 0 -> Tracked, etc). It performs no transformations on IR.\n\n[nislides]: https://llvm.org/devmtg/2015-02/slides/chisnall-pointers-not-int.pdf"},{"title":"Optimization Passes","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#Optimization-Passes","category":"section","text":"These passes are used to perform transformations on LLVM IR that LLVM will not perform itself, e.g. fast math flag propagation, escape analysis, and optimizations on Julia-specific internal functions. They use knowledge about Julia's semantics to perform these optimizations."},{"title":"AllocOpt","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#AllocOpt","category":"section","text":"Filename: llvm-alloc-opt.cpp\nClass Name: AllocOptPass\nOpt Name: function(AllocOpt)\n\nJulia does not have the concept of a program stack as a place to allocate mutable objects. However, allocating objects on the stack reduces GC pressure and is critical for GPU compilation. Thus, AllocOpt performs heap to stack conversion of objects that it can prove do not escape the current function. It also performs a number of other optimizations on allocations, such as removing allocations that are never used, optimizing typeof calls to freshly allocated objects, and removing stores to allocations that are immediately overwritten. The escape analysis implementation is located in llvm-alloc-helpers.cpp. Currently, this pass does not use information from EscapeAnalysis.jl, though that may change in the future."},{"title":"PropagateJuliaAddrspaces","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#PropagateJuliaAddrspaces","category":"section","text":"Filename: llvm-propagate-addrspaces.cpp\nClass Name: PropagateJuliaAddrspacesPass\nOpt Name: function(PropagateJuliaAddrspaces)\n\nThis pass is used to propagate Julia-specific address spaces through operations on pointers. LLVM is not allowed to introduce or remove addrspacecast instructions by optimizations, so this pass acts to eliminate redundant addrspace casts by replacing operations with their equivalent in a Julia address space. For more information on Julia's address spaces, see (TODO link to llvm.md)."},{"title":"JuliaLICM","page":"Custom LLVM Passes","location":"devdocs/llvm-passes.html#JuliaLICM","category":"section","text":"Filename: llvm-julia-licm.cpp\nClass Name: JuliaLICMPass\nOpt Name: loop(JuliaLICM)\n\nThis pass is used to hoist Julia-specific intrinsics out of loops. Specifically, it performs the following transformations:\n\nHoist gc_preserve_begin and sink gc_preserve_end out of loops when the preserved objects are loop-invariant.\nSince objects preserved within a loop are likely preserved for the duration of the loop, this transformation can reduce the number of gc_preserve_begin/gc_preserve_end pairs in the IR. This makes it easier for the LateLowerGCPass to identify where particular objects are preserved.\nHoist write barriers with invariant objects\nHere we assume that there are only two generations that an object can be a part of. Given that, a write barrier needs to only execute once for any pair of the same object. Thus, we can hoist write barriers out of loops when the object being written to is loop-invariant.\nHoist allocations out of loops when they do not escape the loop\nWe use a very conservative definition of escape here, the same as the one used in AllocOptPass. This transformation can reduce the number of allocations in the IR, even when an allocation escapes the function altogether.\n\nnote: Note\nThis pass is required to preserve LLVM's MemorySSA (Short Video, Longer Video) and ScalarEvolution (Newer Slides Older Slides) analyses."},{"title":"Delimited Files","page":"Delimited Files","location":"stdlib/DelimitedFiles.html#Delimited-Files","category":"section","text":""},{"title":"DelimitedFiles.readdlm","page":"Delimited Files","location":"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any, AbstractChar, Type, AbstractChar}","category":"method","text":"readdlm(source, delim::AbstractChar, T::Type, eol::AbstractChar; header=false, skipstart=0, skipblanks=true, use_mmap, quotes=true, dims, comments=false, comment_char='#')\n\nRead a matrix from the source where each line (separated by eol) gives one row, with\nelements separated by the given delimiter. The source can be a text file, stream or byte\narray. Memory mapped files can be used by passing the byte array representation of the\nmapped segment as source.\n\nIf T is a numeric type, the result is an array of that type, with any non-numeric elements\nas NaN for floating-point types, or zero. Other useful values of T include\nString, AbstractString, and Any.\n\nIf header is true, the first row of data will be read as header and the tuple\n(data_cells, header_cells) is returned instead of only data_cells.\n\nSpecifying skipstart will ignore the corresponding number of initial lines from the input.\n\nIf skipblanks is true, blank lines in the input will be ignored.\n\nIf use_mmap is true, the file specified by source is memory mapped for potential\nspeedups if the file is large. Default is false. On a Windows filesystem, use_mmap should not be set\nto true unless the file is only read once and is also not written to.\nSome edge cases exist where an OS is Unix-like but the filesystem is Windows-like.\n\nIf quotes is true, columns enclosed within double-quote (\") characters are allowed to\ncontain new lines and column delimiters. Double-quote characters within a quoted field must\nbe escaped with another double-quote.  Specifying dims as a tuple of the expected rows and\ncolumns (including header, if any) may speed up reading of large files.  If comments is\ntrue, lines beginning with comment_char and text following comment_char in any line\nare ignored.\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [5; 6; 7; 8];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y])\n       end\n\njulia> readdlm(\"delim_file.txt\", '\\t', Int, '\\n')\n4×2 Matrix{Int64}:\n 1  5\n 2  6\n 3  7\n 4  8\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n"},{"title":"DelimitedFiles.readdlm","page":"Delimited Files","location":"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any, AbstractChar, AbstractChar}","category":"method","text":"readdlm(source, delim::AbstractChar, eol::AbstractChar; options...)\n\nIf all data is numeric, the result will be a numeric array. If some elements cannot be\nparsed as numbers, a heterogeneous array of numbers and strings is returned.\n\n\n\n\n\n"},{"title":"DelimitedFiles.readdlm","page":"Delimited Files","location":"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any, AbstractChar, Type}","category":"method","text":"readdlm(source, delim::AbstractChar, T::Type; options...)\n\nThe end of line delimiter is taken as \\n.\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [1.1; 2.2; 3.3; 4.4];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y], ',')\n       end;\n\njulia> readdlm(\"delim_file.txt\", ',', Float64)\n4×2 Matrix{Float64}:\n 1.0  1.1\n 2.0  2.2\n 3.0  3.3\n 4.0  4.4\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n"},{"title":"DelimitedFiles.readdlm","page":"Delimited Files","location":"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any, AbstractChar}","category":"method","text":"readdlm(source, delim::AbstractChar; options...)\n\nThe end of line delimiter is taken as \\n. If all data is numeric, the result will be a\nnumeric array. If some elements cannot be parsed as numbers, a heterogeneous array of\nnumbers and strings is returned.\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [1.1; 2.2; 3.3; 4.4];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y], ',')\n       end;\n\njulia> readdlm(\"delim_file.txt\", ',')\n4×2 Matrix{Float64}:\n 1.0  1.1\n 2.0  2.2\n 3.0  3.3\n 4.0  4.4\n\njulia> z = [\"a\"; \"b\"; \"c\"; \"d\"];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x z], ',')\n       end;\n\njulia> readdlm(\"delim_file.txt\", ',')\n4×2 Matrix{Any}:\n 1  \"a\"\n 2  \"b\"\n 3  \"c\"\n 4  \"d\"\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n"},{"title":"DelimitedFiles.readdlm","page":"Delimited Files","location":"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any, Type}","category":"method","text":"readdlm(source, T::Type; options...)\n\nThe columns are assumed to be separated by one or more whitespaces. The end of line\ndelimiter is taken as \\n.\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [5; 6; 7; 8];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y])\n       end;\n\njulia> readdlm(\"delim_file.txt\", Int64)\n4×2 Matrix{Int64}:\n 1  5\n 2  6\n 3  7\n 4  8\n\njulia> readdlm(\"delim_file.txt\", Float64)\n4×2 Matrix{Float64}:\n 1.0  5.0\n 2.0  6.0\n 3.0  7.0\n 4.0  8.0\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n"},{"title":"DelimitedFiles.readdlm","page":"Delimited Files","location":"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any}","category":"method","text":"readdlm(source; options...)\n\nThe columns are assumed to be separated by one or more whitespaces. The end of line\ndelimiter is taken as \\n. If all data is numeric, the result will be a numeric array. If\nsome elements cannot be parsed as numbers, a heterogeneous array of numbers and strings\nis returned.\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [\"a\"; \"b\"; \"c\"; \"d\"];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y])\n       end;\n\njulia> readdlm(\"delim_file.txt\")\n4×2 Matrix{Any}:\n 1  \"a\"\n 2  \"b\"\n 3  \"c\"\n 4  \"d\"\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n"},{"title":"DelimitedFiles.writedlm","page":"Delimited Files","location":"stdlib/DelimitedFiles.html#DelimitedFiles.writedlm","category":"function","text":"writedlm(f, A, delim='\\t'; opts)\n\nWrite A (a vector, matrix, or an iterable collection of iterable rows) as text to f\n(either a filename string or an IO stream) using the given delimiter\ndelim (which defaults to tab, but can be any printable Julia object, typically a Char or\nAbstractString).\n\nFor example, two vectors x and y of the same length can be written as two columns of\ntab-delimited text to f by either writedlm(f, [x y]) or by writedlm(f, zip(x, y)).\n\nExamples\n\njulia> using DelimitedFiles\n\njulia> x = [1; 2; 3; 4];\n\njulia> y = [5; 6; 7; 8];\n\njulia> open(\"delim_file.txt\", \"w\") do io\n           writedlm(io, [x y])\n       end\n\njulia> readdlm(\"delim_file.txt\", '\\t', Int, '\\n')\n4×2 Matrix{Int64}:\n 1  5\n 2  6\n 3  7\n 4  8\n\njulia> rm(\"delim_file.txt\")\n\n\n\n\n\n"},{"title":"More about types","page":"More about types","location":"devdocs/types.html#More-about-types","category":"section","text":"If you've used Julia for a while, you understand the fundamental role that types play. Here we\ntry to get under the hood, focusing particularly on Parametric Types."},{"title":"Types and sets (and Any and Union{}/Bottom)","page":"More about types","location":"devdocs/types.html#Types-and-sets-(and-Any-and-Union{}/Bottom)","category":"section","text":"It's perhaps easiest to conceive of Julia's type system in terms of sets. While programs manipulate\nindividual values, a type refers to a set of values. This is not the same thing as a collection;\nfor example a Set of values is itself a single Set value.\nRather, a type describes a set of possible values, expressing uncertainty about which value we\nhave.\n\nA concrete type T describes the set of values whose direct tag, as returned by the typeof\nfunction, is T. An abstract type describes some possibly-larger set of values.\n\nAny describes the entire universe of possible values. Integer is a subset of\nAny that includes Int, Int8, and other concrete types.\nInternally, Julia also makes heavy use of another type known as Bottom, which can also be written\nas Union{}. This corresponds to the empty set.\n\nJulia's types support the standard operations of set theory: you can ask whether T1 is a \"subset\"\n(subtype) of T2 with T1 <: T2. Likewise, you intersect two types using typeintersect, take\ntheir union with Union, and compute a type that contains their union with typejoin:\n\njulia> typeintersect(Int, Float64)\nUnion{}\n\njulia> Union{Int, Float64}\nUnion{Float64, Int64}\n\njulia> typejoin(Int, Float64)\nReal\n\njulia> typeintersect(Signed, Union{UInt8, Int8})\nInt8\n\njulia> Union{Signed, Union{UInt8, Int8}}\nUnion{UInt8, Signed}\n\njulia> typejoin(Signed, Union{UInt8, Int8})\nInteger\n\njulia> typeintersect(Tuple{Integer, Float64}, Tuple{Int, Real})\nTuple{Int64, Float64}\n\njulia> Union{Tuple{Integer, Float64}, Tuple{Int, Real}}\nUnion{Tuple{Int64, Real}, Tuple{Integer, Float64}}\n\njulia> typejoin(Tuple{Integer, Float64}, Tuple{Int, Real})\nTuple{Integer, Real}\n\nWhile these operations may seem abstract, they lie at the heart of Julia. For example, method\ndispatch is implemented by stepping through the items in a method list until reaching one for which\nthe type of the argument tuple is a subtype of the method signature.\nFor this algorithm to work, it's important that methods be sorted by their specificity, and that the\nsearch begins with the most specific methods. Consequently, Julia also implements a partial order on\ntypes; this is achieved by functionality that is similar to <:, but with differences that will\nbe discussed below."},{"title":"UnionAll types","page":"More about types","location":"devdocs/types.html#UnionAll-types","category":"section","text":"Julia's type system can also express an iterated union of types: a union of types over all values\nof some variable. This is needed to describe parametric types where the values of some parameters\nare not known.\n\nFor example, Array has two parameters as in Array{Int,2}. If we did not know the element\ntype, we could write Array{T,2} where T, which is the union of Array{T,2} for all values of\nT: Union{Array{Int8,2}, Array{Int16,2}, ...}.\n\nSuch a type is represented by a UnionAll object, which contains a variable (T in this example,\nof type TypeVar), and a wrapped type (Array{T,2} in this example).\n\nConsider the following methods:\n\nf1(A::Array) = 1\nf2(A::Array{Int}) = 2\nf3(A::Array{T}) where {T<:Any} = 3\nf4(A::Array{Any}) = 4\n\nThe signature - as described in Function calls - of f3 is a UnionAll type wrapping a tuple type: Tuple{typeof(f3), Array{T}} where T.\nAll but f4 can be called with a = [1,2]; all but f2 can be called with b = Any[1,2].\n\nLet's look at these types a little more closely:\n\njulia> dump(Array)\nUnionAll\n  var: TypeVar\n    name: Symbol T\n    lb: Union{}\n    ub: abstract type Any\n  body: UnionAll\n    var: TypeVar\n      name: Symbol N\n      lb: Union{}\n      ub: abstract type Any\n    body: mutable struct Array{T, N} <: DenseArray{T, N}\n      ref::MemoryRef{T}\n      size::NTuple{N, Int64}\n\nThis indicates that Array actually names a UnionAll type. There is one UnionAll type for\neach parameter, nested. The syntax Array{Int,2} is equivalent to Array{Int}{2};\ninternally each UnionAll is instantiated with a particular variable value, one at a time,\noutermost-first. This gives a natural meaning to the omission of trailing type parameters;\nArray{Int} gives a type equivalent to Array{Int,N} where N.\n\nA TypeVar is not itself a type, but rather should be considered part of the structure of a\nUnionAll type. Type variables have lower and upper bounds on their values (in the fields\nlb and ub). The symbol name is purely cosmetic. Internally, TypeVars are compared by\naddress, so they are defined as mutable types to ensure that \"different\" type variables can be\ndistinguished. However, by convention they should not be mutated.\n\nOne can construct TypeVars manually:\n\njulia> TypeVar(:V, Signed, Real)\nSigned<:V<:Real\n\nThere are convenience versions that allow you to omit any of these arguments except the name\nsymbol.\n\nThe syntax Array{T} where T<:Integer is lowered to\n\nlet T = TypeVar(:T,Integer)\n    UnionAll(T, Array{T})\nend\n\nso it is seldom necessary to construct a TypeVar manually (indeed, this is to be avoided)."},{"title":"Free variables","page":"More about types","location":"devdocs/types.html#Free-variables","category":"section","text":"The concept of a free type variable is extremely important in the type system. We say that a\nvariable V is free in type T if T does not contain the UnionAll that introduces variable\nV. For example, the type Array{Array{V} where V<:Integer} has no free variables, but the\nArray{V} part inside of it does have a free variable, V.\n\nA type with free variables is, in some sense, not really a type at all. Consider the type\nArray{Array{T}} where T, which refers to all homogeneous arrays of arrays.\nThe inner type Array{T}, seen by itself, might seem to refer to any kind of array.\nHowever, every element of the outer array must have the same array type, so Array{T} cannot\nrefer to just any old array. One could say that Array{T} effectively \"occurs\" multiple times,\nand T must have the same value each \"time\".\n\nFor this reason, the function jl_has_free_typevars in the C API is very important. Types for\nwhich it returns true will not give meaningful answers in subtyping and other type functions."},{"title":"TypeNames","page":"More about types","location":"devdocs/types.html#TypeNames","category":"section","text":"The following two Array types are functionally equivalent, yet print differently:\n\njulia> TV, NV = TypeVar(:T), TypeVar(:N)\n(T, N)\n\njulia> Array\nArray\n\njulia> Array{TV, NV}\nArray{T, N}\n\nThese can be distinguished by examining the name field of the type, which is an object of type\nTypeName:\n\njulia> dump(Array{Int,1}.name)\nTypeName\n  name: Symbol Array\n  module: Module Core\n  singletonname: Symbol Array\n  names: SimpleVector\n    1: Symbol ref\n    2: Symbol size\n  atomicfields: Ptr{Nothing}(0x0000000000000000)\n  constfields: Ptr{Nothing}(0x0000000000000000)\n  wrapper: UnionAll\n    var: TypeVar\n      name: Symbol T\n      lb: Union{}\n      ub: abstract type Any\n    body: UnionAll\n      var: TypeVar\n        name: Symbol N\n        lb: Union{}\n        ub: abstract type Any\n      body: mutable struct Array{T, N} <: DenseArray{T, N}\n  Typeofwrapper: abstract type Type{Array} <: Any\n  cache: SimpleVector\n    ...\n  linearcache: SimpleVector\n    ...\n  hash: Int64 2594190783455944385\n  backedges: #undef\n  partial: #undef\n  max_args: Int32 0\n  n_uninitialized: Int32 0\n  flags: UInt8 0x02\n  cache_entry_count: UInt8 0x00\n  max_methods: UInt8 0x00\n  constprop_heuristic: UInt8 0x00\n\nIn this case, the relevant field is wrapper, which holds a reference to the top-level type used\nto make new Array types.\n\njulia> pointer_from_objref(Array)\nPtr{Cvoid} @0x00007fcc7de64850\n\njulia> pointer_from_objref(Array.body.body.name.wrapper)\nPtr{Cvoid} @0x00007fcc7de64850\n\njulia> pointer_from_objref(Array{TV,NV})\nPtr{Cvoid} @0x00007fcc80c4d930\n\njulia> pointer_from_objref(Array{TV,NV}.name.wrapper)\nPtr{Cvoid} @0x00007fcc7de64850\n\nThe wrapper field of Array points to itself, but for Array{TV,NV} it points back\nto the original definition of the type.\n\nWhat about the other fields? hash assigns an integer to each type. To examine the cache\nfield, it's helpful to pick a type that is less heavily used than Array. Let's first create our\nown type:\n\njulia> struct MyType{T,N} end\n\njulia> MyType{Int,2}\nMyType{Int64, 2}\n\njulia> MyType{Float32, 5}\nMyType{Float32, 5}\n\nWhen you instantiate a parametric type, each concrete type gets saved in a type\ncache (MyType.body.body.name.cache). However, instances containing free type\nvariables are not cached."},{"title":"Tuple types","page":"More about types","location":"devdocs/types.html#Tuple-types","category":"section","text":"Tuple types constitute an interesting special case. For dispatch to work on declarations like\nx::Tuple, the type has to be able to accommodate any tuple. Let's check the parameters:\n\njulia> Tuple\nTuple\n\njulia> Tuple.parameters\nsvec(Vararg{Any})\n\nUnlike other types, tuple types are covariant in their parameters, so this definition permits\nTuple to match any type of tuple:\n\njulia> typeintersect(Tuple, Tuple{Int,Float64})\nTuple{Int64, Float64}\n\njulia> typeintersect(Tuple{Vararg{Any}}, Tuple{Int,Float64})\nTuple{Int64, Float64}\n\nHowever, if a variadic (Vararg) tuple type has free variables it can describe different kinds\nof tuples:\n\njulia> typeintersect(Tuple{Vararg{T} where T}, Tuple{Int,Float64})\nTuple{Int64, Float64}\n\njulia> typeintersect(Tuple{Vararg{T}} where T, Tuple{Int,Float64})\nUnion{}\n\nNotice that when T is free with respect to the Tuple type (i.e. its binding UnionAll\ntype is outside the Tuple type), only one T value must work over the whole type.\nTherefore a heterogeneous tuple does not match.\n\nFinally, it's worth noting that Tuple{} is distinct:\n\njulia> Tuple{}\nTuple{}\n\njulia> Tuple{}.parameters\nsvec()\n\njulia> typeintersect(Tuple{}, Tuple{Int})\nUnion{}\n\nWhat is the \"primary\" tuple-type?\n\njulia> pointer_from_objref(Tuple)\nPtr{Cvoid} @0x00007f5998a04370\n\njulia> pointer_from_objref(Tuple{})\nPtr{Cvoid} @0x00007f5998a570d0\n\njulia> pointer_from_objref(Tuple.name.wrapper)\nPtr{Cvoid} @0x00007f5998a04370\n\njulia> pointer_from_objref(Tuple{}.name.wrapper)\nPtr{Cvoid} @0x00007f5998a04370\n\nso Tuple == Tuple{Vararg{Any}} is indeed the primary type."},{"title":"Diagonal types","page":"More about types","location":"devdocs/types.html#Diagonal-types","category":"section","text":"Consider the type Tuple{T,T} where T.\nA method with this signature would look like:\n\nf(x::T, y::T) where {T} = ...\n\nAccording to the usual interpretation of a UnionAll type, this T ranges over all\ntypes, including Any, so this type should be equivalent to Tuple{Any,Any}.\nHowever, this interpretation causes some practical problems.\n\nFirst, a value of T needs to be available inside the method definition.\nFor a call like f(1, 1.0), it's not clear what T should be.\nIt could be Union{Int,Float64}, or perhaps Real.\nIntuitively, we expect the declaration x::T to mean T === typeof(x).\nTo make sure that invariant holds, we need typeof(x) === typeof(y) === T in this method.\nThat implies the method should only be called for arguments of the exact same type.\n\nIt turns out that being able to dispatch on whether two values have the same type\nis very useful (this is used by the promotion system for example), so we have\nmultiple reasons to want a different interpretation of Tuple{T,T} where T.\nTo make this work we add the following rule to subtyping: if a variable occurs\nmore than once in covariant position, it is restricted to ranging over only concrete\ntypes.\n(\"Covariant position\" means that only Tuple and Union types occur between an\noccurrence of a variable and the UnionAll type that introduces it.)\nSuch variables are called \"diagonal variables\" or \"concrete variables\".\n\nSo for example, Tuple{T,T} where T can be seen as\nUnion{Tuple{Int8,Int8}, Tuple{Int16,Int16}, ...}, where T ranges over all\nconcrete types.\nThis gives rise to some interesting subtyping results.\nFor example Tuple{Real,Real} is not a subtype of Tuple{T,T} where T, because\nit includes some types like Tuple{Int8,Int16} where the two elements have\ndifferent types.\nTuple{Real,Real} and Tuple{T,T} where T have the non-trivial intersection\nTuple{T,T} where T<:Real.\nHowever, Tuple{Real} is a subtype of Tuple{T} where T, because in that case\nT occurs only once and so is not diagonal.\n\nNext consider a signature like the following:\n\nf(a::Array{T}, x::T, y::T) where {T} = ...\n\nIn this case, T occurs in invariant position inside Array{T}.\nThat means whatever type of array is passed unambiguously determines\nthe value of T – we say T has an equality constraint on it.\nTherefore in this case the diagonal rule is not really necessary, since\nthe array determines T and we can then allow x and y to be of\nany subtypes of T.\nSo variables that occur in invariant position are never considered diagonal.\nThis choice of behavior is slightly controversial – some feel this definition\nshould be written as\n\nf(a::Array{T}, x::S, y::S) where {T, S<:T} = ...\n\nto clarify whether x and y need to have the same type.\nIn this version of the signature they would, or we could introduce a third variable for\nthe type of y if x and y can have different types.\n\nThe next complication is the interaction of unions and diagonal variables, e.g.\n\nf(x::Union{Nothing,T}, y::T) where {T} = ...\n\nConsider what this declaration means.\ny has type T. x then can have either the same type T, or else be of type Nothing.\nSo all of the following calls should match:\n\nf(1, 1)\nf(\"\", \"\")\nf(2.0, 2.0)\nf(nothing, 1)\nf(nothing, \"\")\nf(nothing, 2.0)\n\nThese examples are telling us something: when x is nothing::Nothing, there are no\nextra constraints on y.\nIt is as if the method signature had y::Any.\nIndeed, we have the following type equivalence:\n\n(Tuple{Union{Nothing,T},T} where T) == Union{Tuple{Nothing,Any}, Tuple{T,T} where T}\n\nThe general rule is: a concrete variable in covariant position acts like it's\nnot concrete if the subtyping algorithm only uses it once.\nWhen x has type Nothing, we don't need to use the T in Union{Nothing,T};\nwe only use it in the second slot.\nThis arises naturally from the observation that in Tuple{T} where T restricting\nT to concrete types makes no difference; the type is equal to Tuple{Any} either way.\n\nHowever, appearing in invariant position disqualifies a variable from being concrete\nwhether that appearance of the variable is used or not.\nOtherwise types can behave differently depending on which other types\nthey are compared to, making subtyping not transitive. For example, consider\n\nTuple{Int,Int8,Vector{Integer}} <: Tuple{T,T,Vector{Union{Integer,T}}} where T\n\nIf the T inside the Union is ignored, then T is concrete and the answer is \"false\"\nsince the first two types aren't the same.\nBut consider instead\n\nTuple{Int,Int8,Vector{Any}} <: Tuple{T,T,Vector{Union{Integer,T}}} where T\n\nNow we cannot ignore the T in the Union (we must have T == Any), so T is not\nconcrete and the answer is \"true\".\nThat would make the concreteness of T depend on the other type, which is not\nacceptable since a type must have a clear meaning on its own.\nTherefore the appearance of T inside Vector is considered in both cases."},{"title":"Subtyping diagonal variables","page":"More about types","location":"devdocs/types.html#Subtyping-diagonal-variables","category":"section","text":"The subtyping algorithm for diagonal variables has two components:\n(1) identifying variable occurrences, and (2) ensuring that diagonal\nvariables range over concrete types only.\n\nThe first task is accomplished by keeping counters occurs_inv and occurs_cov\n(in src/subtype.c) for each variable in the environment, tracking the number\nof invariant and covariant occurrences, respectively.\nA variable is diagonal when occurs_inv == 0 && occurs_cov > 1.\n\nThe second task is accomplished by imposing a condition on a variable's lower bound.\nAs the subtyping algorithm runs, it narrows the bounds of each variable\n(raising lower bounds and lowering upper bounds) to keep track of the\nrange of variable values for which the subtype relation would hold.\nWhen we are done evaluating the body of a UnionAll type whose variable is diagonal,\nwe look at the final values of the bounds.\nSince the variable must be concrete, a contradiction occurs if its lower bound\ncould not be a subtype of a concrete type.\nFor example, an abstract type like AbstractArray cannot be a subtype of a concrete\ntype, but a concrete type like Int can be, and the empty type Bottom can be as well.\nIf a lower bound fails this test the algorithm stops with the answer false.\n\nFor example, in the problem Tuple{Int,String} <: Tuple{T,T} where T, we derive that\nthis would be true if T were a supertype of Union{Int,String}.\nHowever, Union{Int,String} is an abstract type, so the relation does not hold.\n\nThis concreteness test is done by the function is_leaf_bound.\nNote that this test is slightly different from jl_is_leaf_type, since it also returns\ntrue for Bottom.\nCurrently this function is heuristic, and does not catch all possible concrete types.\nThe difficulty is that whether a lower bound is concrete might depend on the values\nof other type variable bounds.\nFor example, Vector{T} is equivalent to the concrete type Vector{Int} only if\nboth the upper and lower bounds of T equal Int.\nWe have not yet worked out a complete algorithm for this."},{"title":"Introduction to the internal machinery","page":"More about types","location":"devdocs/types.html#Introduction-to-the-internal-machinery","category":"section","text":"Most operations for dealing with types are found in the files jltypes.c and subtype.c.\nA good way to start is to watch subtyping in action.\nBuild Julia with make debug and fire up Julia within a debugger.\ngdb debugging tips has some tips which may be useful.\n\nBecause the subtyping code is used heavily in the REPL itself – and hence breakpoints in this\ncode get triggered often – it will be easiest if you make the following definition:\n\njulia> function mysubtype(a,b)\n           ccall(:jl_breakpoint, Cvoid, (Any,), nothing)\n           a <: b\n       end\n\nand then set a breakpoint in jl_breakpoint. Once this breakpoint gets triggered, you can set\nbreakpoints in other functions.\n\nAs a warm-up, try the following:\n\nmysubtype(Tuple{Int, Float64}, Tuple{Integer, Real})\n\nWe can make it more interesting by trying a more complex case:\n\nmysubtype(Tuple{Array{Int,2}, Int8}, Tuple{Array{T}, T} where T)"},{"title":"Subtyping and method sorting","page":"More about types","location":"devdocs/types.html#Subtyping-and-method-sorting","category":"section","text":"The type_morespecific functions are used for imposing a partial order on functions in method\ntables (from most-to-least specific). Specificity is strict; if a is more specific than b,\nthen a does not equal b and b is not more specific than a.\n\nIf a is a strict subtype of b, then it is automatically considered more specific.\nFrom there, type_morespecific employs some less formal rules.\nFor example, subtype is sensitive to the number of arguments, but type_morespecific may not be.\nIn particular, Tuple{Int,AbstractFloat} is more specific than Tuple{Integer}, even though it is\nnot a subtype.  (Of Tuple{Int,AbstractFloat} and Tuple{Integer,Float64}, neither is more specific\nthan the other.)  Likewise, Tuple{Int,Vararg{Int}} is not a subtype of Tuple{Integer}, but it is\nconsidered more specific. However, morespecific does get a bonus for length: in particular,\nTuple{Int,Int} is more specific than Tuple{Int,Vararg{Int}}.\n\nAdditionally, if 2 methods are defined with identical signatures, per type-equal, then they\nwill instead be compared by order of addition, such that the later method is more specific\nthan the earlier one."},{"title":"Ahead of Time Compilation","page":"Ahead of Time Compilation","location":"devdocs/aot.html#Ahead-of-Time-Compilation","category":"section","text":"This document describes the design and structure of the ahead-of-time (AOT) compilation system in Julia. This system is used when generating system images and package images. Much of the implementation described here is located in aotcompile.cpp, staticdata.c, and processor.cpp"},{"title":"Introduction","page":"Ahead of Time Compilation","location":"devdocs/aot.html#Introduction","category":"section","text":"Though Julia normally compiles code just-in-time (JIT), it is possible to compile code ahead of time and save the resulting code to a file. This can be useful for a number of reasons:\n\nTo reduce the time it takes to start a Julia process.\nTo reduce the time spent in the JIT compiler instead of executing code (time to first execution, TTFX).\nTo reduce the amount of memory used by the JIT compiler."},{"title":"High-Level Overview","page":"Ahead of Time Compilation","location":"devdocs/aot.html#High-Level-Overview","category":"section","text":"The following descriptions are a snapshot of the current implementation details of the end-to-end pipeline that happens internally when the user compiles a new AOT module, such as occurs when they type using Foo. These details are likely to change over time as we implement better ways to handle them, so current implementations may not exactly match the dataflow and functions described below."},{"title":"Compiling Code Images","page":"Ahead of Time Compilation","location":"devdocs/aot.html#Compiling-Code-Images","category":"section","text":"Firstly, the methods that need to be compiled to native code must be identified. This can only be done by actually executing the code to be compiled, as the set of methods that need to be compiled depends on the types of the arguments passed to the methods, and method invocations with certain combinations of types may not be known until runtime. During this process, the exact methods that the compiler sees are tracked for later compilation, producing a compilation trace.\n\nnote: Note\nCurrently when compiling images, Julia runs the trace generation in a different process than the process performing the AOT compilation. This can have impacts when attempting to use a debugger during precompilation. The best way to debug precompilation with a debugger is to use the rr debugger, record the entire process tree, use rr ps to identify the relevant failing process, and then use rr replay -p PID to replay just the failing process.\n\nOnce the methods to be compiled have been identified, they are passed to the jl_create_system_image function. This function sets up a number of data structures that will be used when serializing native code to a file, and then calls jl_create_native with the array of methods. jl_create_native runs codegen on the methods produces one or more LLVM modules. jl_create_system_image then records some useful information about what codegen produced from the module(s).\n\nThe module(s) are then passed to jl_dump_native, along with the information recorded by jl_create_system_image. jl_dump_native contains the code necessary to serialize the module(s) to bitcode, object, or assembly files depending on the command-line options passed to Julia. The serialized code and information are then written to a file as an archive.\n\nThe final step is to run a system linker on the object files in the archive produced by jl_dump_native. Once this step is complete, a shared library containing the compiled code is produced."},{"title":"Loading Code Images","page":"Ahead of Time Compilation","location":"devdocs/aot.html#Loading-Code-Images","category":"section","text":"When loading a code image, the shared library produced by the linker is loaded into memory. The system image data is then loaded from the shared library. This data contains information about the types, methods, and code instances that were compiled into the shared library. This data is used to restore the state of the runtime to what it was when the code image was compiled.\n\nIf the code image was compiled with multiversioning, the loader will pick the appropriate version of each function to use based on the CPU features available on the current machine.\n\nFor system images, since no other code has been loaded, the state of the runtime is now the same as it was when the code image was compiled. For package images, the environment may have changed compared to when the code was compiled, so each method must be checked against the global method table to determine if it is still valid code."},{"title":"Compiling Methods","page":"Ahead of Time Compilation","location":"devdocs/aot.html#Compiling-Methods","category":"section","text":""},{"title":"Tracing Compiled Methods","page":"Ahead of Time Compilation","location":"devdocs/aot.html#Tracing-Compiled-Methods","category":"section","text":"Julia has a command-line flag to record all of the methods that are compiled by the JIT compiler, --trace-compile=filename. When a function is compiled and this flag has a filename, Julia will print out a precompile statement to that file with the method and argument types it was called with. This therefore generates a precompile script that can be used later in the AOT compilation process. The PrecompileTools package has tooling that can make taking advantage of this functionality easier for package developers."},{"title":"jl_create_system_image","page":"Ahead of Time Compilation","location":"devdocs/aot.html#jl_create_system_image","category":"section","text":"jl_create_system_image saves all of the Julia-specific metadata necessary to later restore the state of the runtime. This includes data such as code instances, method instances, method tables, and type information. This function also sets up the data structures necessary to serialize the native code to a file. Finally, it calls jl_create_native to create one or more LLVM modules containing the native code for the methods passed to it. jl_create_native is responsible for running codegen on the methods passed to it."},{"title":"jl_dump_native","page":"Ahead of Time Compilation","location":"devdocs/aot.html#jl_dump_native","category":"section","text":"jl_dump_native is responsible for serializing the LLVM module containing the native code to a file. In addition to the module, the system image data produced by jl_create_system_image is compiled as a global variable. The output of this method is bitcode, object, and/or assembly archives containing the code and system image data.\n\njl_dump_native is typically one of the larger time sinks when emitting native code, with much of the time spent in optimizing LLVM IR and emitting machine code. Therefore, this function is capable of multithreading the optimization and machine code emission steps. This multithreading is parameterized on the size of the module, but can be explicitly overridden by setting the JULIA_IMAGE_THREADS environment variable. The default maximum number of threads is half the number of available threads, but setting it to be lower can reduce peak memory usage during compilation.\n\njl_dump_native can also produce native code optimized for multiple architectures, when integrated with the Julia loader. This is triggered by setting the JULIA_CPU_TARGET environment variable and mediated by the multiversioning pass in the optimization pipeline. To make this work with multithreading, an annotation step is added before the module is split into submodules that are emitted on their own threads, and this annotation step uses information available throughout the entire module to decide what functions are cloned for different architectures. Once the annotation has happened, individual threads can emit code for different architectures in parallel, knowing that a different submodule is guaranteed to produce the necessary functions that will be called by a cloned function.\n\nSome other metadata about how the module was serialized is also stored in the archive, such as the number of threads used to serialize the module and the number of functions that were compiled."},{"title":"Static Linking","page":"Ahead of Time Compilation","location":"devdocs/aot.html#Static-Linking","category":"section","text":"The final step in the AOT compilation process is to run a linker on the object files in the archive produced by jl_dump_native. This produces a shared library containing the compiled code. This shared library can then be loaded by Julia to restore the state of the runtime. When compiling a system image, the native linker used by a C compiler is used to produce the final shared library. For package images, the LLVM linker LLD is used to provide a more consistent linking interface."},{"title":"Loading Code Images","page":"Ahead of Time Compilation","location":"devdocs/aot.html#Loading-Code-Images-2","category":"section","text":""},{"title":"Loading the Shared Library","page":"Ahead of Time Compilation","location":"devdocs/aot.html#Loading-the-Shared-Library","category":"section","text":"The first step in loading a code image is to load the shared library produced by the linker. This is done by calling jl_dlopen on the path to the shared library. This function is responsible for loading the shared library and resolving all of the symbols in the library."},{"title":"Loading Native Code","page":"Ahead of Time Compilation","location":"devdocs/aot.html#Loading-Native-Code","category":"section","text":"The loader first needs to identify whether the native code that was compiled is valid for the architecture that the loader is running on. This is necessary to avoid executing instructions that older CPUs do not recognize. This is done by checking the CPU features available on the current machine against the CPU features that the code was compiled for. When multiversioning is enabled, the loader will pick the appropriate version of each function to use based on the CPU features available on the current machine. If none of the feature sets that were multiversioned, the loader will throw an error.\n\nPart of the multiversioning pass creates a number of global arrays of all of the functions in the module. When this process is multithreaded, an array of arrays is created, which the loader reorganizes into one large array with all of the functions that were compiled for this architecture. A similar process occurs for the global variables in the module."},{"title":"Setting Up Julia State","page":"Ahead of Time Compilation","location":"devdocs/aot.html#Setting-Up-Julia-State","category":"section","text":"The loader then uses the global variables and functions produced from loading native code to set up Julia runtime core data structures in the current process. This setup involves adding types and methods to the Julia runtime, and making the cached native code available for use by other Julia functions and the interpreter. For package images, each method must be validated, in that the global method table's state must match the state that the package image was compiled for. In particular, if a different set of methods exists at the load time compared to compile time of the package image, the method must be invalidated and recompiled on first use. This is necessary to ensure that execution semantics remain the same regardless of if a package was precompiled or if the code was directly executed. System images do not need to perform this validation, since the global method table is empty at load time. Thus, system images have faster load times than package images."},{"title":"Missing Values","page":"Missing Values","location":"manual/missing.html#missing","category":"section","text":"Julia provides support for representing missing values in the statistical sense.\nThis is for situations where no value is available for a variable in an observation,\nbut a valid value theoretically exists.\nMissing values are represented via the missing object, which is the\nsingleton instance of the type Missing. missing is equivalent to\nNULL in SQL and\nNA in R,\nand behaves like them in most situations."},{"title":"Propagation of Missing Values","page":"Missing Values","location":"manual/missing.html#Propagation-of-Missing-Values","category":"section","text":"missing values propagate automatically when passed to standard mathematical\noperators and functions.\nFor these functions, uncertainty about the value of one of the operands\ninduces uncertainty about the result. In practice, this means a math operation\ninvolving a missing value generally returns missing:\n\njulia> missing + 1\nmissing\n\njulia> \"a\" * missing\nmissing\n\njulia> abs(missing)\nmissing\n\nSince missing is a normal Julia object, this propagation rule only works\nfor functions which have opted in to implement this behavior. This can be\nachieved by:\n\nadding a specific method defined for arguments of type Missing,\naccepting arguments of this type, and passing them to functions\nwhich propagate them (like standard math operators).\n\nPackages should consider\nwhether it makes sense to propagate missing values when defining new functions,\nand define methods appropriately if this is the case. Passing a missing value\nto a function which does not have a method accepting arguments of type Missing\nthrows a MethodError, just like for any other type.\n\nFunctions that do not propagate missing values can be made to do so by wrapping\nthem in the passmissing function provided by the\nMissings.jl package.\nFor example, f(x) becomes passmissing(f)(x)."},{"title":"Equality and Comparison Operators","page":"Missing Values","location":"manual/missing.html#Equality-and-Comparison-Operators","category":"section","text":"Standard equality and comparison operators follow the propagation rule presented\nabove: if any of the operands is missing, the result is missing.\nHere are a few examples:\n\njulia> missing == 1\nmissing\n\njulia> missing == missing\nmissing\n\njulia> missing < 1\nmissing\n\njulia> 2 >= missing\nmissing\n\nIn particular, note that missing == missing returns missing, so == cannot\nbe used to test whether a value is missing. To test whether x is missing,\nuse ismissing(x).\n\nSpecial comparison operators isequal and === are exceptions\nto the propagation rule. They will always return a Bool value, even in the presence\nof missing values, considering missing as equal to missing and as different\nfrom any other value. They can therefore be used to test whether a value is missing:\n\njulia> missing === 1\nfalse\n\njulia> isequal(missing, 1)\nfalse\n\njulia> missing === missing\ntrue\n\njulia> isequal(missing, missing)\ntrue\n\nThe isless operator is another exception: missing is considered\nas greater than any other value. This operator is used by sort!,\nwhich therefore places missing values after all other values:\n\njulia> isless(1, missing)\ntrue\n\njulia> isless(missing, Inf)\nfalse\n\njulia> isless(missing, missing)\nfalse"},{"title":"Logical operators","page":"Missing Values","location":"manual/missing.html#Logical-operators","category":"section","text":"Logical (or boolean) operators |, & and xor are\nanother special case since they only propagate missing values when it is logically\nrequired. For these operators, whether or not the result is uncertain, depends\non the particular operation. This follows the well-established rules of\nthree-valued logic which are\nimplemented by e.g. NULL in SQL and NA in R. This abstract definition\ncorresponds to a relatively natural behavior which is best explained\nvia concrete examples.\n\nLet us illustrate this principle with the logical \"or\" operator |.\nFollowing the rules of boolean logic, if one of the operands is true,\nthe value of the other operand does not have an influence on the result,\nwhich will always be true:\n\njulia> true | true\ntrue\n\njulia> true | false\ntrue\n\njulia> false | true\ntrue\n\nBased on this observation, we can conclude if one of the operands is true\nand the other missing, we know that the result is true in spite of the\nuncertainty about the actual value of one of the operands. If we had\nbeen able to observe the actual value of the second operand, it could only be\ntrue or false, and in both cases the result would be true. Therefore,\nin this particular case, missingness does not propagate:\n\njulia> true | missing\ntrue\n\njulia> missing | true\ntrue\n\nOn the contrary, if one of the operands is false, the result could be either\ntrue or false depending on the value of the other operand. Therefore,\nif that operand is missing, the result has to be missing too:\n\njulia> false | true\ntrue\n\njulia> true | false\ntrue\n\njulia> false | false\nfalse\n\njulia> false | missing\nmissing\n\njulia> missing | false\nmissing\n\nThe behavior of the logical \"and\" operator & is similar to that of the\n| operator, with the difference that missingness does not propagate when\none of the operands is false. For example, when that is the case of the first\noperand:\n\njulia> false & false\nfalse\n\njulia> false & true\nfalse\n\njulia> false & missing\nfalse\n\nOn the other hand, missingness propagates when one of the operands is true,\nfor example the first one:\n\njulia> true & true\ntrue\n\njulia> true & false\nfalse\n\njulia> true & missing\nmissing\n\nFinally, the \"exclusive or\" logical operator xor always propagates\nmissing values, since both operands always have an effect on the result.\nAlso note that the negation operator ! returns missing when the\noperand is missing, just like other unary operators."},{"title":"Control Flow and Short-Circuiting Operators","page":"Missing Values","location":"manual/missing.html#Control-Flow-and-Short-Circuiting-Operators","category":"section","text":"Control flow operators including if, while and the\nternary operator x ? y : z\ndo not allow for missing values. This is because of the uncertainty about whether\nthe actual value would be true or false if we could observe it.\nThis implies we do not know how the program should behave. In this case, a\nTypeError is thrown as soon as a missing value is encountered in this context:\n\njulia> if missing\n           println(\"here\")\n       end\nERROR: TypeError: non-boolean (Missing) used in boolean context\n\nFor the same reason, contrary to logical operators presented above,\nthe short-circuiting boolean operators && and || do not\nallow for missing values in situations where the value of the operand\ndetermines whether the next operand is evaluated or not. For example:\n\njulia> missing || false\nERROR: TypeError: non-boolean (Missing) used in boolean context\n\njulia> missing && false\nERROR: TypeError: non-boolean (Missing) used in boolean context\n\njulia> true && missing && false\nERROR: TypeError: non-boolean (Missing) used in boolean context\n\nIn contrast, there is no error thrown when the result can be determined without\nthe missing values. This is the case when the code short-circuits\nbefore evaluating the missing operand, and when the missing operand is the\nlast one:\n\njulia> true && missing\nmissing\n\njulia> false && missing\nfalse"},{"title":"Arrays With Missing Values","page":"Missing Values","location":"manual/missing.html#Arrays-With-Missing-Values","category":"section","text":"Arrays containing missing values can be created like other arrays:\n\njulia> [1, missing]\n2-element Vector{Union{Missing, Int64}}:\n 1\n  missing\n\nAs this example shows, the element type of such arrays is Union{Missing, T},\nwith T the type of the non-missing values. This reflects the fact that\narray entries can be either of type T (here, Int64) or of type Missing.\nThis kind of array uses an efficient memory storage equivalent to an Array{T}\nholding the actual values combined with an Array{UInt8} indicating the type\nof the entry (i.e. whether it is Missing or T).\n\nArrays allowing for missing values can be constructed with the standard syntax.\nUse Array{Union{Missing, T}}(missing, dims) to create arrays filled with\nmissing values:\n\njulia> Array{Union{Missing, String}}(missing, 2, 3)\n2×3 Matrix{Union{Missing, String}}:\n missing  missing  missing\n missing  missing  missing\n\nnote: Note\nUsing undef or similar may currently give an array filled with\nmissing, but this is not the correct way to obtain such an array.\nUse a missing constructor as shown above instead.\n\nAn array with element type allowing missing entries (e.g. Vector{Union{Missing, T}})\nwhich does not contain any missing entries can be converted to an array type that does\nnot allow for missing entries (e.g. Vector{T}) using\nconvert. If the array contains missing values, a MethodError is thrown\nduring conversion:\n\njulia> x = Union{Missing, String}[\"a\", \"b\"]\n2-element Vector{Union{Missing, String}}:\n \"a\"\n \"b\"\n\njulia> convert(Array{String}, x)\n2-element Vector{String}:\n \"a\"\n \"b\"\n\njulia> y = Union{Missing, String}[missing, \"b\"]\n2-element Vector{Union{Missing, String}}:\n missing\n \"b\"\n\njulia> convert(Array{String}, y)\nERROR: MethodError: Cannot `convert` an object of type Missing to an object of type String"},{"title":"Skipping Missing Values","page":"Missing Values","location":"manual/missing.html#Skipping-Missing-Values","category":"section","text":"Since missing values propagate with standard mathematical operators, reduction\nfunctions return missing when called on arrays which contain missing values:\n\njulia> sum([1, missing])\nmissing\n\nIn this situation, use the skipmissing function to skip missing values:\n\njulia> sum(skipmissing([1, missing]))\n1\n\nThis convenience function returns an iterator which filters out missing values\nefficiently. It can therefore be used with any function which supports iterators:\n\njulia> x = skipmissing([3, missing, 2, 1])\nskipmissing(Union{Missing, Int64}[3, missing, 2, 1])\n\njulia> maximum(x)\n3\n\njulia> sum(x)\n6\n\njulia> mapreduce(sqrt, +, x)\n4.146264369941973\n\nObjects created by calling skipmissing on an array can be indexed using indices\nfrom the parent array. Indices corresponding to missing values are not valid for\nthese objects, and an error is thrown when trying to use them (they are also skipped\nby keys and eachindex):\n\njulia> x[1]\n3\n\njulia> x[2]\nERROR: MissingException: the value at index (2,) is missing\n[...]\n\nThis allows functions which operate on indices to work in combination with skipmissing.\nThis is notably the case for search and find functions. These functions return indices\nvalid for the object returned by skipmissing, and are also the indices of the\nmatching entries in the parent array:\n\njulia> findall(==(1), x)\n1-element Vector{Int64}:\n 4\n\njulia> findfirst(!iszero, x)\n1\n\njulia> argmax(x)\n1\n\nUse collect to extract non-missing values and store them in an array:\n\njulia> collect(x)\n3-element Vector{Int64}:\n 3\n 2\n 1"},{"title":"Logical Operations on Arrays","page":"Missing Values","location":"manual/missing.html#Logical-Operations-on-Arrays","category":"section","text":"The three-valued logic described above for logical operators is also used\nby logical functions applied to arrays. Thus, array equality tests using\nthe == operator return missing whenever the result cannot be\ndetermined without knowing the actual value of the missing entry. In practice,\nthis means missing is returned if all non-missing values of the compared\narrays are equal, but one or both arrays contain missing values (possibly at\ndifferent positions):\n\njulia> [1, missing] == [2, missing]\nfalse\n\njulia> [1, missing] == [1, missing]\nmissing\n\njulia> [1, 2, missing] == [1, missing, 2]\nmissing\n\nAs for single values, use isequal to treat missing values as equal\nto other missing values, but different from non-missing values:\n\njulia> isequal([1, missing], [1, missing])\ntrue\n\njulia> isequal([1, 2, missing], [1, missing, 2])\nfalse\n\nFunctions any and all also follow the rules of\nthree-valued logic. Thus, returning missing when the result cannot be determined:\n\njulia> all([true, missing])\nmissing\n\njulia> all([false, missing])\nfalse\n\njulia> any([true, missing])\ntrue\n\njulia> any([false, missing])\nmissing"},{"title":"The World Age mechanism","page":"The World Age mechanism","location":"manual/worldage.html#man-world-age","category":"section","text":"note: Note\nWorld age is an advanced concept. For the vast majority of Julia users, the world age\nmechanism operates invisibly in the background. This documentation is intended for the\nfew users who may encounter world-age related issues or error messages.\n\ncompat: Julia 1.12\nPrior to Julia 1.12, the world age mechanism did not apply to changes to the global binding table.\nThe documentation in this chapter is specific to Julia 1.12+.\n\nwarning: Warning\nThis manual chapter uses internal functions to introspect world age and runtime data structures\nas an explanatory aid. In general, unless otherwise noted the world age mechanism is not a stable\ninterface and should be interacted with in packages through stable APIs (e.g. invokelatest) only.\nIn particular, do not assume that world ages are always integers or that they have a linear order."},{"title":"World age in general","page":"The World Age mechanism","location":"manual/worldage.html#World-age-in-general","category":"section","text":"The \"world age counter\" is a monotonically increasing counter that is incremented for every\nchange to the global method table or the global binding table (e.g. through method definition,\ntype definition, import/using declaration, creation of (typed) globals or definition of constants).\n\nThe current value of the global world age counter can be retrieved using the (internal) function Base.get_world_counter.\n\njulia> Base.get_world_counter()\n0x0000000000009632\n\njulia> const x = 1\n\njulia> Base.get_world_counter()\n0x0000000000009633\n\nIn addition, each Task stores a local world age that determines which modifications to\nthe global binding and method tables are currently visible to the running task. The world age of\nthe running task will never exceed the global world age counter, but may run arbitrarily behind it.\nIn general the term \"current world age\" refers to the local world age of the currently running task.\nThe current world age may be retrieved using the (internal) function Base.tls_world_age\n\njulia> function f end\nf (generic function with 0 methods)\n\njulia> begin\n           @show (Int(Base.get_world_counter()), Int(Base.tls_world_age()))\n           Core.eval(@__MODULE__, :(f() = 1))\n           @show (Int(Base.get_world_counter()), Int(Base.tls_world_age()))\n           f()\n       end\n(Int(Base.get_world_counter()), Int(Base.tls_world_age())) = (38452, 38452)\n(Int(Base.get_world_counter()), Int(Base.tls_world_age())) = (38453, 38452)\nERROR: MethodError: no method matching f()\nThe applicable method may be too new: running in current world age 38452, while global world is 38453.\n\nClosest candidates are:\n  f() (method too new to be called from this world context.)\n   @ Main REPL[2]:3\n\nStacktrace:\n [1] top-level scope\n   @ REPL[2]:5\n\njulia> (f(), Int(Base.tls_world_age()))\n(1, 38453)\n\nHere the definition of the method f raised the global world counter, but the current world\nage did not change. As a result, the definition of f was not visible in the currently\nexecuting task and a MethodError resulted.\n\nnote: Note\nThe method error printing provided additional information that f() is available in a newer world age.\nThis information is added by the error display, not the task that threw the MethodError.\nThe thrown MethodError is identical whether or not a matching definition of f() exists\nin a newer world age.\n\nHowever, note that the definition of f() was subsequently available at the next REPL prompt, because\nthe current task's world age had been raised. In general, certain syntactic constructs (in particular most definitions)\nwill raise the current task's world age to the latest global world age, thus making all changes\n(both from the current task and any concurrently executing other tasks) visible. The following statements\nraise the current world age:\n\nAn explicit invocation of Core.@latestworld\nThe start of every top-level statement\nThe start of every REPL prompt\nAny type or struct definition\nAny method definition\nAny constant declaration\nAny global variable declaration (but not a global variable assignment)\nAny using, import, export or public statement\nCertain other macros like @eval (depends on the macro implementation)\n\nNote, however, that the current task's world age may only ever be permanently incremented at\ntop level. As a general rule, using any of the above statements in non-top-level scope is a syntax error:\n\njulia> f() = Core.@latestworld\nERROR: syntax: World age increment not at top level\nStacktrace:\n [1] top-level scope\n   @ REPL[5]:1\n\nWhen it isn't (for example for @eval), the world age side effect is ignored.\n\nAs a result of these rules, Julia may assume that the world age does not change\nwithin the execution of an ordinary function.\n\nfunction my_function()\n    before = Base.tls_world_age()\n    # Any arbitrary code\n    after = Base.tls_world_age()\n    @assert before === after # always true\nend\n\nThis is the key invariant that allows Julia to optimize based on the current state\nof its global data structures, while still having the well-defined ability to change\nthese data structures."},{"title":"Temporarily raising the world age using invokelatest","page":"The World Age mechanism","location":"manual/worldage.html#Temporarily-raising-the-world-age-using-invokelatest","category":"section","text":"As described above, it is not possible to permanently raise the world age for the remainder of\na Task's execution unless the task is executing top-level statements. However, it is possible to\ntemporarily change the world age in a scoped manner using invokelatest:\n\njulia> function f end\nf (generic function with 0 methods)\n\njulia> begin\n           Core.eval(@__MODULE__, :(f() = 1))\n           invokelatest(f)\n       end\n1\n\ninvokelatest will temporarily raise the current task's world age to the latest global world age (at\nentry to invokelatest) and execute the provided function. Note that the world age will return\nto its prior value upon exit from invokelatest."},{"title":"World age and const struct redefinitions","page":"The World Age mechanism","location":"manual/worldage.html#World-age-and-const-struct-redefinitions","category":"section","text":"The semantics described above for method redefinition also apply to redefinition of constants:\n\njulia> const x = 1\n1\n\njulia> get_const() = x\nget_const (generic function with 1 method)\n\njulia> begin\n           @show get_const()\n           Core.eval(@__MODULE__, :(const x = 2))\n           @show get_const()\n           Core.@latestworld\n           @show get_const()\n       end\nget_const() = 1\nget_const() = 1\nget_const() = 2\n2\n\nHowever, for the avoidance of doubt, they do not apply to ordinary assignment to global variables, which becomes visible immediately:\n\njulia> global y = 1\n1\n\njulia> get_global() = y\nget_global (generic function with 1 method)\n\njulia> begin\n           @show get_global()\n           Core.eval(@__MODULE__, :(y = 2))\n           @show get_global()\n       end\nget_global() = 1\nget_global() = 2\n2\n\nOne particular special case of constant reassignment is the redefinition of struct types:\n\njulia> struct MyStruct\n           x::Int\n       end\n\njulia> const one_field = MyStruct(1)\nMyStruct(1)\n\njulia> struct MyStruct\n           x::Int\n           y::Float64\n       end\n\njulia> const two_field = MyStruct(1, 2.0)\nMyStruct(1, 2.0)\n\njulia> one_field\n@world(MyStruct, 38452:38455)(1)\n\njulia> two_field\nMyStruct(1, 2.0)\n\nInternally the two definitions of MyStruct are entirely separate types. However,\nafter the new MyStruct type is defined, there is no longer any default binding\nfor the original definition of MyStruct. To nevertheless facilitate access to\nthese types, the special @world macro may be used to access the meaning\nof a name in a previous world. However, this facility is intended for introspection\nonly and in particular note that world age numbers are not stable across precompilation\nand should in general be treated opaquely."},{"title":"Binding partition introspection","page":"The World Age mechanism","location":"manual/worldage.html#Binding-partition-introspection","category":"section","text":"In certain cases, it can be helpful to introspect the system's understanding of what\na binding means in any particular world age. The default display printing of Core.Binding\nprovides a helpful summary (e.g. on the MyStruct example from above):\n\njulia> convert(Core.Binding, GlobalRef(@__MODULE__, :MyStruct))\nBinding Main.MyStruct\n   38456:∞ - constant binding to MyStruct\n   38452:38455 - constant binding to @world(MyStruct, 38452:38455)\n   38451:38451 - backdated constant binding to @world(MyStruct, 38452:38455)\n   0:38450 - backdated constant binding to @world(MyStruct, 38452:38455)"},{"title":"World age and using/import","page":"The World Age mechanism","location":"manual/worldage.html#World-age-and-using/import","category":"section","text":"Bindings provided via using and import also operate via the world age mechanism.\nBinding resolution is a stateless function of the import and using definitions\nvisible in the current world age. For example:\n\njulia> module M1; const x = 1; export x; end\n\njulia> module M2; const x = 2; export x; end\n\njulia> using .M1\n\njulia> x\n1\n\njulia> using .M2\n\njulia> x\nERROR: UndefVarError: `x` not defined in `Main`\nHint: It looks like two or more modules export different bindings with this name, resulting in ambiguity. Try explicitly importing it from a particular module, or qualifying the name with the module it should come from.\n\njulia> convert(Core.Binding, GlobalRef(@__MODULE__, :x))\nBinding Main.x\n   38458:∞ - ambiguous binding - guard entry\n   38457:38457 - implicit `using` resolved to constant 1"},{"title":"World age capture","page":"The World Age mechanism","location":"manual/worldage.html#World-age-capture","category":"section","text":"Certain language features capture the current task's world age. Perhaps the most common of\nthese is creation of new tasks. Newly created tasks will inherit the creating task's local\nworld age at creation time and will retain said world age (unless explicitly raised) even\nif the originating tasks raises its world age:\n\njulia> const x = 1\n\njulia> t = @task (wait(); println(\"Running now\"); x);\n\njulia> const x = 2\n\njulia> schedule(t);\nRunning now\n\njulia> x\n2\n\njulia> fetch(t)\n1\n\nIn addition to tasks, opaque closures also capture their world age at creation. See Base.Experimental.@opaque."},{"title":"Base.@world","page":"The World Age mechanism","location":"manual/worldage.html#Base.@world","category":"macro","text":"@world(sym, world)\n\nResolve the binding sym in world world. See invoke_in_world for running\narbitrary code in fixed worlds. world may be UnitRange, in which case the macro\nwill error unless the binding is valid and has the same value across the entire world\nrange.\n\nAs a special case, the world ∞ always refers to the latest world, even if that world\nis newer than the world currently running.\n\nThe @world macro is primarily used in the printing of bindings that are no longer\navailable in the current world.\n\nExample\n\njulia> struct Foo; a::Int; end\nFoo\n\njulia> fold = Foo(1)\n\njulia> Int(Base.get_world_counter())\n26866\n\njulia> struct Foo; a::Int; b::Int end\nFoo\n\njulia> fold\n@world(Foo, 26866)(1)\n\ncompat: Julia 1.12\nThis functionality requires at least Julia 1.12.\n\n\n\n\n\n"},{"title":"Base.get_world_counter","page":"The World Age mechanism","location":"manual/worldage.html#Base.get_world_counter","category":"function","text":"get_world_counter()\n\nReturn the current maximum world-age counter. This counter is monotonically\nincreasing.\n\nwarning: Warning\nThis counter is global and may change at any time between invocations.\nIn general, most reflection functions operate on the current task's world\nage, rather than the global maximum world age. See tls_world_age\nas well as the manual chapter of world age.\n\n\n\n\n\n"},{"title":"Base.tls_world_age","page":"The World Age mechanism","location":"manual/worldage.html#Base.tls_world_age","category":"function","text":"tls_world_age()\n\nReturn the world the current_task() is executing within.\n\n\n\n\n\n"},{"title":"Base.invoke_in_world","page":"The World Age mechanism","location":"manual/worldage.html#Base.invoke_in_world","category":"function","text":"invoke_in_world(world, f, args...; kwargs...)\n\nCall f(args...; kwargs...) in a fixed world age, world.\n\nThis is useful for infrastructure running in the user's Julia session which is\nnot part of the user's program. For example, things related to the REPL, editor\nsupport libraries, etc. In these cases it can be useful to prevent unwanted\nmethod invalidation and recompilation latency, and to prevent the user from\nbreaking supporting infrastructure by mistake.\n\nThe global world age can be queried using Base.get_world_counter()\nand stored for later use within the lifetime of the current Julia session, or\nwhen serializing and reloading the system image.\n\nTechnically, invoke_in_world will prevent any function called by f from\nbeing extended by the user during their Julia session. That is, generic\nfunction method tables seen by f (and any functions it calls) will be frozen\nas they existed at the given world age. In a sense, this is like the opposite\nof invokelatest.\n\nnote: Note\nIt is not valid to store world ages obtained in precompilation for later use.\nThis is because precompilation generates a \"parallel universe\" where the\nworld age refers to system state unrelated to the main Julia session.\n\n\n\n\n\n"},{"title":"Base.Experimental.@opaque","page":"The World Age mechanism","location":"manual/worldage.html#Base.Experimental.@opaque","category":"macro","text":"@opaque ([type, ]args...) -> body\n\nMarks a given closure as \"opaque\". Opaque closures capture the\nworld age of their creation (as opposed to their invocation).\nThis allows for more aggressive optimization of the capture\nlist, but trades off against the ability to inline opaque\nclosures at the call site, if their creation is not statically\nvisible.\n\nAn argument tuple type (type) may optionally be specified, to\nspecify allowed argument types in a more flexible way. In particular,\nthe argument type may be fixed length even if the function is variadic.\n\nwarning: Warning\nThis interface is experimental and subject to change or removal without notice.\n\n\n\n\n\n"},{"title":"Reporting and analyzing crashes (segfaults)","page":"Reporting and analyzing crashes (segfaults)","location":"devdocs/backtraces.html#Reporting-and-analyzing-crashes-(segfaults)","category":"section","text":"So you managed to break Julia. Congratulations!  Collected here are some general procedures you\ncan undergo for common symptoms encountered when something goes awry. Including the information\nfrom these debugging steps can greatly help the maintainers when tracking down a segfault or trying\nto figure out why your script is running slower than expected.\n\nIf you've been directed to this page, find the symptom that best matches what you're experiencing\nand follow the instructions to generate the debugging information requested. Table of symptoms:\n\nSegfaults during bootstrap (sysimg.jl)\nSegfaults when running a script\nErrors during Julia startup\nOther generic segfaults or unreachables reached"},{"title":"Version/Environment info","page":"Reporting and analyzing crashes (segfaults)","location":"devdocs/backtraces.html#dev-version-info","category":"section","text":"No matter the error, we will always need to know what version of Julia you are running. When Julia\nfirst starts up, a header is printed out with a version number and date. Please also include the output of versioninfo() (exported from the InteractiveUtils standard library) in any report you create:\n\nusing InteractiveUtils\nversioninfo()"},{"title":"Segfaults during bootstrap (sysimg.jl)","page":"Reporting and analyzing crashes (segfaults)","location":"devdocs/backtraces.html#Segfaults-during-bootstrap-(sysimg.jl)","category":"section","text":"Segfaults toward the end of the make process of building Julia are a common symptom of something\ngoing wrong while Julia is preparsing the corpus of code in the base/ folder. Many factors\ncan contribute toward this process dying unexpectedly, however it is as often as not due to an\nerror in the C-code portion of Julia, and as such must typically be debugged with a debug build\ninside of gdb. Explicitly:\n\nCreate a debug build of Julia:\n\n$ cd <julia_root>\n$ make debug\n\nNote that this process will likely fail with the same error as a normal make incantation, however\nthis will create a debug executable that will offer gdb the debugging symbols needed to get\naccurate backtraces. Next, manually run the bootstrap process inside of gdb:\n\n$ cd base/\n$ gdb -x ../contrib/debug_bootstrap.gdb\n\nThis will start gdb, attempt to run the bootstrap process using the debug build of Julia, and\nprint out a backtrace if (when) it segfaults. You may need to hit <enter> a few times to get\nthe full backtrace. Create a gist with the backtrace, the version info,\nand any other pertinent information you can think of and open a new issue\non Github with a link to the gist."},{"title":"Segfaults when running a script","page":"Reporting and analyzing crashes (segfaults)","location":"devdocs/backtraces.html#Segfaults-when-running-a-script","category":"section","text":"The procedure is very similar to Segfaults during bootstrap (sysimg.jl). Create a debug\nbuild of Julia, and run your script inside of a debugged Julia process:\n\n$ cd <julia_root>\n$ make debug\n$ gdb --args usr/bin/julia-debug <path_to_your_script>\n\nNote that gdb will sit there, waiting for instructions. Type r to run the process, and bt\nto generate a backtrace once it segfaults:\n\n(gdb) r\nStarting program: /home/sabae/src/julia/usr/bin/julia-debug ./test.jl\n...\n(gdb) bt\n\nCreate a gist with the backtrace, the version info, and any\nother pertinent information you can think of and open a new issue\non Github with a link to the gist."},{"title":"Errors during Julia startup","page":"Reporting and analyzing crashes (segfaults)","location":"devdocs/backtraces.html#Errors-during-Julia-startup","category":"section","text":"Occasionally errors occur during Julia's startup process (especially when using binary distributions,\nas opposed to compiling from source) such as the following:\n\n$ julia\nexec: error -5\n\nThese errors typically indicate something is not getting loaded properly very early on in the\nbootup phase, and our best bet in determining what's going wrong is to use external tools to audit\nthe disk activity of the julia process:\n\nOn Linux, use strace:\n$ strace julia\nOn OSX, use dtruss:\n$ dtruss -f julia\n\nCreate a gist with the strace/ dtruss output, the version info,\nand any other pertinent information and open a new issue\non Github with a link to the gist."},{"title":"Other generic segfaults or unreachables reached","page":"Reporting and analyzing crashes (segfaults)","location":"devdocs/backtraces.html#Other-generic-segfaults-or-unreachables-reached","category":"section","text":"As mentioned elsewhere, julia has good integration with rr for generating traces; this includes, on Linux, the ability to automatically run julia under rr and share the trace after a crash. This can be immensely helpful when debugging such crashes and is strongly encouraged when reporting crash issues to the JuliaLang/julia repo. To run julia under rr automatically, do:\n\njulia --bug-report=rr\n\nTo generate the rr trace locally, but not share, you can do:\n\njulia --bug-report=rr-local\n\nNote that this is only works on Linux. The blog post on Time Travelling Bug Reporting has many more details."},{"title":"Glossary","page":"Reporting and analyzing crashes (segfaults)","location":"devdocs/backtraces.html#Glossary","category":"section","text":"A few terms have been used as shorthand in this guide:\n\n<julia_root> refers to the root directory of the Julia source tree; e.g. it should contain folders\nsuch as base, deps, src, test, etc."},{"title":"EscapeAnalysis","page":"EscapeAnalysis","location":"devdocs/EscapeAnalysis.html#EscapeAnalysis","category":"section","text":"Compiler.EscapeAnalysis is a compiler utility module that aims to analyze\nescape information of Julia's SSA-form IR a.k.a. IRCode.\n\nThis escape analysis aims to:\n\nleverage Julia's high-level semantics, especially reason about escapes and aliasing via\ninter-procedural calls\nbe versatile enough to be used for various optimizations including\nalias-aware SROA,\nearly finalize insertion,\ncopy-free ImmutableArray construction,\nstack allocation of mutable objects,\nand so on.\nachieve a simple implementation based on a fully backward data-flow analysis implementation\nas well as a new lattice design that combines orthogonal lattice properties"},{"title":"Try it out!","page":"EscapeAnalysis","location":"devdocs/EscapeAnalysis.html#Try-it-out!","category":"section","text":"You can give a try to the escape analysis by loading the EAUtils.jl utility script that\ndefines the convenience entries code_escapes and @code_escapes for testing and debugging purposes:\n\n# InteractiveUtils.@activate Compiler # to use the stdlib version of the Compiler\n\nlet JULIA_DIR = normpath(Sys.BINDIR, Base.DATAROOTDIR, \"julia\")\n    include(normpath(JULIA_DIR, \"Compiler\", \"test\", \"EAUtils.jl\"))\n    using .EAUtils\nend\n\nmutable struct SafeRef{T}\n    x::T\nend\nBase.getindex(x::SafeRef) = x.x;\nBase.setindex!(x::SafeRef, v) = x.x = v;\nBase.isassigned(x::SafeRef) = true;\nget′(x) = isassigned(x) ? x[] : throw(x);\n\nresult = code_escapes((Base.RefValue{String},String,String,)) do r1, s2, s3\n    r2 = Ref(s2)\n    r3 = SafeRef(s3)\n    try\n        s1 = get′(r1)\n        ret = sizeof(s1)\n    catch err\n        global GV = err # `r1` may escape\n    end\n    s2 = get′(r2)       # `r2` doesn't escape\n    s3 = get′(r3)       # `r3` doesn't escape\n    return s2, s3, s4\nend\n\nThe symbols on the side of each call argument and SSA statements represent the following meaning:\n\n◌ (plain): this value is not analyzed because escape information of it won't be used anyway (when the object is isbitstype for example)\n✓ (green or cyan): this value never escapes (has_no_escape(result.state[x]) holds), colored blue if it has arg escape also (has_arg_escape(result.state[x]) holds)\n↑ (blue or yellow): this value can escape to the caller via return (has_return_escape(result.state[x]) holds), colored yellow if it has unhandled thrown escape also (has_thrown_escape(result.state[x]) holds)\nX (red): this value can escape to somewhere the escape analysis can't reason about like escapes to a global memory (has_all_escape(result.state[x]) holds)\n* (bold): this value's escape state is between the ReturnEscape and AllEscape in the partial order of EscapeInfo, colored yellow if it has unhandled thrown escape also (has_thrown_escape(result.state[x]) holds)\n′: this value has additional object field / array element information in its AliasInfo property\n\nEscape information of each call argument and SSA value can be inspected programmatically as like:\n\nresult.state[Core.Argument(3)] # get EscapeInfo of `s2`\n\nresult.state[Core.SSAValue(3)] # get EscapeInfo of `r3`"},{"title":"Analysis Design","page":"EscapeAnalysis","location":"devdocs/EscapeAnalysis.html#Analysis-Design","category":"section","text":""},{"title":"Lattice Design","page":"EscapeAnalysis","location":"devdocs/EscapeAnalysis.html#Lattice-Design","category":"section","text":"EscapeAnalysis is implemented as a data-flow analysis\nthat works on a lattice of x::EscapeInfo,\nwhich is composed of the following properties:\n\nx.Analyzed::Bool: not formally part of the lattice, only indicates x has not been analyzed or not\nx.ReturnEscape::BitSet: records SSA statements where x can escape to the caller via return\nx.ThrownEscape::BitSet: records SSA statements where x can be thrown as exception\n(used for the exception handling described below)\nx.AliasInfo: maintains all possible values that can be aliased to fields or array elements of x\n(used for the alias analysis described below)\nx.ArgEscape::Int (not implemented yet): indicates it will escape to the caller through\nsetfield! on argument(s)\n\nThese attributes can be combined to create a partial lattice that has a finite height, given\nthe invariant that an input program has a finite number of statements, which is assured by Julia's semantics.\nThe clever part of this lattice design is that it enables a simpler implementation of\nlattice operations by allowing them to handle each lattice property separately[LatticeDesign]."},{"title":"Backward Escape Propagation","page":"EscapeAnalysis","location":"devdocs/EscapeAnalysis.html#Backward-Escape-Propagation","category":"section","text":"This escape analysis implementation is based on the data-flow algorithm described in the paper[MM02].\nThe analysis works on the lattice of EscapeInfo and transitions lattice elements from the\nbottom to the top until every lattice element gets converged to a fixed point by maintaining\na (conceptual) working set that contains program counters corresponding to remaining SSA\nstatements to be analyzed. The analysis manages a single global state that tracks\nEscapeInfo of each argument and SSA statement, but also note that some flow-sensitivity\nis encoded as program counters recorded in EscapeInfo's ReturnEscape property,\nwhich can be combined with domination analysis later to reason about flow-sensitivity if necessary.\n\nOne distinctive design of this escape analysis is that it is fully backward,\ni.e. escape information flows from usages to definitions.\nFor example, in the code snippet below, EA first analyzes the statement return %1 and\nimposes ReturnEscape on %1 (corresponding to obj), and then it analyzes\n%1 = %new(Base.RefValue{Base.RefValue{String}, _2})) and propagates the ReturnEscape\nimposed on %1 to the call argument _2 (corresponding to s):\n\ncode_escapes((Base.RefValue{String},)) do s\n    obj = Ref(s)\n    return obj\nend\n\nThe key observation here is that this backward analysis allows escape information to flow\nnaturally along the use-def chain rather than control-flow[BackandForth].\nAs a result this scheme enables a simple implementation of escape analysis,\ne.g. PhiNode for example can be handled simply by propagating escape information\nimposed on a PhiNode to its predecessor values:\n\ncode_escapes((Bool, Base.RefValue{String}, Base.RefValue{String})) do cnd, s, t\n    if cnd\n        obj = Ref(s)\n    else\n        obj = Ref(t)\n    end\n    return obj\nend"},{"title":"Alias Analysis","page":"EscapeAnalysis","location":"devdocs/EscapeAnalysis.html#EA-Alias-Analysis","category":"section","text":"EscapeAnalysis implements a backward field analysis in order to reason about escapes\nimposed on object fields with certain accuracy,\nand x::EscapeInfo's x.AliasInfo property exists for this purpose.\nIt records all possible values that can be aliased to fields of x at \"usage\" sites,\nand then the escape information of that recorded values are propagated to the actual field values later at \"definition\" sites.\nMore specifically, the analysis records a value that may be aliased to a field of object by analyzing getfield call,\nand then it propagates its escape information to the field when analyzing %new(...) expression or setfield! call[Dynamism].\n\ncode_escapes((String,)) do s\n    obj = SafeRef(\"init\")\n    obj[] = s\n    v = obj[]\n    return v\nend\n\nIn the example above, ReturnEscape imposed on %3 (corresponding to v) is not directly\npropagated to %1 (corresponding to obj) but rather that ReturnEscape is only propagated\nto _2 (corresponding to s). Here %3 is recorded in %1's AliasInfo property as\nit can be aliased to the first field of %1, and then when analyzing Base.setfield!(%1, :x, _2)::String,\nthat escape information is propagated to _2 but not to %1.\n\nSo EscapeAnalysis tracks which IR elements can be aliased across a getfield-%new/setfield! chain\nin order to analyze escapes of object fields, but actually this alias analysis needs to be\ngeneralized to handle other IR elements as well. This is because in Julia IR the same\nobject is sometimes represented by different IR elements and so we should make sure that those\ndifferent IR elements that actually can represent the same object share the same escape information.\nIR elements that return the same object as their operand(s), such as PiNode and typeassert,\ncan cause that IR-level aliasing and thus requires escape information imposed on any of such\naliased values to be shared between them.\nMore interestingly, it is also needed for correctly reasoning about mutations on PhiNode.\nLet's consider the following example:\n\ncode_escapes((Bool, String,)) do cond, x\n    if cond\n        ϕ2 = ϕ1 = SafeRef(\"foo\")\n    else\n        ϕ2 = ϕ1 = SafeRef(\"bar\")\n    end\n    ϕ2[] = x\n    y = ϕ1[]\n    return y\nend\n\nϕ1 = %5 and ϕ2 = %6 are aliased and thus ReturnEscape imposed on %8 = Base.getfield(%6, :x)::String (corresponding to y = ϕ1[])\nneeds to be propagated to Base.setfield!(%5, :x, _3)::String (corresponding to ϕ2[] = x).\nIn order for such escape information to be propagated correctly, the analysis should recognize that\nthe predecessors of ϕ1 and ϕ2 can be aliased as well and equalize their escape information.\n\nOne interesting property of such aliasing information is that it is not known at \"usage\" site\nbut can only be derived at \"definition\" site (as aliasing is conceptually equivalent to assignment),\nand thus it doesn't naturally fit in a backward analysis. In order to efficiently propagate escape\ninformation between related values, EscapeAnalysis.jl uses an approach inspired by the escape\nanalysis algorithm explained in an old JVM paper[JVM05]. That is, in addition to managing\nescape lattice elements, the analysis also maintains an \"equi\"-alias set, a disjoint set of\naliased arguments and SSA statements. The alias set manages values that can be aliased to\neach other and allows escape information imposed on any of such aliased values to be equalized\nbetween them."},{"title":"Array Analysis","page":"EscapeAnalysis","location":"devdocs/EscapeAnalysis.html#EA-Array-Analysis","category":"section","text":"The alias analysis for object fields described above can also be generalized to analyze array operations.\nEscapeAnalysis implements handlings for various primitive array operations so that it can propagate\nescapes via arrayref-arrayset use-def chain and does not escape allocated arrays too conservatively:\n\ncode_escapes((String,)) do s\n    ary = Any[]\n    push!(ary, SafeRef(s))\n    return ary[1], length(ary)\nend\n\nIn the above example EscapeAnalysis understands that %20 and %2 (corresponding to the allocated object SafeRef(s))\nare aliased via the arrayset-arrayref chain and imposes ReturnEscape on them,\nbut not impose it on the allocated array %1 (corresponding to ary).\nEscapeAnalysis still imposes ThrownEscape on ary since it also needs to account for\npotential escapes via BoundsError, but also note that such unhandled ThrownEscape can\noften be ignored when optimizing the ary allocation.\n\nFurthermore, in cases when array index information as well as array dimensions can be known precisely,\nEscapeAnalysis is able to even reason about \"per-element\" aliasing via arrayref-arrayset chain,\nas EscapeAnalysis does \"per-field\" alias analysis for objects:\n\ncode_escapes((String,String)) do s, t\n    ary = Vector{Any}(undef, 2)\n    ary[1] = SafeRef(s)\n    ary[2] = SafeRef(t)\n    return ary[1], length(ary)\nend\n\nNote that ReturnEscape is only imposed on %2 (corresponding to SafeRef(s)) but not on %4 (corresponding to SafeRef(t)).\nThis is because the allocated array's dimension and indices involved with all arrayref/arrayset\noperations are available as constant information and EscapeAnalysis can understand that\n%6 is aliased to %2 but never be aliased to %4.\nIn this kind of case, the succeeding optimization passes will be able to\nreplace Base.arrayref(true, %1, 1)::Any with %2 (a.k.a. \"load-forwarding\") and\neventually eliminate the allocation of array %1 entirely (a.k.a. \"scalar-replacement\").\n\nWhen compared to object field analysis, where an access to object field can be analyzed trivially\nusing type information derived by inference, array dimension isn't encoded as type information\nand so we need an additional analysis to derive that information. EscapeAnalysis at this moment\nfirst does an additional simple linear scan to analyze dimensions of allocated arrays before\nfiring up the main analysis routine so that the succeeding escape analysis can precisely\nanalyze operations on those arrays.\n\nHowever, such precise \"per-element\" alias analysis is often hard.\nEssentially, the main difficulty inherit to array is that array dimension and index are often non-constant:\n\nloop often produces loop-variant, non-constant array indices\n(specific to vectors) array resizing changes array dimension and invalidates its constant-ness\n\nLet's discuss those difficulties with concrete examples.\n\nIn the following example, EscapeAnalysis fails the precise alias analysis since the index\nat the Base.arrayset(false, %4, %8, %6)::Vector{Any} is not (trivially) constant.\nEspecially Any[nothing, nothing] forms a loop and calls that arrayset operation in a loop,\nwhere %6 is represented as a ϕ-node value (whose value is control-flow dependent).\nAs a result, ReturnEscape ends up imposed on both %23 (corresponding to SafeRef(s)) and\n%25 (corresponding to SafeRef(t)), although ideally we want it to be imposed only on %23 but not on %25:\n\ncode_escapes((String,String)) do s, t\n    ary = Any[nothing, nothing]\n    ary[1] = SafeRef(s)\n    ary[2] = SafeRef(t)\n    return ary[1], length(ary)\nend\n\nThe next example illustrates how vector resizing makes precise alias analysis hard.\nThe essential difficulty is that the dimension of allocated array %1 is first initialized as 0,\nbut it changes by the two :jl_array_grow_end calls afterwards.\nEscapeAnalysis currently simply gives up precise alias analysis whenever it encounters any\narray resizing operations and so ReturnEscape is imposed on both %2 (corresponding to SafeRef(s))\nand %20 (corresponding to SafeRef(t)):\n\ncode_escapes((String,String)) do s, t\n    ary = Any[]\n    push!(ary, SafeRef(s))\n    push!(ary, SafeRef(t))\n    ary[1], length(ary)\nend\n\nIn order to address these difficulties, we need inference to be aware of array dimensions\nand propagate array dimensions in a flow-sensitive way[ArrayDimension], as well as come\nup with nice representation of loop-variant values.\n\nEscapeAnalysis at this moment quickly switches to the more imprecise analysis that doesn't\ntrack precise index information in cases when array dimensions or indices are trivially non\nconstant. The switch can naturally be implemented as a lattice join operation of\nEscapeInfo.AliasInfo property in the data-flow analysis framework."},{"title":"Exception Handling","page":"EscapeAnalysis","location":"devdocs/EscapeAnalysis.html#EA-Exception-Handling","category":"section","text":"It would be also worth noting how EscapeAnalysis handles possible escapes via exceptions.\nNaively it seems enough to propagate escape information imposed on :the_exception object to\nall values that may be thrown in a corresponding try block.\nBut there are actually several other ways to access to the exception object in Julia,\nsuch as Base.current_exceptions and rethrow.\nFor example, escape analysis needs to account for potential escape of r in the example below:\n\nconst GR = Ref{Any}();\n@noinline function rethrow_escape!()\n    try\n        rethrow()\n    catch err\n        GR[] = err\n    end\nend;\nget′(x) = isassigned(x) ? x[] : throw(x);\n\ncode_escapes() do\n    r = Ref{String}()\n    local t\n    try\n        t = get′(r)\n    catch err\n        t = typeof(err)   # `err` (which `r` aliases to) doesn't escape here\n        rethrow_escape!() # but `r` escapes here\n    end\n    return t\nend\n\nIt requires a global analysis in order to correctly reason about all possible escapes via\nexisting exception interfaces. For now we always propagate the topmost escape information to\nall potentially thrown objects conservatively, since such an additional analysis might not be\nworthwhile to do given that exception handling and error path usually don't need to be\nvery performance sensitive, and also optimizations of error paths might be very ineffective anyway\nsince they are often even \"unoptimized\" intentionally for latency reasons.\n\nx::EscapeInfo's x.ThrownEscape property records SSA statements where x can be thrown as an exception.\nUsing this information EscapeAnalysis can propagate possible escapes via exceptions limitedly\nto only those may be thrown in each try region:\n\nresult = code_escapes((String,String)) do s1, s2\n    r1 = Ref(s1)\n    r2 = Ref(s2)\n    local ret\n    try\n        s1 = get′(r1)\n        ret = sizeof(s1)\n    catch err\n        global GV = err # will definitely escape `r1`\n    end\n    s2 = get′(r2)       # still `r2` doesn't escape fully\n    return s2\nend"},{"title":"Analysis Usage","page":"EscapeAnalysis","location":"devdocs/EscapeAnalysis.html#Analysis-Usage","category":"section","text":"analyze_escapes is the entry point to analyze escape information of SSA-IR elements.\n\nMost optimizations like SROA (sroa_pass!) are more effective when applied to\nan optimized source that the inlining pass (ssa_inlining_pass!) has simplified\nby resolving inter-procedural calls and expanding callee sources.\nAccordingly, analyze_escapes is also able to analyze post-inlining IR and collect\nescape information that is useful for certain memory-related optimizations.\n\nHowever, since certain optimization passes like inlining can change control flows and eliminate dead code,\nthey can break the inter-procedural validity of escape information. In particularity,\nin order to collect inter-procedurally valid escape information, we need to analyze a pre-inlining IR.\n\nBecause of this reason, analyze_escapes can analyze IRCode at any Julia-level optimization stage,\nand especially, it is supposed to be used at the following two stages:\n\nIPO EA: analyze pre-inlining IR to generate IPO-valid escape information cache\nLocal EA: analyze post-inlining IR to collect locally-valid escape information\n\nEscape information derived by IPO EA is transformed to the ArgEscapeCache data structure and cached globally.\nBy passing an appropriate get_escape_cache callback to analyze_escapes,\nthe escape analysis can improve analysis accuracy by utilizing cached inter-procedural information of\nnon-inlined callees that has been derived by previous IPO EA.\nMore interestingly, it is also valid to use IPO EA escape information for type inference,\ne.g., inference accuracy can be improved by forming Const/PartialStruct/MustAlias of mutable object.\n\n\n\n[LatticeDesign]: Our type inference implementation takes the alternative approach,\nwhere each lattice property is represented by a special lattice element type object.\nIt turns out that it started to complicate implementations of the lattice operations\nmainly because it often requires conversion rules between each lattice element type object.\nAnd we are working on overhauling our type inference lattice implementation\nwith EscapeInfo-like lattice design.\n\n[MM02]: A Graph-Free approach to Data-Flow Analysis.\n     Markas Mohnen, 2002, April.\n     https://api.semanticscholar.org/CorpusID:28519618.\n\n[BackandForth]: Our type inference algorithm in contrast is implemented as a forward analysis,\nbecause type information usually flows from \"definition\" to \"usage\" and it is more\nnatural and effective to propagate such information in a forward way.\n\n[Dynamism]: In some cases, however, object fields can't be analyzed precisely.\nFor example, object may escape to somewhere EscapeAnalysis can't account for possible memory effects on it,\nor fields of the objects simply can't be known because of the lack of type information.\nIn such cases AliasInfo property is raised to the topmost element within its own lattice order,\nand it causes succeeding field analysis to be conservative and escape information imposed on\nfields of an unanalyzable object to be propagated to the object itself.\n\n[JVM05]: Escape Analysis in the Context of Dynamic Compilation and Deoptimization.\n      Thomas Kotzmann and Hanspeter Mössenböck, 2005, June.\n      https://dl.acm.org/doi/10.1145/1064979.1064996.\n\n[ArrayDimension]: Otherwise we will need yet another forward data-flow analysis on top of the escape analysis."},{"title":"Base.Compiler.EscapeAnalysis.analyze_escapes","page":"EscapeAnalysis","location":"devdocs/EscapeAnalysis.html#Base.Compiler.EscapeAnalysis.analyze_escapes","category":"function","text":"analyze_escapes(ir::IRCode, nargs::Int, get_escape_cache) -> estate::EscapeState\n\nAnalyzes escape information in ir:\n\nnargs: the number of actual arguments of the analyzed call\nget_escape_cache(::MethodInstance) -> Union{Bool,ArgEscapeCache}:\nretrieves cached argument escape information\n\n\n\n\n\n"},{"title":"Base.Compiler.EscapeAnalysis.EscapeState","page":"EscapeAnalysis","location":"devdocs/EscapeAnalysis.html#Base.Compiler.EscapeAnalysis.EscapeState","category":"type","text":"estate::EscapeState\n\nExtended lattice that maps arguments and SSA values to escape information represented as EscapeInfo.\nEscape information imposed on SSA IR element x can be retrieved by estate[x].\n\n\n\n\n\n"},{"title":"Base.Compiler.EscapeAnalysis.EscapeInfo","page":"EscapeAnalysis","location":"devdocs/EscapeAnalysis.html#Base.Compiler.EscapeAnalysis.EscapeInfo","category":"type","text":"x::EscapeInfo\n\nA lattice for escape information, which holds the following properties:\n\nx.Analyzed::Bool: not formally part of the lattice, only indicates whether x has been analyzed\nx.ReturnEscape::Bool: indicates x can escape to the caller via return\nx.ThrownEscape::BitSet: records SSA statement numbers where x can be thrown as exception:\nisempty(x.ThrownEscape): x will never be thrown in this call frame (the bottom)\npc ∈ x.ThrownEscape: x may be thrown at the SSA statement at pc\n-1 ∈ x.ThrownEscape: x may be thrown at arbitrary points of this call frame (the top)\nThis information will be used by escape_exception! to propagate potential escapes via exception.\nx.AliasInfo::Union{Bool,IndexableFields,Unindexable}: maintains all possible values\nthat can be aliased to fields or array elements of x:\nx.AliasInfo === false indicates the fields/elements of x aren't analyzed yet\nx.AliasInfo === true indicates the fields/elements of x can't be analyzed,\ne.g. the type of x is not known or is not concrete and thus its fields/elements\ncan't be known precisely\nx.AliasInfo::IndexableFields records all the possible values that can be aliased to fields of object x with precise index information\nx.AliasInfo::Unindexable records all the possible values that can be aliased to fields/elements of x without precise index information\nx.Liveness::BitSet: records SSA statement numbers where x should be live, e.g.\nto be used as a call argument, to be returned to a caller, or preserved for :foreigncall:\nisempty(x.Liveness): x is never be used in this call frame (the bottom)\n0 ∈ x.Liveness also has the special meaning that it's a call argument of the currently\nanalyzed call frame (and thus it's visible from the caller immediately).\npc ∈ x.Liveness: x may be used at the SSA statement at pc\n-1 ∈ x.Liveness: x may be used at arbitrary points of this call frame (the top)\n\nThere are utility constructors to create common EscapeInfos, e.g.,\n\nNoEscape(): the bottom(-like) element of this lattice, meaning it won't escape to anywhere\nAllEscape(): the topmost element of this lattice, meaning it will escape to everywhere\n\nanalyze_escapes will transition these elements from the bottom to the top,\nin the same direction as Julia's native type inference routine.\nAn abstract state will be initialized with the bottom(-like) elements:\n\nthe call arguments are initialized as ArgEscape(), whose Liveness property includes 0\nto indicate that it is passed as a call argument and visible from a caller immediately\nthe other states are initialized as NotAnalyzed(), which is a special lattice element that\nis slightly lower than NoEscape, but at the same time doesn't represent any meaning\nother than it's not analyzed yet (thus it's not formally part of the lattice)\n\n\n\n\n\n"},{"title":"Code Loading","page":"Code Loading","location":"manual/code-loading.html#code-loading","category":"section","text":"note: Note\nThis chapter covers the technical details of package loading. To install packages, use Pkg, Julia's built-in package manager, to add packages to your active environment. To use packages already in your active environment, write import X or using X, as described in the Modules documentation."},{"title":"Definitions","page":"Code Loading","location":"manual/code-loading.html#Definitions","category":"section","text":"Julia has two mechanisms for loading code:\n\nCode inclusion: e.g. include(\"source.jl\"). Inclusion allows you to split a single program across multiple source files. The expression include(\"source.jl\") causes the contents of the file source.jl to be evaluated in the global scope of the module where the include call occurs. If include(\"source.jl\") is called multiple times, source.jl is evaluated multiple times. The included path, source.jl, is interpreted relative to the file where the include call occurs. This makes it simple to relocate a subtree of source files. In the REPL, included paths are interpreted relative to the current working directory, pwd().\nPackage loading: e.g. import X or using X. The import mechanism allows you to load a package—i.e. an independent, reusable collection of Julia code, wrapped in a module—and makes the resulting module available by the name X inside of the importing module. If the same X package is imported multiple times in the same Julia session, it is only loaded the first time—on subsequent imports, the importing module gets a reference to the same module. Note though, that import X can load different packages in different contexts: X can refer to one package named X in the main project but potentially to different packages also named X in each dependency. More on this below.\n\nCode inclusion is quite straightforward and simple: it evaluates the given source file in the context of the caller. Package loading is built on top of code inclusion and serves a different purpose. The rest of this chapter focuses on the behavior and mechanics of package loading.\n\nA package is a source tree with a standard layout providing functionality that can be reused by other Julia projects. A package is loaded by import X or  using X statements. These statements also make the module named X—which results from loading the package code—available within the module where the import statement occurs. The meaning of X in import X is context-dependent: which X package is loaded depends on what code the statement occurs in. Thus, handling of import X happens in two stages: first, it determines what package is defined to be X in this context; second, it determines where that particular X package is found.\n\nThese questions are answered by searching through the project environments listed in LOAD_PATH for project files (Project.toml or JuliaProject.toml), manifest files (Manifest.toml or JuliaManifest.toml, or the same names suffixed by -v{major}.{minor}.toml for specific versions), or folders of source files."},{"title":"Federation of packages","page":"Code Loading","location":"manual/code-loading.html#Federation-of-packages","category":"section","text":"Most of the time, a package is uniquely identifiable simply from its name. However, sometimes a project might encounter a situation where it needs to use two different packages that share the same name. While you might be able fix this by renaming one of the packages, being forced to do so can be highly disruptive in a large, shared code base. Instead, Julia's code loading mechanism allows the same package name to refer to different packages in different components of an application.\n\nJulia supports federated package management, which means that multiple independent parties can maintain both public and private packages and registries of packages, and that projects can depend on a mix of public and private packages from different registries. Packages from various registries are installed and managed using a common set of tools and workflows. The Pkg package manager that ships with Julia lets you install and manage your projects' dependencies. It assists in creating and manipulating project files (which describe what other projects that your project depends on), and manifest files (which snapshot exact versions of your project's complete dependency graph).\n\nOne consequence of federation is that there cannot be a central authority for package naming. Different entities may use the same name to refer to unrelated packages. This possibility is unavoidable since these entities do not coordinate and may not even know about each other. Because of the lack of a central naming authority, a single project may end up depending on different packages that have the same name. Julia's package loading mechanism does not require package names to be globally unique, even within the dependency graph of a single project. Instead, packages are identified by universally unique identifiers (UUIDs), which get assigned when each package is created. Usually you won't have to work directly with these somewhat cumbersome 128-bit identifiers since Pkg will take care of generating and tracking them for you. However, these UUIDs provide the definitive answer to the question of \"what package does X refer to?\"\n\nSince the decentralized naming problem is somewhat abstract, it may help to walk through a concrete scenario to understand the issue. Suppose you're developing an application called App, which uses two packages: Pub and  Priv. Priv is a private package that you created, whereas Pub is a public package that you use but don't control. When you created Priv, there was no public package by the name Priv. Subsequently, however, an unrelated package also named Priv has been published and become popular. In fact, the Pub package has started to use it. Therefore, when you next upgrade Pub to get the latest bug fixes and features, App will end up depending on two different packages named Priv—through no action of yours other than upgrading. App has a direct dependency on your private Priv package, and an indirect dependency, through Pub, on the new public Priv package. Since these two Priv packages are different but are both required for App to continue working correctly, the expression import Priv must refer to different Priv packages depending on whether it occurs in App's code or in Pub's code. To handle this, Julia's package loading mechanism distinguishes the two Priv packages by their UUID and picks the correct one based on its context (the module that called import). How this distinction works is determined by environments, as explained in the following sections."},{"title":"Environments","page":"Code Loading","location":"manual/code-loading.html#Environments","category":"section","text":"An environment determines what import X and using X mean in various code contexts and what files these statements cause to be loaded. Julia understands two kinds of environments:\n\nA project environment is a directory with a project file and an optional manifest file, and forms an explicit environment. The project file determines what the names and identities of the direct dependencies of a project are. The manifest file, if present, gives a complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to locate and load the correct version.\nA package directory is a directory containing the source trees of a set of packages as subdirectories, and forms an implicit environment. If X is a subdirectory of a package directory and X/src/X.jl exists, then the package X is available in the package directory environment and X/src/X.jl is the source file by which it is loaded.\n\nThese can be intermixed to create a stacked environment: an ordered set of project environments and package directories, overlaid to make a single composite environment. The precedence and visibility rules then combine to determine which packages are available and where they get loaded from. Julia's load path forms a stacked environment, for example.\n\nThese environments each serve a different purpose:\n\nProject environments provide reproducibility. By checking a project environment into version control—e.g. a git repository—along with the rest of the project's source code, you can reproduce the exact state of the project and all of its dependencies. The manifest file, in particular, captures the exact version of every dependency, identified by a cryptographic hash of its source tree, which makes it possible for Pkg to retrieve the correct versions and be sure that you are running the exact code that was recorded for all dependencies.\nPackage directories provide convenience when a full carefully-tracked project environment is unnecessary. They are useful when you want to put a set of packages somewhere and be able to directly use them, without needing to create a project environment for them.\nStacked environments allow for adding tools to the primary environment. You can push an environment of development tools onto the end of the stack to make them available from the REPL and scripts, but not from inside packages.\n\nnote: Note\nWhen loading a package from another environment in the stack other than the active environment the package is loaded in the context of the active environment. This means that the package will be loaded as if it were imported in the active environment, which may affect how its dependencies versions are resolved. When such a package is precompiling it will be marked as a (serial) precompile job, which means that its dependencies will be precompiled in series within the same job, which will likely be slower.\n\nAt a high-level, each environment conceptually defines three maps: roots, graph and paths. When resolving the meaning of import X, the roots and graph maps are used to determine the identity of X, while the paths map is used to locate the source code of X. The specific roles of the three maps are:\n\nroots: name::Symbol ⟶ uuid::UUID\nAn environment's roots map assigns package names to UUIDs for all the top-level dependencies that the environment makes available to the main project (i.e. the ones that can be loaded in Main). When Julia encounters import X in the main project, it looks up the identity of X as roots[:X].\ngraph: context::UUID ⟶ name::Symbol ⟶ uuid::UUID\nAn environment's graph is a multilevel map which assigns, for each context UUID, a map from names to UUIDs, similar to the roots map but specific to that context. When Julia sees import X in the code of the package whose UUID is context, it looks up the identity of X as graph[context][:X]. In particular, this means that import X can refer to different packages depending on context.\npaths: uuid::UUID × name::Symbol ⟶ path::String\nThe paths map assigns to each package UUID-name pair, the location of that package's entry-point source file. After the identity of X in import X has been resolved to a UUID via roots or graph (depending on whether it is loaded from the main project or a dependency), Julia determines what file to load to acquire X by looking up paths[uuid,:X] in the environment. Including this file should define a module named X. Once this package is loaded, any subsequent import resolving to the same uuid will create a new binding to the already-loaded package module.\n\nEach kind of environment defines these three maps differently, as detailed in the following sections.\n\nnote: Note\nFor ease of understanding, the examples throughout this chapter show full data structures for roots, graph and paths. However, Julia's package loading code does not explicitly create these. Instead, it lazily computes only as much of each structure as it needs to load a given package."},{"title":"Project environments","page":"Code Loading","location":"manual/code-loading.html#project-environments","category":"section","text":"A project environment is determined by a directory containing a project file called Project.toml, and optionally a manifest file called Manifest.toml. These files may also be called JuliaProject.toml and JuliaManifest.toml, in which case Project.toml and Manifest.toml are ignored. This allows for coexistence with other tools that might consider files called Project.toml and Manifest.toml significant. For pure Julia projects, however, the names Project.toml and Manifest.toml are preferred. However, from Julia v1.10.8 onwards, (Julia)Manifest-v{major}.{minor}.toml is recognized as a format to make a given julia version use a specific manifest file i.e. in the same folder, a Manifest-v1.11.toml would be used by v1.11 and Manifest.toml by any other julia version.\n\nThe roots, graph and paths maps of a project environment are defined as follows:\n\nThe roots map of the environment is determined by the contents of the project file, specifically, its top-level name and uuid entries and its [deps] section (all optional). Consider the following example project file for the hypothetical application, App, as described earlier:\n\nname = \"App\"\nuuid = \"8f986787-14fe-4607-ba5d-fbff2944afa9\"\n\n[deps]\nPriv = \"ba13f791-ae1d-465a-978b-69c3ad90f72b\"\nPub  = \"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"\n\nThis project file implies the following roots map, if it was represented by a Julia dictionary:\n\nroots = Dict(\n    :App  => UUID(\"8f986787-14fe-4607-ba5d-fbff2944afa9\"),\n    :Priv => UUID(\"ba13f791-ae1d-465a-978b-69c3ad90f72b\"),\n    :Pub  => UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"),\n)\n\nGiven this roots map, in App's code the statement import Priv will cause Julia to look up roots[:Priv], which yields ba13f791-ae1d-465a-978b-69c3ad90f72b, the UUID of the Priv package that is to be loaded in that context. This UUID identifies which Priv package to load and use when the main application evaluates import Priv.\n\nThe dependency graph of a project environment is determined by the contents of the manifest file, if present. If there is no manifest file, graph is empty. A manifest file contains a stanza for each of a project's direct or indirect dependencies. For each dependency, the file lists the package's UUID and a source tree hash or an explicit path to the source code. Consider the following example manifest file for App:\n\n[[Priv]] # the private one\ndeps = [\"Pub\", \"Zebra\"]\nuuid = \"ba13f791-ae1d-465a-978b-69c3ad90f72b\"\npath = \"deps/Priv\"\n\n[[Priv]] # the public one\nuuid = \"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"\ngit-tree-sha1 = \"1bf63d3be994fe83456a03b874b409cfd59a6373\"\nversion = \"0.1.5\"\n\n[[Pub]]\nuuid = \"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"\ngit-tree-sha1 = \"9ebd50e2b0dd1e110e842df3b433cb5869b0dd38\"\nversion = \"2.1.4\"\n\n  [Pub.deps]\n  Priv = \"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"\n  Zebra = \"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"\n\n[[Zebra]]\nuuid = \"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"\ngit-tree-sha1 = \"e808e36a5d7173974b90a15a353b564f3494092f\"\nversion = \"3.4.2\"\n\nThis manifest file describes a possible complete dependency graph for the App project:\n\nThere are two different packages named Priv that the application uses. It uses a private package, which is a root dependency, and a public one, which is an indirect dependency through Pub. These are differentiated by their distinct UUIDs, and they have different deps:\nThe private Priv depends on the Pub and Zebra packages.\nThe public Priv has no dependencies.\nThe application also depends on the Pub package, which in turn depends on the public Priv and the same Zebra package that the private Priv package depends on.\n\nThis dependency graph represented as a dictionary, looks like this:\n\ngraph = Dict(\n    # Priv – the private one:\n    UUID(\"ba13f791-ae1d-465a-978b-69c3ad90f72b\") => Dict(\n        :Pub   => UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"),\n        :Zebra => UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"),\n    ),\n    # Priv – the public one:\n    UUID(\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\") => Dict(),\n    # Pub:\n    UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\") => Dict(\n        :Priv  => UUID(\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"),\n        :Zebra => UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"),\n    ),\n    # Zebra:\n    UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\") => Dict(),\n)\n\nGiven this dependency graph, when Julia sees import Priv in the Pub package—which has UUID c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1—it looks up:\n\ngraph[UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\")][:Priv]\n\nand gets 2d15fe94-a1f7-436c-a4d8-07a9a496e01c, which indicates that in the context of the Pub package, import Priv refers to the public Priv package, rather than the private one which the app depends on directly. This is how the name Priv can refer to different packages in the main project than it does in one of its package's dependencies, which allows for duplicate names in the package ecosystem.\n\nWhat happens if import Zebra is evaluated in the main App code base? Since Zebra does not appear in the project file, the import will fail even though Zebra does appear in the manifest file. Moreover, if import Zebra occurs in the public Priv package—the one with UUID 2d15fe94-a1f7-436c-a4d8-07a9a496e01c—then that would also fail since that Priv package has no declared dependencies in the manifest file and therefore cannot load any packages. The Zebra package can only be loaded by packages for which it appears as an explicit dependency in the manifest file: the Pub package and one of the Priv packages.\n\nThe paths map of a project environment is extracted from the manifest file. The path of a package uuid named X is determined by these rules (in order):\n\nIf the project file in the directory matches uuid and name X, then either:\nIt has a toplevel entryfile entry, then uuid will be mapped to that path, interpreted relative to the directory containing the project file.\nOtherwise, uuid is mapped to src/X.jl relative to the directory containing the project file.\nIf the above is not the case and the project file has a corresponding manifest file and the manifest contains a stanza matching uuid then:\nIf it has a path entry, use that path (relative to the directory containing the manifest file).\nIf it has a git-tree-sha1 entry, compute a deterministic hash function of uuid and git-tree-sha1—call it slug—and look for a directory named packages/X/$slug in each directory in the Julia DEPOT_PATH global array. Use the first such directory that exists.\nIf this is a directory then uuid is mapped to src/X.jl unless the matching manifest stanza has an entryfile entry in which case this is used. In both cases, these are relative to the directory in 2.1.\n\nIf any of these result in success, the path to the source code entry point will be either that result, the relative path from that result plus src/X.jl; otherwise, there is no path mapping for uuid. When loading X, if no source code path is found, the lookup will fail, and the user may be prompted to install the appropriate package version or to take other corrective action (e.g. declaring X as a dependency).\n\nIn the example manifest file above, to find the path of the first Priv package—the one with UUID ba13f791-ae1d-465a-978b-69c3ad90f72b—Julia looks for its stanza in the manifest file, sees that it has a path entry, looks at deps/Priv relative to the App project directory—let's suppose the App code lives in /home/me/projects/App—sees that /home/me/projects/App/deps/Priv exists and therefore loads Priv from there.\n\nIf, on the other hand, Julia was loading the other Priv package—the one with UUID 2d15fe94-a1f7-436c-a4d8-07a9a496e01c—it finds its stanza in the manifest, see that it does not have a path entry, but that it does have a git-tree-sha1 entry. It then computes the slug for this UUID/SHA-1 pair, which is HDkrT (the exact details of this computation aren't important, but it is consistent and deterministic). This means that the path to this Priv package will be packages/Priv/HDkrT/src/Priv.jl in one of the package depots. Suppose the contents of DEPOT_PATH is [\"/home/me/.julia\", \"/usr/local/julia\"], then Julia will look at the following paths to see if they exist:\n\n/home/me/.julia/packages/Priv/HDkrT\n/usr/local/julia/packages/Priv/HDkrT\n\nJulia uses the first of these that exists to try to load the public Priv package from the file packages/Priv/HDKrT/src/Priv.jl in the depot where it was found.\n\nHere is a representation of a possible paths map for our example App project environment,\nas provided in the Manifest given above for the dependency graph,\nafter searching the local file system:\n\npaths = Dict(\n    # Priv – the private one:\n    (UUID(\"ba13f791-ae1d-465a-978b-69c3ad90f72b\"), :Priv) =>\n        # relative entry-point inside `App` repo:\n        \"/home/me/projects/App/deps/Priv/src/Priv.jl\",\n    # Priv – the public one:\n    (UUID(\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"), :Priv) =>\n        # package installed in the system depot:\n        \"/usr/local/julia/packages/Priv/HDkrT/src/Priv.jl\",\n    # Pub:\n    (UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"), :Pub) =>\n        # package installed in the user depot:\n        \"/home/me/.julia/packages/Pub/oKpw/src/Pub.jl\",\n    # Zebra:\n    (UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"), :Zebra) =>\n        # package installed in the system depot:\n        \"/usr/local/julia/packages/Zebra/me9k/src/Zebra.jl\",\n)\n\nThis example map includes three different kinds of package locations (the first and third are part of the default load path):\n\nThe private Priv package is \"vendored\" inside the App repository.\nThe public Priv and Zebra packages are in the system depot, where packages installed and managed by the system administrator live. These are available to all users on the system.\nThe Pub package is in the user depot, where packages installed by the user live. These are only available to the user who installed them."},{"title":"Package directories","page":"Code Loading","location":"manual/code-loading.html#Package-directories","category":"section","text":"Package directories provide a simpler kind of environment without the ability to handle name collisions. In a package directory, the set of top-level packages is the set of subdirectories that \"look like\" packages. A package X exists in a package directory if the directory contains one of the following \"entry point\" files:\n\nX.jl\nX/src/X.jl\nX.jl/src/X.jl\n\nWhich dependencies a package in a package directory can import depends on whether the package contains a project file:\n\nIf it has a project file, it can only import those packages which are identified in the [deps] section of the project file.\nIf it does not have a project file, it can import any top-level package—i.e. the same packages that can be loaded in Main or the REPL.\n\nThe roots map is determined by examining the contents of the package directory to generate a list of all packages that exist.\nAdditionally, a UUID will be assigned to each entry as follows: For a given package found inside the folder X...\n\nIf X/Project.toml exists and has a uuid entry, then uuid is that value.\nIf X/Project.toml exists and but does not have a top-level UUID entry, uuid is a dummy UUID generated by hashing the canonical (real) path to X/Project.toml.\nOtherwise (if Project.toml does not exist), then uuid is the all-zero nil UUID.\n\nThe dependency graph of a project directory is determined by the presence and contents of project files in the subdirectory of each package. The rules are:\n\nIf a package subdirectory has no project file, then it is omitted from graph and import statements in its code are treated as top-level, the same as the main project and REPL.\nIf a package subdirectory has a project file, then the graph entry for its UUID is the [deps] map of the project file, which is considered to be empty if the section is absent.\n\nAs an example, suppose a package directory has the following structure and content:\n\nAardvark/\n    src/Aardvark.jl:\n        import Bobcat\n        import Cobra\n\nBobcat/\n    Project.toml:\n        [deps]\n        Cobra = \"4725e24d-f727-424b-bca0-c4307a3456fa\"\n        Dingo = \"7a7925be-828c-4418-bbeb-bac8dfc843bc\"\n\n    src/Bobcat.jl:\n        import Cobra\n        import Dingo\n\nCobra/\n    Project.toml:\n        uuid = \"4725e24d-f727-424b-bca0-c4307a3456fa\"\n        [deps]\n        Dingo = \"7a7925be-828c-4418-bbeb-bac8dfc843bc\"\n\n    src/Cobra.jl:\n        import Dingo\n\nDingo/\n    Project.toml:\n        uuid = \"7a7925be-828c-4418-bbeb-bac8dfc843bc\"\n\n    src/Dingo.jl:\n        # no imports\n\nHere is a corresponding roots structure, represented as a dictionary:\n\nroots = Dict(\n    :Aardvark => UUID(\"00000000-0000-0000-0000-000000000000\"), # no project file, nil UUID\n    :Bobcat   => UUID(\"85ad11c7-31f6-5d08-84db-0a4914d4cadf\"), # dummy UUID based on path\n    :Cobra    => UUID(\"4725e24d-f727-424b-bca0-c4307a3456fa\"), # UUID from project file\n    :Dingo    => UUID(\"7a7925be-828c-4418-bbeb-bac8dfc843bc\"), # UUID from project file\n)\n\nHere is the corresponding graph structure, represented as a dictionary:\n\ngraph = Dict(\n    # Bobcat:\n    UUID(\"85ad11c7-31f6-5d08-84db-0a4914d4cadf\") => Dict(\n        :Cobra => UUID(\"4725e24d-f727-424b-bca0-c4307a3456fa\"),\n        :Dingo => UUID(\"7a7925be-828c-4418-bbeb-bac8dfc843bc\"),\n    ),\n    # Cobra:\n    UUID(\"4725e24d-f727-424b-bca0-c4307a3456fa\") => Dict(\n        :Dingo => UUID(\"7a7925be-828c-4418-bbeb-bac8dfc843bc\"),\n    ),\n    # Dingo:\n    UUID(\"7a7925be-828c-4418-bbeb-bac8dfc843bc\") => Dict(),\n)\n\nA few general rules to note:\n\nA package without a project file can depend on any top-level dependency, and since every package in a package directory is available at the top-level, it can import all packages in the environment.\nA package with a project file cannot depend on one without a project file since packages with project files can only load packages in graph and packages without project files do not appear in graph.\nA package with a project file but no explicit UUID can only be depended on by packages without project files since dummy UUIDs assigned to these packages are strictly internal.\n\nObserve the following specific instances of these rules in our example:\n\nAardvark can import on any of Bobcat, Cobra or Dingo; it does import Bobcat and Cobra.\nBobcat can and does import both Cobra and Dingo, which both have project files with UUIDs and are declared as dependencies in Bobcat's [deps] section.\nBobcat cannot depend on Aardvark since Aardvark does not have a project file.\nCobra can and does import Dingo, which has a project file and UUID, and is declared as a dependency in Cobra's  [deps] section.\nCobra cannot depend on Aardvark or Bobcat since neither have real UUIDs.\nDingo cannot import anything because it has a project file without a [deps] section.\n\nThe paths map in a package directory is simple: it maps subdirectory names to their corresponding entry-point paths. In other words, if the path to our example project directory is /home/me/animals then the paths map could be represented by this dictionary:\n\npaths = Dict(\n    (UUID(\"00000000-0000-0000-0000-000000000000\"), :Aardvark) =>\n        \"/home/me/AnimalPackages/Aardvark/src/Aardvark.jl\",\n    (UUID(\"85ad11c7-31f6-5d08-84db-0a4914d4cadf\"), :Bobcat) =>\n        \"/home/me/AnimalPackages/Bobcat/src/Bobcat.jl\",\n    (UUID(\"4725e24d-f727-424b-bca0-c4307a3456fa\"), :Cobra) =>\n        \"/home/me/AnimalPackages/Cobra/src/Cobra.jl\",\n    (UUID(\"7a7925be-828c-4418-bbeb-bac8dfc843bc\"), :Dingo) =>\n        \"/home/me/AnimalPackages/Dingo/src/Dingo.jl\",\n)\n\nSince all packages in a package directory environment are, by definition, subdirectories with the expected entry-point files, their paths map entries always have this form."},{"title":"Environment stacks","page":"Code Loading","location":"manual/code-loading.html#Environment-stacks","category":"section","text":"The third and final kind of environment is one that combines other environments by overlaying several of them, making the packages in each available in a single composite environment. These composite environments are called environment stacks. The Julia LOAD_PATH global defines an environment stack—the environment in which the Julia process operates. If you want your Julia process to have access only to the packages in one project or package directory, make it the only entry in LOAD_PATH. It is often quite useful, however, to have access to some of your favorite tools—standard libraries, profilers, debuggers, personal utilities, etc.—even if they are not dependencies of the project you're working on. By adding an environment containing these tools to the load path, you immediately have access to them in top-level code without needing to add them to your project.\n\nThe mechanism for combining the roots, graph and paths data structures of the components of an environment stack is simple: they are merged as dictionaries, favoring earlier entries over later ones in the case of key collisions. In other words, if we have stack = [env₁, env₂, …] then we have:\n\nroots = reduce(merge, reverse([roots₁, roots₂, …]))\ngraph = reduce(merge, reverse([graph₁, graph₂, …]))\npaths = reduce(merge, reverse([paths₁, paths₂, …]))\n\nThe subscripted rootsᵢ, graphᵢ and pathsᵢ variables correspond to the subscripted environments, envᵢ, contained in stack. The reverse is present because merge favors the last argument rather than first when there are collisions between keys in its argument dictionaries. There are a couple of noteworthy features of this design:\n\nThe primary environment—i.e. the first environment in a stack—is faithfully embedded in a stacked environment. The full dependency graph of the first environment in a stack is guaranteed to be included intact in the stacked environment including the same versions of all dependencies.\nPackages in non-primary environments can end up using incompatible versions of their dependencies even if their own environments are entirely compatible. This can happen when one of their dependencies is shadowed by a version in an earlier environment in the stack (either by graph or path, or both).\n\nSince the primary environment is typically the environment of a project you're working on, while environments later in the stack contain additional tools, this is the right trade-off: it's better to break your development tools but keep the project working. When such incompatibilities occur, you'll typically want to upgrade your dev tools to versions that are compatible with the main project."},{"title":"Package Extensions","page":"Code Loading","location":"manual/code-loading.html#man-extensions","category":"section","text":"A package \"extension\" is a module that is automatically loaded when a specified set of other packages (its \"triggers\") are loaded in the current Julia session. Extensions are defined under the [extensions] section in the project file. The triggers of an extension are a subset of those packages listed under the [weakdeps] (and possibly, but uncommonly the [deps]) section of the project file. Those packages can have compat entries like other packages.\n\nname = \"MyPackage\"\n\n[compat]\nExtDep = \"1.0\"\nOtherExtDep = \"1.0\"\n\n[weakdeps]\nExtDep = \"c9a23...\" # uuid\nOtherExtDep = \"862e...\" # uuid\n\n[extensions]\nBarExt = [\"ExtDep\", \"OtherExtDep\"]\nFooExt = \"ExtDep\"\n...\n\nThe keys under extensions are the names of the extensions.\nThey are loaded when all the packages on the right hand side (the triggers) of that extension are loaded.\nIf an extension only has one trigger the list of triggers can be written as just a string for brevity.\nThe location for the entry point of the extension is either in ext/FooExt.jl or ext/FooExt/FooExt.jl for\nextension FooExt.\nThe content of an extension is often structured as:\n\nmodule FooExt\n\n# Load main package and triggers\nusing MyPackage, ExtDep\n\n# Extend functionality in main package with types from the triggers\nMyPackage.func(x::ExtDep.SomeStruct) = ...\n\nend\n\nWhen a package with extensions is added to an environment, the weakdeps and extensions sections\nare stored in the manifest file in the section for that package. The dependency lookup rules for\na package are the same as for its \"parent\" except that the listed triggers are also considered as\ndependencies."},{"title":"Workspaces","page":"Code Loading","location":"manual/code-loading.html#workspaces","category":"section","text":"A project file can define a workspace by giving a set of projects that is part of that workspace:\n\n[workspace]\nprojects = [\"test\", \"benchmarks\", \"docs\", \"SomePackage\"]\n\nEach project listed in the projects array is specified by its relative path from the workspace root. This can be a direct child directory (e.g., \"test\") or a nested subdirectory (e.g., \"nested/subdir/MyPackage\"). Each project contains its own Project.toml file, which may include additional dependencies and compatibility constraints. In such cases, the package manager gathers all dependency information from all the projects in the workspace generating a single manifest file that combines the versions of all dependencies.\n\nWhen Julia loads a project, it searches upward through parent directories until it reaches the user's home directory to find a workspace that includes that project. This allows workspace projects to be nested at arbitrary depth within the workspace directory tree.\n\nFurthermore, workspaces can be \"nested\", meaning a project defining a workspace can also be part of another workspace. In this scenario, a single manifest file is still utilized, stored alongside the \"root project\" (the project that doesn't have another workspace including it). An example file structure could look like this:\n\nProject.toml # projects = [\"MyPackage\"]\nManifest.toml\nMyPackage/\n    Project.toml # projects = [\"test\"]\n    test/\n        Project.toml"},{"title":"Package/Environment Preferences","page":"Code Loading","location":"manual/code-loading.html#preferences","category":"section","text":"Preferences are dictionaries of metadata that influence package behavior within an environment.\nThe preferences system supports reading preferences at compile-time, which means that at code-loading time, we must ensure that the precompilation files selected by Julia were built with the same preferences as the current environment before loading them.\nThe public API for modifying Preferences is contained within the Preferences.jl package.\nPreferences are stored as TOML dictionaries within a (Julia)LocalPreferences.toml file next to the currently-active project.\nIf a preference is \"exported\", it is instead stored within the (Julia)Project.toml instead.\nThe intention is to allow shared projects to contain shared preferences, while allowing for users themselves to override those preferences with their own settings in the LocalPreferences.toml file, which should be .gitignored as the name implies.\n\nPreferences that are accessed during compilation are automatically marked as compile-time preferences, and any change recorded to these preferences will cause the Julia compiler to recompile any cached precompilation file(s) (.ji and corresponding .so, .dll, or .dylib files) for that module.\nThis is done by serializing the hash of all compile-time preferences during compilation, then checking that hash against the current environment when searching for the proper file(s) to load.\n\nPreferences can be set with depot-wide defaults; if package Foo is installed within your global environment and it has preferences set, these preferences will apply as long as your global environment is part of your LOAD_PATH.\nPreferences in environments higher up in the environment stack get overridden by the more proximal entries in the load path, ending with the currently active project.\nThis allows depot-wide preference defaults to exist, with active projects able to merge or even completely overwrite these inherited preferences.\nSee the docstring for Preferences.set_preferences!() for the full details of how to set preferences to allow or disallow merging."},{"title":"Syntax Versioning","page":"Code Loading","location":"manual/code-loading.html#syntax-versioning","category":"section","text":"Syntax versioning allows packages to specify which version of Julia's syntax they use. In particular, different\npackages can use different versions of the Julia syntax. This allows evolution of Julia's syntax in a non-breaking\nway, while allowing packages to upgrade at their own pace. The syntax version is determined from the package's\ncorresponding Project.toml and propagates to all modules defined in the package."},{"title":"Syntax Version Determination","page":"Code Loading","location":"manual/code-loading.html#Syntax-Version-Determination","category":"section","text":"The syntax version for a package is determined by the loading mechanism in the following order of precedence:\n\nIf a syntax.julia_version field is present in the project file, it is used directly:\nname = \"MyPackage\"\nuuid = \"...\"\nsyntax.julia_version = \"1.14\"\nOtherwise, if a [compat] section specifies a Julia version constraint, the minimum compatible version is used:\n[compat]\njulia = \"1.13-2\"  # implies syntax version 1.13.0\nIf neither is specified, the current Julia version is used."},{"title":"In scripts and the REPL","page":"Code Loading","location":"manual/code-loading.html#In-scripts-and-the-REPL","category":"section","text":"Scripts and the REPL use the active project's syntax version. This determination happens:\n\nAt startup after processing --project\nBefore parsing any REPL input, once for each prompt\n\nIn particular, a manual set_active_project in a script will not change the syntax versioned used\nfor the rest of the script. However, doing so at the REPL (explicitly or implicitly via the Pkg\nREPL mode) will affect the syntax version used to parse the next REPL input."},{"title":"Conclusion","page":"Code Loading","location":"manual/code-loading.html#Conclusion","category":"section","text":"Federated package management and precise software reproducibility are difficult but worthy goals in a package system. In combination, these goals lead to a more complex package loading mechanism than most dynamic languages have, but it also yields scalability and reproducibility that is more commonly associated with static languages. Typically, Julia users should be able to use the built-in package manager to manage their projects without needing a precise understanding of these interactions. A call to Pkg.add(\"X\") will add to the appropriate project and manifest files, selected via Pkg.activate(\"Y\"), so that a future call to import X will load X without further thought."},{"title":"Multi-processing and Distributed Computing","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#Multi-processing-and-Distributed-Computing","category":"section","text":"An implementation of distributed memory parallel computing is provided by module Distributed\nas part of the standard library shipped with Julia.\n\nMost modern computers possess more than one CPU, and several computers can be combined together\nin a cluster. Harnessing the power of these multiple CPUs allows many computations to be completed\nmore quickly. There are two major factors that influence performance: the speed of the CPUs themselves,\nand the speed of their access to memory. In a cluster, it's fairly obvious that a given CPU will\nhave fastest access to the RAM within the same computer (node). Perhaps more surprisingly, similar\nissues are relevant on a typical multicore laptop, due to differences in the speed of main memory\nand the cache. Consequently, a good multiprocessing\nenvironment should allow control over the \"ownership\" of a chunk of memory by a particular CPU.\nJulia provides a multiprocessing environment based on message passing to allow programs to run\non multiple processes in separate memory domains at once.\n\nJulia's implementation of message passing is different from other environments such as MPI[1].\nCommunication in Julia is generally \"one-sided\", meaning that the programmer needs to explicitly\nmanage only one process in a two-process operation. Furthermore, these operations typically do\nnot look like \"message send\" and \"message receive\" but rather resemble higher-level operations\nlike calls to user functions.\n\nDistributed programming in Julia is built on two primitives: remote references and remote calls.\nA remote reference is an object that can be used from any process to refer to an object stored\non a particular process. A remote call is a request by one process to call a certain function\non certain arguments on another (possibly the same) process.\n\nRemote references come in two flavors: Future and RemoteChannel.\n\nA remote call returns a Future to its result. Remote calls return immediately; the process\nthat made the call proceeds to its next operation while the remote call happens somewhere else.\nYou can wait for a remote call to finish by calling wait on the returned Future,\nand you can obtain the full value of the result using fetch.\n\nOn the other hand, RemoteChannel s are rewritable. For example, multiple processes can\ncoordinate their processing by referencing the same remote Channel.\n\nEach process has an associated identifier. The process providing the interactive Julia prompt\nalways has an id equal to 1. The processes used by default for parallel operations are referred\nto as \"workers\". When there is only one process, process 1 is considered a worker. Otherwise,\nworkers are considered to be all processes other than process 1. As a result, adding 2 or more\nprocesses is required to gain benefits from parallel processing methods like pmap. Adding\na single process is beneficial if you just wish to do other things in the main process while a long\ncomputation is running on the worker.\n\nLet's try this out. Starting with julia -p n provides n worker processes on the local machine.\nGenerally it makes sense for n to equal the number of CPU threads (logical cores) on the machine. Note that the -p\nargument implicitly loads module Distributed.\n\n$ julia -p 2\n\njulia> r = remotecall(rand, 2, 2, 2)\nFuture(2, 1, 4, nothing)\n\njulia> s = @spawnat 2 1 .+ fetch(r)\nFuture(2, 1, 5, nothing)\n\njulia> fetch(s)\n2×2 Matrix{Float64}:\n 1.18526  1.50912\n 1.16296  1.60607\n\nThe first argument to remotecall is the function to call. Most parallel programming\nin Julia does not reference specific processes or the number of processes available, but remotecall\nis considered a low-level interface providing finer control. The second argument to remotecall\nis the id of the process that will do the work, and the remaining arguments will be passed to\nthe function being called.\n\nAs you can see, in the first line we asked process 2 to construct a 2-by-2 random matrix, and\nin the second line we asked it to add 1 to it. The result of both calculations is available in\nthe two futures, r and s. The @spawnat macro evaluates the expression in the second\nargument on the process specified by the first argument.\n\nOccasionally you might want a remotely-computed value immediately. This typically happens when\nyou read from a remote object to obtain data needed by the next local operation. The function\nremotecall_fetch exists for this purpose. It is equivalent to fetch(remotecall(...))\nbut is more efficient.\n\njulia> remotecall_fetch(r-> fetch(r)[1, 1], 2, r)\n0.18526337335308085\n\nThis fetches the array on worker 2 and returns the first value. Note, that fetch doesn't move any data in\nthis case, since it's executed on the worker that owns the array. One can also write:\n\njulia> remotecall_fetch(getindex, 2, r, 1, 1)\n0.10824216411304866\n\nRemember that getindex(r,1,1) is equivalent to r[1,1], so this call fetches\nthe first element of the future r.\n\nTo make things easier, the symbol :any can be passed to @spawnat, which picks where to do\nthe operation for you:\n\njulia> r = @spawnat :any rand(2,2)\nFuture(2, 1, 4, nothing)\n\njulia> s = @spawnat :any 1 .+ fetch(r)\nFuture(3, 1, 5, nothing)\n\njulia> fetch(s)\n2×2 Matrix{Float64}:\n 1.38854  1.9098\n 1.20939  1.57158\n\nNote that we used 1 .+ fetch(r) instead of 1 .+ r. This is because we do not know where the\ncode will run, so in general a fetch might be required to move r to the process\ndoing the addition. In this case, @spawnat is smart enough to perform the computation\non the process that owns r, so the fetch will be a no-op (no work is done).\n\n(It is worth noting that @spawnat is not built-in but defined in Julia as a macro.\nIt is possible to define your own such constructs.)\n\nAn important thing to remember is that, once fetched, a Future will cache its value\nlocally. Further fetch calls do not entail a network hop. Once all referencing Futures\nhave fetched, the remote stored value is deleted.\n\nThreads.@spawn is similar to @spawnat, but only runs tasks on the local process. We\nuse it to create a \"feeder\" task for each process. Each task picks the next index that needs to\nbe computed, then waits for its process to finish, then repeats until we run out of indices. Note\nthat the feeder tasks do not begin to execute until the main task reaches the end of the @sync\nblock, at which point it surrenders control and waits for all the local tasks to complete before\nreturning from the function.\nAs for v0.7 and beyond, the feeder tasks are able to share state via nextidx because\nthey all run on the same process.\nEven if Tasks are scheduled cooperatively, locking may still be required in some contexts, as in\nasynchronous I/O.\nThis means context switches only occur at well-defined points: in this case,\nwhen remotecall_fetch is called. This is the current state of implementation and it may change\nfor future Julia versions, as it is intended to make it possible to run up to N Tasks on M Process, aka\nM:N Threading. Then a lock acquiring\\releasing\nmodel for nextidx will be needed, as it is not safe to let multiple processes read-write a resource at\nthe same time."},{"title":"Code Availability and Loading Packages","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#code-availability","category":"section","text":"Your code must be available on any process that runs it. For example, type the following into\nthe Julia prompt:\n\njulia> function rand2(dims...)\n           return 2*rand(dims...)\n       end\n\njulia> rand2(2,2)\n2×2 Matrix{Float64}:\n 0.153756  0.368514\n 1.15119   0.918912\n\njulia> fetch(@spawnat :any rand2(2,2))\nERROR: RemoteException(2, CapturedException(UndefVarError(Symbol(\"#rand2\"))))\nStacktrace:\n[...]\n\nProcess 1 knew about the function rand2, but process 2 did not.\n\nMost commonly you'll be loading code from files or packages, and you have a considerable amount\nof flexibility in controlling which processes load code. Consider a file, DummyModule.jl,\ncontaining the following code:\n\nmodule DummyModule\n\nexport MyType, f\n\nmutable struct MyType\n    a::Int\nend\n\nf(x) = x^2+1\n\nprintln(\"loaded\")\n\nend\n\nIn order to refer to MyType across all processes, DummyModule.jl needs to be loaded on\nevery process. Calling include(\"DummyModule.jl\") loads it only on a single process. To\nload it on every process, use the @everywhere macro (starting Julia with julia -p 2):\n\njulia> @everywhere include(\"DummyModule.jl\")\nloaded\n      From worker 3:    loaded\n      From worker 2:    loaded\n\nAs usual, this does not bring DummyModule into scope on any of the processes, which requires\nusing or import. Moreover, when DummyModule is brought into scope on one process, it\nis not on any other:\n\njulia> using .DummyModule\n\njulia> MyType(7)\nMyType(7)\n\njulia> fetch(@spawnat 2 MyType(7))\nERROR: On worker 2:\nUndefVarError: `MyType` not defined in `Main`\n⋮\n\njulia> fetch(@spawnat 2 DummyModule.MyType(7))\nMyType(7)\n\nHowever, it's still possible, for instance, to send a MyType to a process which has loaded\nDummyModule even if it's not in scope:\n\njulia> put!(RemoteChannel(2), MyType(7))\nRemoteChannel{Channel{Any}}(2, 1, 13)\n\nA file can also be preloaded on multiple processes at startup with the -L flag, and a\ndriver script can be used to drive the computation:\n\njulia -p <n> -L file1.jl -L file2.jl driver.jl\n\nThe Julia process running the driver script in the example above has an id equal to 1, just\nlike a process providing an interactive prompt.\n\nFinally, if DummyModule.jl is not a standalone file but a package, then using DummyModule will load DummyModule.jl on all processes, but only bring it into scope on\nthe process where using was called."},{"title":"Starting and managing worker processes","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#Starting-and-managing-worker-processes","category":"section","text":"The base Julia installation has in-built support for two types of clusters:\n\nA local cluster specified with the -p option as shown above.\nA cluster spanning machines using the --machine-file option. This uses a passwordless ssh login\nto start Julia worker processes (from the same path as the current host) on the specified machines. Each machine definition\ntakes the form [count*][user@]host[:port] [bind_addr[:port]]. user defaults to current user,\nport to the standard ssh port. count is the number of workers to spawn on the node, and defaults\nto 1. The optional bind-to bind_addr[:port] specifies the IP address and port that other workers\nshould use to connect to this worker.\n\nnote: Note\nWhile Julia generally strives for backward compatibility, distribution of code to worker processes relies on\nSerialization.serialize. As pointed out in the corresponding documentation, this can not be guaranteed to work across\ndifferent Julia versions, so it is advised that all workers on all machines use the same version.\n\nFunctions addprocs, rmprocs, workers, and others are available\nas a programmatic means of adding, removing and querying the processes in a cluster.\n\njulia> using Distributed\n\njulia> addprocs(2)\n2-element Vector{Int64}:\n 2\n 3\n\nModule Distributed must be explicitly loaded on the master process before invoking addprocs.\nIt is automatically made available on the worker processes.\n\nnote: Note\nNote that workers do not run a ~/.julia/config/startup.jl startup script, nor do they synchronize\ntheir global state (such as command-line switches, global variables, new method definitions, and loaded modules) with any\nof the other running processes. You may use addprocs(exeflags=\"--project\") to initialize a worker with\na particular environment, and then @everywhere using <modulename> or @everywhere include(\"file.jl\").\n\nOther types of clusters can be supported by writing your own custom ClusterManager, as described\nbelow in the ClusterManagers section."},{"title":"Data Movement","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#Data-Movement","category":"section","text":"Sending messages and moving data constitute most of the overhead in a distributed program. Reducing\nthe number of messages and the amount of data sent is critical to achieving performance and scalability.\nTo this end, it is important to understand the data movement performed by Julia's various distributed\nprogramming constructs.\n\nfetch can be considered an explicit data movement operation, since it directly asks\nthat an object be moved to the local machine. @spawnat (and a few related constructs)\nalso moves data, but this is not as obvious, hence it can be called an implicit data movement\noperation. Consider these two approaches to constructing and squaring a random matrix:\n\nMethod 1:\n\njulia> A = rand(1000,1000);\n\njulia> Bref = @spawnat :any A^2;\n\n[...]\n\njulia> fetch(Bref);\n\nMethod 2:\n\njulia> Bref = @spawnat :any rand(1000,1000)^2;\n\n[...]\n\njulia> fetch(Bref);\n\nThe difference seems trivial, but in fact is quite significant due to the behavior of @spawnat.\nIn the first method, a random matrix is constructed locally, then sent to another process where\nit is squared. In the second method, a random matrix is both constructed and squared on another\nprocess. Therefore the second method sends much less data than the first.\n\nIn this toy example, the two methods are easy to distinguish and choose from. However, in a real\nprogram designing data movement might require more thought and likely some measurement. For example,\nif the first process needs matrix A then the first method might be better. Or, if computing\nA is expensive and only the current process has it, then moving it to another process might\nbe unavoidable. Or, if the current process has very little to do between the @spawnat\nand fetch(Bref), it might be better to eliminate the parallelism altogether. Or imagine rand(1000,1000)\nis replaced with a more expensive operation. Then it might make sense to add another @spawnat\nstatement just for this step."},{"title":"Global variables","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#Global-variables","category":"section","text":"Expressions executed remotely via @spawnat, or closures specified for remote execution using\nremotecall may refer to global variables. Global bindings under module Main are treated\na little differently compared to global bindings in other modules. Consider the following code\nsnippet:\n\nA = rand(10,10)\nremotecall_fetch(()->sum(A), 2)\n\nIn this case sum MUST be defined in the remote process.\nNote that A is a global variable defined in the local workspace. Worker 2 does not have a variable called\nA under Main. The act of shipping the closure ()->sum(A) to worker 2 results in Main.A being defined\non 2. Main.A continues to exist on worker 2 even after the call remotecall_fetch returns. Remote calls\nwith embedded global references (under Main module only) manage globals as follows:\n\nNew global bindings are created on destination workers if they are referenced as part of a remote call.\nGlobal constants are declared as constants on remote nodes too.\nGlobals are re-sent to a destination worker only in the context of a remote call, and then only\nif its value has changed. Also, the cluster does not synchronize global bindings across nodes.\nFor example:\nA = rand(10,10)\nremotecall_fetch(()->sum(A), 2) # worker 2\nA = rand(10,10)\nremotecall_fetch(()->sum(A), 3) # worker 3\nA = nothing\nExecuting the above snippet results in Main.A on worker 2 having a different value from\nMain.A on worker 3, while the value of Main.A on node 1 is set to nothing.\n\nAs you may have realized, while memory associated with globals may be collected when they are reassigned\non the master, no such action is taken on the workers as the bindings continue to be valid.\nclear! can be used to manually reassign specific globals on remote nodes to nothing once\nthey are no longer required. This will release any memory associated with them as part of a regular garbage\ncollection cycle.\n\nThus programs should be careful referencing globals in remote calls. In fact, it is preferable to avoid them\naltogether if possible. If you must reference globals, consider using let blocks to localize global variables.\n\nFor example:\n\njulia> A = rand(10,10);\n\njulia> remotecall_fetch(()->A, 2);\n\njulia> B = rand(10,10);\n\njulia> let B = B\n           remotecall_fetch(()->B, 2)\n       end;\n\njulia> @fetchfrom 2 InteractiveUtils.varinfo()\nname           size summary\n––––––––– ––––––––– ––––––––––––––––––––––\nA         800 bytes 10×10 Array{Float64,2}\nBase                Module\nCore                Module\nMain                Module\n\nAs can be seen, global variable A is defined on worker 2, but B is captured as a local variable\nand hence a binding for B does not exist on worker 2."},{"title":"Parallel Map and Loops","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#Parallel-Map-and-Loops","category":"section","text":"Fortunately, many useful parallel computations do not require data movement. A common example\nis a Monte Carlo simulation, where multiple processes can handle independent simulation trials\nsimultaneously. We can use @spawnat to flip coins on two processes. First, write the following\nfunction in count_heads.jl:\n\nfunction count_heads(n)\n    c::Int = 0\n    for i = 1:n\n        c += rand(Bool)\n    end\n    c\nend\n\nThe function count_heads simply adds together n random bits. Here is how we can perform some\ntrials on two machines, and add together the results:\n\njulia> @everywhere include_string(Main, $(read(\"count_heads.jl\", String)), \"count_heads.jl\")\n\njulia> a = @spawnat :any count_heads(100000000)\nFuture(2, 1, 6, nothing)\n\njulia> b = @spawnat :any count_heads(100000000)\nFuture(3, 1, 7, nothing)\n\njulia> fetch(a)+fetch(b)\n100001564\n\nThis example demonstrates a powerful and often-used parallel programming pattern. Many iterations\nrun independently over several processes, and then their results are combined using some function.\nThe combination process is called a reduction, since it is generally tensor-rank-reducing: a\nvector of numbers is reduced to a single number, or a matrix is reduced to a single row or column,\netc. In code, this typically looks like the pattern x = f(x,v[i]), where x is the accumulator,\nf is the reduction function, and the v[i] are the elements being reduced. It is desirable\nfor f to be associative, so that it does not matter what order the operations are performed\nin.\n\nNotice that our use of this pattern with count_heads can be generalized. We used two explicit\n@spawnat statements, which limits the parallelism to two processes. To run on any number\nof processes, we can use a parallel for loop, running in distributed memory, which can be written\nin Julia using @distributed like this:\n\nnheads = @distributed (+) for i = 1:200000000\n    Int(rand(Bool))\nend\n\nThis construct implements the pattern of assigning iterations to multiple processes, and combining\nthem with a specified reduction (in this case (+)). The result of each iteration is taken as\nthe value of the last expression inside the loop. The whole parallel loop expression itself evaluates\nto the final answer.\n\nNote that although parallel for loops look like serial for loops, their behavior is dramatically\ndifferent. In particular, the iterations do not happen in a specified order, and writes to variables\nor arrays will not be globally visible since iterations run on different processes. Any variables\nused inside the parallel loop will be copied and broadcast to each process.\n\nFor example, the following code will not work as intended:\n\na = zeros(100000)\n@distributed for i = 1:100000\n    a[i] = i\nend\n\nThis code will not initialize all of a, since each process will have a separate copy of it.\nParallel for loops like these must be avoided. Fortunately, Shared Arrays can be used\nto get around this limitation:\n\nusing SharedArrays\n\na = SharedArray{Float64}(10)\n@distributed for i = 1:10\n    a[i] = i\nend\n\nUsing \"outside\" variables in parallel loops is perfectly reasonable if the variables are read-only:\n\na = randn(1000)\n@distributed (+) for i = 1:100000\n    f(a[rand(1:end)])\nend\n\nHere each iteration applies f to a randomly-chosen sample from a vector a shared by all processes.\n\nAs you could see, the reduction operator can be omitted if it is not needed. In that case, the\nloop executes asynchronously, i.e. it spawns independent tasks on all available workers and returns\nan array of Future immediately without waiting for completion. The caller can wait for\nthe Future completions at a later point by calling fetch on them, or wait\nfor completion at the end of the loop by prefixing it with @sync, like @sync @distributed for.\n\nIn some cases no reduction operator is needed, and we merely wish to apply a function to all integers\nin some range (or, more generally, to all elements in some collection). This is another useful\noperation called parallel map, implemented in Julia as the pmap function. For example,\nwe could compute the singular values of several large random matrices in parallel as follows:\n\njulia> M = Matrix{Float64}[rand(1000,1000) for i = 1:10];\n\njulia> pmap(svdvals, M);\n\nJulia's pmap is designed for the case where each function call does a large amount\nof work. In contrast, @distributed for can handle situations where each iteration is tiny, perhaps\nmerely summing two numbers. Only worker processes are used by both pmap and @distributed for\nfor the parallel computation. In case of @distributed for, the final reduction is done on the calling\nprocess."},{"title":"Remote References and AbstractChannels","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#Remote-References-and-AbstractChannels","category":"section","text":"Remote references always refer to an implementation of an AbstractChannel.\n\nA concrete implementation of an AbstractChannel (like Channel), is required to implement\nput!, take!, fetch, isready and wait.\nThe remote object referred to by a Future is stored in a Channel{Any}(1), i.e., a\nChannel of size 1 capable of holding objects of Any type.\n\nRemoteChannel, which is rewritable, can point to any type and size of channels, or any\nother implementation of an AbstractChannel.\n\nThe constructor RemoteChannel(f::Function, pid)() allows us to construct references to channels\nholding more than one value of a specific type. f is a function executed on pid and it must\nreturn an AbstractChannel.\n\nFor example, RemoteChannel(()->Channel{Int}(10), pid), will return a reference to a channel\nof type Int and size 10. The channel exists on worker pid.\n\nMethods put!, take!, fetch, isready and wait\non a RemoteChannel are proxied onto the backing store on the remote process.\n\nRemoteChannel can thus be used to refer to user implemented AbstractChannel objects.\nA simple example of this is the following DictChannel which uses a dictionary as its\nremote store:\n\njulia> struct DictChannel{T} <: AbstractChannel{T}\n           d::Dict\n           cond_take::Threads.Condition    # waiting for data to become available\n           DictChannel{T}() where {T} = new(Dict(), Threads.Condition())\n           DictChannel() = DictChannel{Any}()\n       end\n\njulia> begin\n       function Base.put!(D::DictChannel, k, v)\n           @lock D.cond_take begin\n               D.d[k] = v\n               notify(D.cond_take)\n           end\n           return D\n       end\n       function Base.take!(D::DictChannel, k)\n           @lock D.cond_take begin\n               v = fetch(D, k)\n               delete!(D.d, k)\n               return v\n           end\n       end\n       Base.isready(D::DictChannel) = @lock D.cond_take !isempty(D.d)\n       Base.isready(D::DictChannel, k) = @lock D.cond_take haskey(D.d, k)\n       function Base.fetch(D::DictChannel, k)\n           @lock D.cond_take begin\n               wait(D, k)\n               return D.d[k]\n           end\n       end\n       function Base.wait(D::DictChannel, k)\n           @lock D.cond_take begin\n               while !isready(D, k)\n                   wait(D.cond_take)\n               end\n           end\n       end\n       end;\n\njulia> d = DictChannel();\n\njulia> isready(d)\nfalse\n\njulia> put!(d, :k, :v);\n\njulia> isready(d, :k)\ntrue\n\njulia> fetch(d, :k)\n:v\n\njulia> wait(d, :k)\n\njulia> take!(d, :k)\n:v\n\njulia> isready(d, :k)\nfalse"},{"title":"Channels and RemoteChannels","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#Channels-and-RemoteChannels","category":"section","text":"A Channel is local to a process. Worker 2 cannot directly refer to a Channel on worker 3 and\nvice-versa. A RemoteChannel, however, can put and take values across workers.\nA RemoteChannel can be thought of as a handle to a Channel.\nThe process id, pid, associated with a RemoteChannel identifies the process where\nthe backing store, i.e., the backing Channel exists.\nAny process with a reference to a RemoteChannel can put and take items from the channel.\nData is automatically sent to (or retrieved from) the process a RemoteChannel is associated\nwith.\nSerializing  a Channel also serializes any data present in the channel. Deserializing it therefore\neffectively makes a copy of the original object.\nOn the other hand, serializing a RemoteChannel only involves the serialization of an\nidentifier that identifies the location and instance of Channel referred to by the handle. A\ndeserialized RemoteChannel object (on any worker), therefore also points to the same\nbacking store as the original.\n\nThe channels example from above can be modified for interprocess communication,\nas shown below.\n\nWe start 4 workers to process a single jobs remote channel. Jobs, identified by an id (job_id),\nare written to the channel. Each remotely executing task in this simulation reads a job_id,\nwaits for a random amount of time and writes back a tuple of job_id, time taken and its own\npid to the results channel. Finally all the results are printed out on the master process.\n\njulia> addprocs(4); # add worker processes\n\njulia> const jobs = RemoteChannel(()->Channel{Int}(32));\n\njulia> const results = RemoteChannel(()->Channel{Tuple}(32));\n\njulia> @everywhere function do_work(jobs, results) # define work function everywhere\n           while true\n               job_id = take!(jobs)\n               exec_time = rand()\n               sleep(exec_time) # simulates elapsed time doing actual work\n               put!(results, (job_id, exec_time, myid()))\n           end\n       end\n\njulia> function make_jobs(n)\n           for i in 1:n\n               put!(jobs, i)\n           end\n       end;\n\njulia> n = 12;\n\njulia> errormonitor(Threads.@spawn make_jobs(n)); # feed the jobs channel with \"n\" jobs\n\njulia> for p in workers() # start tasks on the workers to process requests in parallel\n           remote_do(do_work, p, jobs, results)\n       end\n\njulia> @elapsed while n > 0 # print out results\n           job_id, exec_time, worker_id = take!(results)\n           println(\"$job_id finished in $(round(exec_time; digits=2)) seconds on worker $worker_id\")\n           global n = n - 1\n       end\n1 finished in 0.18 seconds on worker 4\n2 finished in 0.26 seconds on worker 5\n6 finished in 0.12 seconds on worker 4\n7 finished in 0.18 seconds on worker 4\n5 finished in 0.35 seconds on worker 5\n4 finished in 0.68 seconds on worker 2\n3 finished in 0.73 seconds on worker 3\n11 finished in 0.01 seconds on worker 3\n12 finished in 0.02 seconds on worker 3\n9 finished in 0.26 seconds on worker 5\n8 finished in 0.57 seconds on worker 4\n10 finished in 0.58 seconds on worker 2\n0.055971741"},{"title":"Remote References and Distributed Garbage Collection","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#Remote-References-and-Distributed-Garbage-Collection","category":"section","text":"Objects referred to by remote references can be freed only when all held references\nin the cluster are deleted.\n\nThe node where the value is stored keeps track of which of the workers have a reference to it.\nEvery time a RemoteChannel or a (unfetched) Future is serialized to a worker,\nthe node pointed to by the reference is notified. And every time a RemoteChannel or\na (unfetched) Future is garbage collected locally, the node owning the value is again\nnotified. This is implemented in an internal cluster aware serializer. Remote references are only\nvalid in the context of a running cluster. Serializing and deserializing references to and from\nregular IO objects is not supported.\n\nThe notifications are done via sending of \"tracking\" messages–an \"add reference\" message when\na reference is serialized to a different process and a \"delete reference\" message when a reference\nis locally garbage collected.\n\nSince Futures are write-once and cached locally, the act of fetching a\nFuture also updates reference tracking information on the node owning the value.\n\nThe node which owns the value frees it once all references to it are cleared.\n\nWith Futures, serializing an already fetched Future to a different node also\nsends the value since the original remote store may have collected the value by this time.\n\nIt is important to note that when an object is locally garbage collected depends on the size\nof the object and the current memory pressure in the system.\n\nIn case of remote references, the size of the local reference object is quite small, while the\nvalue stored on the remote node may be quite large. Since the local object may not be collected\nimmediately, it is a good practice to explicitly call finalize on local instances\nof a RemoteChannel, or on unfetched Futures. Since calling fetch\non a Future also removes its reference from the remote store, this is not required on\nfetched Futures. Explicitly calling finalize results in an immediate message\nsent to the remote node to go ahead and remove its reference to the value.\n\nOnce finalized, a reference becomes invalid and cannot be used in any further calls."},{"title":"Local invocations","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#Local-invocations","category":"section","text":"Data is necessarily copied over to the remote node for execution. This is the case for both\nremotecalls and when data is stored to a RemoteChannel / Future on\na different node. As expected, this results in a copy of the serialized objects\non the remote node. However, when the destination node is the local node, i.e.\nthe calling process id is the same as the remote node id, it is executed\nas a local call. It is usually (not always) executed in a different task - but there is no\nserialization/deserialization of data. Consequently, the call refers to the same object instances\nas passed - no copies are created. This behavior is highlighted below:\n\njulia> using Distributed\n\njulia> rc = RemoteChannel(()->Channel(3));   # RemoteChannel created on local node\n\njulia> v = [0];\n\njulia> for i in 1:3\n           v[1] = i                          # Reusing `v`\n           put!(rc, v)\n       end;\n\njulia> result = [take!(rc) for _ in 1:3];\n\njulia> println(result);\n[[3], [3], [3]]\n\njulia> println(\"Num Unique objects : \", length(unique(map(objectid, result))));\nNum Unique objects : 1\n\njulia> addprocs(1);\n\njulia> rc = RemoteChannel(()->Channel(3), workers()[1]);   # RemoteChannel created on remote node\n\njulia> v = [0];\n\njulia> for i in 1:3\n           v[1] = i\n           put!(rc, v)\n       end;\n\njulia> result = [take!(rc) for _ in 1:3];\n\njulia> println(result);\n[[1], [2], [3]]\n\njulia> println(\"Num Unique objects : \", length(unique(map(objectid, result))));\nNum Unique objects : 3\n\nAs can be seen, put! on a locally owned RemoteChannel with the same\nobject v modified between calls results in the same single object instance stored. As\nopposed to copies of v being created when the node owning rc is a different node.\n\nIt is to be noted that this is generally not an issue. It is something to be factored in only\nif the object is both being stored locally and modified post the call. In such cases it may be\nappropriate to store a deepcopy of the object.\n\nThis is also true for remotecalls on the local node as seen in the following example:\n\njulia> using Distributed; addprocs(1);\n\njulia> v = [0];\n\njulia> v2 = remotecall_fetch(x->(x[1] = 1; x), myid(), v);     # Executed on local node\n\njulia> println(\"v=$v, v2=$v2, \", v === v2);\nv=[1], v2=[1], true\n\njulia> v = [0];\n\njulia> v2 = remotecall_fetch(x->(x[1] = 1; x), workers()[1], v); # Executed on remote node\n\njulia> println(\"v=$v, v2=$v2, \", v === v2);\nv=[0], v2=[1], false\n\nAs can be seen once again, a remote call onto the local node behaves just like a direct invocation.\nThe call modifies local objects passed as arguments. In the remote invocation, it operates on\na copy of the arguments.\n\nTo repeat, in general this is not an issue. If the local node is also being used as a compute\nnode, and the arguments used post the call, this behavior needs to be factored in and if required\ndeep copies of arguments must be passed to the call invoked on the local node. Calls on remote nodes\nwill always operate on copies of arguments."},{"title":"Shared Arrays","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#man-shared-arrays","category":"section","text":"Shared Arrays use system shared memory to map the same array across many processes. A\nSharedArray is a good choice when you want to have a large amount of data jointly\naccessible to two or more processes on the same machine. Shared Array support is available via the\nmodule SharedArrays, which must be explicitly loaded on all participating workers.\n\nA complementary data structure is provided by the external package\nDistributedArrays.jl in the form of a\nDArray. While there are some similarities to a SharedArray, the behavior of a\nDArray is quite different. In a\nSharedArray, each \"participating\" process has access to the entire array; in contrast, in\na DArray, each process has local access\nto just a chunk of the data, and no two processes share the same chunk.\n\nSharedArray indexing (assignment and accessing values) works just as with regular arrays,\nand is efficient because the underlying memory is available to the local process. Therefore,\nmost algorithms work naturally on SharedArrays, albeit in single-process mode. In cases\nwhere an algorithm insists on an Array input, the underlying array can be retrieved\nfrom a SharedArray by calling sdata. For other AbstractArray types, sdata\njust returns the object itself, so it's safe to use sdata on any Array-type object.\n\nThe constructor for a shared array is of the form:\n\nSharedArray{T,N}(dims::NTuple; init=false, pids=Int[])\n\nwhich creates an N-dimensional shared array of a bits type T and size dims across the processes specified\nby pids. Unlike distributed arrays, a shared array is accessible only from those participating\nworkers specified by the pids named argument (and the creating process too, if it is on the\nsame host). Note that only elements that are isbits are supported in a SharedArray.\n\nIf an init function, of signature initfn(S::SharedArray), is specified, it is called on all\nthe participating workers. You can specify that each worker runs the init function on a distinct\nportion of the array, thereby parallelizing initialization.\n\nHere's a brief example:\n\njulia> using Distributed\n\njulia> addprocs(3)\n3-element Vector{Int64}:\n 2\n 3\n 4\n\njulia> @everywhere using SharedArrays\n\njulia> S = SharedArray{Int,2}((3,4), init = S -> S[localindices(S)] = repeat([myid()], length(localindices(S))))\n3×4 SharedMatrix{Int64}:\n 2  2  3  4\n 2  3  3  4\n 2  3  4  4\n\njulia> S[3,2] = 7\n7\n\njulia> S\n3×4 SharedMatrix{Int64}:\n 2  2  3  4\n 2  3  3  4\n 2  7  4  4\n\nSharedArrays.localindices provides disjoint one-dimensional ranges of indices, and is sometimes\nconvenient for splitting up tasks among processes. You can, of course, divide the work any way\nyou wish:\n\njulia> S = SharedArray{Int,2}((3,4), init = S -> S[indexpids(S):length(procs(S)):length(S)] = repeat([myid()], length( indexpids(S):length(procs(S)):length(S))))\n3×4 SharedMatrix{Int64}:\n 2  2  2  2\n 3  3  3  3\n 4  4  4  4\n\nSince all processes have access to the underlying data, you do have to be careful not to set up\nconflicts. For example:\n\n@sync begin\n    for p in procs(S)\n        Threads.@spawn begin\n            remotecall_wait(fill!, p, S, p)\n        end\n    end\nend\n\nwould result in undefined behavior. Because each process fills the entire array with its own\npid, whichever process is the last to execute (for any particular element of S) will have\nits pid retained.\n\nAs a more extended and complex example, consider running the following \"kernel\" in parallel:\n\nq[i,j,t+1] = q[i,j,t] + u[i,j,t]\n\nIn this case, if we try to split up the work using a one-dimensional index, we are likely to run\ninto trouble: if q[i,j,t] is near the end of the block assigned to one worker and q[i,j,t+1]\nis near the beginning of the block assigned to another, it's very likely that q[i,j,t] will\nnot be ready at the time it's needed for computing q[i,j,t+1]. In such cases, one is better\noff chunking the array manually. Let's split along the second dimension.\nDefine a function that returns the (irange, jrange) indices assigned to this worker:\n\njulia> @everywhere function myrange(q::SharedArray)\n           idx = indexpids(q)\n           if idx == 0 # This worker is not assigned a piece\n               return 1:0, 1:0\n           end\n           nchunks = length(procs(q))\n           splits = [round(Int, s) for s in range(0, stop=size(q,2), length=nchunks+1)]\n           1:size(q,1), splits[idx]+1:splits[idx+1]\n       end\n\nNext, define the kernel:\n\njulia> @everywhere function advection_chunk!(q, u, irange, jrange, trange)\n           @show (irange, jrange, trange)  # display so we can see what's happening\n           for t in trange, j in jrange, i in irange\n               q[i,j,t+1] = q[i,j,t] + u[i,j,t]\n           end\n           q\n       end\n\nWe also define a convenience wrapper for a SharedArray implementation\n\njulia> @everywhere advection_shared_chunk!(q, u) =\n           advection_chunk!(q, u, myrange(q)..., 1:size(q,3)-1)\n\nNow let's compare three different versions, one that runs in a single process:\n\njulia> advection_serial!(q, u) = advection_chunk!(q, u, 1:size(q,1), 1:size(q,2), 1:size(q,3)-1);\n\none that uses @distributed:\n\njulia> function advection_parallel!(q, u)\n           for t = 1:size(q,3)-1\n               @sync @distributed for j = 1:size(q,2)\n                   for i = 1:size(q,1)\n                       q[i,j,t+1]= q[i,j,t] + u[i,j,t]\n                   end\n               end\n           end\n           q\n       end;\n\nand one that delegates in chunks:\n\njulia> function advection_shared!(q, u)\n           @sync begin\n               for p in procs(q)\n                   Threads.@spawn remotecall_wait(advection_shared_chunk!, p, q, u)\n               end\n           end\n           q\n       end;\n\nIf we create SharedArrays and time these functions, we get the following results (with julia -p 4):\n\njulia> q = SharedArray{Float64,3}((500,500,500));\n\njulia> u = SharedArray{Float64,3}((500,500,500));\n\nRun the functions once to JIT-compile and @time them on the second run:\n\njulia> @time advection_serial!(q, u);\n(irange,jrange,trange) = (1:500,1:500,1:499)\n 830.220 milliseconds (216 allocations: 13820 bytes)\n\njulia> @time advection_parallel!(q, u);\n   2.495 seconds      (3999 k allocations: 289 MB, 2.09% gc time)\n\njulia> @time advection_shared!(q,u);\n        From worker 2:       (irange,jrange,trange) = (1:500,1:125,1:499)\n        From worker 4:       (irange,jrange,trange) = (1:500,251:375,1:499)\n        From worker 3:       (irange,jrange,trange) = (1:500,126:250,1:499)\n        From worker 5:       (irange,jrange,trange) = (1:500,376:500,1:499)\n 238.119 milliseconds (2264 allocations: 169 KB)\n\nThe biggest advantage of advection_shared! is that it minimizes traffic among the workers, allowing\neach to compute for an extended time on the assigned piece."},{"title":"Shared Arrays and Distributed Garbage Collection","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#Shared-Arrays-and-Distributed-Garbage-Collection","category":"section","text":"Like remote references, shared arrays are also dependent on garbage collection on the creating\nnode to release references from all participating workers. Code which creates many short lived\nshared array objects would benefit from explicitly finalizing these objects as soon as possible.\nThis results in both memory and file handles mapping the shared segment being released sooner."},{"title":"ClusterManagers","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#ClusterManagers","category":"section","text":"The launching, management and networking of Julia processes into a logical cluster is done via\ncluster managers. A ClusterManager is responsible for\n\nlaunching worker processes in a cluster environment\nmanaging events during the lifetime of each worker\noptionally, providing data transport\n\nA Julia cluster has the following characteristics:\n\nThe initial Julia process, also called the master, is special and has an id of 1.\nOnly the master process can add or remove worker processes.\nAll processes can directly communicate with each other.\n\nConnections between workers (using the in-built TCP/IP transport) is established in the following\nmanner:\n\naddprocs is called on the master process with a ClusterManager object.\naddprocs calls the appropriate launch method which spawns required number\nof worker processes on appropriate machines.\nEach worker starts listening on a free port and writes out its host and port information to stdout.\nThe cluster manager captures the stdout of each worker and makes it available to the\nmaster process.\nThe master process parses this information and sets up TCP/IP connections to each worker.\nEvery worker is also notified of other workers in the cluster.\nEach worker connects to all workers whose id is less than the worker's own id.\nIn this way a mesh network is established, wherein every worker is directly connected with every\nother worker.\n\nWhile the default transport layer uses plain TCPSocket, it is possible for a Julia cluster to\nprovide its own transport.\n\nJulia provides two in-built cluster managers:\n\nLocalManager, used when addprocs() or addprocs(np::Integer) are called\nSSHManager, used when addprocs(hostnames::Array) is called with a list of hostnames\n\nLocalManager is used to launch additional workers on the same host, thereby leveraging multi-core\nand multi-processor hardware.\n\nThus, a minimal cluster manager would need to:\n\nbe a subtype of the abstract ClusterManager\nimplement launch, a method responsible for launching new workers\nimplement manage, which is called at various events during a worker's lifetime (for\nexample, sending an interrupt signal)\n\naddprocs(manager::FooManager) requires FooManager to implement:\n\nfunction launch(manager::FooManager, params::Dict, launched::Array, c::Condition)\n    [...]\nend\n\nfunction manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)\n    [...]\nend\n\nAs an example let us see how the LocalManager, the manager responsible for starting workers\non the same host, is implemented:\n\nstruct LocalManager <: ClusterManager\n    np::Integer\nend\n\nfunction launch(manager::LocalManager, params::Dict, launched::Array, c::Condition)\n    [...]\nend\n\nfunction manage(manager::LocalManager, id::Integer, config::WorkerConfig, op::Symbol)\n    [...]\nend\n\nThe launch method takes the following arguments:\n\nmanager::ClusterManager: the cluster manager that addprocs is called with\nparams::Dict: all the keyword arguments passed to addprocs\nlaunched::Array: the array to append one or more WorkerConfig objects to\nc::Condition: the condition variable to be notified as and when workers are launched\n\nThe launch method is called asynchronously in a separate task. The termination of\nthis task signals that all requested workers have been launched. Hence the launch\nfunction MUST exit as soon as all the requested workers have been launched.\n\nNewly launched workers are connected to each other and the master process in an all-to-all manner.\nSpecifying the command line argument --worker[=<cookie>] results in the launched processes\ninitializing themselves as workers and connections being set up via TCP/IP sockets.\n\nAll workers in a cluster share the same cookie as the master. When the cookie is\nunspecified, i.e, with the --worker option, the worker tries to read it from its standard input.\n LocalManager and SSHManager both pass the cookie to newly launched workers via their\n standard inputs.\n\nBy default a worker will listen on a free port at the address returned by a call to getipaddr().\nA specific address to listen on may be specified by optional argument --bind-to bind_addr[:port].\nThis is useful for multi-homed hosts.\n\nAs an example of a non-TCP/IP transport, an implementation may choose to use MPI, in which case\n--worker must NOT be specified. Instead, newly launched workers should call init_worker(cookie)\nbefore using any of the parallel constructs.\n\nFor every worker launched, the launch method must add a WorkerConfig object (with\nappropriate fields initialized) to launched\n\nmutable struct WorkerConfig\n    # Common fields relevant to all cluster managers\n    io::Union{IO, Nothing}\n    host::Union{AbstractString, Nothing}\n    port::Union{Integer, Nothing}\n\n    # Used when launching additional workers at a host\n    count::Union{Int, Symbol, Nothing}\n    exename::Union{AbstractString, Cmd, Nothing}\n    exeflags::Union{Cmd, Nothing}\n\n    # External cluster managers can use this to store information at a per-worker level\n    # Can be a dict if multiple fields need to be stored.\n    userdata::Any\n\n    # SSHManager / SSH tunnel connections to workers\n    tunnel::Union{Bool, Nothing}\n    bind_addr::Union{AbstractString, Nothing}\n    sshflags::Union{Cmd, Nothing}\n    max_parallel::Union{Integer, Nothing}\n\n    # Used by Local/SSH managers\n    connect_at::Any\n\n    [...]\nend\n\nMost of the fields in WorkerConfig are used by the inbuilt managers. Custom cluster managers\nwould typically specify only io or host / port:\n\nIf io is specified, it is used to read host/port information. A Julia worker prints out its\nbind address and port at startup. This allows Julia workers to listen on any free port available\ninstead of requiring worker ports to be configured manually.\nIf io is not specified, host and port are used to connect.\ncount, exename and exeflags are relevant for launching additional workers from a worker.\nFor example, a cluster manager may launch a single worker per node, and use that to launch additional\nworkers.\ncount with an integer value n will launch a total of n workers.\ncount with a value of :auto will launch as many workers as the number of CPU threads (logical cores) on that machine.\nexename is the name of the julia executable including the full path.\nexeflags should be set to the required command line arguments for new workers.\ntunnel, bind_addr, sshflags and max_parallel are used when a ssh tunnel is required to\nconnect to the workers from the master process.\nuserdata is provided for custom cluster managers to store their own worker-specific information.\n\nmanage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol) is called at different\ntimes during the worker's lifetime with appropriate op values:\n\nwith :register/:deregister when a worker is added / removed from the Julia worker pool.\nwith :interrupt when interrupt(workers) is called. The ClusterManager should signal the\nappropriate worker with an interrupt signal.\nwith :finalize for cleanup purposes."},{"title":"Cluster Managers with Custom Transports","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#Cluster-Managers-with-Custom-Transports","category":"section","text":"Replacing the default TCP/IP all-to-all socket connections with a custom transport layer is a\nlittle more involved. Each Julia process has as many communication tasks as the workers it is\nconnected to. For example, consider a Julia cluster of 32 processes in an all-to-all mesh network:\n\nEach Julia process thus has 31 communication tasks.\nEach task handles all incoming messages from a single remote worker in a message-processing loop.\nThe message-processing loop waits on an IO object (for example, a TCPSocket in the default\nimplementation), reads an entire message, processes it and waits for the next one.\nSending messages to a process is done directly from any Julia task–not just communication tasks–again,\nvia the appropriate IO object.\n\nReplacing the default transport requires the new implementation to set up connections to remote\nworkers and to provide appropriate IO objects that the message-processing loops can wait on.\nThe manager-specific callbacks to be implemented are:\n\nconnect(manager::FooManager, pid::Integer, config::WorkerConfig)\nkill(manager::FooManager, pid::Int, config::WorkerConfig)\n\nThe default implementation (which uses TCP/IP sockets) is implemented as connect(manager::ClusterManager, pid::Integer, config::WorkerConfig).\n\nconnect should return a pair of IO objects, one for reading data sent from worker pid, and\nthe other to write data that needs to be sent to worker pid. Custom cluster managers can use\nan in-memory BufferStream as the plumbing to proxy data between the custom, possibly non-IO\ntransport and Julia's in-built parallel infrastructure.\n\nA BufferStream is an in-memory IOBuffer which behaves like an IO–it is a stream which can\nbe handled asynchronously.\n\nThe folder clustermanager/0mq in the Examples repository\ncontains an example of using ZeroMQ to connect Julia workers\nin a star topology with a 0MQ broker in the middle. Note: The Julia processes are still all logically\nconnected to each other–any worker can message any other worker directly without any awareness\nof 0MQ being used as the transport layer.\n\nWhen using custom transports:\n\nJulia workers must NOT be started with --worker. Starting with --worker will result in the\nnewly launched workers defaulting to the TCP/IP socket transport implementation.\nFor every incoming logical connection with a worker, Base.process_messages(rd::IO, wr::IO)()\nmust be called. This launches a new task that handles reading and writing of messages from/to\nthe worker represented by the IO objects.\ninit_worker(cookie, manager::FooManager) must be called as part of worker process initialization.\nField connect_at::Any in WorkerConfig can be set by the cluster manager when launch\nis called. The value of this field is passed in all connect callbacks. Typically,\nit carries information on how to connect to a worker. For example, the TCP/IP socket transport\nuses this field to specify the (host, port) tuple at which to connect to a worker.\n\nkill(manager, pid, config) is called to remove a worker from the cluster. On the master process,\nthe corresponding IO objects must be closed by the implementation to ensure proper cleanup.\nThe default implementation simply executes an exit() call on the specified remote worker.\n\nThe Examples folder clustermanager/simple is an example that shows a simple implementation using UNIX domain\nsockets for cluster setup."},{"title":"Network Requirements for LocalManager and SSHManager","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#Network-Requirements-for-LocalManager-and-SSHManager","category":"section","text":"Julia clusters are designed to be executed on already secured environments on infrastructure such\nas local laptops, departmental clusters, or even the cloud. This section covers network security\nrequirements for the inbuilt LocalManager and SSHManager:\n\nThe master process does not listen on any port. It only connects out to the workers.\nEach worker binds to only one of the local interfaces and listens on an ephemeral port number\nassigned by the OS.\nLocalManager, used by addprocs(N), by default binds only to the loopback interface. This means\nthat workers started later on remote hosts (or by anyone with malicious intentions) are unable\nto connect to the cluster. An addprocs(4) followed by an addprocs([\"remote_host\"]) will fail.\nSome users may need to create a cluster comprising their local system and a few remote systems.\nThis can be done by explicitly requesting LocalManager to bind to an external network interface\nvia the restrict keyword argument: addprocs(4; restrict=false).\nSSHManager, used by addprocs(list_of_remote_hosts), launches workers on remote hosts via SSH.\nBy default SSH is only used to launch Julia workers. Subsequent master-worker and worker-worker\nconnections use plain, unencrypted TCP/IP sockets. The remote hosts must have passwordless login\nenabled. Additional SSH flags or credentials may be specified via keyword argument sshflags.\naddprocs(list_of_remote_hosts; tunnel=true, sshflags=<ssh keys and other flags>) is useful when\nwe wish to use SSH connections for master-worker too. A typical scenario for this is a local laptop\nrunning the Julia REPL (i.e., the master) with the rest of the cluster on the cloud, say on Amazon\nEC2. In this case only port 22 needs to be opened at the remote cluster coupled with SSH client\nauthenticated via public key infrastructure (PKI). Authentication credentials can be supplied\nvia sshflags, for example sshflags=`-i <keyfile>`.\nIn an all-to-all topology (the default), all workers connect to each other via plain TCP sockets.\nThe security policy on the cluster nodes must thus ensure free connectivity between workers for\nthe ephemeral port range (varies by OS).\nSecuring and encrypting all worker-worker traffic (via SSH) or encrypting individual messages\ncan be done via a custom ClusterManager.\nIf you specify multiplex=true as an option to addprocs, SSH multiplexing is used to create\na tunnel between the master and workers. If you have configured SSH multiplexing on your own and\nthe connection has already been established, SSH multiplexing is used regardless of multiplex\noption. If multiplexing is enabled, forwarding is set by using the existing connection\n(-O forward option in ssh). This is beneficial if your servers require password authentication;\nyou can avoid authentication in Julia by logging in to the server ahead of addprocs. The control\nsocket will be located at ~/.ssh/julia-%r@%h:%p during the session unless the existing multiplexing\nconnection is used. Note that bandwidth may be limited if you create multiple processes on a node\nand enable multiplexing, because in that case processes share a single multiplexing TCP connection."},{"title":"Cluster Cookie","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#man-cluster-cookie","category":"section","text":"All processes in a cluster share the same cookie which, by default, is a randomly generated string\non the master process:\n\ncluster_cookie() returns the cookie, while cluster_cookie(cookie)() sets\nit and returns the new cookie.\nAll connections are authenticated on both sides to ensure that only workers started by the master\nare allowed to connect to each other.\nThe cookie may be passed to the workers at startup via argument --worker=<cookie>. If argument\n--worker is specified without the cookie, the worker tries to read the cookie from its\nstandard input (stdin). The stdin is closed immediately after the cookie is retrieved.\nClusterManagers can retrieve the cookie on the master by calling cluster_cookie().\nCluster managers not using the default TCP/IP transport (and hence not specifying --worker)\nmust call init_worker(cookie, manager) with the same cookie as on the master.\n\nNote that environments requiring higher levels of security can implement this via a custom ClusterManager.\nFor example, cookies can be pre-shared and hence not specified as a startup argument."},{"title":"Specifying Network Topology (Experimental)","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#Specifying-Network-Topology-(Experimental)","category":"section","text":"The keyword argument topology passed to addprocs is used to specify how the workers must be\nconnected to each other:\n\n:all_to_all, the default: all workers are connected to each other.\n:master_worker: only the driver process, i.e. pid 1, has connections to the workers.\n:custom: the launch method of the cluster manager specifies the connection topology via the\nfields ident and connect_idents in WorkerConfig. A worker with a cluster-manager-provided\nidentity ident will connect to all workers specified in connect_idents.\n\nKeyword argument lazy=true|false only affects topology option :all_to_all. If true, the cluster\nstarts off with the master connected to all workers. Specific worker-worker connections are established\nat the first remote invocation between two workers. This helps in reducing initial resources allocated for\nintra-cluster communication. Connections are setup depending on the runtime requirements of a parallel\nprogram. Default value for lazy is true.\n\nCurrently, sending a message between unconnected workers results in an error. This behaviour,\nas with the functionality and interface, should be considered experimental in nature and may change\nin future releases."},{"title":"Noteworthy external packages","page":"Multi-processing and Distributed Computing","location":"manual/distributed-computing.html#Noteworthy-external-packages","category":"section","text":"Outside of Julia parallelism there are plenty of external packages that should be mentioned.\nFor example, MPI.jl is a Julia wrapper for the MPI\nprotocol, Dagger.jl provides functionality similar to\nPython's Dask, and\nDistributedArrays.jl provides array\noperations distributed across workers, as outlined above.\n\nA mention must be made of Julia's GPU programming ecosystem, which includes:\n\nCUDA.jl wraps the various CUDA libraries and supports compiling Julia kernels for Nvidia GPUs.\noneAPI.jl wraps the oneAPI unified programming model, and supports executing Julia kernels on supported accelerators. Currently only Linux is supported.\nAMDGPU.jl wraps the AMD ROCm libraries and supports compiling Julia kernels for AMD GPUs. Currently only Linux is supported.\nHigh-level libraries like KernelAbstractions.jl, Tullio.jl and ArrayFire.jl.\n\nIn the following example we will use both DistributedArrays.jl and CUDA.jl to distribute an array across multiple\nprocesses by first casting it through distribute() and CuArray().\n\nRemember when importing DistributedArrays.jl to import it across all processes using @everywhere\n\n$ ./julia -p 4\n\njulia> addprocs()\n\njulia> @everywhere using DistributedArrays\n\njulia> using CUDA\n\njulia> B = ones(10_000) ./ 2;\n\njulia> A = ones(10_000) .* π;\n\njulia> C = 2 .* A ./ B;\n\njulia> all(C .≈ 4*π)\ntrue\n\njulia> typeof(C)\nVector{Float64} (alias for Array{Float64, 1})\n\njulia> dB = distribute(B);\n\njulia> dA = distribute(A);\n\njulia> dC = 2 .* dA ./ dB;\n\njulia> all(dC .≈ 4*π)\ntrue\n\njulia> typeof(dC)\nDistributedArrays.DArray{Float64,1,Vector{Float64}}\n\njulia> cuB = CuArray(B);\n\njulia> cuA = CuArray(A);\n\njulia> cuC = 2 .* cuA ./ cuB;\n\njulia> all(cuC .≈ 4*π);\ntrue\n\njulia> typeof(cuC)\nCuArray{Float64,1}\n\nIn the following example we will use both DistributedArrays.jl and CUDA.jl to distribute an array across multiple\nprocesses and call a generic function on it.\n\nfunction power_method(M, v)\n    for i in 1:100\n        v = M*v\n        v /= norm(v)\n    end\n\n    return v, norm(M*v) / norm(v)  # or  (M*v) ./ v\nend\n\npower_method repeatedly creates a new vector and normalizes it. We have not specified any type signature in\nfunction declaration, let's see if it works with the aforementioned datatypes:\n\njulia> M = [2. 1; 1 1];\n\njulia> v = rand(2)\n2-element Vector{Float64}:\n0.40395\n0.445877\n\njulia> power_method(M,v)\n([0.850651, 0.525731], 2.618033988749895)\n\njulia> cuM = CuArray(M);\n\njulia> cuv = CuArray(v);\n\njulia> curesult = power_method(cuM, cuv);\n\njulia> typeof(curesult)\nCuArray{Float64,1}\n\njulia> dM = distribute(M);\n\njulia> dv = distribute(v);\n\njulia> dC = power_method(dM, dv);\n\njulia> typeof(dC)\nTuple{DistributedArrays.DArray{Float64,1,Vector{Float64}},Float64}\n\nTo end this short exposure to external packages, we can consider MPI.jl, a Julia wrapper\nof the MPI protocol. As it would take too long to consider every inner function, it would be better\nto simply appreciate the approach used to implement the protocol.\n\nConsider this toy script which simply calls each subprocess, instantiate its rank and when the master\nprocess is reached, performs the ranks' sum\n\nimport MPI\n\nMPI.Init()\n\ncomm = MPI.COMM_WORLD\nMPI.Barrier(comm)\n\nroot = 0\nr = MPI.Comm_rank(comm)\n\nsr = MPI.Reduce(r, MPI.SUM, root, comm)\n\nif(MPI.Comm_rank(comm) == root)\n   @printf(\"sum of ranks: %s\\n\", sr)\nend\n\nMPI.Finalize()\n\nmpirun -np 4 ./julia example.jl\n\n[1]: In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee\nintroduced a new set of communication mechanisms, collectively referred to as Remote Memory Access\n(RMA). The motivation for adding rma to the MPI standard was to facilitate one-sided communication\npatterns. For additional information on the latest MPI standard, see https://mpi-forum.org/docs."},{"title":"Julia v1.14 Release Notes","page":"Julia v1.14 Release Notes","location":"NEWS.html#Julia-v1.14-Release-Notes","category":"section","text":""},{"title":"New language features","page":"Julia v1.14 Release Notes","location":"NEWS.html#New-language-features","category":"section","text":"It is now possible to control which version of the Julia syntax will be used to parse a package by setting the\ncompat.julia or syntax.julia_version key in Project.toml. This feature is similar to the notion of \"editions\"\nin other language ecosystems and will allow non-breaking evolution of Julia syntax in future versions.\nSee the \"Syntax Versioning\" section in the code loading documentation (#60018).\nᵅ (U+U+1D45), ᵋ (U+1D4B), ᶲ (U+1DB2), ˱ (U+02F1), ˲ (U+02F2), and ₔ (U+2094) can now also be used as\noperator suffixes, accessible as \\^alpha, \\^epsilon, \\^ltphi, \\_<, \\_>, and \\_schwa at the REPL\n(#60285)."},{"title":"Language changes","page":"Julia v1.14 Release Notes","location":"NEWS.html#Language-changes","category":"section","text":""},{"title":"Compiler/Runtime improvements","page":"Julia v1.14 Release Notes","location":"NEWS.html#Compiler/Runtime-improvements","category":"section","text":""},{"title":"Command-line option changes","page":"Julia v1.14 Release Notes","location":"NEWS.html#Command-line-option-changes","category":"section","text":""},{"title":"Multi-threading changes","page":"Julia v1.14 Release Notes","location":"NEWS.html#Multi-threading-changes","category":"section","text":"New functions Threads.atomic_fence_heavy and Threads.atomic_fence_light provide support for\nasymmetric atomic fences, speeding up atomic synchronization where one side of the synchronization\nruns significantly less often than the other (#60311)."},{"title":"Build system changes","page":"Julia v1.14 Release Notes","location":"NEWS.html#Build-system-changes","category":"section","text":""},{"title":"New library functions","page":"Julia v1.14 Release Notes","location":"NEWS.html#New-library-functions","category":"section","text":""},{"title":"New library features","page":"Julia v1.14 Release Notes","location":"NEWS.html#New-library-features","category":"section","text":"IOContext supports a new boolean hexunsigned option that allows for\nprinting unsigned integers in decimal instead of hexadecimal (#60267)."},{"title":"Standard library changes","page":"Julia v1.14 Release Notes","location":"NEWS.html#Standard-library-changes","category":"section","text":"codepoint(c) now succeeds for overlong encodings.  Base.ismalformed, Base.isoverlong, and\nBase.show_invalid are now public and documented (but not exported) (#55152)."},{"title":"JuliaSyntaxHighlighting","page":"Julia v1.14 Release Notes","location":"NEWS.html#JuliaSyntaxHighlighting","category":"section","text":""},{"title":"LinearAlgebra","page":"Julia v1.14 Release Notes","location":"NEWS.html#LinearAlgebra","category":"section","text":""},{"title":"Markdown","page":"Julia v1.14 Release Notes","location":"NEWS.html#Markdown","category":"section","text":"Strikethrough text via ~strike~ or ~~through~~ is now supported by the\nMarkdown parser. (#60537)"},{"title":"Profile","page":"Julia v1.14 Release Notes","location":"NEWS.html#Profile","category":"section","text":""},{"title":"Random","page":"Julia v1.14 Release Notes","location":"NEWS.html#Random","category":"section","text":""},{"title":"REPL","page":"Julia v1.14 Release Notes","location":"NEWS.html#REPL","category":"section","text":""},{"title":"Test","page":"Julia v1.14 Release Notes","location":"NEWS.html#Test","category":"section","text":"@test, @test_throws, and @test_broken now support a context keyword argument\nthat provides additional information displayed on test failure. This is useful for\ndebugging which specific case failed in parameterized tests (#60501).\n@test_throws, @test_warn, @test_nowarn, @test_logs, and @test_deprecated now support\nbroken and skip keyword arguments for consistency with @test (#60543)."},{"title":"InteractiveUtils","page":"Julia v1.14 Release Notes","location":"NEWS.html#InteractiveUtils","category":"section","text":""},{"title":"Dates","page":"Julia v1.14 Release Notes","location":"NEWS.html#Dates","category":"section","text":""},{"title":"External dependencies","page":"Julia v1.14 Release Notes","location":"NEWS.html#External-dependencies","category":"section","text":""},{"title":"Tooling Improvements","page":"Julia v1.14 Release Notes","location":"NEWS.html#Tooling-Improvements","category":"section","text":""},{"title":"Deprecated or removed","page":"Julia v1.14 Release Notes","location":"NEWS.html#Deprecated-or-removed","category":"section","text":""},{"title":"Base64","page":"Base64","location":"stdlib/Base64.html#Base64","category":"section","text":""},{"title":"Base64.Base64","page":"Base64","location":"stdlib/Base64.html#Base64.Base64","category":"module","text":"Base64\n\nFunctionality for base64 encoding and decoding,\na method to represent binary data using text, common on the web.\n\n\n\n\n\n"},{"title":"Base64.Base64EncodePipe","page":"Base64","location":"stdlib/Base64.html#Base64.Base64EncodePipe","category":"type","text":"Base64EncodePipe(ostream)\n\nReturn a new write-only I/O stream, which converts any bytes written to it into\nbase64-encoded ASCII bytes written to ostream.  Calling close on the\nBase64EncodePipe stream is necessary to complete the encoding (but does not\nclose ostream).\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> iob64_encode = Base64EncodePipe(io);\n\njulia> write(iob64_encode, \"Hello!\")\n6\n\njulia> close(iob64_encode);\n\njulia> str = takestring!(io)\n\"SGVsbG8h\"\n\njulia> String(base64decode(str))\n\"Hello!\"\n\n\n\n\n\n"},{"title":"Base64.base64encode","page":"Base64","location":"stdlib/Base64.html#Base64.base64encode","category":"function","text":"base64encode(writefunc, args...; context=nothing)\nbase64encode(args...; context=nothing)\n\nGiven a write-like function writefunc, which takes an I/O stream as\nits first argument, base64encode(writefunc, args...) calls writefunc to\nwrite args... to a base64-encoded string, and returns the string.\nbase64encode(args...) is equivalent to base64encode(write, args...): it\nconverts its arguments into bytes using the standard write functions\nand returns the base64-encoded string.\n\nThe optional keyword argument context can be set to :key=>value pair\nor an IO or IOContext object whose attributes are used for the I/O\nstream passed to writefunc or write.\n\nSee also base64decode.\n\n\n\n\n\n"},{"title":"Base64.Base64DecodePipe","page":"Base64","location":"stdlib/Base64.html#Base64.Base64DecodePipe","category":"type","text":"Base64DecodePipe(istream)\n\nReturn a new read-only I/O stream, which decodes base64-encoded data read from\nistream.\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> iob64_decode = Base64DecodePipe(io);\n\njulia> write(io, \"SGVsbG8h\")\n8\n\njulia> seekstart(io);\n\njulia> String(read(iob64_decode))\n\"Hello!\"\n\n\n\n\n\n"},{"title":"Base64.base64decode","page":"Base64","location":"stdlib/Base64.html#Base64.base64decode","category":"function","text":"base64decode(string)\n\nDecode the base64-encoded string and returns a Vector{UInt8} of the decoded\nbytes.\n\nSee also base64encode.\n\nExamples\n\njulia> b = base64decode(\"SGVsbG8h\")\n6-element Vector{UInt8}:\n 0x48\n 0x65\n 0x6c\n 0x6c\n 0x6f\n 0x21\n\njulia> String(b)\n\"Hello!\"\n\n\n\n\n\n"},{"title":"Base64.stringmime","page":"Base64","location":"stdlib/Base64.html#Base64.stringmime","category":"function","text":"stringmime(mime, x; context=nothing)\n\nReturn an AbstractString containing the representation of x in the\nrequested mime type. This is similar to repr(mime, x) except\nthat binary data is base64-encoded as an ASCII string.\n\nThe optional keyword argument context can be set to :key=>value pair\nor an IO or IOContext object whose attributes are used for the I/O\nstream passed to show.\n\n\n\n\n\n"},{"title":"LibGit2","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2","category":"section","text":"The LibGit2 module provides bindings to libgit2, a portable C library that\nimplements core functionality for the Git version control system.\nThese bindings are currently used to power Julia's package manager.\nIt is expected that this module will eventually be moved into a separate package."},{"title":"Functionality","page":"LibGit2","location":"stdlib/LibGit2.html#Functionality","category":"section","text":"Some of this documentation assumes some prior knowledge of the libgit2 API.\nFor more information on some of the objects and methods referenced here, consult the upstream\nlibgit2 API reference."},{"title":"LibGit2.Buffer","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.Buffer","category":"type","text":"LibGit2.Buffer\n\nA data buffer for exporting data from libgit2.\nMatches the git_buf struct.\n\nWhen fetching data from LibGit2, a typical usage would look like:\n\nbuf_ref = Ref(Buffer())\n@check ccall(..., (Ptr{Buffer},), buf_ref)\n# operation on buf_ref\nfree(buf_ref)\n\nIn particular, note that LibGit2.free should be called afterward on the Ref object.\n\n\n\n\n\n"},{"title":"LibGit2.CheckoutOptions","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.CheckoutOptions","category":"type","text":"LibGit2.CheckoutOptions\n\nMatches the git_checkout_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\ncheckout_strategy: determine how to handle conflicts and whether to force the\n checkout/recreate missing files.\ndisable_filters: if nonzero, do not apply filters like CLRF (to convert file newlines between UNIX and DOS).\ndir_mode: read/write/access mode for any directories involved in the checkout. Default is 0755.\nfile_mode: read/write/access mode for any files involved in the checkout.\n Default is 0755 or 0644, depending on the blob.\nfile_open_flags: bitflags used to open any files during the checkout.\nnotify_flags: Flags for what sort of conflicts the user should be notified about.\nnotify_cb: An optional callback function to notify the user if a checkout conflict occurs.\n If this function returns a non-zero value, the checkout will be cancelled.\nnotify_payload: Payload for the notify callback function.\nprogress_cb: An optional callback function to display checkout progress.\nprogress_payload: Payload for the progress callback.\npaths: If not empty, describes which paths to search during the checkout.\n If empty, the checkout will occur over all files in the repository.\nbaseline: Expected content of the workdir, captured in a (pointer to a)\n GitTree. Defaults to the state of the tree at HEAD.\nbaseline_index: Expected content of the workdir, captured in a (pointer to a)\n GitIndex. Defaults to the state of the index at HEAD.\ntarget_directory: If not empty, checkout to this directory instead of the workdir.\nancestor_label: In case of conflicts, the name of the common ancestor side.\nour_label: In case of conflicts, the name of \"our\" side.\ntheir_label: In case of conflicts, the name of \"their\" side.\nperfdata_cb: An optional callback function to display performance data.\nperfdata_payload: Payload for the performance callback.\n\n\n\n\n\n"},{"title":"LibGit2.CloneOptions","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.CloneOptions","category":"type","text":"LibGit2.CloneOptions\n\nMatches the git_clone_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\ncheckout_opts: The options for performing the checkout of the remote as part of the clone.\nfetch_opts: The options for performing the pre-checkout fetch of the remote as part of the clone.\nbare: If 0, clone the full remote repository. If non-zero, perform a bare clone, in which\n there is no local copy of the source files in the repository and the gitdir and workdir\n are the same.\nlocalclone: Flag whether to clone a local object database or do a fetch. The default is to let git decide.\n It will not use the git-aware transport for a local clone, but will use it for URLs which begin with file://.\ncheckout_branch: The name of the branch to checkout. If an empty string, the default branch of the\n remote will be checked out.\nrepository_cb: An optional callback which will be used to create the new repository into which\n the clone is made.\nrepository_cb_payload: The payload for the repository callback.\nremote_cb: An optional callback used to create the GitRemote before making the clone from it.\nremote_cb_payload: The payload for the remote callback.\n\n\n\n\n\n"},{"title":"LibGit2.DescribeOptions","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.DescribeOptions","category":"type","text":"LibGit2.DescribeOptions\n\nMatches the git_describe_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nmax_candidates_tags: consider this many most recent tags in refs/tags to describe a commit.\n Defaults to 10 (so that the 10 most recent tags would be examined to see if they describe a commit).\ndescribe_strategy: whether to consider all entries in refs/tags (equivalent to git-describe --tags)\n or all entries in refs/ (equivalent to git-describe --all). The default is to only show annotated tags.\n If Consts.DESCRIBE_TAGS is passed, all tags, annotated or not, will be considered.\n If Consts.DESCRIBE_ALL is passed, any ref in refs/ will be considered.\npattern: only consider tags which match pattern. Supports glob expansion.\nonly_follow_first_parent: when finding the distance from a matching reference to the described\n object, only consider the distance from the first parent.\nshow_commit_oid_as_fallback: if no matching reference can be found which describes a commit, show the\n commit's GitHash instead of throwing an error (the default behavior).\n\n\n\n\n\n"},{"title":"LibGit2.DescribeFormatOptions","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.DescribeFormatOptions","category":"type","text":"LibGit2.DescribeFormatOptions\n\nMatches the git_describe_format_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nabbreviated_size: lower bound on the size of the abbreviated GitHash to use, defaulting to 7.\nalways_use_long_format: set to 1 to use the long format for strings even if a short format can be used.\ndirty_suffix: if set, this will be appended to the end of the description string if the workdir is dirty.\n\n\n\n\n\n"},{"title":"LibGit2.DiffDelta","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.DiffDelta","category":"type","text":"LibGit2.DiffDelta\n\nDescription of changes to one entry.\nMatches the git_diff_delta struct.\n\nThe fields represent:\n\nstatus: One of Consts.DELTA_STATUS, indicating whether the file has been added/modified/deleted.\nflags: Flags for the delta and the objects on each side. Determines whether to treat the file(s)\n as binary/text, whether they exist on each side of the diff, and whether the object ids are known\n to be correct.\nsimilarity: Used to indicate if a file has been renamed or copied.\nnfiles: The number of files in the delta (for instance, if the delta\n was run on a submodule commit id, it may contain more than one file).\nold_file: A DiffFile containing information about the file(s) before the changes.\nnew_file: A DiffFile containing information about the file(s) after the changes.\n\n\n\n\n\n"},{"title":"LibGit2.DiffFile","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.DiffFile","category":"type","text":"LibGit2.DiffFile\n\nDescription of one side of a delta.\nMatches the git_diff_file struct.\n\nThe fields represent:\n\nid: the GitHash of the item in the diff. If the item is empty on this\n side of the diff (for instance, if the diff is of the removal of a file), this will\n be GitHash(0).\npath: a NULL terminated path to the item relative to the working directory of the repository.\nsize: the size of the item in bytes.\nflags: a combination of the git_diff_flag_t\n flags. The ith bit of this integer sets the ith flag.\nmode: the stat mode for the item.\nid_abbrev: only present in LibGit2 versions newer than or equal to 0.25.0.\n The length of the id field when converted using string. Usually equal to OID_HEXSZ (40).\n\n\n\n\n\n"},{"title":"LibGit2.DiffOptionsStruct","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.DiffOptionsStruct","category":"type","text":"LibGit2.DiffOptionsStruct\n\nMatches the git_diff_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nflags: flags controlling which files will appear in the diff. Defaults to DIFF_NORMAL.\nignore_submodules: whether to look at files in submodules or not. Defaults to\nSUBMODULE_IGNORE_UNSPECIFIED, which means the submodule's configuration will control\n whether it appears in the diff or not.\npathspec: path to files to include in the diff. Default is to use all files in the repository.\nnotify_cb: optional callback which will notify the user of changes to the diff as file deltas are\n added to it.\nprogress_cb: optional callback which will display diff progress. Only relevant on libgit2 versions\n at least as new as 0.24.0.\npayload: the payload to pass to notify_cb and progress_cb.\ncontext_lines: the number of unchanged lines used to define the edges of a hunk.\n This is also the number of lines which will be shown before/after a hunk to provide\n context. Default is 3.\ninterhunk_lines: the maximum number of unchanged lines between two separate\n hunks allowed before the hunks will be combined. Default is 0.\nid_abbrev: sets the length of the abbreviated GitHash to print.\n Default is 7.\nmax_size: the maximum file size of a blob. Above this size, it will be treated\n as a binary blob. The default is 512 MB.\nold_prefix: the virtual file directory in which to place old files on one side\n of the diff. Default is \"a\".\nnew_prefix: the virtual file directory in which to place new files on one side\n of the diff. Default is \"b\".\n\n\n\n\n\n"},{"title":"LibGit2.FetchHead","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.FetchHead","category":"type","text":"LibGit2.FetchHead\n\nContains the information about HEAD during a fetch, including the name and URL\nof the branch fetched from, the oid of the HEAD, and whether the fetched HEAD\nhas been merged locally.\n\nThe fields represent:\n\nname: The name in the local reference database of the fetch head, for example,\n \"refs/heads/master\".\nurl: The URL of the fetch head.\noid: The GitHash of the tip of the fetch head.\nismerge: Boolean flag indicating whether the changes at the\n remote have been merged into the local copy yet or not. If true, the local\n copy is up to date with the remote fetch head.\n\n\n\n\n\n"},{"title":"LibGit2.FetchOptions","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.FetchOptions","category":"type","text":"LibGit2.FetchOptions\n\nMatches the git_fetch_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\ncallbacks: remote callbacks to use during the fetch.\nprune: whether to perform a prune after the fetch or not. The default is to\n use the setting from the GitConfig.\nupdate_fetchhead: whether to update the FetchHead after the fetch.\n The default is to perform the update, which is the normal git behavior.\ndownload_tags: whether to download tags present at the remote or not. The default\n is to request the tags for objects which are being downloaded anyway from the server.\nproxy_opts: options for connecting to the remote through a proxy. See ProxyOptions.\n Only present on libgit2 versions newer than or equal to 0.25.0.\ncustom_headers: any extra headers needed for the fetch. Only present on libgit2 versions\n newer than or equal to 0.24.0.\n\n\n\n\n\n"},{"title":"LibGit2.GitAnnotated","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitAnnotated","category":"type","text":"GitAnnotated(repo::GitRepo, commit_id::GitHash)\nGitAnnotated(repo::GitRepo, ref::GitReference)\nGitAnnotated(repo::GitRepo, fh::FetchHead)\nGitAnnotated(repo::GitRepo, committish::AbstractString)\n\nAn annotated git commit carries with it information about how it was looked up and\nwhy, so that rebase or merge operations have more information about the context of\nthe commit. Conflict files contain information about the source/target branches in\nthe merge which are conflicting, for instance. An annotated commit can refer to the\ntip of a remote branch, for instance when a FetchHead is passed, or to a\nbranch head described using GitReference.\n\n\n\n\n\n"},{"title":"LibGit2.GitBlame","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitBlame","category":"type","text":"GitBlame(repo::GitRepo, path::AbstractString; options::BlameOptions=BlameOptions())\n\nConstruct a GitBlame object for the file at path, using change information gleaned\nfrom the history of repo. The GitBlame object records who changed which chunks of\nthe file when, and how. options controls how to separate the contents of the file and\nwhich commits to probe - see BlameOptions for more information.\n\n\n\n\n\n"},{"title":"LibGit2.GitBlob","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitBlob","category":"type","text":"GitBlob(repo::GitRepo, hash::AbstractGitHash)\nGitBlob(repo::GitRepo, spec::AbstractString)\n\nReturn a GitBlob object from repo specified by hash/spec.\n\nhash is a full (GitHash) or partial (GitShortHash) hash.\nspec is a textual specification: see the git docs for a full list.\n\n\n\n\n\n"},{"title":"LibGit2.GitCommit","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitCommit","category":"type","text":"GitCommit(repo::GitRepo, hash::AbstractGitHash)\nGitCommit(repo::GitRepo, spec::AbstractString)\n\nReturn a GitCommit object from repo specified by hash/spec.\n\nhash is a full (GitHash) or partial (GitShortHash) hash.\nspec is a textual specification: see the git docs for a full list.\n\n\n\n\n\n"},{"title":"LibGit2.GitConfig","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitConfig","category":"type","text":"GitConfig(path::AbstractString, level::Consts.GIT_CONFIG=Consts.CONFIG_LEVEL_APP, force::Bool=false)\n\nCreate a new GitConfig by loading configuration information from the file at path. See\naddfile for more information about the level, repo and force options.\n\n\n\n\n\nGitConfig(repo::GitRepo)\n\nGet the stored configuration for the git repository repo. If repo does not\nhave a specific configuration file set, the default git configuration will be\nused.\n\n\n\n\n\nGitConfig(level::Consts.GIT_CONFIG=Consts.CONFIG_LEVEL_DEFAULT)\n\nGet the default git configuration by loading the global and system configuration\nfiles into a prioritized configuration. This can be used to access default configuration\noptions outside a specific git repository.\n\n\n\n\n\n"},{"title":"LibGit2.GitHash","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitHash","category":"type","text":"GitHash\n\nA git object identifier, based on the sha-1 hash. It is a 20 byte string\n(40 hex digits) used to identify a GitObject in a repository.\n\n\n\n\n\n"},{"title":"LibGit2.GitObject","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitObject","category":"type","text":"GitObject(repo::GitRepo, hash::AbstractGitHash)\nGitObject(repo::GitRepo, spec::AbstractString)\n\nReturn the specified object (GitCommit, GitBlob, GitTree or GitTag) from repo\nspecified by hash/spec.\n\nhash is a full (GitHash) or partial (GitShortHash) hash.\nspec is a textual specification: see the git docs for a full list.\n\n\n\n\n\n"},{"title":"LibGit2.GitRemote","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitRemote","category":"type","text":"GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString)::GitRemote\n\nLook up a remote git repository using its name and URL. Uses the default fetch refspec.\n\nExamples\n\nrepo = LibGit2.init(repo_path)\nremote = LibGit2.GitRemote(repo, \"upstream\", repo_url)\n\n\n\n\n\nGitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString, fetch_spec::AbstractString)::GitRemote\n\nLook up a remote git repository using the repository's name and URL,\nas well as specifications for how to fetch from the remote\n(e.g. which remote branch to fetch from).\n\nExamples\n\nrepo = LibGit2.init(repo_path)\nrefspec = \"+refs/heads/mybranch:refs/remotes/origin/mybranch\"\nremote = LibGit2.GitRemote(repo, \"upstream\", repo_url, refspec)\n\n\n\n\n\n"},{"title":"LibGit2.GitRemoteAnon","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitRemoteAnon","category":"function","text":"GitRemoteAnon(repo::GitRepo, url::AbstractString)::GitRemote\n\nLook up a remote git repository using only its URL, not its name.\n\nExamples\n\nrepo = LibGit2.init(repo_path)\nremote = LibGit2.GitRemoteAnon(repo, repo_url)\n\n\n\n\n\n"},{"title":"LibGit2.GitRepo","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitRepo","category":"type","text":"LibGit2.GitRepo(path::AbstractString)\n\nOpen a git repository at path.\n\n\n\n\n\n"},{"title":"LibGit2.GitRepoExt","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitRepoExt","category":"function","text":"LibGit2.GitRepoExt(path::AbstractString, flags::Cuint = Cuint(Consts.REPOSITORY_OPEN_DEFAULT))\n\nOpen a git repository at path with extended controls (for instance, if the current\nuser must be a member of a special access group to read path).\n\n\n\n\n\n"},{"title":"LibGit2.GitRevWalker","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitRevWalker","category":"type","text":"GitRevWalker(repo::GitRepo)\n\nA GitRevWalker walks through the revisions (i.e. commits) of\na git repository repo. It is a collection of the commits\nin the repository, and supports iteration and calls to LibGit2.map\nand LibGit2.count (for instance, LibGit2.count could be used to determine\nwhat percentage of commits in a repository were made by a certain\nauthor).\n\ncnt = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker\n    LibGit2.count((oid,repo)->(oid == commit_oid1), walker, oid=commit_oid1, by=LibGit2.Consts.SORT_TIME)\nend\n\nHere, LibGit2.count finds the number of commits along the walk with a certain GitHash.\nSince the GitHash is unique to a commit, cnt will be 1.\n\n\n\n\n\n"},{"title":"LibGit2.GitShortHash","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitShortHash","category":"type","text":"GitShortHash(hash::GitHash, len::Integer)\n\nA shortened git object identifier, which can be used to identify a git object when it is\nunique, consisting of the initial len hexadecimal digits of hash (the remaining digits\nare ignored).\n\n\n\n\n\n"},{"title":"LibGit2.GitSignature","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitSignature","category":"type","text":"LibGit2.GitSignature\n\nThis is a Julia wrapper around a pointer to a\ngit_signature object.\n\n\n\n\n\n"},{"title":"LibGit2.GitStatus","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitStatus","category":"type","text":"LibGit2.GitStatus(repo::GitRepo; status_opts=StatusOptions())\n\nCollect information about the status of each file in the git\nrepository repo (e.g. is the file modified, staged, etc.).\nstatus_opts can be used to set various options, for instance\nwhether or not to look at untracked files or whether to include\nsubmodules or not. See StatusOptions for more information.\n\n\n\n\n\n"},{"title":"LibGit2.GitTag","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitTag","category":"type","text":"GitTag(repo::GitRepo, hash::AbstractGitHash)\nGitTag(repo::GitRepo, spec::AbstractString)\n\nReturn a GitTag object from repo specified by hash/spec.\n\nhash is a full (GitHash) or partial (GitShortHash) hash.\nspec is a textual specification: see the git docs for a full list.\n\n\n\n\n\n"},{"title":"LibGit2.GitTree","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitTree","category":"type","text":"GitTree(repo::GitRepo, hash::AbstractGitHash)\nGitTree(repo::GitRepo, spec::AbstractString)\n\nReturn a GitTree object from repo specified by hash/spec.\n\nhash is a full (GitHash) or partial (GitShortHash) hash.\nspec is a textual specification: see the git docs for a full list.\n\n\n\n\n\n"},{"title":"LibGit2.IndexEntry","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.IndexEntry","category":"type","text":"LibGit2.IndexEntry\n\nIn-memory representation of a file entry in the index.\nMatches the git_index_entry struct.\n\n\n\n\n\n"},{"title":"LibGit2.IndexTime","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.IndexTime","category":"type","text":"LibGit2.IndexTime\n\nMatches the git_index_time struct.\n\n\n\n\n\n"},{"title":"LibGit2.BlameOptions","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.BlameOptions","category":"type","text":"LibGit2.BlameOptions\n\nMatches the git_blame_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nflags: one of Consts.BLAME_NORMAL or Consts.BLAME_FIRST_PARENT (the other blame flags\n are not yet implemented by libgit2).\nmin_match_characters: the minimum number of alphanumeric characters which much change\nin a commit in order for the change to be associated with that commit. The default is 20.\nOnly takes effect if one of the Consts.BLAME_*_COPIES flags are used, which libgit2 does\nnot implement yet.\nnewest_commit: the GitHash of the newest commit from which to look at changes.\noldest_commit: the GitHash of the oldest commit from which to look at changes.\nmin_line: the first line of the file from which to starting blaming. The default is 1.\nmax_line: the last line of the file to which to blame. The default is 0, meaning the\nlast line of the file.\n\n\n\n\n\n"},{"title":"LibGit2.MergeOptions","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.MergeOptions","category":"type","text":"LibGit2.MergeOptions\n\nMatches the git_merge_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nflags: an enum for flags describing merge behavior.\n Defined in git_merge_flag_t.\n The corresponding Julia enum is GIT_MERGE and has values:\nMERGE_FIND_RENAMES: detect if a file has been renamed between the common\nancestor and the \"ours\" or \"theirs\" side of the merge. Allows merges where\na file has been renamed.\nMERGE_FAIL_ON_CONFLICT: exit immediately if a conflict is found rather\nthan trying to resolve it.\nMERGE_SKIP_REUC: do not write the REUC extension on the index resulting\nfrom the merge.\nMERGE_NO_RECURSIVE: if the commits being merged have multiple merge bases,\nuse the first one, rather than trying to recursively merge the bases.\nrename_threshold: how similar two files must to consider one a rename of the other.\nThis is an integer that sets the percentage similarity. The default is 50.\ntarget_limit: the maximum number of files to compare with to look for renames.\nThe default is 200.\nmetric: optional custom function to use to determine the similarity between two\nfiles for rename detection.\nrecursion_limit: the upper limit on the number of merges of common ancestors to\nperform to try to build a new virtual merge base for the merge. The default is no\nlimit. This field is only present on libgit2 versions newer than 0.24.0.\ndefault_driver: the merge driver to use if both sides have changed. This field\nis only present on libgit2 versions newer than 0.25.0.\nfile_favor: how to handle conflicting file contents for the text driver.\nMERGE_FILE_FAVOR_NORMAL: if both sides of the merge have changes to a section,\n make a note of the conflict in the index which git checkout will use to create\n a merge file, which the user can then reference to resolve the conflicts. This is\n the default.\nMERGE_FILE_FAVOR_OURS: if both sides of the merge have changes to a section,\n use the version in the \"ours\" side of the merge in the index.\nMERGE_FILE_FAVOR_THEIRS: if both sides of the merge have changes to a section,\n use the version in the \"theirs\" side of the merge in the index.\nMERGE_FILE_FAVOR_UNION: if both sides of the merge have changes to a section,\n include each unique line from both sides in the file which is put into the index.\nfile_flags: guidelines for merging files.\n\n\n\n\n\n"},{"title":"LibGit2.ProxyOptions","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.ProxyOptions","category":"type","text":"LibGit2.ProxyOptions\n\nOptions for connecting through a proxy.\n\nMatches the git_proxy_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nproxytype: an enum for the type of proxy to use.\n Defined in git_proxy_t.\n The corresponding Julia enum is GIT_PROXY and has values:\nPROXY_NONE: do not attempt the connection through a proxy.\nPROXY_AUTO: attempt to figure out the proxy configuration from the git configuration.\nPROXY_SPECIFIED: connect using the URL given in the url field of this struct.\nDefault is to auto-detect the proxy type.\nurl: the URL of the proxy.\ncredential_cb: a pointer to a callback function which will be called if the remote\nrequires authentication to connect.\ncertificate_cb: a pointer to a callback function which will be called if certificate\nverification fails. This lets the user decide whether or not to keep connecting. If\nthe function returns 1, connecting will be allowed. If it returns 0, the connection\nwill not be allowed. A negative value can be used to return errors.\npayload: the payload to be provided to the two callback functions.\n\nExamples\n\njulia> fo = LibGit2.FetchOptions(\n           proxy_opts = LibGit2.ProxyOptions(url = Cstring(\"https://my_proxy_url.com\")))\n\njulia> fetch(remote, \"master\", options=fo)\n\n\n\n\n\n"},{"title":"LibGit2.PushOptions","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.PushOptions","category":"type","text":"LibGit2.PushOptions\n\nMatches the git_push_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nparallelism: if a pack file must be created, this variable sets the number of worker\n threads which will be spawned by the packbuilder. If 0, the packbuilder will auto-set\n the number of threads to use. The default is 1.\ncallbacks: the callbacks (e.g. for authentication with the remote) to use for the push.\nproxy_opts: only relevant if the LibGit2 version is greater than or equal to 0.25.0.\n Sets options for using a proxy to communicate with a remote. See ProxyOptions\n for more information.\ncustom_headers: only relevant if the LibGit2 version is greater than or equal to 0.24.0.\n Extra headers needed for the push operation.\nremote_push_options: only relevant if the LibGit2 version is greater than or equal to 1.8.0.\n \"Push options\" to deliver to the remote.\n\n\n\n\n\n"},{"title":"LibGit2.RebaseOperation","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.RebaseOperation","category":"type","text":"LibGit2.RebaseOperation\n\nDescribes a single instruction/operation to be performed during the rebase.\nMatches the git_rebase_operation struct.\n\nThe fields represent:\n\noptype: the type of rebase operation currently being performed. The options are:\nREBASE_OPERATION_PICK: cherry-pick the commit in question.\nREBASE_OPERATION_REWORD: cherry-pick the commit in question, but rewrite its\nmessage using the prompt.\nREBASE_OPERATION_EDIT: cherry-pick the commit in question, but allow the user\nto edit the commit's contents and its message.\nREBASE_OPERATION_SQUASH: squash the commit in question into the previous commit.\nThe commit messages of the two commits will be merged.\nREBASE_OPERATION_FIXUP: squash the commit in question into the previous commit.\nOnly the commit message of the previous commit will be used.\nREBASE_OPERATION_EXEC: do not cherry-pick a commit. Run a command and continue if\nthe command exits successfully.\nid: the GitHash of the commit being worked on during this rebase step.\nexec: in case REBASE_OPERATION_EXEC is used, the command to run during this step\n(for instance, running the test suite after each commit).\n\n\n\n\n\n"},{"title":"LibGit2.RebaseOptions","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.RebaseOptions","category":"type","text":"LibGit2.RebaseOptions\n\nMatches the git_rebase_options struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nquiet: inform other git clients helping with/working on the rebase that the rebase\nshould be done \"quietly\". Used for interoperability. The default is 1.\ninmemory: start an in-memory rebase. Callers working on the rebase can go through its\nsteps and commit any changes, but cannot rewind HEAD or update the repository. The\nworkdir will not be modified. Only present on libgit2 versions newer than or equal to 0.24.0.\nrewrite_notes_ref: name of the reference to notes to use to rewrite the commit notes as\nthe rebase is finished.\nmerge_opts: merge options controlling how the trees will be merged at each rebase step.\n Only present on libgit2 versions newer than or equal to 0.24.0.\ncheckout_opts: checkout options for writing files when initializing the rebase, stepping\nthrough it, and aborting it. See CheckoutOptions for more information.\n\n\n\n\n\n"},{"title":"LibGit2.RemoteCallbacks","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.RemoteCallbacks","category":"type","text":"LibGit2.RemoteCallbacks\n\nCallback settings.\nMatches the git_remote_callbacks struct.\n\n\n\n\n\n"},{"title":"LibGit2.SignatureStruct","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.SignatureStruct","category":"type","text":"LibGit2.SignatureStruct\n\nAn action signature (e.g. for committers, taggers, etc).\nMatches the git_signature struct.\n\nThe fields represent:\n\nname: The full name of the committer or author of the commit.\nemail: The email at which the committer/author can be contacted.\nwhen: a TimeStruct indicating when the commit was\n authored/committed into the repository.\n\n\n\n\n\n"},{"title":"LibGit2.StatusEntry","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.StatusEntry","category":"type","text":"LibGit2.StatusEntry\n\nProviding the differences between the file as it exists in HEAD and the index, and\nproviding the differences between the index and the working directory.\nMatches the git_status_entry struct.\n\nThe fields represent:\n\nstatus: contains the status flags for the file, indicating if it is current,\nor has been changed in some way in the index or work tree.\nhead_to_index: a pointer to a DiffDelta which encapsulates the difference(s)\nbetween the file as it exists in HEAD and in the index.\nindex_to_workdir: a pointer to a DiffDelta which encapsulates the difference(s)\nbetween the file as it exists in the index and in the workdir.\n\n\n\n\n\n"},{"title":"LibGit2.StatusOptions","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.StatusOptions","category":"type","text":"LibGit2.StatusOptions\n\nOptions to control how git_status_foreach_ext() will issue callbacks.\nMatches the git_status_opt_t struct.\n\nThe fields represent:\n\nversion: version of the struct in use, in case this changes later. For now, always 1.\nshow: a flag for which files to examine and in which order.\nThe default is Consts.STATUS_SHOW_INDEX_AND_WORKDIR.\nflags: flags for controlling any callbacks used in a status call.\npathspec: an array of paths to use for path-matching. The behavior of the path-matching\nwill vary depending on the values of show and flags.\nThe baseline is the tree to be used for comparison to the working directory and\nindex; defaults to HEAD.\n\n\n\n\n\n"},{"title":"LibGit2.StrArrayStruct","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.StrArrayStruct","category":"type","text":"LibGit2.StrArrayStruct\n\nA LibGit2 representation of an array of strings.\nMatches the git_strarray struct.\n\nWhen fetching data from LibGit2, a typical usage would look like:\n\nsa_ref = Ref(StrArrayStruct())\n@check ccall(..., (Ptr{StrArrayStruct},), sa_ref)\nres = collect(sa_ref[])\nfree(sa_ref)\n\nIn particular, note that LibGit2.free should be called afterward on the Ref object.\n\nConversely, when passing a vector of strings to LibGit2, it is generally simplest to rely\non implicit conversion:\n\nstrs = String[...]\n@check ccall(..., (Ptr{StrArrayStruct},), strs)\n\nNote that no call to free is required as the data is allocated by Julia.\n\n\n\n\n\n"},{"title":"LibGit2.TimeStruct","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.TimeStruct","category":"type","text":"LibGit2.TimeStruct\n\nTime in a signature.\nMatches the git_time struct.\n\n\n\n\n\n"},{"title":"LibGit2.addfile","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.addfile","category":"function","text":"addfile(cfg::GitConfig, path::AbstractString,\n        level::Consts.GIT_CONFIG=Consts.CONFIG_LEVEL_APP,\n        repo::Union{GitRepo, Nothing} = nothing,\n        force::Bool=false)\n\nAdd an existing git configuration file located at path to the current\nGitConfig cfg. If the file does not exist, it will be created.\n\nlevel sets the git configuration priority level and is determined by\n\nConsts.GIT_CONFIG.\n\nrepo is an optional repository to allow parsing of conditional includes.\nIf force is false and a configuration for the given priority level already exists,\n\naddfile will error. If force is true, the existing configuration will be replaced by\nthe one in the file at path.\n\n\n\n\n\n"},{"title":"LibGit2.add!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.add!","category":"function","text":"add!(repo::GitRepo, files::AbstractString...; flags::Cuint = Consts.INDEX_ADD_DEFAULT)\nadd!(idx::GitIndex, files::AbstractString...; flags::Cuint = Consts.INDEX_ADD_DEFAULT)\n\nAdd all the files with paths specified by files to the index idx (or the index\nof the repo). If the file already exists, the index entry will be updated.\nIf the file does not exist already, it will be newly added into the index.\nfiles may contain glob patterns which will be expanded and any matching files will\nbe added (unless INDEX_ADD_DISABLE_PATHSPEC_MATCH is set, see below).\nIf a file has been ignored (in .gitignore or in the config), it will not be\nadded, unless it is already being tracked in the index, in which case it will be\nupdated. The keyword argument flags is a set of bit-flags which control the behavior\nwith respect to ignored files:\n\nConsts.INDEX_ADD_DEFAULT - default, described above.\nConsts.INDEX_ADD_FORCE - disregard the existing ignore rules and force addition of\nthe file to the index even if it is already ignored.\nConsts.INDEX_ADD_CHECK_PATHSPEC - cannot be used at the same time as INDEX_ADD_FORCE.\nCheck that each file in files which exists on disk is not in the ignore list. If one\nof the files is ignored, the function will return EINVALIDSPEC.\nConsts.INDEX_ADD_DISABLE_PATHSPEC_MATCH - turn off glob matching, and only add files\nto the index which exactly match the paths specified in files.\n\n\n\n\n\n"},{"title":"LibGit2.add_fetch!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.add_fetch!","category":"function","text":"add_fetch!(repo::GitRepo, rmt::GitRemote, fetch_spec::String)\n\nAdd a fetch refspec for the specified rmt. This refspec will contain\ninformation about which branch(es) to fetch from.\n\nExamples\n\njulia> LibGit2.add_fetch!(repo, remote, \"upstream\");\n\njulia> LibGit2.fetch_refspecs(remote)\nString[\"+refs/heads/*:refs/remotes/upstream/*\"]\n\n\n\n\n\n"},{"title":"LibGit2.add_push!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.add_push!","category":"function","text":"add_push!(repo::GitRepo, rmt::GitRemote, push_spec::String)\n\nAdd a push refspec for the specified rmt. This refspec will contain\ninformation about which branch(es) to push to.\n\nExamples\n\njulia> LibGit2.add_push!(repo, remote, \"refs/heads/master\");\n\njulia> remote = LibGit2.get(LibGit2.GitRemote, repo, branch);\n\njulia> LibGit2.push_refspecs(remote)\nString[\"refs/heads/master\"]\n\nnote: Note\nYou may need to close and reopen the GitRemote\nin question after updating its push refspecs in order for\nthe change to take effect and for calls to push\nto work.\n\n\n\n\n\n"},{"title":"LibGit2.addblob!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.addblob!","category":"function","text":"LibGit2.addblob!(repo::GitRepo, path::AbstractString)\n\nRead the file at path and adds it to the object database of repo as a loose blob.\nReturn the GitHash of the resulting blob.\n\nExamples\n\nhash_str = string(commit_oid)\nblob_file = joinpath(repo_path, \".git\", \"objects\", hash_str[1:2], hash_str[3:end])\nid = LibGit2.addblob!(repo, blob_file)\n\n\n\n\n\n"},{"title":"LibGit2.author","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.author","category":"function","text":"author(c::GitCommit)\n\nReturn the Signature of the author of the commit c. The author is\nthe person who made changes to the relevant file(s). See also committer.\n\n\n\n\n\n"},{"title":"LibGit2.authors","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.authors","category":"function","text":"authors(repo::GitRepo)::Vector{Signature}\n\nReturn all authors of commits to the repo repository.\n\nExamples\n\nrepo = LibGit2.GitRepo(repo_path)\nrepo_file = open(joinpath(repo_path, test_file), \"a\")\n\nprintln(repo_file, commit_msg)\nflush(repo_file)\nLibGit2.add!(repo, test_file)\nsig = LibGit2.Signature(\"TEST\", \"TEST@TEST.COM\", round(time(), 0), 0)\ncommit_oid1 = LibGit2.commit(repo, \"commit1\"; author=sig, committer=sig)\nprintln(repo_file, randstring(10))\nflush(repo_file)\nLibGit2.add!(repo, test_file)\ncommit_oid2 = LibGit2.commit(repo, \"commit2\"; author=sig, committer=sig)\n\n# will be a Vector of [sig, sig]\nauths = LibGit2.authors(repo)\n\n\n\n\n\n"},{"title":"LibGit2.branch","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.branch","category":"function","text":"branch(repo::GitRepo)\n\nEquivalent to git branch.\nCreate a new branch from the current HEAD.\n\n\n\n\n\n"},{"title":"LibGit2.branch!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.branch!","category":"function","text":"branch!(repo::GitRepo, branch_name::AbstractString, commit::AbstractString=\"\"; kwargs...)\n\nCheckout a new git branch in the repo repository. commit is the GitHash,\nin string form, which will be the start of the new branch.\nIf commit is an empty string, the current HEAD will be used.\n\nThe keyword arguments are:\n\ntrack::AbstractString=\"\": the name of the\nremote branch this new branch should track, if any.\nIf empty (the default), no remote branch\nwill be tracked.\nforce::Bool=false: if true, branch creation will\nbe forced.\nset_head::Bool=true: if true, after the branch creation\nfinishes the branch head will be set as the HEAD of repo.\n\nEquivalent to git checkout [-b|-B] <branch_name> [<commit>] [--track <track>].\n\nExamples\n\nrepo = LibGit2.GitRepo(repo_path)\nLibGit2.branch!(repo, \"new_branch\", set_head=false)\n\n\n\n\n\n"},{"title":"LibGit2.checkout!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.checkout!","category":"function","text":"checkout!(repo::GitRepo, commit::AbstractString=\"\"; force::Bool=true)\n\nEquivalent to git checkout [-f] --detach <commit>.\nCheckout the git commit commit (a GitHash in string form)\nin repo. If force is true, force the checkout and discard any\ncurrent changes. Note that this detaches the current HEAD.\n\nExamples\n\nrepo = LibGit2.GitRepo(repo_path)\nopen(joinpath(LibGit2.path(repo), \"file1\"), \"w\") do f\n    write(f, \"111\n\")\nend\nLibGit2.add!(repo, \"file1\")\ncommit_oid = LibGit2.commit(repo, \"add file1\")\nopen(joinpath(LibGit2.path(repo), \"file1\"), \"w\") do f\n    write(f, \"112\n\")\nend\n# would fail without the force=true\n# since there are modifications to the file\nLibGit2.checkout!(repo, string(commit_oid), force=true)\n\n\n\n\n\n"},{"title":"LibGit2.clone","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.clone","category":"function","text":"clone(repo_url::AbstractString, repo_path::AbstractString, clone_opts::CloneOptions)\n\nClone the remote repository at repo_url (which can be a remote URL or a path on the local\nfilesystem) to repo_path (which must be a path on the local filesystem). Options for the\nclone, such as whether to perform a bare clone or not, are set by CloneOptions.\n\nExamples\n\nrepo_url = \"https://github.com/JuliaLang/Example.jl\"\nrepo = LibGit2.clone(repo_url, \"/home/me/projects/Example\")\n\n\n\n\n\nclone(repo_url::AbstractString, repo_path::AbstractString; kwargs...)\n\nClone a remote repository located at repo_url to the local filesystem location repo_path.\n\nThe keyword arguments are:\n\nbranch::AbstractString=\"\": which branch of the remote to clone,\nif not the default repository branch (usually master).\nisbare::Bool=false: if true, clone the remote as a bare repository,\nwhich will make repo_path itself the git directory instead of repo_path/.git.\nThis means that a working tree cannot be checked out. Plays the role of the\ngit CLI argument --bare.\nremote_cb::Ptr{Cvoid}=C_NULL: a callback which will be used to create the remote\nbefore it is cloned. If C_NULL (the default), no attempt will be made to create\nthe remote - it will be assumed to already exist.\ndepth::Integer=0: create a shallow clone with a history truncated to the\nspecified number of commits. 0 indicates a full clone (the default).\nUse Consts.FETCH_DEPTH_UNSHALLOW to fetch all missing data from a shallow clone.\nNote: shallow clones are, at the time of writing, only supported for network protocols (http, https, git, ssh), not for local filesystem paths.\n(https://github.com/libgit2/libgit2/issues/6634)\ncredentials::Creds=nothing: provides credentials and/or settings when authenticating\nagainst a private repository.\ncallbacks::Callbacks=Callbacks(): user provided callbacks and payloads.\n\nEquivalent to git clone [-b <branch>] [--bare] [--depth <depth>] <repo_url> <repo_path>.\n\nExamples\n\nrepo_url = \"https://github.com/JuliaLang/Example.jl\"\nrepo1 = LibGit2.clone(repo_url, \"test_path\")\nrepo2 = LibGit2.clone(repo_url, \"test_path\", isbare=true)\njulia_url = \"https://github.com/JuliaLang/julia\"\njulia_repo = LibGit2.clone(julia_url, \"julia_path\", branch=\"release-0.6\")\n# Shallow clone with only the most recent commit\nshallow_repo = LibGit2.clone(repo_url, \"shallow_path\", depth=1)\n\n\n\n\n\n"},{"title":"LibGit2.commit","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.commit","category":"function","text":"commit(repo::GitRepo, msg::AbstractString; kwargs...)::GitHash\n\nWrapper around git_commit_create.\nCreate a commit in the repository repo. msg is the commit message. Return the OID of the new commit.\n\nThe keyword arguments are:\n\nrefname::AbstractString=Consts.HEAD_FILE: if not NULL, the name of the reference to update to point to\nthe new commit. For example, \"HEAD\" will update the HEAD of the current branch. If the reference does\nnot yet exist, it will be created.\nauthor::Signature = Signature(repo) is a Signature containing information about the person who authored the commit.\ncommitter::Signature = Signature(repo) is a Signature containing information about the person who committed the commit to\nthe repository. Not necessarily the same as author, for instance if author emailed a patch to\ncommitter who committed it.\ntree_id::GitHash = GitHash() is a git tree to use to create the commit, showing its ancestry and relationship with\nany other history. tree must belong to repo.\nparent_ids::Vector{GitHash}=GitHash[] is a list of commits by GitHash to use as parent\ncommits for the new one, and may be empty. A commit might have multiple parents if it is a merge commit, for example.\n\n\n\n\n\nLibGit2.commit(rb::GitRebase, sig::GitSignature)\n\nCommit the current patch to the rebase rb, using sig as the committer. Is silent if\nthe commit has already been applied.\n\n\n\n\n\n"},{"title":"LibGit2.committer","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.committer","category":"function","text":"committer(c::GitCommit)\n\nReturn the Signature of the committer of the commit c. The committer is\nthe person who committed the changes originally authored by the author, but\nneed not be the same as the author, for example, if the author emailed a patch to\na committer who committed it.\n\n\n\n\n\n"},{"title":"LibGit2.count","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.count","category":"function","text":"LibGit2.count(f::Function, walker::GitRevWalker; oid::GitHash=GitHash(), by::Cint=Consts.SORT_NONE, rev::Bool=false)\n\nUsing the GitRevWalker walker to \"walk\" over every commit in the repository's history,\nfind the number of commits which return true when f is applied to them. The keyword arguments\nare:\n    * oid: The GitHash of the commit to begin the walk from. The default is to use\n      push_head! and therefore the HEAD commit and all its ancestors.\n    * by: The sorting method. The default is not to sort. Other options are to sort by\n      topology (LibGit2.Consts.SORT_TOPOLOGICAL), to sort forwards in time\n      (LibGit2.Consts.SORT_TIME, most ancient first) or to sort backwards in time\n      (LibGit2.Consts.SORT_REVERSE, most recent first).\n    * rev: Whether to reverse the sorted order (for instance, if topological sorting is used).\n\nExamples\n\ncnt = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker\n    LibGit2.count((oid, repo)->(oid == commit_oid1), walker, oid=commit_oid1, by=LibGit2.Consts.SORT_TIME)\nend\n\nLibGit2.count finds the number of commits along the walk with a certain GitHash commit_oid1, starting\nthe walk from that commit and moving forwards in time from it. Since the GitHash is unique to\na commit, cnt will be 1.\n\n\n\n\n\n"},{"title":"LibGit2.counthunks","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.counthunks","category":"function","text":"counthunks(blame::GitBlame)\n\nReturn the number of distinct \"hunks\" with a file. A hunk may contain multiple lines.\nA hunk is usually a piece of a file that was added/changed/removed together, for example,\na function added to a source file or an inner loop that was optimized out of\nthat function later.\n\n\n\n\n\n"},{"title":"LibGit2.create_branch","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.create_branch","category":"function","text":"LibGit2.create_branch(repo::GitRepo, bname::AbstractString, commit_obj::GitCommit; force::Bool=false)\n\nCreate a new branch in the repository repo with name bname, which\npoints to commit commit_obj (which has to be part of repo). If\nforce is true, overwrite an existing branch named bname if it\nexists. If force is false and a branch already exists named bname,\nthis function will throw an error.\n\n\n\n\n\n"},{"title":"LibGit2.credentials_callback","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.credentials_callback","category":"function","text":"credential_callback(...)::Cint\n\nA LibGit2 credential callback function which provides different credential acquisition\nfunctionality w.r.t. a connection protocol. The payload_ptr is required to contain a\nLibGit2.CredentialPayload object which will keep track of state and settings.\n\nThe allowed_types contains a bitmask of LibGit2.Consts.GIT_CREDTYPE values specifying\nwhich authentication methods should be attempted.\n\nCredential authentication is done in the following order (if supported):\n\nSSH agent\nSSH private/public key pair\nUsername/password plain text\n\nIf a user is presented with a credential prompt they can abort the prompt by typing ^D\n(pressing the control key together with the d key).\n\nNote: Due to the specifics of the libgit2 authentication procedure, when\nauthentication fails, this function is called again without any indication whether\nauthentication was successful or not. To avoid an infinite loop from repeatedly\nusing the same faulty credentials, we will keep track of state using the payload.\n\nFor addition details see the LibGit2 guide on\nauthenticating against a server.\n\n\n\n\n\n"},{"title":"LibGit2.credentials_cb","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.credentials_cb","category":"function","text":"C function pointer for credentials_callback\n\n\n\n\n\n"},{"title":"LibGit2.default_signature","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.default_signature","category":"function","text":"Return signature object. Free it after use.\n\n\n\n\n\n"},{"title":"LibGit2.delete_branch","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.delete_branch","category":"function","text":"LibGit2.delete_branch(branch::GitReference)\n\nDelete the branch pointed to by branch.\n\n\n\n\n\n"},{"title":"LibGit2.diff_files","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.diff_files","category":"function","text":"diff_files(repo::GitRepo, branch1::AbstractString, branch2::AbstractString; kwarg...)::Vector{AbstractString}\n\nShow which files have changed in the git repository repo between branches branch1\nand branch2.\n\nThe keyword argument is:\n\nfilter::Set{Consts.DELTA_STATUS}=Set([Consts.DELTA_ADDED, Consts.DELTA_MODIFIED, Consts.DELTA_DELETED])),\nand it sets options for the diff. The default is to show files added, modified, or deleted.\n\nReturn only the names of the files which have changed, not their contents.\n\nExamples\n\nLibGit2.branch!(repo, \"branch/a\")\nLibGit2.branch!(repo, \"branch/b\")\n# add a file to repo\nopen(joinpath(LibGit2.path(repo),\"file\"),\"w\") do f\n    write(f, \"hello repo\n\")\nend\nLibGit2.add!(repo, \"file\")\nLibGit2.commit(repo, \"add file\")\n# returns [\"file\"]\nfilt = Set([LibGit2.Consts.DELTA_ADDED])\nfiles = LibGit2.diff_files(repo, \"branch/a\", \"branch/b\", filter=filt)\n# returns [] because existing files weren't modified\nfilt = Set([LibGit2.Consts.DELTA_MODIFIED])\nfiles = LibGit2.diff_files(repo, \"branch/a\", \"branch/b\", filter=filt)\n\nEquivalent to git diff --name-only --diff-filter=<filter> <branch1> <branch2>.\n\n\n\n\n\n"},{"title":"LibGit2.entryid","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.entryid","category":"function","text":"entryid(te::GitTreeEntry)\n\nReturn the GitHash of the object to which te refers.\n\n\n\n\n\n"},{"title":"LibGit2.entrytype","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.entrytype","category":"function","text":"entrytype(te::GitTreeEntry)\n\nReturn the type of the object to which te refers. The result will be\none of the types which objtype returns, e.g. a GitTree or GitBlob.\n\n\n\n\n\n"},{"title":"LibGit2.fetch","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.fetch","category":"function","text":"fetch(rmt::GitRemote, refspecs; options::FetchOptions=FetchOptions(), msg=\"\")\n\nFetch from the specified rmt remote git repository, using refspecs to\ndetermine which remote branch(es) to fetch.\nThe keyword arguments are:\n\noptions: determines the options for the fetch, e.g. whether to prune afterwards.\nSee FetchOptions for more information.\nmsg: a message to insert into the reflogs.\n\n\n\n\n\nfetch(repo::GitRepo; kwargs...)\n\nFetches updates from an upstream of the repository repo.\n\nThe keyword arguments are:\n\nremote::AbstractString=\"origin\": which remote, specified by name,\nof repo to fetch from. If this is empty, the URL will be used to\nconstruct an anonymous remote.\nremoteurl::AbstractString=\"\": the URL of remote. If not specified,\nwill be assumed based on the given name of remote.\nrefspecs=AbstractString[]: determines properties of the fetch.\ndepth::Integer=0: limit fetching to the specified number of commits from the tip\nof each remote branch. 0 indicates a full fetch (the default).\nUse Consts.FETCH_DEPTH_UNSHALLOW to fetch all missing data from a shallow clone.\nNote: depth is, at the time of writing, only supported for network protocols (http, https, git, ssh), not for local filesystem paths.\n(https://github.com/libgit2/libgit2/issues/6634)\ncredentials=nothing: provides credentials and/or settings when authenticating against\na private remote.\ncallbacks=Callbacks(): user provided callbacks and payloads.\n\nEquivalent to git fetch [--depth <depth>] [<remoteurl>|<repo>] [<refspecs>].\n\n\n\n\n\n"},{"title":"LibGit2.fetchheads","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.fetchheads","category":"function","text":"fetchheads(repo::GitRepo)::Vector{FetchHead}\n\nReturn the list of all the fetch heads for repo, each represented as a FetchHead,\nincluding their names, URLs, and merge statuses.\n\nExamples\n\njulia> fetch_heads = LibGit2.fetchheads(repo);\n\njulia> fetch_heads[1].name\n\"refs/heads/master\"\n\njulia> fetch_heads[1].ismerge\ntrue\n\njulia> fetch_heads[2].name\n\"refs/heads/test_branch\"\n\njulia> fetch_heads[2].ismerge\nfalse\n\n\n\n\n\n"},{"title":"LibGit2.fetch_refspecs","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.fetch_refspecs","category":"function","text":"fetch_refspecs(rmt::GitRemote)::Vector{String}\n\nGet the fetch refspecs for the specified rmt. These refspecs contain\ninformation about which branch(es) to fetch from.\n\nExamples\n\njulia> remote = LibGit2.get(LibGit2.GitRemote, repo, \"upstream\");\n\njulia> LibGit2.add_fetch!(repo, remote, \"upstream\");\n\njulia> LibGit2.fetch_refspecs(remote)\nString[\"+refs/heads/*:refs/remotes/upstream/*\"]\n\n\n\n\n\n"},{"title":"LibGit2.fetchhead_foreach_cb","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.fetchhead_foreach_cb","category":"function","text":"C function pointer for fetchhead_foreach_callback\n\n\n\n\n\n"},{"title":"LibGit2.merge_base","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.merge_base","category":"function","text":"merge_base(repo::GitRepo, one::AbstractString, two::AbstractString)::GitHash\n\nFind a merge base (a common ancestor) between the commits one and two.\none and two may both be in string form. Return the GitHash of the merge base.\n\n\n\n\n\n"},{"title":"LibGit2.merge!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.merge!-Tuple{GitRepo}","category":"method","text":"merge!(repo::GitRepo; kwargs...)::Bool\n\nPerform a git merge on the repository repo, merging commits\nwith diverging history into the current branch. Return true\nif the merge succeeded, false if not.\n\nThe keyword arguments are:\n\ncommittish::AbstractString=\"\": Merge the named commit(s) in committish.\nbranch::AbstractString=\"\": Merge the branch branch and all its commits\nsince it diverged from the current branch.\nfastforward::Bool=false: If fastforward is true, only merge if the\nmerge is a fast-forward (the current branch head is an ancestor of the\ncommits to be merged), otherwise refuse to merge and return false.\nThis is equivalent to the git CLI option --ff-only.\nmerge_opts::MergeOptions=MergeOptions(): merge_opts specifies options\nfor the merge, such as merge strategy in case of conflicts.\ncheckout_opts::CheckoutOptions=CheckoutOptions(): checkout_opts specifies\noptions for the checkout step.\n\nEquivalent to git merge [--ff-only] [<committish> | <branch>].\n\nnote: Note\nIf you specify a branch, this must be done in reference format, since\nthe string will be turned into a GitReference. For example, if you\nwanted to merge branch branch_a, you would call\nmerge!(repo, branch=\"refs/heads/branch_a\").\n\n\n\n\n\n"},{"title":"LibGit2.merge!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.merge!-Tuple{GitRepo, Vector{LibGit2.GitAnnotated}}","category":"method","text":"merge!(repo::GitRepo, anns::Vector{GitAnnotated}; kwargs...)::Bool\n\nMerge changes from the annotated commits (captured as GitAnnotated objects)\nanns into the HEAD of the repository repo. The keyword arguments are:\n\nmerge_opts::MergeOptions = MergeOptions(): options for how to perform the merge,\nincluding whether fastforwarding is allowed. See MergeOptions for more\ninformation.\ncheckout_opts::CheckoutOptions = CheckoutOptions(): options for how to perform\nthe checkout. See CheckoutOptions for more information.\n\nanns may refer to remote or local branch heads. Return true if the merge is\nsuccessful, otherwise return false (for instance, if no merge is possible\nbecause the branches have no common ancestor).\n\nExamples\n\nupst_ann = LibGit2.GitAnnotated(repo, \"branch/a\")\n\n# merge the branch in\nLibGit2.merge!(repo, [upst_ann])\n\n\n\n\n\n"},{"title":"LibGit2.merge!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.merge!-Tuple{GitRepo, Vector{LibGit2.GitAnnotated}, Bool}","category":"method","text":"merge!(repo::GitRepo, anns::Vector{GitAnnotated}, fastforward::Bool; kwargs...)::Bool\n\nMerge changes from the annotated commits (captured as GitAnnotated objects)\nanns into the HEAD of the repository repo. If fastforward is true, only a\nfastforward merge is allowed. In this case, if conflicts occur, the merge will fail.\nOtherwise, if fastforward is false, the merge may produce a conflict file which\nthe user will need to resolve.\n\nThe keyword arguments are:\n\nmerge_opts::MergeOptions = MergeOptions(): options for how to perform the merge,\nincluding whether fastforwarding is allowed. See MergeOptions for more\ninformation.\ncheckout_opts::CheckoutOptions = CheckoutOptions(): options for how to perform\nthe checkout. See CheckoutOptions for more information.\n\nanns may refer to remote or local branch heads. Return true if the merge is\nsuccessful, otherwise return false (for instance, if no merge is possible\nbecause the branches have no common ancestor).\n\nExamples\n\nupst_ann_1 = LibGit2.GitAnnotated(repo, \"branch/a\")\n\n# merge the branch in, fastforward\nLibGit2.merge!(repo, [upst_ann_1], true)\n\n# merge conflicts!\nupst_ann_2 = LibGit2.GitAnnotated(repo, \"branch/b\")\n# merge the branch in, try to fastforward\nLibGit2.merge!(repo, [upst_ann_2], true) # will return false\nLibGit2.merge!(repo, [upst_ann_2], false) # will return true\n\n\n\n\n\n"},{"title":"LibGit2.ffmerge!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.ffmerge!","category":"function","text":"ffmerge!(repo::GitRepo, ann::GitAnnotated)\n\nFastforward merge changes into current HEAD. This is only possible if the commit\nreferred to by ann is descended from the current HEAD (e.g. if pulling changes\nfrom a remote branch which is simply ahead of the local branch tip).\n\n\n\n\n\n"},{"title":"LibGit2.fullname","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.fullname","category":"function","text":"LibGit2.fullname(ref::GitReference)\n\nReturn the name of the reference pointed to by the\nsymbolic reference ref. If ref is not a symbolic\nreference, return an empty string.\n\n\n\n\n\n"},{"title":"LibGit2.features","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.features","category":"function","text":"features()\n\nReturn a list of git features the current version of libgit2 supports, such as\nthreading or using HTTPS or SSH.\n\n\n\n\n\n"},{"title":"LibGit2.filename","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.filename","category":"function","text":"filename(te::GitTreeEntry)\n\nReturn the filename of the object on disk to which te refers.\n\n\n\n\n\n"},{"title":"LibGit2.filemode","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.filemode","category":"function","text":"filemode(te::GitTreeEntry)::Cint\n\nReturn the UNIX filemode of the object on disk to which te refers as an integer.\n\n\n\n\n\n"},{"title":"LibGit2.gitdir","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.gitdir","category":"function","text":"LibGit2.gitdir(repo::GitRepo)\n\nReturn the location of the \"git\" files of repo:\n\nfor normal repositories, this is the location of the .git folder.\nfor bare repositories, this is the location of the repository itself.\n\nSee also workdir, path.\n\n\n\n\n\n"},{"title":"LibGit2.git_url","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.git_url","category":"function","text":"LibGit2.git_url(; kwargs...)::String\n\nCreate a string based upon the URL components provided. When the scheme keyword is not\nprovided the URL produced will use the alternative scp-like syntax.\n\nKeywords\n\nscheme::AbstractString=\"\": the URL scheme which identifies the protocol to be used.\nFor HTTP use \"http\", SSH use \"ssh\", etc. When scheme is not provided the output format\nwill be \"ssh\" but using the scp-like syntax.\nusername::AbstractString=\"\": the username to use in the output if provided.\npassword::AbstractString=\"\": the password to use in the output if provided.\nhost::AbstractString=\"\": the hostname to use in the output. A hostname is required to\nbe specified.\nport::Union{AbstractString,Integer}=\"\": the port number to use in the output if\nprovided. Cannot be specified when using the scp-like syntax.\npath::AbstractString=\"\": the path to use in the output if provided.\n\nwarning: Warning\nAvoid using passwords in URLs. Unlike the credential objects, Julia is not able\nto securely zero or destroy the sensitive data after use and the password may\nremain in memory; possibly to be exposed by an uninitialized memory.\n\nExamples\n\njulia> LibGit2.git_url(username=\"git\", host=\"github.com\", path=\"JuliaLang/julia.git\")\n\"git@github.com:JuliaLang/julia.git\"\n\njulia> LibGit2.git_url(scheme=\"https\", host=\"github.com\", path=\"/JuliaLang/julia.git\")\n\"https://github.com/JuliaLang/julia.git\"\n\njulia> LibGit2.git_url(scheme=\"ssh\", username=\"git\", host=\"github.com\", port=2222, path=\"JuliaLang/julia.git\")\n\"ssh://git@github.com:2222/JuliaLang/julia.git\"\n\n\n\n\n\n"},{"title":"LibGit2.@githash_str","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.@githash_str","category":"macro","text":"@githash_str -> AbstractGitHash\n\nConstruct a git hash object from the given string, returning a GitShortHash if\nthe string is shorter than 40 hexadecimal digits, otherwise a GitHash.\n\nExamples\n\njulia> LibGit2.githash\"d114feb74ce633\"\nGitShortHash(\"d114feb74ce633\")\n\njulia> LibGit2.githash\"d114feb74ce63307afe878a5228ad014e0289a85\"\nGitHash(\"d114feb74ce63307afe878a5228ad014e0289a85\")\n\n\n\n\n\n"},{"title":"LibGit2.head","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.head","category":"function","text":"LibGit2.head(repo::GitRepo)::GitReference\n\nReturn a GitReference to the current HEAD of repo.\n\n\n\n\n\nhead(pkg::AbstractString)::String\n\nReturn current HEAD GitHash of\nthe pkg repo as a string.\n\n\n\n\n\n"},{"title":"LibGit2.head!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.head!","category":"function","text":"LibGit2.head!(repo::GitRepo, ref::GitReference)::GitReference\n\nSet the HEAD of repo to the object pointed to by ref.\n\n\n\n\n\n"},{"title":"LibGit2.head_oid","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.head_oid","category":"function","text":"LibGit2.head_oid(repo::GitRepo)::GitHash\n\nLookup the object id of the current HEAD of git\nrepository repo.\n\n\n\n\n\n"},{"title":"LibGit2.headname","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.headname","category":"function","text":"LibGit2.headname(repo::GitRepo)\n\nLookup the name of the current HEAD of git\nrepository repo. If repo is currently\ndetached, return the name of the HEAD it's\ndetached from.\n\n\n\n\n\n"},{"title":"LibGit2.init","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.init","category":"function","text":"LibGit2.init(path::AbstractString, bare::Bool=false)::GitRepo\n\nOpen a new git repository at path. If bare is false,\nthe working tree will be created in path/.git. If bare\nis true, no working directory will be created.\n\n\n\n\n\n"},{"title":"LibGit2.is_ancestor_of","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.is_ancestor_of","category":"function","text":"is_ancestor_of(a::AbstractString, b::AbstractString, repo::GitRepo)::Bool\n\nReturn true if a, a GitHash in string form, is an ancestor of\nb, a GitHash in string form.\n\nExamples\n\njulia> repo = GitRepo(repo_path);\n\njulia> LibGit2.add!(repo, test_file1);\n\njulia> commit_oid1 = LibGit2.commit(repo, \"commit1\");\n\njulia> LibGit2.add!(repo, test_file2);\n\njulia> commit_oid2 = LibGit2.commit(repo, \"commit2\");\n\njulia> LibGit2.is_ancestor_of(string(commit_oid1), string(commit_oid2), repo)\ntrue\n\n\n\n\n\n"},{"title":"LibGit2.isbinary","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.isbinary","category":"function","text":"isbinary(blob::GitBlob)::Bool\n\nUse a heuristic to guess if a file is binary: searching for NULL bytes and\nlooking for a reasonable ratio of printable to non-printable characters among\nthe first 8000 bytes.\n\n\n\n\n\n"},{"title":"LibGit2.iscommit","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.iscommit","category":"function","text":"iscommit(id::AbstractString, repo::GitRepo)::Bool\n\nCheck if commit id (which is a GitHash in string form)\nis in the repository.\n\nExamples\n\njulia> repo = GitRepo(repo_path);\n\njulia> LibGit2.add!(repo, test_file);\n\njulia> commit_oid = LibGit2.commit(repo, \"add test_file\");\n\njulia> LibGit2.iscommit(string(commit_oid), repo)\ntrue\n\n\n\n\n\n"},{"title":"LibGit2.isdiff","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.isdiff","category":"function","text":"LibGit2.isdiff(repo::GitRepo, treeish::AbstractString, pathspecs::AbstractString=\"\"; cached::Bool=false)\n\nChecks if there are any differences between the tree specified by treeish and the\ntracked files in the working tree (if cached=false) or the index (if cached=true).\npathspecs are the specifications for options for the diff.\n\nExamples\n\nrepo = LibGit2.GitRepo(repo_path)\nLibGit2.isdiff(repo, \"HEAD\") # should be false\nopen(joinpath(repo_path, new_file), \"a\") do f\n    println(f, \"here's my cool new file\")\nend\nLibGit2.isdiff(repo, \"HEAD\") # now true\n\nEquivalent to git diff-index <treeish> [-- <pathspecs>].\n\n\n\n\n\n"},{"title":"LibGit2.isdirty","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.isdirty","category":"function","text":"LibGit2.isdirty(repo::GitRepo, pathspecs::AbstractString=\"\"; cached::Bool=false)::Bool\n\nCheck if there have been any changes to tracked files in the working tree (if\ncached=false) or the index (if cached=true).\npathspecs are the specifications for options for the diff.\n\nExamples\n\nrepo = LibGit2.GitRepo(repo_path)\nLibGit2.isdirty(repo) # should be false\nopen(joinpath(repo_path, new_file), \"a\") do f\n    println(f, \"here's my cool new file\")\nend\nLibGit2.isdirty(repo) # now true\nLibGit2.isdirty(repo, new_file) # now true\n\nEquivalent to git diff-index HEAD [-- <pathspecs>].\n\n\n\n\n\n"},{"title":"LibGit2.isorphan","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.isorphan","category":"function","text":"LibGit2.isorphan(repo::GitRepo)\n\nCheck if the current branch is an \"orphan\" branch, i.e. has no commits. The first commit\nto this branch will have no parents.\n\n\n\n\n\n"},{"title":"LibGit2.isset","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.isset","category":"function","text":"isset(val::Integer, flag::Integer)\n\nTest whether the bits of val indexed by flag are set (1) or unset (0).\n\n\n\n\n\n"},{"title":"LibGit2.iszero","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.iszero","category":"function","text":"iszero(id::GitHash)::Bool\n\nDetermine whether all hexadecimal digits of the given GitHash are zero.\n\n\n\n\n\n"},{"title":"LibGit2.lookup_branch","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.lookup_branch","category":"function","text":"lookup_branch(repo::GitRepo, branch_name::AbstractString, remote::Bool=false)::Union{GitReference, Nothing}\n\nDetermine if the branch specified by branch_name exists in the repository repo.\nIf remote is true, repo is assumed to be a remote git repository. Otherwise, it\nis part of the local filesystem.\n\nReturn either a GitReference to the requested branch\nif it exists, or nothing if not.\n\n\n\n\n\n"},{"title":"LibGit2.map","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.map","category":"function","text":"LibGit2.map(f::Function, walker::GitRevWalker; oid::GitHash=GitHash(), range::AbstractString=\"\", by::Cint=Consts.SORT_NONE, rev::Bool=false)\n\nUsing the GitRevWalker walker to \"walk\" over every commit in the repository's history,\napply f to each commit in the walk. The keyword arguments are:\n    * oid: The GitHash of the commit to begin the walk from. The default is to use\n      push_head! and therefore the HEAD commit and all its ancestors.\n    * range: A range of GitHashs in the format oid1..oid2. f will be\n      applied to all commits between the two.\n    * by: The sorting method. The default is not to sort. Other options are to sort by\n      topology (LibGit2.Consts.SORT_TOPOLOGICAL), to sort forwards in time\n      (LibGit2.Consts.SORT_TIME, most ancient first) or to sort backwards in time\n      (LibGit2.Consts.SORT_REVERSE, most recent first).\n    * rev: Whether to reverse the sorted order (for instance, if topological sorting is used).\n\nExamples\n\noids = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker\n    LibGit2.map((oid, repo)->string(oid), walker, by=LibGit2.Consts.SORT_TIME)\nend\n\nHere, LibGit2.map visits each commit using the GitRevWalker and finds its GitHash.\n\n\n\n\n\n"},{"title":"LibGit2.mirror_callback","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.mirror_callback","category":"function","text":"Mirror callback function\n\nFunction sets +refs/*:refs/* refspecs and mirror flag for remote reference.\n\n\n\n\n\n"},{"title":"LibGit2.mirror_cb","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.mirror_cb","category":"function","text":"C function pointer for mirror_callback\n\n\n\n\n\n"},{"title":"LibGit2.message","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.message","category":"function","text":"message(c::GitCommit, raw::Bool=false)\n\nReturn the commit message describing the changes made in commit c. If\nraw is false, return a slightly \"cleaned up\" message (which has any\nleading newlines removed). If raw is true, the message is not stripped\nof any such newlines.\n\n\n\n\n\n"},{"title":"LibGit2.merge_analysis","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.merge_analysis","category":"function","text":"merge_analysis(repo::GitRepo, anns::Vector{GitAnnotated}) -> analysis, preference\n\nRun analysis on the branches pointed to by the annotated branch tips anns and\ndetermine under what circumstances they can be merged. For instance, if anns[1]\nis simply an ancestor of ann[2], then merge_analysis will report that a\nfast-forward merge is possible.\n\nReturn two outputs, analysis and preference. analysis has several possible values:\n    * MERGE_ANALYSIS_NONE: it is not possible to merge the elements of anns.\n    * MERGE_ANALYSIS_NORMAL: a regular merge, when HEAD and the commits that the\n      user wishes to merge have all diverged from a common ancestor. In this case the\n      changes have to be resolved and conflicts may occur.\n    * MERGE_ANALYSIS_UP_TO_DATE: all the input commits the user wishes to merge can\n      be reached from HEAD, so no merge needs to be performed.\n    * MERGE_ANALYSIS_FASTFORWARD: the input commit is a descendant of HEAD and so no\n      merge needs to be performed - instead, the user can simply checkout the\n      input commit(s).\n    * MERGE_ANALYSIS_UNBORN: the HEAD of the repository refers to a commit which does not\n      exist. It is not possible to merge, but it may be possible to checkout the input\n      commits.\npreference also has several possible values:\n    * MERGE_PREFERENCE_NONE: the user has no preference.\n    * MERGE_PREFERENCE_NO_FASTFORWARD: do not allow any fast-forward merges.\n    * MERGE_PREFERENCE_FASTFORWARD_ONLY: allow only fast-forward merges and no\n      other type (which may introduce conflicts).\npreference can be controlled through the repository or global git configuration.\n\n\n\n\n\n"},{"title":"LibGit2.name","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.name","category":"function","text":"LibGit2.name(ref::GitReference)\n\nReturn the full name of ref.\n\n\n\n\n\nname(rmt::GitRemote)\n\nGet the name of a remote repository, for instance \"origin\".\nIf the remote is anonymous (see GitRemoteAnon)\nthe name will be an empty string \"\".\n\nExamples\n\njulia> repo_url = \"https://github.com/JuliaLang/Example.jl\";\n\njulia> repo = LibGit2.clone(cache_repo, \"test_directory\");\n\njulia> remote = LibGit2.GitRemote(repo, \"origin\", repo_url);\n\njulia> name(remote)\n\"origin\"\n\n\n\n\n\nLibGit2.name(tag::GitTag)\n\nThe name of tag (e.g. \"v0.5\").\n\n\n\n\n\n"},{"title":"LibGit2.need_update","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.need_update","category":"function","text":"need_update(repo::GitRepo)\n\nEquivalent to git update-index. Return true\nif repo needs updating.\n\n\n\n\n\n"},{"title":"LibGit2.objtype","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.objtype","category":"function","text":"objtype(obj_type::Consts.OBJECT)\n\nReturn the type corresponding to the enum value.\n\n\n\n\n\n"},{"title":"LibGit2.path","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.path","category":"function","text":"LibGit2.path(repo::GitRepo)\n\nReturn the base file path of the repository repo.\n\nfor normal repositories, this will typically be the parent directory of the \".git\"\ndirectory (note: this may be different than the working directory, see workdir for\nmore details).\nfor bare repositories, this is the location of the \"git\" files.\n\nSee also gitdir, workdir.\n\n\n\n\n\n"},{"title":"LibGit2.peel","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.peel","category":"function","text":"peel([T,] ref::GitReference)\n\nRecursively peel ref until an object of type T is obtained. If no T is provided,\nthen ref will be peeled until an object other than a GitTag is obtained.\n\nA GitTag will be peeled to the object it references.\nA GitCommit will be peeled to a GitTree.\n\nnote: Note\nOnly annotated tags can be peeled to GitTag objects. Lightweight tags (the default)\nare references under refs/tags/ which point directly to GitCommit objects.\n\n\n\n\n\npeel([T,] obj::GitObject)\n\nRecursively peel obj until an object of type T is obtained. If no T is provided,\nthen obj will be peeled until the type changes.\n\nA GitTag will be peeled to the object it references.\nA GitCommit will be peeled to a GitTree.\n\n\n\n\n\n"},{"title":"LibGit2.posixpath","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.posixpath","category":"function","text":"LibGit2.posixpath(path)\n\nStandardise the path string path to use POSIX separators.\n\n\n\n\n\n"},{"title":"LibGit2.push","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.push","category":"function","text":"push(rmt::GitRemote, refspecs; force::Bool=false, options::PushOptions=PushOptions())\n\nPush to the specified rmt remote git repository, using refspecs to\ndetermine which remote branch(es) to push to.\nThe keyword arguments are:\n\nforce: if true, a force-push will occur, disregarding conflicts.\noptions: determines the options for the push, e.g. which proxy headers to use.\nSee PushOptions for more information.\n\nnote: Note\nYou can add information about the push refspecs in two other ways: by setting\nan option in the repository's GitConfig (with push.default as the key) or\nby calling add_push!. Otherwise you will need to explicitly specify\na push refspec in the call to push for it to have any effect, like so:\nLibGit2.push(repo, refspecs=[\"refs/heads/master\"]).\n\n\n\n\n\npush(repo::GitRepo; kwargs...)\n\nPushes updates to an upstream of repo.\n\nThe keyword arguments are:\n\nremote::AbstractString=\"origin\": the name of the upstream remote to push to.\nremoteurl::AbstractString=\"\": the URL of remote.\nrefspecs=AbstractString[]: determines properties of the push.\nforce::Bool=false: determines if the push will be a force push,\n overwriting the remote branch.\ncredentials=nothing: provides credentials and/or settings when authenticating against\n a private remote.\ncallbacks=Callbacks(): user provided callbacks and payloads.\n\nEquivalent to git push [<remoteurl>|<repo>] [<refspecs>].\n\n\n\n\n\n"},{"title":"LibGit2.push!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.push!-Tuple{LibGit2.GitRevWalker, LibGit2.GitHash}","category":"method","text":"LibGit2.push!(w::GitRevWalker, cid::GitHash)\n\nStart the GitRevWalker walker at commit cid. This function can be used\nto apply a function to all commits since a certain year, by passing the first commit\nof that year as cid and then passing the resulting w to LibGit2.map.\n\n\n\n\n\n"},{"title":"LibGit2.push_head!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.push_head!","category":"function","text":"LibGit2.push_head!(w::GitRevWalker)\n\nPush the HEAD commit and its ancestors onto the GitRevWalker\nw. This ensures that HEAD and all its ancestor commits will be encountered\nduring the walk.\n\n\n\n\n\n"},{"title":"LibGit2.push_refspecs","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.push_refspecs","category":"function","text":"push_refspecs(rmt::GitRemote)::Vector{String}\n\nGet the push refspecs for the specified rmt. These refspecs contain\ninformation about which branch(es) to push to.\n\nExamples\n\njulia> remote = LibGit2.get(LibGit2.GitRemote, repo, \"upstream\");\n\njulia> LibGit2.add_push!(repo, remote, \"refs/heads/master\");\n\njulia> close(remote);\n\njulia> remote = LibGit2.get(LibGit2.GitRemote, repo, \"upstream\");\n\njulia> LibGit2.push_refspecs(remote)\nString[\"refs/heads/master\"]\n\n\n\n\n\n"},{"title":"LibGit2.raw","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.raw","category":"function","text":"raw(id::GitHash)::Vector{UInt8}\n\nObtain the raw bytes of the GitHash as a vector of length 20.\n\n\n\n\n\n"},{"title":"LibGit2.read_tree!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.read_tree!","category":"function","text":"LibGit2.read_tree!(idx::GitIndex, tree::GitTree)\nLibGit2.read_tree!(idx::GitIndex, treehash::AbstractGitHash)\n\nRead the tree tree (or the tree pointed to by treehash in the repository owned by\nidx) into the index idx. The current index contents will be replaced.\n\n\n\n\n\n"},{"title":"LibGit2.rebase!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.rebase!","category":"function","text":"LibGit2.rebase!(repo::GitRepo, upstream::AbstractString=\"\", newbase::AbstractString=\"\")\n\nAttempt an automatic merge rebase of the current branch, from upstream if provided, or\notherwise from the upstream tracking branch.\nnewbase is the branch to rebase onto. By default this is upstream.\n\nIf any conflicts arise which cannot be automatically resolved, the rebase will abort,\nleaving the repository and working tree in its original state, and the function will throw\na GitError. This is roughly equivalent to the following command line statement:\n\ngit rebase --merge [<upstream>]\nif [ -d \".git/rebase-merge\" ]; then\n    git rebase --abort\nfi\n\n\n\n\n\n"},{"title":"LibGit2.ref_list","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.ref_list","category":"function","text":"LibGit2.ref_list(repo::GitRepo)::Vector{String}\n\nGet a list of all reference names in the repo repository.\n\n\n\n\n\n"},{"title":"LibGit2.reftype","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.reftype","category":"function","text":"LibGit2.reftype(ref::GitReference)::Cint\n\nReturn a Cint corresponding to the type of ref:\n\n0 if the reference is invalid\n1 if the reference is an object id\n2 if the reference is symbolic\n\n\n\n\n\n"},{"title":"LibGit2.remotes","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.remotes","category":"function","text":"LibGit2.remotes(repo::GitRepo)\n\nReturn a vector of the names of the remotes of repo.\n\n\n\n\n\n"},{"title":"LibGit2.remove!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.remove!","category":"function","text":"remove!(repo::GitRepo, files::AbstractString...)\nremove!(idx::GitIndex, files::AbstractString...)\n\nRemove all the files with paths specified by files in the index idx (or the index\nof the repo).\n\n\n\n\n\n"},{"title":"LibGit2.reset","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.reset","category":"function","text":"reset(val::Integer, flag::Integer)\n\nUnset the bits of val indexed by flag, returning them to 0.\n\n\n\n\n\n"},{"title":"LibGit2.reset!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.reset!","category":"function","text":"reset!(payload, [config])::CredentialPayload\n\nReset the payload state back to the initial values so that it can be used again within\nthe credential callback. If a config is provided the configuration will also be updated.\n\n\n\n\n\nUpdates some entries, determined by the pathspecs, in the index from the target commit tree.\n\n\n\n\n\nSets the current head to the specified commit oid and optionally resets the index and working tree to match.\n\n\n\n\n\ngit reset [<committish>] [–] <pathspecs>... \n\n\n\n\n\nreset!(repo::GitRepo, id::GitHash, mode::Cint=Consts.RESET_MIXED)\n\nReset the repository repo to its state at id, using one of three modes\nset by mode:\n\nConsts.RESET_SOFT - move HEAD to id.\nConsts.RESET_MIXED - default, move HEAD to id and reset the index to id.\nConsts.RESET_HARD - move HEAD to id, reset the index to id, and discard all working changes.\n\nExamples\n\n# fetch changes\nLibGit2.fetch(repo)\nisfile(joinpath(repo_path, our_file)) # will be false\n\n# fastforward merge the changes\nLibGit2.merge!(repo, fastforward=true)\n\n# because there was not any file locally, but there is\n# a file remotely, we need to reset the branch\nhead_oid = LibGit2.head_oid(repo)\nnew_head = LibGit2.reset!(repo, head_oid, LibGit2.Consts.RESET_HARD)\n\nIn this example, the remote which is being fetched from does have\na file called our_file in its index, which is why we must reset.\n\nEquivalent to git reset [--soft | --mixed | --hard] <id>.\n\nExamples\n\nrepo = LibGit2.GitRepo(repo_path)\nhead_oid = LibGit2.head_oid(repo)\nopen(joinpath(repo_path, \"file1\"), \"w\") do f\n    write(f, \"111\n\")\nend\nLibGit2.add!(repo, \"file1\")\nmode = LibGit2.Consts.RESET_HARD\n# will discard the changes to file1\n# and unstage it\nnew_head = LibGit2.reset!(repo, head_oid, mode)\n\n\n\n\n\n"},{"title":"LibGit2.restore","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.restore","category":"function","text":"restore(s::State, repo::GitRepo)\n\nReturn a repository repo to a previous State s, for\nexample the HEAD of a branch before a merge attempt. s\ncan be generated using the snapshot function.\n\n\n\n\n\n"},{"title":"LibGit2.revcount","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.revcount","category":"function","text":"LibGit2.revcount(repo::GitRepo, commit1::AbstractString, commit2::AbstractString)\n\nList the number of revisions between commit1 and commit2 (committish OIDs in string form).\nSince commit1 and commit2 may be on different branches, revcount performs a \"left-right\"\nrevision list (and count), returning a tuple of Ints - the number of left and right\ncommits, respectively. A left (or right) commit refers to which side of a symmetric\ndifference in a tree the commit is reachable from.\n\nEquivalent to git rev-list --left-right --count <commit1> <commit2>.\n\nExamples\n\nrepo = LibGit2.GitRepo(repo_path)\nrepo_file = open(joinpath(repo_path, test_file), \"a\")\nprintln(repo_file, \"hello world\")\nflush(repo_file)\nLibGit2.add!(repo, test_file)\ncommit_oid1 = LibGit2.commit(repo, \"commit 1\")\nprintln(repo_file, \"hello world again\")\nflush(repo_file)\nLibGit2.add!(repo, test_file)\ncommit_oid2 = LibGit2.commit(repo, \"commit 2\")\nLibGit2.revcount(repo, string(commit_oid1), string(commit_oid2))\n\nThis will return (-1, 0).\n\n\n\n\n\n"},{"title":"LibGit2.set_remote_url","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.set_remote_url","category":"function","text":"set_remote_url(repo::GitRepo, remote_name, url)\nset_remote_url(repo::String, remote_name, url)\n\nSet both the fetch and push url for remote_name for the GitRepo or the git repository\nlocated at path. Typically git repos use \"origin\" as the remote name.\n\nExamples\n\nrepo_path = joinpath(tempdir(), \"Example\")\nrepo = LibGit2.init(repo_path)\nLibGit2.set_remote_url(repo, \"upstream\", \"https://github.com/JuliaLang/Example.jl\")\nLibGit2.set_remote_url(repo_path, \"upstream2\", \"https://github.com/JuliaLang/Example2.jl\")\n\n\n\n\n\n"},{"title":"LibGit2.shortname","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.shortname","category":"function","text":"LibGit2.shortname(ref::GitReference)\n\nReturn a shortened version of the name of ref that's\n\"human-readable\".\n\njulia> repo = GitRepo(path_to_repo);\n\njulia> branch_ref = LibGit2.head(repo);\n\njulia> LibGit2.name(branch_ref)\n\"refs/heads/master\"\n\njulia> LibGit2.shortname(branch_ref)\n\"master\"\n\n\n\n\n\n"},{"title":"LibGit2.snapshot","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.snapshot","category":"function","text":"snapshot(repo::GitRepo)::State\n\nTake a snapshot of the current state of the repository repo,\nstoring the current HEAD, index, and any uncommitted work.\nThe output State can be used later during a call to restore\nto return the repository to the snapshotted state.\n\n\n\n\n\n"},{"title":"LibGit2.split_cfg_entry","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.split_cfg_entry","category":"function","text":"LibGit2.split_cfg_entry(ce::LibGit2.ConfigEntry)::Tuple{String,String,String,String}\n\nBreak the ConfigEntry up to the following pieces: section, subsection, name, and value.\n\nExamples\n\nGiven the git configuration file containing:\n\n[credential \"https://example.com\"]\n    username = me\n\nThe ConfigEntry would look like the following:\n\njulia> entry\nConfigEntry(\"credential.https://example.com.username\", \"me\")\n\njulia> LibGit2.split_cfg_entry(entry)\n(\"credential\", \"https://example.com\", \"username\", \"me\")\n\nRefer to the git config syntax documentation\nfor more details.\n\n\n\n\n\n"},{"title":"LibGit2.status","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.status","category":"function","text":"LibGit2.status(repo::GitRepo, path::String)::Union{Cuint, Cvoid}\n\nLookup the status of the file at path in the git\nrepository repo. For instance, this can be used\nto check if the file at path has been modified\nand needs to be staged and committed.\n\n\n\n\n\n"},{"title":"LibGit2.stage","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.stage","category":"function","text":"stage(ie::IndexEntry)::Cint\n\nGet the stage number of ie. The stage number 0 represents the current state\nof the working tree, but other numbers can be used in the case of a merge conflict.\nIn such a case, the various stage numbers on an IndexEntry describe which side(s)\nof the conflict the current state of the file belongs to. Stage 0 is the state\nbefore the attempted merge, stage 1 is the changes which have been made locally,\nstages 2 and larger are for changes from other branches (for instance, in the case\nof a multi-branch \"octopus\" merge, stages 2, 3, and 4 might be used).\n\n\n\n\n\n"},{"title":"LibGit2.tag_create","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.tag_create","category":"function","text":"LibGit2.tag_create(repo::GitRepo, tag::AbstractString, commit; kwargs...)\n\nCreate a new git tag tag (e.g. \"v0.5\") in the repository repo, at\nthe commit commit.\n\nThe keyword arguments are:\n\nmsg::AbstractString=\"\": the message for the tag.\nforce::Bool=false: if true, existing references will be overwritten.\nsig::Signature=Signature(repo): the tagger's signature.\n\n\n\n\n\n"},{"title":"LibGit2.tag_delete","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.tag_delete","category":"function","text":"LibGit2.tag_delete(repo::GitRepo, tag::AbstractString)\n\nRemove the git tag tag from the repository repo.\n\n\n\n\n\n"},{"title":"LibGit2.tag_list","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.tag_list","category":"function","text":"LibGit2.tag_list(repo::GitRepo)::Vector{String}\n\nGet a list of all tags in the git repository repo.\n\n\n\n\n\n"},{"title":"LibGit2.target","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.target","category":"function","text":"LibGit2.target(tag::GitTag)\n\nThe GitHash of the target object of tag.\n\n\n\n\n\n"},{"title":"LibGit2.toggle","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.toggle","category":"function","text":"toggle(val::Integer, flag::Integer)\n\nFlip the bits of val indexed by flag, so that if a bit is 0 it\nwill be 1 after the toggle, and vice-versa.\n\n\n\n\n\n"},{"title":"LibGit2.transact","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.transact","category":"function","text":"transact(f::Function, repo::GitRepo)\n\nApply function f to the git repository repo, taking a snapshot before\napplying f. If an error occurs within f, repo will be returned to its snapshot\nstate using restore. The error which occurred will be rethrown, but the\nstate of repo will not be corrupted.\n\n\n\n\n\n"},{"title":"LibGit2.treewalk","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.treewalk","category":"function","text":"treewalk(f, tree::GitTree, post::Bool=false)\n\nTraverse the entries in tree and its subtrees in post or pre order. Preorder\nmeans beginning at the root and then traversing the leftmost subtree (and\nrecursively on down through that subtree's leftmost subtrees) and moving right\nthrough the subtrees. Postorder means beginning at the bottom of the leftmost\nsubtree, traversing upwards through it, then traversing the next right subtree\n(again beginning at the bottom) and finally visiting the tree root last of all.\n\nThe function parameter f should have following signature:\n\n(String, GitTreeEntry) -> Cint\n\nA negative value returned from f stops the tree walk. A positive value means\nthat the entry will be skipped if post is false.\n\n\n\n\n\n"},{"title":"LibGit2.upstream","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.upstream","category":"function","text":"upstream(ref::GitReference)::Union{GitReference, Nothing}\n\nDetermine if the branch containing ref has a specified upstream branch.\n\nReturn either a GitReference to the upstream branch if it exists,\nor nothing if the requested branch does not have an upstream counterpart.\n\n\n\n\n\n"},{"title":"LibGit2.update!","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.update!","category":"function","text":"update!(repo::GitRepo, files::AbstractString...)\nupdate!(idx::GitIndex, files::AbstractString...)\n\nUpdate all the files with paths specified by files in the index idx (or the index\nof the repo). Match the state of each file in the index with the current state on\ndisk, removing it if it has been removed on disk, or updating its entry in the object\ndatabase.\n\n\n\n\n\n"},{"title":"LibGit2.url","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.url","category":"function","text":"url(rmt::GitRemote)\n\nGet the fetch URL of a remote git repository.\n\nExamples\n\njulia> repo_url = \"https://github.com/JuliaLang/Example.jl\";\n\njulia> repo = LibGit2.init(mktempdir());\n\njulia> remote = LibGit2.GitRemote(repo, \"origin\", repo_url);\n\njulia> LibGit2.url(remote)\n\"https://github.com/JuliaLang/Example.jl\"\n\n\n\n\n\n"},{"title":"LibGit2.version","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.version","category":"function","text":"version()::VersionNumber\n\nReturn the version of libgit2 in use, as a VersionNumber.\n\n\n\n\n\n"},{"title":"LibGit2.with","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.with","category":"function","text":"with(f::Function, obj)\n\nResource management helper function. Applies f to obj, making sure to call\nclose on obj after f successfully returns or throws an error. Ensures that\nallocated git resources are finalized as soon as they are no longer needed.\n\n\n\n\n\n"},{"title":"LibGit2.with_warn","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.with_warn","category":"function","text":"with_warn(f::Function, ::Type{T}, args...)\n\nResource management helper function. Apply f to args, first constructing\nan instance of type T from args. Makes sure to call close on the resulting\nobject after f successfully returns or throws an error. Ensures that\nallocated git resources are finalized as soon as they are no longer needed. If an\nerror is thrown by f, a warning is shown containing the error.\n\n\n\n\n\n"},{"title":"LibGit2.workdir","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.workdir","category":"function","text":"LibGit2.workdir(repo::GitRepo)\n\nReturn the location of the working directory of repo.\nThis will throw an error for bare repositories.\n\nnote: Note\nThis will typically be the parent directory of gitdir(repo), but can be different in\nsome cases: e.g. if either the core.worktree configuration variable or the\nGIT_WORK_TREE environment variable is set.\n\nSee also gitdir, path.\n\n\n\n\n\n"},{"title":"LibGit2.GitObject","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.GitObject-Tuple{LibGit2.GitTreeEntry}","category":"method","text":"(::Type{T})(te::GitTreeEntry) where T<:GitObject\n\nGet the git object to which te refers and return it as its actual type (the type\nentrytype would show), for instance a GitBlob or GitTag.\n\nExamples\n\ntree = LibGit2.GitTree(repo, \"HEAD^{tree}\")\ntree_entry = tree[1]\nblob = LibGit2.GitBlob(tree_entry)\n\n\n\n\n\n"},{"title":"LibGit2.UserPasswordCredential","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.UserPasswordCredential","category":"type","text":"Credential that support only user and password parameters\n\n\n\n\n\n"},{"title":"LibGit2.SSHCredential","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.SSHCredential","category":"type","text":"SSH credential type\n\n\n\n\n\n"},{"title":"LibGit2.isfilled","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.isfilled","category":"function","text":"isfilled(cred::AbstractCredential)::Bool\n\nVerifies that a credential is ready for use in authentication.\n\n\n\n\n\n"},{"title":"LibGit2.CachedCredentials","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.CachedCredentials","category":"type","text":"Caches credential information for re-use\n\n\n\n\n\n"},{"title":"LibGit2.CredentialPayload","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.CredentialPayload","category":"type","text":"LibGit2.CredentialPayload\n\nRetains the state between multiple calls to the credential callback for the same URL.\nA CredentialPayload instance is expected to be reset! whenever it will be used with a\ndifferent URL.\n\n\n\n\n\n"},{"title":"LibGit2.approve","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.approve","category":"function","text":"approve(payload::CredentialPayload; shred::Bool=true) -> nothing\n\nStore the payload credential for re-use in a future authentication. Should only be called\nwhen authentication was successful.\n\nThe shred keyword controls whether sensitive information in the payload credential field\nshould be destroyed. Should only be set to false during testing.\n\n\n\n\n\n"},{"title":"LibGit2.reject","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.reject","category":"function","text":"reject(payload::CredentialPayload; shred::Bool=true) -> nothing\n\nDiscard the payload credential from begin re-used in future authentication. Should only be\ncalled when authentication was unsuccessful.\n\nThe shred keyword controls whether sensitive information in the payload credential field\nshould be destroyed. Should only be set to false during testing.\n\n\n\n\n\n"},{"title":"LibGit2.Consts.GIT_CONFIG","page":"LibGit2","location":"stdlib/LibGit2.html#LibGit2.Consts.GIT_CONFIG","category":"type","text":"Priority level of a config file.\n\nThese priority levels correspond to the natural escalation logic (from higher to lower) when searching for config entries in git.\n\nCONFIG_LEVEL_DEFAULT - Open the global, XDG and system configuration files if any available.\nCONFIG_LEVEL_PROGRAMDATA - System-wide on Windows, for compatibility with portable git\nCONFIG_LEVEL_SYSTEM - System-wide configuration file; /etc/gitconfig on Linux systems\nCONFIG_LEVEL_XDG - XDG compatible configuration file; typically ~/.config/git/config\nCONFIG_LEVEL_GLOBAL - User-specific configuration file (also called Global configuration file); typically ~/.gitconfig\nCONFIG_LEVEL_LOCAL - Repository specific configuration file; $WORK_DIR/.git/config on non-bare repos\nCONFIG_LEVEL_WORKTREE - Worktree specific configuration file; $GIT_DIR/config.worktree\nCONFIG_LEVEL_APP - Application specific configuration file; freely defined by applications\nCONFIG_HIGHEST_LEVEL - Represents the highest level available config file (i.e. the most specific config file available that actually is loaded)\n\n\n\n\n\n"},{"title":"Shared Arrays","page":"Shared Arrays","location":"stdlib/SharedArrays.html#Shared-Arrays","category":"section","text":"SharedArray represents an array, which is shared across multiple processes, on a single machine."},{"title":"SharedArrays.SharedArray","page":"Shared Arrays","location":"stdlib/SharedArrays.html#SharedArrays.SharedArray","category":"type","text":"SharedArray{T}(dims::NTuple; init=false, pids=Int[])\nSharedArray{T,N}(...)\n\nConstruct a SharedArray of a bits type T and size dims across the\nprocesses specified by pids - all of which have to be on the same\nhost.  If N is specified by calling SharedArray{T,N}(dims), then\nN must match the length of dims.\n\nIf pids is left unspecified, the shared array will be mapped across all processes on the\ncurrent host, including the master. But, localindices and indexpids will only refer to\nworker processes. This facilitates work distribution code to use workers for actual\ncomputation with the master process acting as a driver.\n\nIf an init function of the type initfn(S::SharedArray) is specified, it is called on all\nthe participating workers.\n\nThe shared array is valid as long as a reference to the SharedArray object exists on the node\nwhich created the mapping.\n\nSharedArray{T}(filename::AbstractString, dims::NTuple, [offset=0]; mode=nothing, init=false, pids=Int[])\nSharedArray{T,N}(...)\n\nConstruct a SharedArray backed by the file filename, with element\ntype T (must be a bits type) and size dims, across the processes\nspecified by pids - all of which have to be on the same host. This\nfile is mmapped into the host memory, with the following consequences:\n\nThe array data must be represented in binary format (e.g., an ASCII\nformat like CSV cannot be supported)\nAny changes you make to the array values (e.g., A[3] = 0) will\nalso change the values on disk\n\nIf pids is left unspecified, the shared array will be mapped across\nall processes on the current host, including the master. But,\nlocalindices and indexpids will only refer to worker\nprocesses. This facilitates work distribution code to use workers for\nactual computation with the master process acting as a driver.\n\nmode must be one of \"r\", \"r+\", \"w+\", or \"a+\", and defaults\nto \"r+\" if the file specified by filename already exists, or\n\"w+\" if not. If an init function of the type\ninitfn(S::SharedArray) is specified, it is called on all the\nparticipating workers. You cannot specify an init function if the\nfile is not writable.\n\noffset allows you to skip the specified number of bytes at the\nbeginning of the file.\n\n\n\n\n\n"},{"title":"SharedArrays.SharedVector","page":"Shared Arrays","location":"stdlib/SharedArrays.html#SharedArrays.SharedVector","category":"type","text":"SharedVector\n\nA one-dimensional SharedArray.\n\n\n\n\n\n"},{"title":"SharedArrays.SharedMatrix","page":"Shared Arrays","location":"stdlib/SharedArrays.html#SharedArrays.SharedMatrix","category":"type","text":"SharedMatrix\n\nA two-dimensional SharedArray.\n\n\n\n\n\n"},{"title":"Distributed.procs","page":"Shared Arrays","location":"stdlib/SharedArrays.html#Distributed.procs-Tuple{SharedArray}","category":"method","text":"procs(S::SharedArray)\n\nGet the vector of processes mapping the shared array.\n\n\n\n\n\n"},{"title":"SharedArrays.sdata","page":"Shared Arrays","location":"stdlib/SharedArrays.html#SharedArrays.sdata","category":"function","text":"sdata(S::SharedArray)\n\nReturn the actual Array object backing S.\n\n\n\n\n\n"},{"title":"SharedArrays.indexpids","page":"Shared Arrays","location":"stdlib/SharedArrays.html#SharedArrays.indexpids","category":"function","text":"indexpids(S::SharedArray)\n\nReturn the current worker's index in the list of workers\nmapping the SharedArray (i.e. in the same list returned by procs(S)), or\n0 if the SharedArray is not mapped locally.\n\n\n\n\n\n"},{"title":"SharedArrays.localindices","page":"Shared Arrays","location":"stdlib/SharedArrays.html#SharedArrays.localindices","category":"function","text":"localindices(S::SharedArray)\n\nReturn a range describing the \"default\" indices to be handled by the\ncurrent process.  This range should be interpreted in the sense of\nlinear indexing, i.e., as a sub-range of 1:length(S).  In\nmulti-process contexts, returns an empty range in the parent process\n(or any process for which indexpids returns 0).\n\nIt's worth emphasizing that localindices exists purely as a\nconvenience, and you can partition work on the array among workers any\nway you wish. For a SharedArray, all indices should be equally fast\nfor each worker process.\n\n\n\n\n\n"},{"title":"Julia SSA-form IR","page":"Julia SSA-form IR","location":"devdocs/ssair.html#Julia-SSA-form-IR","category":"section","text":"Julia uses a static single assignment intermediate representation (SSA IR) to perform optimization.\nThis IR is different from LLVM IR, and unique to Julia.\nIt allows for Julia specific optimizations.\n\nBasic blocks (regions with no control flow) are explicitly annotated.\nif/else and loops are turned into goto statements.\nlines with multiple operations are split into multiple lines by introducing variables.\n\nFor example the following Julia code:\n\nfunction foo(x)\n    y = sin(x)\n    if x > 5.0\n        y = y + cos(x)\n    end\n    return exp(2) + y\nend\n\nwhen called with a Float64 argument is translated into:\n\nusing InteractiveUtils\n@code_typed foo(1.0)\n\nCodeInfo(\n1 ─ %1 = invoke Main.sin(x::Float64)::Float64\n│   %2 = Base.lt_float(x, 5.0)::Bool\n└──      goto #3 if not %2\n2 ─ %4 = invoke Main.cos(x::Float64)::Float64\n└── %5 = Base.add_float(%1, %4)::Float64\n3 ┄ %6 = φ (#2 => %5, #1 => %1)::Float64\n│   %7 = Base.add_float(7.38905609893065, %6)::Float64\n└──      return %7\n) => Float64\n\nIn this example, we can see all of these changes.\n\nThe first basic block is everything in\n\n1 ─ %1 = invoke Main.sin(x::Float64)::Float64\n│   %2 = Base.lt_float(x, 5.0)::Bool\n└──      goto #3 if not %2\n\nThe if statement is translated into goto #3 if not %2 which goes to the 3rd basic block if x>5 isn't met and otherwise goes to the second basic block.\n%2 is an SSA value introduced to represent x > 5."},{"title":"Background","page":"Julia SSA-form IR","location":"devdocs/ssair.html#Background","category":"section","text":"Beginning in Julia 0.7, parts of the compiler use a new SSA-form\nintermediate representation (IR). Historically, the compiler would directly generate LLVM IR from a lowered form of the Julia\nAST. This form had most syntactic abstractions removed, but still looked a lot like an abstract syntax tree.\nOver time, in order to facilitate optimizations, SSA values were introduced to this IR and the IR was\nlinearized (i.e. turned into a form where function arguments could only be SSA values or constants). However, non-SSA values\n(slots) remained in the IR due to the lack of Phi nodes in the IR (necessary for back-edges and re-merging of\nconditional control flow). This negated much of the usefulness of SSA form representation when performing\nmiddle end optimizations. Some heroic effort was put into making these optimizations work without a complete SSA\nform representation, but the lack of such a representation ultimately proved prohibitive."},{"title":"Categories of IR nodes","page":"Julia SSA-form IR","location":"devdocs/ssair.html#Categories-of-IR-nodes","category":"section","text":"The SSA IR representation has four categories of IR nodes: Phi, Pi, PhiC, and Upsilon nodes (the latter two are only used for exception handling)."},{"title":"Phi nodes and Pi nodes","page":"Julia SSA-form IR","location":"devdocs/ssair.html#Phi-nodes-and-Pi-nodes","category":"section","text":"Phi nodes are part of generic SSA abstraction (see the link above if you're not familiar with\nthe concept). In the Julia IR, these nodes are represented as:\n\nstruct PhiNode\n    edges::Vector{Int32}\n    values::Vector{Any}\nend\n\nwhere we ensure that both vectors always have the same length. In the canonical representation (the one\nhandled by codegen and the interpreter), the edge values indicate come-from statement numbers (i.e.\nif edge has an entry of 15, there must be a goto, gotoifnot or implicit fall through from\nstatement 15 that targets this phi node). Values are either SSA values or constants. It is also\npossible for a value to be unassigned if the variable was not defined on this path. However, undefinedness\nchecks get explicitly inserted and represented as booleans after middle end optimizations, so code generators\nmay assume that any use of a Phi node will have an assigned value in the corresponding slot. It is also legal\nfor the mapping to be incomplete, i.e. for a Phi node to have missing incoming edges. In that case, it must\nbe dynamically guaranteed that the corresponding value will not be used.\n\nNote that SSA uses semantically occur after the terminator of the corresponding predecessor (\"on the edge\").\nConsequently, if multiple Phi nodes appear at the start of a basic block, they are run simultaneously.\nThis means that in the following IR snippet, if we came from block 23, %46 will take the value associated to\n%45 before we entered this block.\n\n%45 = φ (#18 => %23, #23 => %50)\n%46 = φ (#18 => 1.0, #23 => %45)\n\nPiNodes encode statically proven information that may be implicitly assumed in basic blocks dominated by a given\npi node. They are conceptually equivalent to the technique introduced in the paper\nABCD: Eliminating Array Bounds Checks on Demand or the predicate info nodes in LLVM. To see how they work, consider,\ne.g.\n\n%x::Union{Int, Float64} # %x is some Union{Int, Float64} typed ssa value\nif isa(x, Int)\n    # use x\nelse\n    # use x\nend\n\nWe can perform predicate insertion and turn this into:\n\n%x::Union{Int, Float64} # %x is some Union{Int, Float64} typed ssa value\nif isa(x, Int)\n    %x_int = PiNode(x, Int)\n    # use %x_int\nelse\n    %x_float = PiNode(x, Float64)\n    # use %x_float\nend\n\nPi nodes are generally ignored in the interpreter, since they don't have any effect on the values,\nbut they may sometimes lead to code generation in the compiler (e.g. to change from an implicitly\nunion split representation to a plain unboxed representation). The main usefulness of PiNodes stems\nfrom the fact that path conditions of the values can be accumulated simply by def-use chain walking\nthat is generally done for most optimizations that care about these conditions anyway."},{"title":"PhiC nodes and Upsilon nodes","page":"Julia SSA-form IR","location":"devdocs/ssair.html#PhiC-nodes-and-Upsilon-nodes","category":"section","text":"Exception handling complicates the SSA story moderately, because exception handling\nintroduces additional control flow edges into the IR across which values must be tracked.\nOne approach to do so, which is followed by LLVM, is to make calls which may throw exceptions\ninto basic block terminators and add an explicit control flow edge to the catch handler:\n\ninvoke @function_that_may_throw() to label %regular unwind to %catch\n\nregular:\n# Control flow continues here\n\ncatch:\n# Exceptions go here\n\nHowever, this is problematic in a language like Julia, where at the start of the optimization\npipeline, we do not know which calls throw. We would have to conservatively assume that every\ncall (which in Julia is every statement) throws. This would have several negative effects.\nOn the one hand, it would essentially reduce the scope of every basic block to a single call,\ndefeating the purpose of having operations be performed at the basic block level. On the other\nhand, every catch basic block would have n*m phi node arguments (n, the number of statements\nin the critical region, m the number of live values through the catch block).\n\nTo work around this, we use a combination of Upsilon and PhiC nodes (the C standing for catch,\nwritten φᶜ in the IR pretty printer, because unicode subscript c is not available). There are several ways to think of these nodes, but\nperhaps the easiest is to think of each PhiC as a load from a unique store-many, read-once slot,\nwith Upsilon being the corresponding store operation. The PhiC has an operand list of all the\nupsilon nodes that store to its implicit slot. The Upsilon nodes however, do not record which PhiC\nnode they store to. This is done for more natural integration with the rest of the SSA IR. E.g.\nif there are no more uses of a PhiC node, it is safe to delete it, and the same is true of an\nUpsilon node. In most IR passes, PhiC nodes can be treated like Phi nodes. One can follow\nuse-def chains through them, and they can be lifted to new PhiC nodes and new Upsilon nodes (in the\nsame places as the original Upsilon nodes). The result of this scheme is that the number of\nUpsilon nodes (and PhiC arguments) is proportional to the number of assigned values to a particular\nvariable (before SSA conversion), rather than the number of statements in the critical region.\n\nTo see this scheme in action, consider the function\n\n@noinline opaque() = invokelatest(identity, nothing) # Something opaque\nfunction foo()\n    local y\n    x = 1\n    try\n        y = 2\n        opaque()\n        y = 3\n        error()\n    catch\n    end\n    (x, y)\nend\n\nThe corresponding IR (with irrelevant types stripped) is:\n\n1 ─       nothing::Nothing\n2 ─ %2  = $(Expr(:enter, #4))\n3 ─ %3  = ϒ (false)\n│   %4  = ϒ (#undef)\n│   %5  = ϒ (1)\n│   %6  = ϒ (true)\n│   %7  = ϒ (2)\n│         invoke Main.opaque()::Any\n│   %9  = ϒ (true)\n│   %10 = ϒ (3)\n│         invoke Main.error()::Union{}\n└──       $(Expr(:unreachable))::Union{}\n4 ┄ %13 = φᶜ (%3, %6, %9)::Bool\n│   %14 = φᶜ (%4, %7, %10)::Core.Compiler.MaybeUndef(Int64)\n│   %15 = φᶜ (%5)::Core.Const(1)\n└──       $(Expr(:leave, Core.SSAValue(2)))\n5 ─       $(Expr(:pop_exception, :(%2)))::Any\n│         $(Expr(:throw_undef_if_not, :y, :(%13)))::Any\n│   %19 = Core.tuple(%15, %14)\n└──       return %19\n\nNote in particular that every value live into the critical region gets\nan upsilon node at the top of the critical region. This is because\ncatch blocks are considered to have an invisible control flow edge\nfrom outside the function. As a result, no SSA value dominates the\ncatch blocks, and all incoming values have to come through a φᶜ node."},{"title":"Main SSA data structure","page":"Julia SSA-form IR","location":"devdocs/ssair.html#Main-SSA-data-structure","category":"section","text":"The main SSAIR data structure is worthy of discussion. It draws inspiration from LLVM and Webkit's B3 IR.\nThe core of the data structure is a flat vector of statements. Each statement is implicitly assigned\nan SSA value based on its position in the vector (i.e. the result of the statement at idx 1 can be\naccessed using SSAValue(1) etc). For each SSA value, we additionally maintain its type. Since, SSA values\nare definitionally assigned only once, this type is also the result type of the expression at the corresponding\nindex. However, while this representation is rather efficient (since the assignments don't need to be explicitly\nencoded), it of course carries the drawback that order is semantically significant, so reorderings and insertions\nchange statement numbers. Additionally, we do not keep use lists (i.e. it is impossible to walk from a def to\nall its uses without explicitly computing this map–def lists however are trivial since you can look up the\ncorresponding statement from the index), so the LLVM-style RAUW (replace-all-uses-with) operation is unavailable.\n\nInstead, we do the following:\n\nWe keep a separate buffer of nodes to insert (including the position to insert them at, the type of the\ncorresponding value and the node itself). These nodes are numbered by their occurrence in the insertion\nbuffer, allowing their values to be immediately used elsewhere in the IR (i.e. if there are 12 statements in\nthe original statement list, the first new statement will be accessible as SSAValue(13)).\nRAUW style operations are performed by setting the corresponding statement index to the replacement\nvalue.\nStatements are erased by setting the corresponding statement to nothing (this is essentially just a special-case\nconvention of the above).\nIf there are any uses of the statement being erased, they will be set to nothing.\n\nThere is a compact! function that compacts the above data structure by performing the insertion of nodes in the appropriate place, trivial copy propagation, and renaming of uses to any changed SSA values. However, the clever part\nof this scheme is that this compaction can be done lazily as part of the subsequent pass. Most optimization passes\nneed to walk over the entire list of statements, performing analysis or modifications along the way. We provide an\nIncrementalCompact iterator that can be used to iterate over the statement list. It will perform any necessary compaction\nand return the new index of the node, as well as the node itself. It is legal at this point to walk def-use chains,\nas well as make any modifications or deletions to the IR (insertions are disallowed however).\n\nThe idea behind this arrangement is that, since the optimization passes need to touch the corresponding memory anyway\nand incur the corresponding memory access penalty, performing the extra housekeeping should have comparatively little\noverhead (and save the overhead of maintaining these data structures during IR modification)."},{"title":"Julia Garbage Collector (GC) Internals","page":"Julia Garbage Collector (GC) Internals","location":"devdocs/gc.html#Julia-Garbage-Collector-(GC)-Internals","category":"section","text":""},{"title":"Introduction","page":"Julia Garbage Collector (GC) Internals","location":"devdocs/gc.html#Introduction","category":"section","text":"Julia implements a garbage collector (GC) to automate dynamic memory management. Julia's GC is:\n\nMark-sweep: the object graph is traced starting from a root-set (e.g., global variables and local variables on the stack) to determine the set of live objects.\nNon-moving: objects are not relocated to a different memory address.\nParallel: multiple threads can be used during the marking and sweeping phases.\nPartially concurrent: the runtime provides an option to scavenge pool-allocated memory blocks (e.g., call madvise on these blocks on Linux) concurrently with Julia user code.\nGenerational: objects are partitioned into generations according to how many collection cycles they've survived. Younger generations are collected more often.\nMostly precise: Julia optionally supports conservative stack scanning for users who inter-operate with foreign languages like C."},{"title":"Allocation","page":"Julia Garbage Collector (GC) Internals","location":"devdocs/gc.html#Allocation","category":"section","text":"Julia uses two types of allocators, depending on the size of the allocation request."},{"title":"Small Object Allocation","page":"Julia Garbage Collector (GC) Internals","location":"devdocs/gc.html#Small-Object-Allocation","category":"section","text":"Sufficiently small objects, up to 2k bytes, are allocated through a per-thread free-list pool allocator.\n\nJulia's pool allocator often has better runtime performance than libc malloc for small allocations. Additionally, using a custom pool allocator enables a few optimizations during the sweeping phase (e.g., concurrent scavenging).\n\nThe pool allocator segregates objects on different size classes. Each large memory block (16k bytes) managed by the pool allocator only contains objects belonging to the same size class.\n\nEach pool-allocated memory block is paired with a metadata structure containing information such as whether the block has live objects at all, the number of free memory slots in the block, the offsets to the first and last objects in the block, etc. This metadata is used to aggregate statistics such as number of objects freed during a collection cycle. It's also used to optimize the sweeping phase of the GC: blocks that have no live objects whatsoever don't need to be linearly scanned during the sweeping phase.\n\nJulia's pool allocator stores memory blocks into different global lock-free lists depending on whether the block has been mapped but never accessed (page_pool_clean),  whether the page has been lazily swept and it's waiting to be scavenged by a background GC thread (page_pool_lazily_freed), or whether the page has been scavenged (page_pool_freed).\n\nThe pool allocator uses this partitioning of blocks to implement a tiered allocation discipline. When it requests a fresh memory block, it will:\n\nTry to claim a block from page_pool_lazily_freed, which contains blocks that were empty during the last stop-the-world phase, but haven't been madvised by a concurrent scavenger GC thread yet.\nIf it failed to claim a block from page_pool_lazily_freed, it will try to claim a block from page_pool_clean, which contains blocks mapped on a previous block allocation request but never accessed.\nIf it failed to claim a block from page_pool_clean and from page_pool_lazily_freed, it will try to claim a block from page_pool_freed, which contains blocks already scavenged by a concurrent scavenger GC thread and whose underlying virtual address can be recycled.\nIf it failed in all of the attempts mentioned above, it will map a batch of operating system pages, partition them into memory blocks, claim one block for itself, and insert the remaining blocks into page_pool_clean.\n\n(Image: Diagram of tiered pool allocation)"},{"title":"Large Object Allocation","page":"Julia Garbage Collector (GC) Internals","location":"devdocs/gc.html#Large-Object-Allocation","category":"section","text":"Sufficiently large objects, above the 2k byte threshold mentioned in the previous section, are allocated through libc malloc. Large allocations are typically less performance-critical than small allocations, as they occur less frequently.\n\nAlthough Julia currently uses libc malloc, it also supports pre-loading other dynamic memory allocators (e.g., jemalloc)."},{"title":"Marking and Generational Collection","page":"Julia Garbage Collector (GC) Internals","location":"devdocs/gc.html#Marking-and-Generational-Collection","category":"section","text":"Julia’s mark phase is implemented through a parallel depth-first-search that traverses the object graph to determine which objects are alive.\n\nJulia stores age information for its generational GC in the object header: the lowest two bits of an object’s header store a mark bit, set when an object is marked, and an age bit, set when the object is promoted. Because Julia’s GC is non-moving, object age information can’t be only determined through the object's memory address, such as in GC implementations that allocate young objects in certain memory regions and relocate them to other memory regions during object promotion.\n\nGenerational collection is implemented through sticky bits: objects are only pushed to the mark-stack, and therefore traced, if their mark-bits have not been set. When objects reach the oldest generation, their mark-bits aren't reset during a quick sweep, so these objects aren't traced during a subsequent mark phase. A full sweep, however, resets the mark-bits of all objects, so all of them are traced in a subsequent collection.\n\nWhen the mutator is running, a write barrier intercepts field writes and pushes an object’s address into a per-thread remembered set if the reference crosses generations. Objects in this remembered set are then traced during the next mark phase."},{"title":"Sweeping","page":"Julia Garbage Collector (GC) Internals","location":"devdocs/gc.html#Sweeping","category":"section","text":"If a memory block managed by the pool allocator contains at least one live object, the sweeping phase creates a free-list from its dead objects; if it doesn't, then the block is scavenged and its underlying physical memory might be returned to the operating system through, for instance, madvise on Linux.\n\nThe linear scan of memory blocks that have at least one live object can be run with multiple threads. If concurrent page sweeping is enabled through the flag --gcthreads=X,1 the GC scavenges memory blocks concurrently with the mutator.\n\nDuring the stop-the-world phase of the collector, memory blocks containing no live objects are initially pushed into the page_pool_lazily_freed. The background scavenger thread is then woken up and removes blocks from page_pool_lazily_freed, scavenges them (e.g., madvise on Linux), and inserts them into page_pool_freed. page_pool_lazily_freed is also shared with mutator threads. This can improve performance in some applications because in allocation-heavy multithreaded workloads, mutator threads often avoid a page fault during allocation, which happens by accessing a freshly mapped operating system page or a madvised page, by directly allocating a block from page_pool_lazily_freed. In these workloads, the scavenger thread also needs to scavenge fewer blocks, since some have already been claimed by the mutators."},{"title":"Memory Accounting","page":"Julia Garbage Collector (GC) Internals","location":"devdocs/gc.html#Memory-Accounting","category":"section","text":"The GC determines the heap size by adding the number of bytes in-use by pool-allocated memory blocks and bytes in-use by objects allocated through the large allocator. Previously, we measured the heap size by adding up the bytes for live objects, but not live memory blocks. This definition ignores fragmentation, which can lead to inaccurate GC decisions."},{"title":"GC Trigger Heuristics","page":"Julia Garbage Collector (GC) Internals","location":"devdocs/gc.html#GC-Trigger-Heuristics","category":"section","text":"Julia's GC heuristics are based on MemBalancer (https://dl.acm.org/doi/10.1145/3563323). They decide when to trigger a collection and which (quick or full) collection to trigger. The heuristics adjust the number of bytes the mutator can allocate before triggering a collection cycle by measuring metrics such as allocation rate, freeing rate, and current heap size.\n\nIndependently of allocation rates, freeing rates, or GC times, Julia will always trigger full collections if the heap size exceeds 80% of a memory upper bound specified through --heap-size-hint or determined by reading system information."},{"title":"Control Flow","page":"Control Flow","location":"manual/control-flow.html#Control-Flow","category":"section","text":"Julia provides a variety of control flow constructs:\n\nCompound Expressions: begin and ;.\nConditional Evaluation: if-elseif-else and ?: (ternary operator).\nShort-Circuit Evaluation: logical operators && (“and”) and || (“or”), and also chained comparisons.\nRepeated Evaluation: Loops: while and for.\nException Handling: try-catch, error and throw.\nTasks (aka Coroutines): yieldto.\n\nThe first five control flow mechanisms are standard to high-level programming languages. Tasks\nare not so standard: they provide non-local control flow, making it possible to switch between\ntemporarily-suspended computations. This is a powerful construct: both exception handling and\ncooperative multitasking are implemented in Julia using tasks. Everyday programming requires no\ndirect usage of tasks, but certain problems can be solved much more easily by using tasks."},{"title":"Compound Expressions","page":"Control Flow","location":"manual/control-flow.html#man-compound-expressions","category":"section","text":"Sometimes it is convenient to have a single expression which evaluates several subexpressions\nin order, returning the value of the last subexpression as its value. There are two Julia constructs\nthat accomplish this: begin blocks and ; chains. The value of both compound expression constructs\nis that of the last subexpression. Here's an example of a begin block:\n\njulia> z = begin\n           x = 1\n           y = 2\n           x + y\n       end\n3\n\nSince these are fairly small, simple expressions, they could easily be placed onto a single line,\nwhich is where the ; chain syntax comes in handy:\n\njulia> z = (x = 1; y = 2; x + y)\n3\n\nThis syntax is particularly useful with the terse single-line function definition form introduced\nin Functions. Although it is typical, there is no requirement that begin blocks be multiline\nor that ; chains be single-line:\n\njulia> begin x = 1; y = 2; x + y end\n3\n\njulia> (x = 1;\n        y = 2;\n        x + y)\n3"},{"title":"Conditional Evaluation","page":"Control Flow","location":"manual/control-flow.html#man-conditional-evaluation","category":"section","text":"Conditional evaluation allows portions of code to be evaluated or not evaluated depending on the\nvalue of a boolean expression. Here is the anatomy of the if-elseif-else conditional syntax:\n\nif x < y\n    println(\"x is less than y\")\nelseif x > y\n    println(\"x is greater than y\")\nelse\n    println(\"x is equal to y\")\nend\n\nIf the condition expression x < y is true, then the corresponding block is evaluated; otherwise\nthe condition expression x > y is evaluated, and if it is true, the corresponding block is\nevaluated; if neither expression is true, the else block is evaluated. Here it is in action:\n\njulia> function test(x, y)\n           if x < y\n               println(\"x is less than y\")\n           elseif x > y\n               println(\"x is greater than y\")\n           else\n               println(\"x is equal to y\")\n           end\n       end\ntest (generic function with 1 method)\n\njulia> test(1, 2)\nx is less than y\n\njulia> test(2, 1)\nx is greater than y\n\njulia> test(1, 1)\nx is equal to y\n\nThe elseif and else blocks are optional, and as many elseif blocks as desired can be used.\nThe condition expressions in the if-elseif-else construct are evaluated until the first\none evaluates to true, after which the associated block is evaluated, and no further condition\nexpressions or blocks are evaluated.\n\nif blocks are \"leaky\", i.e. they do not introduce a local scope. This means that new variables\ndefined inside the if clauses can be used after the if block, even if they weren't defined\nbefore. So, we could have defined the test function above as\n\njulia> function test(x,y)\n           if x < y\n               relation = \"less than\"\n           elseif x == y\n               relation = \"equal to\"\n           else\n               relation = \"greater than\"\n           end\n           println(\"x is \", relation, \" y.\")\n       end\ntest (generic function with 1 method)\n\njulia> test(2, 1)\nx is greater than y.\n\nThe variable relation is declared inside the if block, but used outside. However, when depending\non this behavior, make sure all possible code paths define a value for the variable. The following\nchange to the above function results in a runtime error\n\njulia> function test(x,y)\n           if x < y\n               relation = \"less than\"\n           elseif x == y\n               relation = \"equal to\"\n           end\n           println(\"x is \", relation, \" y.\")\n       end\ntest (generic function with 1 method)\n\njulia> test(1,2)\nx is less than y.\n\njulia> test(2,1)\nERROR: UndefVarError: `relation` not defined in local scope\nStacktrace:\n [1] test(::Int64, ::Int64) at ./none:7\n\nif blocks also return a value, which may seem unintuitive to users coming from many other languages.\nThis value is simply the return value of the last executed statement in the branch that was chosen,\nso\n\njulia> x = 3\n3\n\njulia> if x > 0\n           \"positive!\"\n       else\n           \"negative...\"\n       end\n\"positive!\"\n\nNote that very short conditional statements (one-liners) are frequently expressed using Short-Circuit\nEvaluation in Julia, as outlined in the next section.\n\nUnlike C, MATLAB, Perl, Python, and Ruby – but like Java, and a few other stricter, typed languages\n– it is an error if the value of a conditional expression is anything but true or false:\n\njulia> if 1\n           println(\"true\")\n       end\nERROR: TypeError: non-boolean (Int64) used in boolean context\n\nThis error indicates that the conditional was of the wrong type: Int64 rather\nthan the required Bool.\n\nThe so-called \"ternary operator\", ?:, is closely related to the if-elseif-else syntax,\nbut is used where a conditional choice between single expression values is required, as opposed\nto conditional execution of longer blocks of code. It gets its name from being the only operator\nin most languages taking three operands:\n\na ? b : c\n\nThe expression a, before the ?, is a condition expression, and the ternary operation evaluates\nthe expression b, before the :, if the condition a is true or the expression c, after\nthe :, if it is false. Note that the spaces around ? and : are mandatory: an expression\nlike a?b:c is not a valid ternary expression (but a newline is acceptable after both the ? and\nthe :).\n\nThe easiest way to understand this behavior is to see an example. In the previous example, the\nprintln call is shared by all three branches: the only real choice is which literal string to\nprint. This could be written more concisely using the ternary operator. For the sake of clarity,\nlet's try a two-way version first:\n\njulia> x = 1; y = 2;\n\njulia> println(x < y ? \"less than\" : \"not less than\")\nless than\n\njulia> x = 1; y = 0;\n\njulia> println(x < y ? \"less than\" : \"not less than\")\nnot less than\n\nIf the expression x < y is true, the entire ternary operator expression evaluates to the string\n\"less than\" and otherwise it evaluates to the string \"not less than\". The original three-way\nexample requires chaining multiple uses of the ternary operator together:\n\njulia> test(x, y) = println(x < y ? \"x is less than y\"    :\n                            x > y ? \"x is greater than y\" : \"x is equal to y\")\ntest (generic function with 1 method)\n\njulia> test(1, 2)\nx is less than y\n\njulia> test(2, 1)\nx is greater than y\n\njulia> test(1, 1)\nx is equal to y\n\nTo facilitate chaining, the operator associates from right to left.\n\nIt is significant that like if-elseif-else, the expressions before and after the : are\nonly evaluated if the condition expression evaluates to true or false, respectively:\n\njulia> v(x) = (println(x); x)\nv (generic function with 1 method)\n\njulia> 1 < 2 ? v(\"yes\") : v(\"no\")\nyes\n\"yes\"\n\njulia> 1 > 2 ? v(\"yes\") : v(\"no\")\nno\n\"no\""},{"title":"Short-Circuit Evaluation","page":"Control Flow","location":"manual/control-flow.html#Short-Circuit-Evaluation","category":"section","text":"The && and || operators in Julia correspond to logical “and” and “or” operations, respectively,\nand are typically used for this purpose. However, they have an additional property of short-circuit\nevaluation: they don't necessarily evaluate their second argument, as explained below.  (There\nare also bitwise & and | operators that can be used as logical “and” and “or” without\nshort-circuit behavior, but beware that & and | have higher precedence than && and || for evaluation order.)\n\nShort-circuit evaluation is quite similar to conditional evaluation. The behavior is found in\nmost imperative programming languages having the && and || boolean operators: in a series\nof boolean expressions connected by these operators, only the minimum number of expressions are\nevaluated as are necessary to determine the final boolean value of the entire chain. Some\nlanguages (like Python) refer to them as and (&&) and or (||). Explicitly, this means\nthat:\n\nIn the expression a && b, the subexpression b is only evaluated if a evaluates to true.\nIn the expression a || b, the subexpression b is only evaluated if a evaluates to false.\n\nThe reasoning is that a && b must be false if a is false, regardless of the value of\nb, and likewise, the value of a || b must be true if a is true, regardless of the value\nof b. Both && and || associate to the right, but && has higher precedence than || does.\nIt's easy to experiment with this behavior:\n\njulia> t(x) = (println(x); true)\nt (generic function with 1 method)\n\njulia> f(x) = (println(x); false)\nf (generic function with 1 method)\n\njulia> t(1) && t(2)\n1\n2\ntrue\n\njulia> t(1) && f(2)\n1\n2\nfalse\n\njulia> f(1) && t(2)\n1\nfalse\n\njulia> f(1) && f(2)\n1\nfalse\n\njulia> t(1) || t(2)\n1\ntrue\n\njulia> t(1) || f(2)\n1\ntrue\n\njulia> f(1) || t(2)\n1\n2\ntrue\n\njulia> f(1) || f(2)\n1\n2\nfalse\n\nYou can easily experiment in the same way with the associativity and precedence of various combinations\nof && and || operators.\n\nThis behavior is frequently used in Julia to form an alternative to very short if statements.\nInstead of if <cond> <statement> end, one can write <cond> && <statement> (which could be\nread as: <cond> and then <statement>). Similarly, instead of if ! <cond> <statement> end,\none can write <cond> || <statement> (which could be read as: <cond> or else <statement>).\n\nFor example, a recursive factorial routine could be defined like this:\n\njulia> function fact(n::Int)\n           n >= 0 || error(\"n must be non-negative\")\n           n == 0 && return 1\n           n * fact(n-1)\n       end\nfact (generic function with 1 method)\n\njulia> fact(5)\n120\n\njulia> fact(0)\n1\n\njulia> fact(-1)\nERROR: n must be non-negative\nStacktrace:\n [1] error at ./error.jl:33 [inlined]\n [2] fact(::Int64) at ./none:2\n [3] top-level scope\n\nBoolean operations without short-circuit evaluation can be done with the bitwise boolean operators\nintroduced in Mathematical Operations and Elementary Functions: & and |. These are\nnormal functions, which happen to support infix operator syntax, but always evaluate their arguments:\n\njulia> f(1) & t(2)\n1\n2\nfalse\n\njulia> t(1) | t(2)\n1\n2\ntrue\n\nJust like condition expressions used in if, elseif or the ternary operator, the operands of\n&& or || must be boolean values (true or false). Using a non-boolean value anywhere except\nfor the last entry in a conditional chain is an error:\n\njulia> 1 && true\nERROR: TypeError: non-boolean (Int64) used in boolean context\n\nOn the other hand, any type of expression can be used at the end of a conditional chain. It will\nbe evaluated and returned depending on the preceding conditionals:\n\njulia> true && (x = (1, 2, 3))\n(1, 2, 3)\n\njulia> false && (x = (1, 2, 3))\nfalse"},{"title":"Repeated Evaluation: Loops","page":"Control Flow","location":"manual/control-flow.html#man-loops","category":"section","text":"There are two constructs for repeated evaluation of expressions: the while loop and the for\nloop. Here is an example of a while loop:\n\njulia> i = 1;\n\njulia> while i <= 3\n           println(i)\n           global i += 1\n       end\n1\n2\n3\n\nThe while loop evaluates the condition expression (i <= 3 in this case), and as long it remains\ntrue, keeps also evaluating the body of the while loop. If the condition expression is false\nwhen the while loop is first reached, the body is never evaluated.\n\nThe for loop makes common repeated evaluation idioms easier to write. Since counting up and\ndown like the above while loop does is so common, it can be expressed more concisely with a\nfor loop:\n\njulia> for i = 1:3\n           println(i)\n       end\n1\n2\n3\n\nHere the 1:3 is a range object, representing the sequence of numbers 1, 2, 3. The for\nloop iterates through these values, assigning each one in turn to the variable i.\nIn general, the for construct can loop over any \"iterable\" object (or \"container\"), from a  range like 1:3 or 1:3:13 (a StepRange indicating every 3rd integer 1, 4, 7, …, 13) to more generic containers like arrays, including iterators defined by user code\nor external packages. For containers other than ranges, the alternative\n(but fully equivalent) keyword in or ∈ is typically used instead of =, since it makes\nthe code read more clearly:\n\njulia> for i in [1,4,0]\n           println(i)\n       end\n1\n4\n0\n\njulia> for s ∈ [\"foo\",\"bar\",\"baz\"]\n           println(s)\n       end\nfoo\nbar\nbaz\n\nVarious types of iterable containers will be introduced and discussed in later sections of the\nmanual (see, e.g., Multi-dimensional Arrays).\n\nOne rather\nimportant distinction between the previous while loop form and the for loop form is the scope\nduring which the variable is visible. A for loop always introduces a new iteration variable in\nits body, regardless of whether a variable of the same name exists in the enclosing scope.\nThis implies that on the one hand i need not be declared before the loop. On the other hand it\nwill not be visible outside the loop, nor will an outside variable of the same name be affected.\nYou'll either need a new interactive session instance or a different variable\nname to test this:\n\njulia> for j = 1:3\n           println(j)\n       end\n1\n2\n3\n\njulia> j\nERROR: UndefVarError: `j` not defined in `Main`\n\njulia> j = 0;\n\njulia> for j = 1:3\n           println(j)\n       end\n1\n2\n3\n\njulia> j\n0\n\nUse for outer to modify the latter behavior and reuse an existing local variable.\n\nSee Scope of Variables for a detailed explanation of variable scope, outer, and how it works in\nJulia.\n\nIt is sometimes convenient to terminate the repetition of a while before the test condition\nis falsified or stop iterating in a for loop before the end of the iterable object is reached.\nThis can be accomplished with the break keyword:\n\njulia> i = 1;\n\njulia> while true\n           println(i)\n           if i >= 3\n               break\n           end\n           global i += 1\n       end\n1\n2\n3\n\njulia> for j = 1:1000\n           println(j)\n           if j >= 3\n               break\n           end\n       end\n1\n2\n3\n\nWithout the break keyword, the above while loop would never terminate on its own, and the for loop would iterate up to 1000. These loops are both exited early by using break.\n\nIn other circumstances, it is handy to be able to stop an iteration and move on to the next one\nimmediately. The continue keyword accomplishes this:\n\njulia> for i = 1:10\n           if i % 3 != 0\n               continue\n           end\n           println(i)\n       end\n3\n6\n9\n\nThis is a somewhat contrived example since we could produce the same behavior more clearly by\nnegating the condition and placing the println call inside the if block. In realistic usage\nthere is more code to be evaluated after the continue, and often there are multiple points from\nwhich one calls continue.\n\nMultiple nested for loops can be combined into a single outer loop, forming the cartesian product\nof its iterables:\n\njulia> for i = 1:2, j = 3:4\n           println((i, j))\n       end\n(1, 3)\n(1, 4)\n(2, 3)\n(2, 4)\n\nWith this syntax, iterables may still refer to outer loop variables; e.g. for i = 1:n, j = 1:i\nis valid.\nHowever a break statement inside such a loop exits the entire nest of loops, not just the inner one.\nBoth variables (i and j) are set to their current iteration values each time the inner loop runs.\nTherefore, assignments to i will not be visible to subsequent iterations:\n\njulia> for i = 1:2, j = 3:4\n           println((i, j))\n           i = 0\n       end\n(1, 3)\n(1, 4)\n(2, 3)\n(2, 4)\n\nIf this example were rewritten to use a for keyword for each variable, then the output would\nbe different: the second and fourth values would contain 0.\n\nMultiple containers can be iterated over at the same time in a single for loop using zip:\n\njulia> for (j, k) in zip([1 2 3], [4 5 6 7])\n           println((j,k))\n       end\n(1, 4)\n(2, 5)\n(3, 6)\n\nUsing zip will create an iterator that is a tuple containing the subiterators for the containers passed to it.\nThe zip iterator will iterate over all subiterators in order, choosing the ith element of each subiterator in the\nith iteration of the for loop. Once any of the subiterators run out, the for loop will stop."},{"title":"Exception Handling","page":"Control Flow","location":"manual/control-flow.html#Exception-Handling","category":"section","text":"When an unexpected condition occurs, a function may be unable to return a reasonable value to\nits caller. In such cases, it may be best for the exceptional condition to either terminate the\nprogram while printing a diagnostic error message, or if the programmer has provided code to handle\nsuch exceptional circumstances then allow that code to take the appropriate action."},{"title":"Built-in Exceptions","page":"Control Flow","location":"manual/control-flow.html#Built-in-Exceptions","category":"section","text":"Exceptions are thrown when an unexpected condition has occurred. The built-in Exceptions listed\nbelow all interrupt the normal flow of control.\n\nException\nArgumentError\nBoundsError\nCompositeException\nDimensionMismatch\nDivideError\nDomainError\nEOFError\nErrorException\nFieldError\nInexactError\nInitError\nInterruptException\nInvalidStateException\nKeyError\nLoadError\nOutOfMemoryError\nReadOnlyMemoryError\nRemoteException\nMethodError\nOverflowError\nMeta.ParseError\nSystemError\nTypeError\nUndefRefError\nUndefVarError\nStringIndexError\n\nFor example, the sqrt function throws a DomainError if applied to a negative\nreal value:\n\njulia> sqrt(-1)\nERROR: DomainError with -1.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n\nYou may define your own exceptions in the following way:\n\njulia> struct MyCustomException <: Exception end"},{"title":"The throw function","page":"Control Flow","location":"manual/control-flow.html#The-[throw](@ref)-function","category":"section","text":"Exceptions can be created explicitly with throw. For example, a function defined only\nfor non-negative numbers could be written to throw a DomainError if the argument\nis negative:\n\njulia> f(x) = x>=0 ? exp(-x) : throw(DomainError(x, \"argument must be non-negative\"))\nf (generic function with 1 method)\n\njulia> f(1)\n0.36787944117144233\n\njulia> f(-1)\nERROR: DomainError with -1:\nargument must be non-negative\nStacktrace:\n [1] f(::Int64) at ./none:1\n\nNote that DomainError without parentheses is not an exception, but a type of exception.\nIt needs to be called to obtain an Exception object:\n\njulia> typeof(DomainError(nothing)) <: Exception\ntrue\n\njulia> typeof(DomainError) <: Exception\nfalse\n\nAdditionally, some exception types take one or more arguments that are used for error reporting:\n\njulia> throw(UndefVarError(:x))\nERROR: UndefVarError: `x` not defined\n\nThis mechanism can be implemented easily by custom exception types following the way UndefVarError\nis written:\n\njulia> struct MyUndefVarError <: Exception\n           var::Symbol\n       end\n\njulia> Base.showerror(io::IO, e::MyUndefVarError) = print(io, e.var, \" not defined\")\n\nnote: Note\nWhen writing an error message, it is preferred to make the first word lowercase. For example,size(A) == size(B) || throw(DimensionMismatch(\"size of A not equal to size of B\"))is preferred oversize(A) == size(B) || throw(DimensionMismatch(\"Size of A not equal to size of B\")).However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument\nto a function is a capital letter:size(A,1) == size(B,2) || throw(DimensionMismatch(\"A has first dimension...\"))."},{"title":"Errors","page":"Control Flow","location":"manual/control-flow.html#Errors","category":"section","text":"The error function is used to produce an ErrorException that interrupts\nthe normal flow of control.\n\nSuppose we want to stop execution immediately if the square root of a negative number is taken.\nTo do this, we can define a fussy version of the sqrt function that raises an error\nif its argument is negative:\n\njulia> fussy_sqrt(x) = x >= 0 ? sqrt(x) : error(\"negative x not allowed\")\nfussy_sqrt (generic function with 1 method)\n\njulia> fussy_sqrt(2)\n1.4142135623730951\n\njulia> fussy_sqrt(-1)\nERROR: negative x not allowed\nStacktrace:\n [1] error at ./error.jl:33 [inlined]\n [2] fussy_sqrt(::Int64) at ./none:1\n [3] top-level scope\n\nIf fussy_sqrt is called with a negative value from another function, instead of trying to continue\nexecution of the calling function, it returns immediately, displaying the error message in the\ninteractive session:\n\njulia> function verbose_fussy_sqrt(x)\n           println(\"before fussy_sqrt\")\n           r = fussy_sqrt(x)\n           println(\"after fussy_sqrt\")\n           return r\n       end\nverbose_fussy_sqrt (generic function with 1 method)\n\njulia> verbose_fussy_sqrt(2)\nbefore fussy_sqrt\nafter fussy_sqrt\n1.4142135623730951\n\njulia> verbose_fussy_sqrt(-1)\nbefore fussy_sqrt\nERROR: negative x not allowed\nStacktrace:\n [1] error at ./error.jl:33 [inlined]\n [2] fussy_sqrt at ./none:1 [inlined]\n [3] verbose_fussy_sqrt(::Int64) at ./none:3\n [4] top-level scope"},{"title":"The try/catch statement","page":"Control Flow","location":"manual/control-flow.html#The-try/catch-statement","category":"section","text":"The try/catch statement allows for Exceptions to be tested for, and for the\ngraceful handling of things that may ordinarily break your application. For example,\nin the below code the function for square root would normally throw an exception. By\nplacing a try/catch block around it we can mitigate that here. You may choose how\nyou wish to handle this exception, whether logging it, return a placeholder value or\nas in the case below where we just printed out a statement. One thing to think about\nwhen deciding how to handle unexpected situations is that using a try/catch block is\nmuch slower than using conditional branching to handle those situations.\nBelow there are more examples of handling exceptions with a try/catch block:\n\njulia> try\n           sqrt(\"ten\")\n       catch e\n           println(\"You should have entered a numeric value\")\n       end\nYou should have entered a numeric value\n\ntry/catch statements also allow the Exception to be saved in a variable. The following\ncontrived example calculates the square root of the second element of x if x\nis indexable, otherwise assumes x is a real number and returns its square root:\n\njulia> sqrt_second(x) = try\n           sqrt(x[2])\n       catch y\n           if isa(y, DomainError)\n               sqrt(complex(x[2], 0))\n           elseif isa(y, BoundsError)\n               sqrt(x)\n           else\n               rethrow() # ensure other exceptions can bubble up the call stack\n           end\n       end\nsqrt_second (generic function with 1 method)\n\njulia> sqrt_second([1 4])\n2.0\n\njulia> sqrt_second([1 -4])\n0.0 + 2.0im\n\njulia> sqrt_second(9)\n3.0\n\njulia> sqrt_second(-9)\nERROR: DomainError with -9.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n\njulia> sqrt_second([1 nothing])\nERROR: MethodError: no method matching sqrt(::Nothing)\nThe function `sqrt` exists, but no method is defined for this combination of argument types.\n[...]\n\nUse rethrow as above to continue unwinding the stack with the original exception so that\nhigher-level exception handlers can deal with the exception. When filtering by exception type\nas above, it is often important to include else rethrow() so that other types of exceptions\nare not hidden from the caller.\n\nNote that the symbol following catch will always be interpreted as a name for the exception,\nso care is needed when writing try/catch expressions on a single line. The following code will\nnot work to return the value of x in case of an error:\n\ntry bad() catch x end\n\nInstead, use a semicolon or insert a line break after catch:\n\ntry bad() catch; x end\n\ntry bad()\ncatch\n    x\nend\n\nThe power of the try/catch construct lies in the ability to unwind a deeply nested computation\nimmediately to a much higher level in the stack of calling functions. There are situations where\nno error has occurred, but the ability to unwind the stack and pass a value to a higher level\nis desirable. Julia provides the backtrace, catch_backtrace\nand current_exceptions functions for more advanced error handling."},{"title":"else Clauses","page":"Control Flow","location":"manual/control-flow.html#else-Clauses","category":"section","text":"compat: Julia 1.8\nThis functionality requires at least Julia 1.8.\n\nIn some cases, one may not only want to appropriately handle the error case, but also want to run\nsome code only if the try block succeeds. For this, an else clause can be specified after the\ncatch block that is run whenever no error was thrown previously. The advantage over including\nthis code in the try block instead is that any further errors don't get silently caught by the\ncatch clause.\n\nlocal x\ntry\n    x = read(\"file\", String)\ncatch\n    # handle read errors\nelse\n    # do something with x\nend\n\nnote: Note\nThe try, catch, else, and finally clauses each introduce their own scope blocks, so if\na variable is only defined in the try block, it can not be accessed by the else or finally\nclause:julia> try\n           foo = 1\n       catch\n       else\n           foo\n       end\nERROR: UndefVarError: `foo` not defined in `Main`\nSuggestion: check for spelling errors or missing imports.Use the local keyword outside the try block to make the variable\naccessible from anywhere within the outer scope."},{"title":"finally Clauses","page":"Control Flow","location":"manual/control-flow.html#finally-Clauses","category":"section","text":"In code that performs state changes or uses resources like files, there is typically clean-up\nwork (such as closing files) that needs to be done when the code is finished. Exceptions potentially\ncomplicate this task, since they can cause a block of code to exit before reaching its normal\nend. The finally keyword provides a way to run some code when a given block of code exits, regardless\nof how it exits.\n\nFor example, here is how we can guarantee that an opened file is closed:\n\nf = open(\"file\")\ntry\n    # operate on file f\nfinally\n    close(f)\nend\n\nWhen control leaves the try block (for example due to a return, or just finishing normally),\nclose(f) will be executed. If the try block exits due to an exception, the exception will\ncontinue propagating. A catch block may be combined with try and finally as well. In this\ncase the finally block will run after catch has handled the error.\n\nWhen evaluating a try/catch/else/finally expression, the value of the entire\nexpression is the value of the last block executed, excluding the finally\nblock. For example:\n\njulia> try\n           1\n       finally\n           2\n       end\n1\n\njulia> try\n           error(\"\")\n       catch\n           1\n       else\n           2\n       finally\n           3\n       end\n1\n\njulia> try\n           0\n       catch\n           1\n       else\n           2\n       finally\n           3\n       end\n2"},{"title":"Tasks (aka Coroutines)","page":"Control Flow","location":"manual/control-flow.html#man-tasks","category":"section","text":"Tasks are a control flow feature that allows computations to be suspended and resumed in a flexible\nmanner. We mention them here only for completeness; for a full discussion see\nAsynchronous Programming."},{"title":"Proper maintenance and care of multi-threading locks","page":"Proper maintenance and care of multi-threading locks","location":"devdocs/locks.html#Proper-maintenance-and-care-of-multi-threading-locks","category":"section","text":"The following strategies are used to ensure that the code is dead-lock free (generally by addressing\nthe 4th Coffman condition: circular wait).\n\nstructure code such that only one lock will need to be acquired at a time\nalways acquire shared locks in the same order, as given by the table below\navoid constructs that expect to need unrestricted recursion"},{"title":"Types of locks","page":"Proper maintenance and care of multi-threading locks","location":"devdocs/locks.html#Types-of-locks","category":"section","text":"uv_mutex_t (or std::mutex) is a wrapper around platform-specific locks\n(pthread_mutex_t on Unix, CRITICAL_SECTION on Windows).  It may cause the\ncurrent OS thread to block, is not reentrant, and is not a safepoint.\n\njl_mutex_t is a reentrant spinlock.  jl_mutex_ts acquired in a try block\nwill be unlocked when we leave the block, either by reaching the end or catching\nan exception.  JL_LOCK/JL_UNLOCK are safepoints, while\nJL_LOCK_NOGC/JL_UNLOCK_NOGC are not.  jl_mutex_t must not be held across\ntask switches."},{"title":"Lock hierarchy","page":"Proper maintenance and care of multi-threading locks","location":"devdocs/locks.html#Lock-hierarchy","category":"section","text":"Below are all of the locks that exist in the system and the mechanisms for using\nthem that avoid the potential for deadlocks (no Ostrich algorithm allowed here).\nExcept in the special cases where a rule for avoiding deadlock is given, no lock\nof a lower level may acquire a lock at a higher level."},{"title":"Level 1","page":"Proper maintenance and care of multi-threading locks","location":"devdocs/locks.html#Level-1","category":"section","text":"No other lock may be acquired when one of these locks is held.  As a result, the\ncode must not do any allocation or hit any safepoints. Note that there are\nsafepoints when doing allocation, enabling/disabling GC, entering/restoring\nexception frames, and taking/releasing locks.\n\nsafepoint_lock (uv_mutex_t)\ndanger: Danger\nThis lock is acquired implicitly by JL_LOCK and JL_UNLOCK. Use the\n_NOGC variants to avoid that for level 1 locks.\nshared_map_lock.mtx (uv_mutex_t)\nfinalizers_lock (jl_mutex_t)\ngc_pages_lock (uv_mutex_t)\ngc_perm_lock (uv_mutex_t)\ngc_queue_observer_lock (uv_mutex_t)\ngc_threads_lock (uv_mutex_t)\nflisp_lock (uv_mutex_t)\nnote: Note\nflisp itself is already threadsafe; this lock only protects the\njl_ast_context_list_t pool.  Likewise, the ResourcePool<?>::mutexes\njust protect the associated resource pool.\nResourcePool<?>.mutex (std::mutex)\nRLST_mutex (std::mutex)\nllvm_printing_mutex (std::mutex)\njl_locked_stream.mutex (std::mutex)\ndebuginfo_asyncsafe (uv_rwlock_t) (can still acquire jl_in_stackwalk (uv_mutex_t, Win32 only))\nprofile_show_peek_cond_lock (jl_mutex_t)\ntrampoline_lock (uv_mutex_t)\nbt_data_prof_lock (uv_mutex_t)\njl_ptls_t.sleep_lock (uv_mutex_t)\ntls_lock (uv_mutex_t)\npage_profile_lock (uv_mutex_t)\nsymtab_lock (uv_mutex_t)\nengine_lock (std::mutex)"},{"title":"Level 2","page":"Proper maintenance and care of multi-threading locks","location":"devdocs/locks.html#Level-2","category":"section","text":"global_roots_lock\njl_module_t.lock\nnewly_inferred_mutex\nJLDebuginfoPlugin.PluginMutex (std::mutex)\nprecompile_field_replace_lock\nlive_tasks_lock (uv_mutex_t)\nheapsnapshot_lock\njitlock\njl_safepoint_suspend_all_threads and jl_safepoint_resume_all_threads\nnote: Note\nInside a region protected by these functions, all other threads are\nblocked inside a safepoint.  It is unsafe to take locks that may safepoint\nin this region."},{"title":"Level 3","page":"Proper maintenance and care of multi-threading locks","location":"devdocs/locks.html#Level-3","category":"section","text":"jl_method_t.writelock\ntypecache_lock\nlibmap_lock"},{"title":"Level 4","page":"Proper maintenance and care of multi-threading locks","location":"devdocs/locks.html#Level-4","category":"section","text":"jl_methcache_t.writelock"},{"title":"Level 5","page":"Proper maintenance and care of multi-threading locks","location":"devdocs/locks.html#Level-5","category":"section","text":"jl_methtable_t.writelock"},{"title":"Level 6","page":"Proper maintenance and care of multi-threading locks","location":"devdocs/locks.html#Level-6","category":"section","text":"No Julia code may be called while holding a lock above this point.\n\nworld_counter_lock\njl_typeinf_lock"},{"title":"Level 7","page":"Proper maintenance and care of multi-threading locks","location":"devdocs/locks.html#Level-7","category":"section","text":"JuliaOJIT::EmissionMutex (std::recursive_mutex)\njl_modules_mutex\njl_uv_mutex (known as iolock from Julia)\ndanger: Danger\nDoing any I/O (for example, printing warning messages or debug information)\nwhile holding any other lock listed above may result in pernicious and\nhard-to-find deadlocks.\nIndividual ThreadSynchronizer locks\ndanger: Danger\nThis may continue to be held after releasing the iolock, or acquired\nwithout it, but be very careful to never attempt to acquire the iolock\nwhile holding it.\nLibdl.LazyLibrary.lock (ReentrantLock)\norc::ThreadSafeContext\ncfun_lock"},{"title":"Level 8","page":"Proper maintenance and care of multi-threading locks","location":"devdocs/locks.html#Level-8","category":"section","text":"precomp_statement_out_lock\ndispatch_statement_out_lock"},{"title":"Exceptions to the lock hierarchy","page":"Proper maintenance and care of multi-threading locks","location":"devdocs/locks.html#Exceptions-to-the-lock-hierarchy","category":"section","text":"Ordinarily, it is forbidden to acquire locks of equal level to a lock already\nheld.  In these specific cases we use a special protocol for acquiring locks at\nthe same level:\n\njl_method_t.writelock\nInvalidation acquires the lock for every method during its depth-first search\nfor backedges.  To avoid deadlocks, we must already hold world_counter_lock\nbefore acquiring multiple jl_method_t.writelocks."},{"title":"Broken locks","page":"Proper maintenance and care of multi-threading locks","location":"devdocs/locks.html#Broken-locks","category":"section","text":"The following locks are broken:\n\nloading.jl: require and register_root_module\nThis file potentially has numerous problems. (fix: needs locks)"},{"title":"Updates to the world counter","page":"Proper maintenance and care of multi-threading locks","location":"devdocs/locks.html#Updates-to-the-world-counter","category":"section","text":"Thanks to the world age mechanism, Julia can allow the\nreplacement of both methods and bindings, yet remain amenable to optimization.\nEvery compiled CodeInstance has a range of valid world ages; we could\nconservatively assume all CIs are stale after a world age increment.  However,\nto avoid spurious recompilation, we track dependencies, called \"edges\", while\nmaintaining the following invariant:\n\nFor every published CodeInstance, either:\n\nmin_world and max_world are finite, and the CI is valid for every world\nin that range.\nmax_world is ∞ (-1), and this CI is ready for invalidation, meaning\nfor every forward edge:\nIf the edge is a CodeInstance that is invoked or inlined into this CI,\nthe edge's MethodInstance backedge array has an entry pointing back.\nIf the edge is a Binding:\nIf the binding is in another module, it has an entry for this CI in its\nbackedges array.\nIf the binding is in the same module, the Method for this CI is in the\nmodule's scanned_methods array.\n\nFor example, the following code replaces a constant in another module, causing a\nchain of invalidations:\n\nconst c1 = 1\nmodule M const c2 = 2 end\nf() = getfield(M, :c2)\ng() = f() + c1\n\ng()                   # compile g\n\n@eval M const c2 = 3  # invalidate f, g\ng()                   # recompile g\n\nAfter compiling the two versions of g(), the global cache looks like this:\n(Image: Global cache state after invalidation)\n\nThe maximum world age, jl_world_counter, is protected by the\nworld_counter_lock.  Julia uses a form of optimistic concurrency control to\nallow type inference without holding world_counter_lock.\n\nPublishing a new method or binding follows these steps:\n\nAcquire world_counter_lock.\nRelaxed-load jl_world_counter and let new_world = jl_world_counter + 1.\nPublish the new binding partitions or method table entries with world range\n[new_world, ∞).  This step is described in the section on the [lock free\ndata structures](@ref man-lock-free-data).\nRelease-store new_world to jl_world_counter.\nRelease world_counter_lock.\n\nType inference proceeds like so:\n\nAcquire-load jl_world_counter (call this validation_world).\nPerform type inference in that world, reading the bindings and method table in\nthat world using the lock-free data structures.\nStore back edges for every inferred CodeInstance:\nFor non-local bindings, this acquires the binding's module's lock.\nFor CIs, this acquires the method's lock.\nAcquire world_counter_lock.\nRelaxed-load jl_world_counter and compare it to validation_world:\nIf it is different, leave the valid world ranges for the inferred CIs\nunchanged.\nIf it is unchanged, our optimism was rewarded.  We can promote all the\ninferred CIs valid in validation_world to [validation_world, ∞) and rely\non the backedges for invalidation.\nRelease world_counter_lock.\n\n(Image: Two threads doing type inference while another adds a method)\n\nIn the above diagram, threads 1 and 2 are doing type inference (the dotted\nline), while thread 3 is activating a new method.  The solid boxes represent\ncritical sections where the world_counter_lock is held.  acq, rel, and\nread, are acquire loads, release stores, and relaxed loads respectively.\n\nT1 promotes its CI in time, but T2 takes too long, blocking on\nworld_counter_lock until T3 has finished publishing the new method and\nincrementing the world counter.  It reads W+1 and fails to promote its CI,\nleaving it with a maximum world of W."},{"title":"Lock free data structures","page":"Proper maintenance and care of multi-threading locks","location":"devdocs/locks.html#man-lock-free-data","category":"section","text":"TODO"},{"title":"Julia + MMTk","page":"Julia + MMTk","location":"devdocs/gc-mmtk.html#Julia-MMTk","category":"section","text":"There has been quite a lot of effort to refactor the GC code inside Julia to support external GCs. The first step to enable using different GC algorithms for Julia was the design and implementation of a GC interface. To drive that interface, we added support for building Julia with MMTk (Memory Management Toolkit). Using Julia + MMTk enables testing different GC implementations, allowing developers to choose a specific implementation when building Julia from source. The connection between Julia and MMTk is done via a binding, which links the language runtime with MMTk core. The mmtk-julia binding is written in Rust and can be found in this repository.\n\n[!NOTE]\nUsing a different GC requires building Julia from source. It is not possible to switch implementations at runtime. To see what version of the GC is currently being used, run versioninfo() from the Julia REPL and it should show the version under GC: ...."},{"title":"Building Julia with MMTk","page":"Julia + MMTk","location":"devdocs/gc-mmtk.html#Building-Julia-with-MMTk","category":"section","text":"There are 3 different ways of building Julia with MMTk: building from source using a fixed release of the binding, checking out a custom version in the mmtk-julia repository or using a precompiled binary from Julia's BinaryBuilder. The easiest way is to use the BinaryBuilder binary. First, to enable MMTk as a third-party GC, set the variable WITH_THIRD_PARTY_GC to mmtk. Then, for example, to use the Immix as the GC, simply set the variable MMTK_PLAN=Immix and build Julia as usual.\n\nThere are different configurations supported by the following variables, which can be set in a Make.user file or as an environment variable. Note that at this time, setting MMTK_PLAN=StickyImmix (to use a generational version of Immix) or MMTK_MOVING=1 (to enable object movement) will likely cause segmentation faults or other build failures, since we have not added support for these configurations yet. Setting MMTK_BUILD=debug will force a debug build of the binding, which will print some logging information that can be used to find errors that are specific to MMTk.\n\nVariable  \nMMTK_PLAN Immix StickyImmix\nMMTK_MOVING 0 1\nMMTK_BUILD release debug\n\nNote that when setting only MMTK_PLAN, then the default is to do a non-moving, release build."},{"title":"Building mmtk-julia from source","page":"Julia + MMTk","location":"devdocs/gc-mmtk.html#Building-mmtk-julia-from-source","category":"section","text":"It is also possible to build the binding from source. To do so, set the variable USE_BINARYBUILDER_MMTK_JULIA=0 and the latest release version of the binding will be downloaded and built as part of building Julia. Note that this requires an installation of the rust toolchain.\n\nIt is also possible to build a custom version of binding by checking it out from the git repository and setting a variable named MMTK_JULIA_DIR as the path that contains the binding.\n\nFor more information on building Julia with MMTk, please refer to the README file in the binding repo."},{"title":"I've got a build error when building Julia with MMTk, what should I do?","page":"Julia + MMTk","location":"devdocs/gc-mmtk.html#I've-got-a-build-error-when-building-Julia-with-MMTk,-what-should-I-do?","category":"section","text":"If you try to build Julia with MMTk and get an error it is likely due to a change to Julia that has not been yet propagated to the binding or to the code in Julia that is specific to MMTk. Some changes include:\n\n(1) Changing the memory layout of objects in Julia. The binding relies on automatically generated Rust FFI bindings from Julia code. These files are generated using a crate named rust-bindgen. To regenerate those files, check out the latest version of the mmtk-julia binding, set the variable JULIA_PATH to the path of the Julia version you are trying to build and run make regen-bindgen-ffi from the directory containing the binding. This should delete the current version of the FFI bindings and generate a new version based on the Julia code from JULIA_PATH.\n\n(2) Changing the root objects passed to the GC. Julia passes a set of objects to the GC as roots in the function gcmarkroots. At the moment, this set needs to be consistent between both the Stock GC and MMTk (in the function jl_gc_scan_vm_specific_roots).\n\n(3) Changing how objects are scanned. MMTk uses the same strategy to find references in Julia objects as the stock GC (see gcmarkoutrefs). Changing the logic from this function should be reflected in the Rust code in the binding that scan Julia objects.\n\nIf your case is not included in one of the alternatives above, please create an issue in the Julia repository tagging it with the GC: MMTK label."},{"title":"C Interface","page":"C Interface","location":"base/c.html#C-Interface","category":"section","text":""},{"title":"LLVM Interface","page":"C Interface","location":"base/c.html#LLVM-Interface","category":"section","text":""},{"title":"Base.@ccall","page":"C Interface","location":"base/c.html#Base.@ccall","category":"macro","text":"@ccall library.function_name(argvalue1::argtype1, ...)::returntype\n@ccall function_name(argvalue1::argtype1, ...)::returntype\n@ccall $function_pointer(argvalue1::argtype1, ...)::returntype\n\nCall a function in a C-exported shared library, specified by\nlibrary.function_name, where library is a string constant or\nliteral. The library may be omitted, in which case the function_name\nis resolved in the current process. Alternatively, @ccall may\nalso be used to call a function pointer $function_pointer, such as\none returned by dlsym.\n\nEach argvalue to @ccall is converted to the corresponding\nargtype, by automatic insertion of calls to unsafe_convert(argtype, cconvert(argtype, argvalue)). (See also the documentation for\nunsafe_convert and [cconvert](@ref\nBase.cconvert) for further details.) In most cases, this simply\nresults in a call to convert(argtype, argvalue).\n\nExamples\n\n@ccall strlen(s::Cstring)::Csize_t\n\nThis calls the C standard library function:\n\nsize_t strlen(char *)\n\nwith a Julia variable named s. See also ccall.\n\nVarargs are supported with the following convention:\n\n@ccall printf(\"%s = %d\"::Cstring ; \"foo\"::Cstring, foo::Cint)::Cint\n\nThe semicolon is used to separate required arguments (of which there\nmust be at least one) from variadic arguments.\n\nExample using an external library:\n\n# C signature of g_uri_escape_string:\n# char *g_uri_escape_string(const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8);\n\nconst glib = \"libglib-2.0\"\n@ccall glib.g_uri_escape_string(my_uri::Cstring, \":/\"::Cstring, true::Cint)::Cstring\n\nThe string literal could also be used directly before the function\nname, if desired \"libglib-2.0\".g_uri_escape_string(...\n\nIt's possible to declare the ccall as gc_safe by using the gc_safe = true option:\n\n@ccall gc_safe=true strlen(s::Cstring)::Csize_t\n\nThis allows the garbage collector to run concurrently with the ccall, which can be useful whenever\nthe ccall may block outside of julia.\n\nwarning: Warning\nThis option should be used with caution, as it can lead to undefined behavior if the ccall\ncalls back into the julia runtime. (@cfunction/@ccallables are safe however)\n\ncompat: Julia 1.12\nThe gc_safe argument requires Julia 1.12 or higher.\n\n\n\n\n\n"},{"title":"ccall","page":"C Interface","location":"base/c.html#ccall","category":"keyword","text":"ccall((function_name, library), returntype, (argtype1, ...), argvalue1, ...)\nccall(function_name, returntype, (argtype1, ...), argvalue1, ...)\nccall(function_pointer, returntype, (argtype1, ...), argvalue1, ...)\n\nCall a function in a C-exported shared library, specified by the tuple (function_name, library),\nwhere each component is either a string or symbol. Instead of specifying a library,\none can also use a function_name symbol or string, which is resolved in the current process.\nAlternatively, ccall may also be used to call a function pointer function_pointer, such as one returned by dlsym.\n\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued\nvariable or expression.\n\nEach argvalue to the ccall will be converted to the corresponding\nargtype, by automatic insertion of calls to unsafe_convert(argtype, cconvert(argtype, argvalue)). (See also the documentation for\nunsafe_convert and cconvert for further details.)\nIn most cases, this simply results in a call to convert(argtype, argvalue).\n\n\n\n\n\n"},{"title":"Core.Intrinsics.cglobal","page":"C Interface","location":"base/c.html#Core.Intrinsics.cglobal","category":"function","text":"cglobal((symbol, library) [, type=Cvoid])\n\nObtain a pointer to a global variable in a C-exported shared library, specified exactly as\nin ccall.\nReturns a Ptr{Type}, defaulting to Ptr{Cvoid} if no Type argument is\nsupplied.\nThe values can be read or written by unsafe_load or unsafe_store!,\nrespectively.\n\n\n\n\n\n"},{"title":"Base.@cfunction","page":"C Interface","location":"base/c.html#Base.@cfunction","category":"macro","text":"@cfunction(callable, ReturnType, (ArgumentTypes...,)) -> Ptr{Cvoid}\n@cfunction($callable, ReturnType, (ArgumentTypes...,)) -> CFunction\n\nGenerate a C-callable function pointer from the Julia function callable\nfor the given type signature.\nTo pass the return value to a ccall, use the argument type Ptr{Cvoid} in the signature.\n\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression\n(although it can include a splat expression). And that these arguments will be evaluated in global scope\nduring compile-time (not deferred until runtime).\nAdding a '$' in front of the function argument changes this to instead create a runtime closure\nover the local variable callable (this is not supported on all architectures).\n\nSee manual section on ccall and cfunction usage.\n\nExamples\n\njulia> function foo(x::Int, y::Int)\n           return x + y\n       end\n\njulia> @cfunction(foo, Int, (Int, Int))\nPtr{Cvoid} @0x000000001b82fcd0\n\n\n\n\n\n"},{"title":"Base.CFunction","page":"C Interface","location":"base/c.html#Base.CFunction","category":"type","text":"CFunction struct\n\nGarbage-collection handle for the return value from @cfunction\nwhen the first argument is annotated with '$'.\nLike all cfunction handles, it should be passed to ccall as a Ptr{Cvoid},\nand will be converted automatically at the call site to the appropriate type.\n\nSee @cfunction.\n\n\n\n\n\n"},{"title":"Base.unsafe_convert","page":"C Interface","location":"base/c.html#Base.unsafe_convert","category":"function","text":"unsafe_convert(T, x)\n\nConvert x to a C argument of type T\nwhere the input x must be the return value of cconvert(T, ...).\n\nIn cases where convert would need to take a Julia object\nand turn it into a Ptr, this function should be used to define and perform\nthat conversion.\n\nBe careful to ensure that a Julia reference to x exists as long as the result of this\nfunction will be used. Accordingly, the argument x to this function should never be an\nexpression, only a variable name or field reference. For example, x=a.b.c is acceptable,\nbut x=[a,b,c] is not.\n\nThe unsafe prefix on this function indicates that using the result of this function after\nthe x argument to this function is no longer accessible to the program may cause undefined\nbehavior, including program corruption or segfaults, at any later time.\n\nSee also cconvert\n\n\n\n\n\n"},{"title":"Base.cconvert","page":"C Interface","location":"base/c.html#Base.cconvert","category":"function","text":"cconvert(T,x)\n\nConvert x to a value to be passed to C code as type T, typically by calling convert(T, x).\n\nIn cases where x cannot be safely converted to T, unlike convert, cconvert may\nreturn an object of a type different from T, which however is suitable for\nunsafe_convert to handle. The result of this function should be kept valid (for the GC)\nuntil the result of unsafe_convert is not needed anymore.\nThis can be used to allocate memory that will be accessed by the ccall.\nIf multiple objects need to be allocated, a tuple of the objects can be used as return value.\n\nNeither convert nor cconvert should take a Julia object and turn it into a Ptr.\n\n\n\n\n\n"},{"title":"Base.unsafe_load","page":"C Interface","location":"base/c.html#Base.unsafe_load","category":"function","text":"unsafe_load(p::Ptr{T}, i::Integer=1)\nunsafe_load(p::Ptr{T}, order::Symbol)\nunsafe_load(p::Ptr{T}, i::Integer, order::Symbol)\n\nLoad a value of type T from the address of the ith element (1-indexed) starting at p.\nThis is equivalent to the C expression p[i-1]. Optionally, an atomic memory ordering can\nbe provided.\n\nThe unsafe prefix on this function indicates that no validation is performed on the\npointer p to ensure that it is valid. Like C, the programmer is responsible for ensuring\nthat referenced memory is not freed or garbage collected while invoking this function.\nIncorrect usage may segfault your program or return garbage answers. Unlike C, dereferencing\nmemory region allocated as different type may be valid provided that the types are compatible.\n\ncompat: Julia 1.10\nThe order argument is available as of Julia 1.10.\n\nSee also: atomic\n\n\n\n\n\n"},{"title":"Base.unsafe_store!","page":"C Interface","location":"base/c.html#Base.unsafe_store!","category":"function","text":"unsafe_store!(p::Ptr{T}, x, i::Integer=1)\nunsafe_store!(p::Ptr{T}, x, order::Symbol)\nunsafe_store!(p::Ptr{T}, x, i::Integer, order::Symbol)\n\nStore a value of type T to the address of the ith element (1-indexed) starting at p.\nThis is equivalent to the C expression p[i-1] = x. Optionally, an atomic memory ordering\ncan be provided.\n\nThe unsafe prefix on this function indicates that no validation is performed on the\npointer p to ensure that it is valid. Like C, the programmer is responsible for ensuring\nthat referenced memory is not freed or garbage collected while invoking this function.\nIncorrect usage may segfault your program. Unlike C, storing memory region allocated as\ndifferent type may be valid provided that the types are compatible.\n\ncompat: Julia 1.10\nThe order argument is available as of Julia 1.10.\n\nSee also: atomic\n\n\n\n\n\n"},{"title":"Base.unsafe_modify!","page":"C Interface","location":"base/c.html#Base.unsafe_modify!","category":"function","text":"unsafe_modify!(p::Ptr{T}, op, x, [order::Symbol])::Pair\n\nThese atomically perform the operations to get and set a memory address after applying\nthe function op. If supported by the hardware (for example, atomic increment), this may be\noptimized to the appropriate hardware instruction, otherwise its execution will be\nsimilar to:\n\ny = unsafe_load(p)\nz = op(y, x)\nunsafe_store!(p, z)\nreturn y => z\n\nThe unsafe prefix on this function indicates that no validation is performed on the\npointer p to ensure that it is valid. Like C, the programmer is responsible for ensuring\nthat referenced memory is not freed or garbage collected while invoking this function.\nIncorrect usage may segfault your program.\n\ncompat: Julia 1.10\nThis function requires at least Julia 1.10.\n\nSee also: modifyproperty!, atomic\n\n\n\n\n\n"},{"title":"Base.unsafe_replace!","page":"C Interface","location":"base/c.html#Base.unsafe_replace!","category":"function","text":"unsafe_replace!(p::Ptr{T}, expected, desired,\n               [success_order::Symbol[, fail_order::Symbol=success_order]]) -> (; old, success::Bool)\n\nThese atomically perform the operations to get and conditionally set a memory address to\na given value. If supported by the hardware, this may be optimized to the appropriate\nhardware instruction, otherwise its execution will be similar to:\n\ny = unsafe_load(p, fail_order)\nok = y === expected\nif ok\n    unsafe_store!(p, desired, success_order)\nend\nreturn (; old = y, success = ok)\n\nThe unsafe prefix on this function indicates that no validation is performed on the\npointer p to ensure that it is valid. Like C, the programmer is responsible for ensuring\nthat referenced memory is not freed or garbage collected while invoking this function.\nIncorrect usage may segfault your program.\n\ncompat: Julia 1.10\nThis function requires at least Julia 1.10.\n\nSee also: replaceproperty!, atomic\n\n\n\n\n\n"},{"title":"Base.unsafe_swap!","page":"C Interface","location":"base/c.html#Base.unsafe_swap!","category":"function","text":"unsafe_swap!(p::Ptr{T}, x, [order::Symbol])\n\nThese atomically perform the operations to simultaneously get and set a memory address.\nIf supported by the hardware, this may be optimized to the appropriate hardware\ninstruction, otherwise its execution will be similar to:\n\ny = unsafe_load(p)\nunsafe_store!(p, x)\nreturn y\n\nThe unsafe prefix on this function indicates that no validation is performed on the\npointer p to ensure that it is valid. Like C, the programmer is responsible for ensuring\nthat referenced memory is not freed or garbage collected while invoking this function.\nIncorrect usage may segfault your program.\n\ncompat: Julia 1.10\nThis function requires at least Julia 1.10.\n\nSee also: swapproperty!, atomic\n\n\n\n\n\n"},{"title":"Base.unsafe_copyto!","page":"C Interface","location":"base/c.html#Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Ptr{T}, Ptr{T}, Any}} where T","category":"method","text":"unsafe_copyto!(dest::Ptr{T}, src::Ptr{T}, N)\n\nCopy N elements from a source pointer to a destination, with no checking. The size of an\nelement is determined by the type of the pointers.\n\nThe unsafe prefix on this function indicates that no validation is performed on the\npointers dest and src to ensure that they are valid. Incorrect usage may corrupt or\nsegfault your program, in the same manner as C.\n\n\n\n\n\n"},{"title":"Base.unsafe_copyto!","page":"C Interface","location":"base/c.html#Base.unsafe_copyto!-Tuple{Array, Any, Array, Any, Any}","category":"method","text":"unsafe_copyto!(dest::Array, doffs, src::Array, soffs, n)\n\nCopy n elements from a source array to a destination, starting at the linear index soffs in the\nsource and doffs in the destination (1-indexed).\n\nThe unsafe prefix on this function indicates that no validation is performed to ensure\nthat n is inbounds on either array. Incorrect usage may corrupt or segfault your program, in\nthe same manner as C.\n\n\n\n\n\n"},{"title":"Base.copyto!","page":"C Interface","location":"base/c.html#Base.copyto!","category":"function","text":"copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -> dest\n\nCopy the block of src in the range of Rsrc to the block of dest\nin the range of Rdest. The sizes of the two regions must match.\n\nExamples\n\njulia> A = zeros(5, 5);\n\njulia> B = [1 2; 3 4];\n\njulia> Ainds = CartesianIndices((2:3, 2:3));\n\njulia> Binds = CartesianIndices(B);\n\njulia> copyto!(A, Ainds, B, Binds)\n5×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  2.0  0.0  0.0\n 0.0  3.0  4.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\ncopyto!(dest::AbstractArray, src) -> dest\n\nCopy all elements from collection src to array dest, whose length must be greater than\nor equal to the length n of src. The first n elements of dest are overwritten,\nthe other elements are left untouched.\n\nSee also copy!, copy.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nExamples\n\njulia> x = [1., 0., 3., 0., 5.];\n\njulia> y = zeros(7);\n\njulia> copyto!(y, x);\n\njulia> y\n7-element Vector{Float64}:\n 1.0\n 0.0\n 3.0\n 0.0\n 5.0\n 0.0\n 0.0\n\n\n\n\n\ncopyto!(dest, doffs, src, soffs, n)\n\nCopy n elements from collection src starting at the linear index soffs, to array dest starting at\nthe index doffs. Return dest.\n\n\n\n\n\ncopyto!(B::AbstractMatrix, ir_dest::AbstractUnitRange, jr_dest::AbstractUnitRange,\n        tM::AbstractChar,\n        M::AbstractVecOrMat, ir_src::AbstractUnitRange, jr_src::AbstractUnitRange) -> B\n\nEfficiently copy elements of matrix M to B conditioned on the character\nparameter tM as follows:\n\ntM Destination Source\n'N' B[ir_dest, jr_dest] M[ir_src, jr_src]\n'T' B[ir_dest, jr_dest] transpose(M)[ir_src, jr_src]\n'C' B[ir_dest, jr_dest] adjoint(M)[ir_src, jr_src]\n\nThe elements B[ir_dest, jr_dest] are overwritten. Furthermore, the index range\nparameters must satisfy length(ir_dest) == length(ir_src) and\nlength(jr_dest) == length(jr_src).\n\nSee also copy_transpose! and copy_adjoint!.\n\n\n\n\n\ncopyto!(dest::AbstractMatrix, src::UniformScaling)\n\nCopies a UniformScaling onto a matrix.\n\ncompat: Julia 1.1\nIn Julia 1.0 this method only supported a square destination matrix. Julia 1.1. added\nsupport for a rectangular matrix.\n\n\n\n\n\n"},{"title":"Base.pointer","page":"C Interface","location":"base/c.html#Base.pointer","category":"function","text":"pointer(array [, index])\n\nGet the native address of an array or string, optionally at a given location index.\n\nThis function is \"unsafe\". Be careful to ensure that a Julia reference to\narray exists as long as this pointer will be used. The GC.@preserve\nmacro should be used to protect the array argument from garbage collection\nwithin a given block of code.\n\nCalling Ref(array[, index]) is generally preferable to this function as it guarantees validity.\n\n\n\n\n\n"},{"title":"Base.unsafe_wrap","page":"C Interface","location":"base/c.html#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T}}, Type{Array{T, N}}}, Ptr{T}, NTuple{N, Int64}}} where {T, N}","category":"method","text":"unsafe_wrap(Array, pointer::Ptr{T}, dims; own = false)\n\nWrap a Julia Array object around the data at the address given by pointer,\nwithout making a copy.  The pointer element type T determines the array\nelement type. dims is either an integer (for a 1d array) or a tuple of the array dimensions.\nown optionally specifies whether Julia should take ownership of the memory,\ncalling free on the pointer when the array is no longer referenced.\n\nThis function is labeled \"unsafe\" because it will crash if pointer is not\na valid memory address to data of the requested length. Unlike unsafe_load\nand unsafe_store!, the programmer is responsible also for ensuring that the\nunderlying data is not accessed through two arrays of different element type, similar\nto the strict aliasing rule in C.\n\n\n\n\n\n"},{"title":"Base.pointer_from_objref","page":"C Interface","location":"base/c.html#Base.pointer_from_objref","category":"function","text":"pointer_from_objref(x)\n\nGet the memory address of a Julia object as a Ptr. The existence of the resulting Ptr\nwill not protect the object from garbage collection, so you must ensure that the object\nremains referenced for the whole time that the Ptr will be used.\n\nThis function may not be called on immutable objects, since they do not have\nstable memory addresses.\n\nSee also unsafe_pointer_to_objref.\n\n\n\n\n\n"},{"title":"Base.unsafe_pointer_to_objref","page":"C Interface","location":"base/c.html#Base.unsafe_pointer_to_objref","category":"function","text":"unsafe_pointer_to_objref(p::Ptr)\n\nConvert a Ptr to an object reference. Assumes the pointer refers to a valid heap-allocated\nJulia object. If this is not the case, undefined behavior results, hence this function is\nconsidered \"unsafe\" and should be used with care.\n\nSee also pointer_from_objref.\n\n\n\n\n\n"},{"title":"Base.disable_sigint","page":"C Interface","location":"base/c.html#Base.disable_sigint","category":"function","text":"disable_sigint(f::Function)\n\nDisable Ctrl-C handler during execution of a function on the current task,\nfor calling external code that may call julia code that is not interrupt safe.\nIntended to be called using do block syntax as follows:\n\ndisable_sigint() do\n    # interrupt-unsafe code\n    ...\nend\n\nThis is not needed on worker threads (Threads.threadid() != 1) since the\nInterruptException will only be delivered to the master thread.\nExternal functions that do not call julia code or julia runtime\nautomatically disable sigint during their execution.\n\n\n\n\n\n"},{"title":"Base.reenable_sigint","page":"C Interface","location":"base/c.html#Base.reenable_sigint","category":"function","text":"reenable_sigint(f::Function)\n\nRe-enable Ctrl-C handler during execution of a function.\nTemporarily reverses the effect of disable_sigint.\n\n\n\n\n\n"},{"title":"Base.exit_on_sigint","page":"C Interface","location":"base/c.html#Base.exit_on_sigint","category":"function","text":"exit_on_sigint(on::Bool)\n\nSet exit_on_sigint flag of the julia runtime.  If false, Ctrl-C\n(SIGINT) is capturable as InterruptException in try block.\nThis is the default behavior in REPL, any code run via -e and -E\nand in Julia script run with -i option.\n\nIf true, InterruptException is not thrown by Ctrl-C.  Running code\nupon such event requires atexit.  This is the default\nbehavior in Julia script run without -i option.\n\ncompat: Julia 1.5\nFunction exit_on_sigint requires at least Julia 1.5.\n\n\n\n\n\n"},{"title":"Base.systemerror","page":"C Interface","location":"base/c.html#Base.systemerror","category":"function","text":"systemerror(sysfunc[, errno::Cint=Libc.errno()])\nsystemerror(sysfunc, iftrue::Bool)\n\nRaises a SystemError for errno with the descriptive string sysfunc if iftrue is true\n\n\n\n\n\n"},{"title":"Base.windowserror","page":"C Interface","location":"base/c.html#Base.windowserror","category":"function","text":"windowserror(sysfunc[, code::UInt32=Libc.GetLastError()])\nwindowserror(sysfunc, iftrue::Bool)\n\nLike systemerror, but for Windows API functions that use GetLastError to\nreturn an error code instead of setting errno.\n\n\n\n\n\n"},{"title":"Core.Ptr","page":"C Interface","location":"base/c.html#Core.Ptr","category":"type","text":"Ptr{T}\n\nA memory address referring to data of type T.  However, there is no guarantee that the\nmemory is actually valid, or that it actually represents data of the specified type.\n\n\n\n\n\n"},{"title":"Core.Ref","page":"C Interface","location":"base/c.html#Core.Ref","category":"type","text":"Ref{T}\n\nAn object that safely references data of type T. This type is guaranteed to point to\nvalid, Julia-allocated memory of the correct type. The underlying data is protected from\nfreeing by the garbage collector as long as the Ref itself is referenced.\n\nIn Julia, Ref objects are dereferenced (loaded or stored) with [].\n\nCreation of a Ref to a value x of type T is usually written Ref(x).\nAdditionally, for creating interior pointers to containers (such as Array or Ptr),\nit can be written Ref(a, i) for creating a reference to the i-th element of a.\n\nRef{T}() creates a reference to a value of type T without initialization.\nFor a bitstype T, the value will be whatever currently resides in the memory\nallocated. For a non-bitstype T, the reference will be undefined and attempting to\ndereference it will result in an error, \"UndefRefError: access to undefined reference\".\n\nTo check if a Ref is an undefined reference, use isassigned(ref::RefValue).\nFor example, isassigned(Ref{T}()) is false if T is not a bitstype.\nIf T is a bitstype, isassigned(Ref{T}()) will always be true.\n\nWhen passed as a ccall argument (either as a Ptr or Ref type), a Ref\nobject will be converted to a native pointer to the data it references.\nFor most T, or when converted to a Ptr{Cvoid}, this is a pointer to the\nobject data. When T is an isbits type, this value may be safely mutated,\notherwise mutation is strictly undefined behavior.\n\nAs a special case, setting T = Any will instead cause the creation of a\npointer to the reference itself when converted to a Ptr{Any}\n(a jl_value_t const* const* if T is immutable, else a jl_value_t *const *).\nWhen converted to a Ptr{Cvoid}, it will still return a pointer to the data\nregion as for any other T.\n\nA C_NULL instance of Ptr can be passed to a ccall Ref argument to initialize it.\n\nUse in broadcasting\n\nRef is sometimes used in broadcasting in order to treat the referenced values as a scalar.\n\nExamples\n\njulia> r = Ref(5) # Create a Ref with an initial value\nBase.RefValue{Int64}(5)\n\njulia> r[] # Getting a value from a Ref\n5\n\njulia> r[] = 7 # Storing a new value in a Ref\n7\n\njulia> r # The Ref now contains 7\nBase.RefValue{Int64}(7)\n\njulia> isa.(Ref([1,2,3]), [Array, Dict, Int]) # Treat reference values as scalar during broadcasting\n3-element BitVector:\n 1\n 0\n 0\n\njulia> Ref{Function}()  # Undefined reference to a non-bitstype, Function\nBase.RefValue{Function}(#undef)\n\njulia> try\n           Ref{Function}()[] # Dereferencing an undefined reference will result in an error\n       catch e\n           println(e)\n       end\nUndefRefError()\n\njulia> Ref{Int64}()[]; # A reference to a bitstype refers to an undetermined value if not given\n\njulia> isassigned(Ref{Int64}()) # A reference to a bitstype is always assigned\ntrue\n\n\n\n\n\n"},{"title":"Base.isassigned","page":"C Interface","location":"base/c.html#Base.isassigned-Tuple{Base.RefValue}","category":"method","text":"isassigned(ref::RefValue)::Bool\n\nTest whether the given Ref is associated with a value.\nThis is always true for a Ref of a bitstype object.\nReturn false if the reference is undefined.\n\nExamples\n\njulia> ref = Ref{Function}()\nBase.RefValue{Function}(#undef)\n\njulia> isassigned(ref)\nfalse\n\njulia> ref[] = (foobar(x) = x)\nfoobar (generic function with 1 method)\n\njulia> isassigned(ref)\ntrue\n\njulia> isassigned(Ref{Int}())\ntrue\n\n\n\n\n\n"},{"title":"Base.Cchar","page":"C Interface","location":"base/c.html#Base.Cchar","category":"type","text":"Cchar\n\nEquivalent to the native char c-type.\n\n\n\n\n\n"},{"title":"Base.Cuchar","page":"C Interface","location":"base/c.html#Base.Cuchar","category":"type","text":"Cuchar\n\nEquivalent to the native unsigned char c-type (UInt8).\n\n\n\n\n\n"},{"title":"Base.Cshort","page":"C Interface","location":"base/c.html#Base.Cshort","category":"type","text":"Cshort\n\nEquivalent to the native signed short c-type (Int16).\n\n\n\n\n\n"},{"title":"Base.Cstring","page":"C Interface","location":"base/c.html#Base.Cstring","category":"type","text":"Cstring\n\nA C-style string composed of the native character type\nCchars. Cstrings are NUL-terminated. For\nC-style strings composed of the native wide character\ntype, see Cwstring. For more information\nabout string interoperability with C, see the\nmanual.\n\n\n\n\n\n"},{"title":"Base.Cushort","page":"C Interface","location":"base/c.html#Base.Cushort","category":"type","text":"Cushort\n\nEquivalent to the native unsigned short c-type (UInt16).\n\n\n\n\n\n"},{"title":"Base.Cint","page":"C Interface","location":"base/c.html#Base.Cint","category":"type","text":"Cint\n\nEquivalent to the native signed int c-type (Int32).\n\n\n\n\n\n"},{"title":"Base.Cuint","page":"C Interface","location":"base/c.html#Base.Cuint","category":"type","text":"Cuint\n\nEquivalent to the native unsigned int c-type (UInt32).\n\n\n\n\n\n"},{"title":"Base.Clong","page":"C Interface","location":"base/c.html#Base.Clong","category":"type","text":"Clong\n\nEquivalent to the native signed long c-type.\n\n\n\n\n\n"},{"title":"Base.Culong","page":"C Interface","location":"base/c.html#Base.Culong","category":"type","text":"Culong\n\nEquivalent to the native unsigned long c-type.\n\n\n\n\n\n"},{"title":"Base.Clonglong","page":"C Interface","location":"base/c.html#Base.Clonglong","category":"type","text":"Clonglong\n\nEquivalent to the native signed long long c-type (Int64).\n\n\n\n\n\n"},{"title":"Base.Culonglong","page":"C Interface","location":"base/c.html#Base.Culonglong","category":"type","text":"Culonglong\n\nEquivalent to the native unsigned long long c-type (UInt64).\n\n\n\n\n\n"},{"title":"Base.Cintmax_t","page":"C Interface","location":"base/c.html#Base.Cintmax_t","category":"type","text":"Cintmax_t\n\nEquivalent to the native intmax_t c-type (Int64).\n\n\n\n\n\n"},{"title":"Base.Cuintmax_t","page":"C Interface","location":"base/c.html#Base.Cuintmax_t","category":"type","text":"Cuintmax_t\n\nEquivalent to the native uintmax_t c-type (UInt64).\n\n\n\n\n\n"},{"title":"Base.Csize_t","page":"C Interface","location":"base/c.html#Base.Csize_t","category":"type","text":"Csize_t\n\nEquivalent to the native size_t c-type (UInt).\n\n\n\n\n\n"},{"title":"Base.Cssize_t","page":"C Interface","location":"base/c.html#Base.Cssize_t","category":"type","text":"Cssize_t\n\nEquivalent to the native ssize_t c-type.\n\n\n\n\n\n"},{"title":"Base.Cptrdiff_t","page":"C Interface","location":"base/c.html#Base.Cptrdiff_t","category":"type","text":"Cptrdiff_t\n\nEquivalent to the native ptrdiff_t c-type (Int).\n\n\n\n\n\n"},{"title":"Base.Cwchar_t","page":"C Interface","location":"base/c.html#Base.Cwchar_t","category":"type","text":"Cwchar_t\n\nEquivalent to the native wchar_t c-type (Int32).\n\n\n\n\n\n"},{"title":"Base.Cwstring","page":"C Interface","location":"base/c.html#Base.Cwstring","category":"type","text":"Cwstring\n\nA C-style string composed of the native wide character type\nCwchar_ts. Cwstrings are NUL-terminated. For\nC-style strings composed of the native character\ntype, see Cstring. For more information\nabout string interoperability with C, see the\nmanual.\n\n\n\n\n\n"},{"title":"Base.Cfloat","page":"C Interface","location":"base/c.html#Base.Cfloat","category":"type","text":"Cfloat\n\nEquivalent to the native float c-type (Float32).\n\n\n\n\n\n"},{"title":"Base.Cdouble","page":"C Interface","location":"base/c.html#Base.Cdouble","category":"type","text":"Cdouble\n\nEquivalent to the native double c-type (Float64).\n\n\n\n\n\n"},{"title":"Core.Intrinsics.llvmcall","page":"C Interface","location":"base/c.html#Core.Intrinsics.llvmcall","category":"function","text":"llvmcall(fun_ir::String, returntype, Tuple{argtype1, ...}, argvalue1, ...)\nllvmcall((mod_ir::String, entry_fn::String), returntype, Tuple{argtype1, ...}, argvalue1, ...)\nllvmcall((mod_bc::Vector{UInt8}, entry_fn::String), returntype, Tuple{argtype1, ...}, argvalue1, ...)\n\nCall the LLVM code provided in the first argument. There are several ways to specify this\nfirst argument:\n\nas a literal string, representing function-level IR (similar to an LLVM define block),\nwith arguments are available as consecutive unnamed SSA variables (%0, %1, etc.);\nas a 2-element tuple, containing a string of module IR and a string representing the name\nof the entry-point function to call;\nas a 2-element tuple, but with the module provided as an Vector{UInt8} with bitcode.\n\nNote that contrary to ccall, the argument types must be specified as a tuple type, and not\na tuple of types. All types, as well as the LLVM code, should be specified as literals, and\nnot as variables or expressions (it may be necessary to use @eval to generate these\nliterals).\n\nSee\ntest/llvmcall.jl\nfor usage examples.\n\n\n\n\n\n"},{"title":"Getting Started","page":"Getting Started","location":"manual/getting-started.html#man-getting-started","category":"section","text":"Julia installation is straightforward, whether using precompiled binaries or compiling from source.\nDownload and install Julia by following the instructions at https://julialang.org/install/.\n\nIf you are coming to Julia from one of the following languages, then you should start by reading the section on noteworthy differences from MATLAB, R, Python, C/C++ or Common Lisp. This will help you avoid some common pitfalls since Julia differs from those languages in many subtle ways.\n\nThe easiest way to learn and experiment with Julia is by starting an interactive session (also\nknown as a read-eval-print loop or \"REPL\") by double-clicking the Julia executable or running\njulia from the command line:\n\nusing REPL\nio = IOBuffer()\nREPL.banner(io)\nbanner = takestring!(io)\nimport Markdown\nMarkdown.parse(\"```\\n\\$ julia\\n\\n$(banner)\\njulia> 1 + 2\\n3\\n\\njulia> ans\\n3\\n```\")\n\nTo exit the interactive session, type CTRL-D (press the Control/^ key together with the d key), or type\nexit(). When run in interactive mode, julia displays a banner and prompts the user for input.\nOnce the user has entered a complete expression, such as 1 + 2, and hits enter, the interactive\nsession evaluates the expression and shows its value. If an expression is entered into an interactive\nsession with a trailing semicolon, its value is not shown. The variable ans is bound to the\nvalue of the last evaluated expression whether it is shown or not. The ans variable is only\nbound in interactive sessions, not when Julia code is run in other ways.\n\nTo evaluate expressions written in a source file file.jl, write include(\"file.jl\").\n\nTo run code in a file non-interactively, you can give it as the first argument to the julia\ncommand:\n\n$ julia script.jl\n\nYou can pass additional arguments to Julia, and to your program script.jl. A detailed list of all the available options can be found under Command-line Interface."},{"title":"Resources","page":"Getting Started","location":"manual/getting-started.html#Resources","category":"section","text":"A curated list of useful learning resources to help new users get started can be found on the learning page of the main Julia website.\n\nYou can use the REPL as a learning resource by switching into the help mode.\nSwitch to help mode by pressing ? at an empty julia> prompt, before typing\nanything else. Typing a keyword in help mode will fetch the documentation for\nit, along with examples. Similarly for most functions or other objects you\nmight encounter!\n\nhelp?> begin\nsearch: begin disable_sigint reenable_sigint\n\n  begin\n\n  begin...end denotes a block of code.\n\nIf you already know Julia a bit, you might want to peek ahead at Performance Tips and Workflow Tips, or check out the comprehensive ModernJuliaWorkflows blog."},{"title":"Frequently Asked Questions","page":"Frequently Asked Questions","location":"manual/faq.html#Frequently-Asked-Questions","category":"section","text":""},{"title":"General","page":"Frequently Asked Questions","location":"manual/faq.html#General","category":"section","text":""},{"title":"Is Julia named after someone or something?","page":"Frequently Asked Questions","location":"manual/faq.html#Is-Julia-named-after-someone-or-something?","category":"section","text":"No."},{"title":"Why don't you compile Matlab/Python/R/… code to Julia?","page":"Frequently Asked Questions","location":"manual/faq.html#Why-don't-you-compile-Matlab/Python/R/…-code-to-Julia?","category":"section","text":"Since many people are familiar with the syntax of other dynamic languages, and lots of code has already been written in those languages, it is natural to wonder why we didn't just plug a Matlab or Python front-end into a Julia back-end (or “transpile” code to Julia) in order to get all the performance benefits of Julia without requiring programmers to learn a new language. Simple, right?\n\nThe basic issue is that there is nothing special about Julia's compiler: we use a commonplace compiler (LLVM) with no “secret sauce” that other language developers don't know about. Indeed, Julia's compiler is in many ways much simpler than those of other dynamic languages (e.g. PyPy or LuaJIT). Julia's performance advantage derives almost entirely from its front-end: its language semantics allow a well-written Julia program to give more opportunities to the compiler to generate efficient code and memory layouts. If you tried to compile Matlab or Python code to Julia, our compiler would be limited by the semantics of Matlab or Python to producing code no better than that of existing compilers for those languages (and probably worse). The key role of semantics is also why several existing Python compilers (like Numba and Pythran) only attempt to optimize a small subset of the language (e.g. operations on Numpy arrays and scalars), and for this subset they are already doing at least as well as we could for the same semantics. The people working on those projects are incredibly smart and have accomplished amazing things, but retrofitting a compiler onto a language that was designed to be interpreted is a very difficult problem.\n\nJulia's advantage is that good performance is not limited to a small subset of “built-in” types and operations, and one can write high-level type-generic code that works on arbitrary user-defined types while remaining fast and memory-efficient. Types in languages like Python simply don't provide enough information to the compiler for similar capabilities, so as soon as you used those languages as a Julia front-end you would be stuck.\n\nFor similar reasons, automated translation to Julia would also typically generate unreadable, slow, non-idiomatic code that would not be a good starting point for a native Julia port from another language.\n\nOn the other hand, language interoperability is extremely useful: we want to exploit existing high-quality code in other languages from Julia (and vice versa)!  The best way to enable this is not a transpiler, but rather via easy inter-language calling facilities. We have worked hard on this, from the built-in ccall intrinsic (to call C and Fortran libraries) to JuliaInterop packages that connect Julia to Python, Matlab, C++, and more."},{"title":"Public API","page":"Frequently Asked Questions","location":"manual/faq.html#man-api","category":"section","text":""},{"title":"How does Julia define its public API?","page":"Frequently Asked Questions","location":"manual/faq.html#How-does-Julia-define-its-public-API?","category":"section","text":"Julia's public API is the behavior described in\ndocumentation of public bindings from Base and the standard libraries. Functions,\ntypes, and constants are not part of the public API if they are not public, even if\nthey have docstrings or are described in the documentation. Further, only the documented\nbehavior of public bindings is part of the public API. Undocumented behavior of public\nbindings is internal.\n\nPublic bindings are those marked with either public foo or export foo.\n\nIn other words:\n\nDocumented behavior of public bindings is part of the public API.\nUndocumented behavior of public bindings is not part of the public API.\nDocumented behavior of private bindings is not part of the public API.\nUndocumented behavior of private bindings is not part of the public API.\n\nYou can get a complete list of the public bindings from a module with names(MyModule).\n\nPackage authors are encouraged to define their public API similarly.\n\nAnything in Julia's Public API is covered by SemVer and therefore\nwill not be removed or receive meaningful breaking changes before Julia 2.0."},{"title":"There is a useful undocumented function/type/constant. Can I use it?","page":"Frequently Asked Questions","location":"manual/faq.html#There-is-a-useful-undocumented-function/type/constant.-Can-I-use-it?","category":"section","text":"Updating Julia may break your code if you use non-public API. If the code is\nself-contained, it may be a good idea to copy it into your project. If you want to rely on\na complex non-public API, especially when using it from a stable package, it is a good idea\nto open an issue or\npull request to start a discussion for turning it\ninto a public API. However, we do not discourage the attempt to create packages that expose\nstable public interfaces while relying on non-public implementation details of Julia and\nbuffering the differences across different Julia versions."},{"title":"The documentation is not accurate enough. Can I rely on the existing behavior?","page":"Frequently Asked Questions","location":"manual/faq.html#The-documentation-is-not-accurate-enough.-Can-I-rely-on-the-existing-behavior?","category":"section","text":"Please open an issue or\npull request to start a discussion for turning the\nexisting behavior into a public API."},{"title":"Sessions and the REPL","page":"Frequently Asked Questions","location":"manual/faq.html#Sessions-and-the-REPL","category":"section","text":""},{"title":"How do I delete an object in memory?","page":"Frequently Asked Questions","location":"manual/faq.html#How-do-I-delete-an-object-in-memory?","category":"section","text":"Julia does not have an analog of MATLAB's clear function; once a name is defined in a Julia\nsession (technically, in module Main), it is always present.\n\nIf memory usage is your concern, you can always replace objects with ones that consume less memory.\n For example, if A is a gigabyte-sized array that you no longer need, you can free the memory\nwith A = nothing. The memory will be released the next time the garbage collector runs; you can force\nthis to happen with GC.gc(). Moreover, an attempt to use A will likely result in an error, because most methods are not defined on type Nothing."},{"title":"Scripting","page":"Frequently Asked Questions","location":"manual/faq.html#man-scripting","category":"section","text":""},{"title":"How do I check if the current file is being run as the main script?","page":"Frequently Asked Questions","location":"manual/faq.html#How-do-I-check-if-the-current-file-is-being-run-as-the-main-script?","category":"section","text":"When a file is run as the main script using julia file.jl one might want to activate extra\nfunctionality like command line argument handling. A way to determine that a file is run in\nthis fashion is to check if abspath(PROGRAM_FILE) == @__FILE__ is true.\n\nHowever, it is recommended to not write files that double as a script and as an importable library.\nIf one needs functionality both available as a library and a script, it is better to write is as a library, then import the functionality into a distinct script."},{"title":"How do I catch CTRL-C in a script?","page":"Frequently Asked Questions","location":"manual/faq.html#catch-ctrl-c","category":"section","text":"Running a Julia script using julia file.jl does not throw\nInterruptException when you try to terminate it with CTRL-C\n(SIGINT). To run a certain code before terminating a Julia script,\nwhich may or may not be caused by CTRL-C, use atexit.\nAlternatively, you can use julia -e 'include(popfirst!(ARGS))' file.jl to execute a script while being able to catch\nInterruptException in the try block.\nNote that with this strategy PROGRAM_FILE will not be set."},{"title":"How do I pass options to julia using #!/usr/bin/env?","page":"Frequently Asked Questions","location":"manual/faq.html#How-do-I-pass-options-to-julia-using-#!/usr/bin/env?","category":"section","text":"Passing options to julia in a so-called shebang line, as in\n#!/usr/bin/env julia --startup-file=no, will not work on many\nplatforms (BSD, macOS, Linux) where the kernel, unlike the shell, does\nnot split arguments at space characters. The option env -S, which\nsplits a single argument string into multiple arguments at spaces,\nsimilar to a shell, offers a simple workaround:\n\n#!/usr/bin/env -S julia --color=yes --startup-file=no\n@show ARGS  # put any Julia code here\n\nnote: Note\nOption env -S appeared in FreeBSD 6.0 (2005), macOS Sierra (2016)\nand GNU/Linux coreutils 8.30 (2018)."},{"title":"Why doesn't run support * or pipes for scripting external programs?","page":"Frequently Asked Questions","location":"manual/faq.html#Why-doesn't-run-support-*-or-pipes-for-scripting-external-programs?","category":"section","text":"Julia's run function launches external programs directly, without\ninvoking an operating-system shell\n(unlike the system(\"...\") function in other languages like Python, R, or C).\nThat means that run does not perform wildcard expansion of * (\"globbing\"),\nnor does it interpret shell pipelines like | or >.\n\nYou can still do globbing and pipelines using Julia features, however. For example, the built-in\npipeline function allows you to chain external programs and files, similar to shell pipes, and\nthe Glob.jl package implements POSIX-compatible globbing.\n\nYou can, of course, run programs through the shell by explicitly passing a shell and a command string to run,\ne.g. run(`sh -c \"ls > files.txt\"`) to use the Unix Bourne shell,\nbut you should generally prefer pure-Julia scripting like run(pipeline(`ls`, \"files.txt\")).\nThe reason why we avoid the shell by default is that shelling out sucks:\nlaunching processes via the shell is slow, fragile to quoting of special characters,  has poor error handling, and is\nproblematic for portability.  (The Python developers came to a similar conclusion.)"},{"title":"Variables and Assignments","page":"Frequently Asked Questions","location":"manual/faq.html#Variables-and-Assignments","category":"section","text":""},{"title":"Why am I getting UndefVarError from a simple loop?","page":"Frequently Asked Questions","location":"manual/faq.html#Why-am-I-getting-UndefVarError-from-a-simple-loop?","category":"section","text":"You might have something like:\n\nx = 0\nwhile x < 10\n    x += 1\nend\n\nand notice that it works fine in an interactive environment (like the Julia REPL),\nbut gives UndefVarError: `x` not defined when you try to run it in script or other\nfile. What is going on is that Julia generally requires you to be explicit about assigning to global variables in a local scope.\n\nHere, x is a global variable, while defines a local scope, and x += 1 is\nan assignment to a global in that local scope.\n\nAs mentioned above, Julia (version 1.5 or later) allows you to omit the global\nkeyword for code in the REPL (and many other interactive environments), to simplify\nexploration (e.g. copy-pasting code from a function to run interactively).\nHowever, once you move to code in files, Julia requires a more disciplined approach\nto global variables. You have least three options:\n\nPut the code into a function (so that x is a local variable in a function). In general, it is good software engineering to use functions rather than global scripts (search online for \"why global variables bad\" to see many explanations). In Julia, global variables are also slow.\nWrap the code in a let block.  (This makes x a local variable within the let ... end statement, again eliminating the need for global).\nExplicitly mark x as global inside the local scope before assigning to it, e.g. write global x += 1.\n\nMore explanation can be found in the manual section on soft scope."},{"title":"Functions","page":"Frequently Asked Questions","location":"manual/faq.html#Functions","category":"section","text":""},{"title":"I passed an argument x to a function, modified it inside that function, but on the outside, the variable x is still unchanged. Why?","page":"Frequently Asked Questions","location":"manual/faq.html#I-passed-an-argument-x-to-a-function,-modified-it-inside-that-function,-but-on-the-outside,-the-variable-x-is-still-unchanged.-Why?","category":"section","text":"Suppose you call a function like this:\n\njulia> x = 10\n10\n\njulia> function change_value!(y)\n           y = 17\n       end\nchange_value! (generic function with 1 method)\n\njulia> change_value!(x)\n17\n\njulia> x # x is unchanged!\n10\n\nIn Julia, the binding of a variable x cannot be changed by passing x as an argument to a function.\nWhen calling change_value!(x) in the above example, y is a newly created variable, bound initially\nto the value of x, i.e. 10; then y is rebound to the constant 17, while the variable\nx of the outer scope is left untouched.\n\nHowever, if x is bound to an object of type Array\n(or any other mutable type). From within the function, you cannot \"unbind\" x from this Array,\nbut you can change its content. For example:\n\njulia> x = [1,2,3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> function change_array!(A)\n           A[1] = 5\n       end\nchange_array! (generic function with 1 method)\n\njulia> change_array!(x)\n5\n\njulia> x\n3-element Vector{Int64}:\n 5\n 2\n 3\n\nHere we created a function change_array!, that assigns 5 to the first element of the passed\narray (bound to x at the call site, and bound to A within the function). Notice that, after\nthe function call, x is still bound to the same array, but the content of that array changed:\nthe variables A and x were distinct bindings referring to the same mutable Array object."},{"title":"Can I use using or import inside a function?","page":"Frequently Asked Questions","location":"manual/faq.html#Can-I-use-using-or-import-inside-a-function?","category":"section","text":"No, you are not allowed to have a using or import statement inside a function. If you want\nto import a module but only use its bindings inside a specific function or set of functions, you\nhave two options:\n\nUse import:\nimport Foo\nfunction bar(...)\n    # ... refer to Foo bindings via Foo.baz ...\nend\nThis loads the module Foo and defines a variable Foo that refers to the module, but does not\nimport any of the other bindings from the module into the current namespace. You refer to the\nFoo bindings by their qualified names Foo.bar etc.\nWrap your function in a module:\nmodule Bar\nexport bar\nusing Foo\nfunction bar(...)\n    # ... refer to Foo.baz as simply baz ....\nend\nend\nusing Bar\nThis imports all the bindings from Foo, but only inside the module Bar."},{"title":"What does the ... operator do?","page":"Frequently Asked Questions","location":"manual/faq.html#What-does-the-...-operator-do?","category":"section","text":""},{"title":"The two uses of the ... operator: slurping and splatting","page":"Frequently Asked Questions","location":"manual/faq.html#The-two-uses-of-the-...-operator:-slurping-and-splatting","category":"section","text":"Many newcomers to Julia find the use of ... operator confusing. Part of what makes the ...\noperator confusing is that it means two different things depending on context."},{"title":"... combines many arguments into one argument in function definitions","page":"Frequently Asked Questions","location":"manual/faq.html#...-combines-many-arguments-into-one-argument-in-function-definitions","category":"section","text":"In the context of function definitions, the ... operator is used to combine many different arguments\ninto a single argument. This use of ... for combining many different arguments into a single\nargument is called slurping:\n\njulia> function printargs(args...)\n           println(typeof(args))\n           for (i, arg) in enumerate(args)\n               println(\"Arg #$i = $arg\")\n           end\n       end\nprintargs (generic function with 1 method)\n\njulia> printargs(1, 2, 3)\nTuple{Int64, Int64, Int64}\nArg #1 = 1\nArg #2 = 2\nArg #3 = 3\n\nIf Julia were a language that made more liberal use of ASCII characters, the slurping operator\nmight have been written as <-... instead of ...."},{"title":"... splits one argument into many different arguments in function calls","page":"Frequently Asked Questions","location":"manual/faq.html#...-splits-one-argument-into-many-different-arguments-in-function-calls","category":"section","text":"In contrast to the use of the ... operator to denote slurping many different arguments into\none argument when defining a function, the ... operator is also used to cause a single function\nargument to be split apart into many different arguments when used in the context of a function\ncall. This use of ... is called splatting:\n\njulia> function threeargs(a, b, c)\n           println(\"a = $a::$(typeof(a))\")\n           println(\"b = $b::$(typeof(b))\")\n           println(\"c = $c::$(typeof(c))\")\n       end\nthreeargs (generic function with 1 method)\n\njulia> x = [1, 2, 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> threeargs(x...)\na = 1::Int64\nb = 2::Int64\nc = 3::Int64\n\nIf Julia were a language that made more liberal use of ASCII characters, the splatting operator\nmight have been written as ...-> instead of ...."},{"title":"What is the return value of an assignment?","page":"Frequently Asked Questions","location":"manual/faq.html#What-is-the-return-value-of-an-assignment?","category":"section","text":"The operator = always returns the right-hand side, therefore:\n\njulia> function threeint()\n           x::Int = 3.0\n           x # returns variable x\n       end\nthreeint (generic function with 1 method)\n\njulia> function threefloat()\n           x::Int = 3.0 # returns 3.0\n       end\nthreefloat (generic function with 1 method)\n\njulia> threeint()\n3\n\njulia> threefloat()\n3.0\n\nand similarly:\n\njulia> function twothreetup()\n           x, y = [2, 3] # assigns 2 to x and 3 to y\n           x, y # returns a tuple\n       end\ntwothreetup (generic function with 1 method)\n\njulia> function twothreearr()\n           x, y = [2, 3] # returns an array\n       end\ntwothreearr (generic function with 1 method)\n\njulia> twothreetup()\n(2, 3)\n\njulia> twothreearr()\n2-element Vector{Int64}:\n 2\n 3"},{"title":"Is a function that ends with ! allowed to allocate?","page":"Frequently Asked Questions","location":"manual/faq.html#Is-a-function-that-ends-with-!-allowed-to-allocate?","category":"section","text":"Yes! A function name ending with ! indicates that the function mutates at\nleast one of its arguments (typically the first argument). However, it may\nstill allocate a scratch space to expedite computation or produce that result."},{"title":"Types, type declarations, and constructors","page":"Frequently Asked Questions","location":"manual/faq.html#Types,-type-declarations,-and-constructors","category":"section","text":""},{"title":"What does \"type-stable\" mean?","page":"Frequently Asked Questions","location":"manual/faq.html#man-type-stability","category":"section","text":"It means that the type of the output is predictable from the types of the inputs. In particular,\nit means that the type of the output cannot vary depending on the values of the inputs. The\nfollowing code is not type-stable:\n\njulia> function unstable(flag::Bool)\n           if flag\n               return 1\n           else\n               return 1.0\n           end\n       end\nunstable (generic function with 1 method)\n\nIt returns either an Int or a Float64 depending on the value of its argument.\nSince Julia can't predict the return type of this function at compile-time, any computation\nthat uses it must be able to cope with values of both types, which makes it hard to produce\nfast machine code."},{"title":"Why does Julia give a DomainError for certain seemingly-sensible operations?","page":"Frequently Asked Questions","location":"manual/faq.html#faq-domain-errors","category":"section","text":"Certain operations make mathematical sense but result in errors:\n\njulia> sqrt(-2.0)\nERROR: DomainError with -2.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n\nThis behavior is an inconvenient consequence of the requirement for type-stability. In the case\nof sqrt, most users want sqrt(2.0) to give a real number, and would be unhappy if\nit produced the complex number 1.4142135623730951 + 0.0im. One could write the sqrt\nfunction to switch to a complex-valued output only when passed a negative number (which is what\nsqrt does in some other languages), but then the result would not be type-stable\nand the sqrt function would have poor performance.\n\nIn these and other cases, you can get the result you want by choosing an input type that conveys\nyour willingness to accept an output type in which the result can be represented:\n\njulia> sqrt(-2.0+0im)\n0.0 + 1.4142135623730951im"},{"title":"How can I constrain or compute type parameters?","page":"Frequently Asked Questions","location":"manual/faq.html#How-can-I-constrain-or-compute-type-parameters?","category":"section","text":"The parameters of a parametric type can hold either\ntypes or bits values, and the type itself chooses how it makes use of these parameters.\nFor example, Array{Float64, 2} is parameterized by the type Float64 to express its\nelement type and the integer value 2 to express its number of dimensions. When\ndefining your own parametric type, you can use subtype constraints to declare that a\ncertain parameter must be a subtype (<:) of some abstract type or a previous\ntype parameter. There is not, however, a dedicated syntax to declare that a parameter\nmust be a value of a given type — that is, you cannot directly declare that a\ndimensionality-like parameter isa Int within the struct definition, for\nexample. Similarly, you cannot do computations (including simple things like addition\nor subtraction) on type parameters. Instead, these sorts of constraints and\nrelationships may be expressed through additional type parameters that are computed\nand enforced within the type's constructors.\n\nAs an example, consider\n\nstruct ConstrainedType{T,N,N+1} # NOTE: INVALID SYNTAX\n    A::Array{T,N}\n    B::Array{T,N+1}\nend\n\nwhere the user would like to enforce that the third type parameter is always the second plus one. This can be implemented with an explicit type parameter that is checked by an inner constructor method (where it can be combined with other checks):\n\nstruct ConstrainedType{T,N,M}\n    A::Array{T,N}\n    B::Array{T,M}\n    function ConstrainedType(A::Array{T,N}, B::Array{T,M}) where {T,N,M}\n        N + 1 == M || throw(ArgumentError(\"second argument should have one more axis\" ))\n        new{T,N,M}(A, B)\n    end\nend\n\nThis check is usually costless, as the compiler can elide the check for valid concrete types. If the second argument is also computed, it may be advantageous to provide an outer constructor method that performs this calculation:\n\nConstrainedType(A) = ConstrainedType(A, compute_B(A))"},{"title":"Why does Julia use native machine integer arithmetic?","page":"Frequently Asked Questions","location":"manual/faq.html#faq-integer-arithmetic","category":"section","text":"Julia uses machine arithmetic for integer computations. This means that the range of Int values\nis bounded and wraps around at either end so that adding, subtracting and multiplying integers\ncan overflow or underflow, leading to some results that can be unsettling at first:\n\njulia> x = typemax(Int)\n9223372036854775807\n\njulia> y = x+1\n-9223372036854775808\n\njulia> z = -y\n-9223372036854775808\n\njulia> 2*z\n0\n\nClearly, this is far from the way mathematical integers behave, and you might think it less than\nideal for a high-level programming language to expose this to the user. For numerical work where\nefficiency and transparency are at a premium, however, the alternatives are worse.\n\nOne alternative to consider would be to check each integer operation for overflow and promote\nresults to bigger integer types such as Int128 or BigInt in the case of overflow.\nUnfortunately, this introduces major overhead on every integer operation (think incrementing a\nloop counter) – it requires emitting code to perform run-time overflow checks after arithmetic\ninstructions and branches to handle potential overflows. Worse still, this would cause every computation\ninvolving integers to be type-unstable. As we mentioned above, type-stability is crucial\nfor effective generation of efficient code. If you can't count on the results of integer operations\nbeing integers, it's impossible to generate fast, simple code the way C and Fortran compilers\ndo.\n\nA variation on this approach, which avoids the appearance of type instability is to merge the\nInt and BigInt types into a single hybrid integer type, that internally changes representation\nwhen a result no longer fits into the size of a machine integer. While this superficially avoids\ntype-instability at the level of Julia code, it just sweeps the problem under the rug by foisting\nall of the same difficulties onto the C code implementing this hybrid integer type. This approach\ncan be made to work and can even be made quite fast in many cases, but has several drawbacks.\nOne problem is that the in-memory representation of integers and arrays of integers no longer\nmatch the natural representation used by C, Fortran and other languages with native machine integers.\nThus, to interoperate with those languages, we would ultimately need to introduce native integer\ntypes anyway. Any unbounded representation of integers cannot have a fixed number of bits, and\nthus cannot be stored inline in an array with fixed-size slots – large integer values will always\nrequire separate heap-allocated storage. And of course, no matter how clever a hybrid integer\nimplementation one uses, there are always performance traps – situations where performance degrades\nunexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability\nto represent integer arrays without additional heap storage, and unpredictable performance characteristics\nmake even the cleverest hybrid integer implementations a poor choice for high-performance numerical\nwork.\n\nAn alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic,\nwhere adding to the largest integer value leaves it unchanged and likewise for subtracting from\nthe smallest integer value. This is precisely what Matlab™ does:\n\n>> int64(9223372036854775807)\n\nans =\n\n  9223372036854775807\n\n>> int64(9223372036854775807) + 1\n\nans =\n\n  9223372036854775807\n\n>> int64(-9223372036854775808)\n\nans =\n\n -9223372036854775808\n\n>> int64(-9223372036854775808) - 1\n\nans =\n\n -9223372036854775808\n\nAt first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808\nthan -9223372036854775808 is and integers are still represented with a fixed size in a natural\nway that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic.\nThe first and most obvious issue is that this is not the way machine integer arithmetic works,\nso implementing saturated operations requires emitting instructions after each machine integer\noperation to check for underflow or overflow and replace the result with typemin(Int)\nor typemax(Int) as appropriate. This expands each integer operation from a single, fast\ninstruction into a few instructions. But it gets worse – saturating integer arithmetic isn't\nassociative. Consider this Matlab computation:\n\n>> n = int64(2)^62\n4611686018427387904\n\n>> n + (n - 1)\n9223372036854775807\n\n>> (n + n) - 1\n9223372036854775806\n\nThis makes it hard to write many basic integer algorithms since a lot of common techniques depend\non the fact that machine addition with overflow is associative. Consider finding the midpoint\nbetween integer values lo and hi in Julia using the expression (lo + hi) >>> 1:\n\njulia> n = 2^62\n4611686018427387904\n\njulia> (n + 2n) >>> 1\n6917529027641081856\n\nSee? No problem. That's the correct midpoint between 2^62 and 2^63, despite the fact that n + 2n\nis -4611686018427387904. Now try it in Matlab:\n\n>> (n + 2*n)/2\n\nans =\n\n  4611686018427387904\n\nOops. Adding a >>> operator to Matlab wouldn't help, because saturation that occurs when adding\nn and 2n has already destroyed the information necessary to compute the correct midpoint.\n\nNot only is lack of associativity unfortunate for programmers who cannot rely it for techniques\nlike this, but it also defeats almost anything compilers might want to do to optimize integer\narithmetic. For example, since Julia integers use normal machine integer arithmetic, LLVM is free\nto aggressively optimize simple little functions like f(k) = 5k-1. The machine code for this\nfunction is just this:\n\njulia> code_native(f, Tuple{Int})\n  .text\nFilename: none\n  pushq %rbp\n  movq  %rsp, %rbp\nSource line: 1\n  leaq  -1(%rdi,%rdi,4), %rax\n  popq  %rbp\n  retq\n  nopl  (%rax,%rax)\n\nThe actual body of the function is a single leaq instruction, which computes the integer multiply\nand add at once. This is even more beneficial when f gets inlined into another function:\n\njulia> function g(k, n)\n           for i = 1:n\n               k = f(k)\n           end\n           return k\n       end\ng (generic function with 1 methods)\n\njulia> code_native(g, Tuple{Int,Int})\n  .text\nFilename: none\n  pushq %rbp\n  movq  %rsp, %rbp\nSource line: 2\n  testq %rsi, %rsi\n  jle L26\n  nopl  (%rax)\nSource line: 3\nL16:\n  leaq  -1(%rdi,%rdi,4), %rdi\nSource line: 2\n  decq  %rsi\n  jne L16\nSource line: 5\nL26:\n  movq  %rdi, %rax\n  popq  %rbp\n  retq\n  nop\n\nSince the call to f gets inlined, the loop body ends up being just a single leaq instruction.\nNext, consider what happens if we make the number of loop iterations fixed:\n\njulia> function g(k)\n           for i = 1:10\n               k = f(k)\n           end\n           return k\n       end\ng (generic function with 2 methods)\n\njulia> code_native(g,(Int,))\n  .text\nFilename: none\n  pushq %rbp\n  movq  %rsp, %rbp\nSource line: 3\n  imulq $9765625, %rdi, %rax    # imm = 0x9502F9\n  addq  $-2441406, %rax         # imm = 0xFFDABF42\nSource line: 5\n  popq  %rbp\n  retq\n  nopw  %cs:(%rax,%rax)\n\nBecause the compiler knows that integer addition and multiplication are associative and that multiplication\ndistributes over addition – neither of which is true of saturating arithmetic – it can optimize\nthe entire loop down to just a multiply and an add. Saturated arithmetic completely defeats this\nkind of optimization since associativity and distributivity can fail at each loop iteration, causing\ndifferent outcomes depending on which iteration the failure occurs in. The compiler can unroll\nthe loop, but it cannot algebraically reduce multiple operations into fewer equivalent operations.\n\nThe most reasonable alternative to having integer arithmetic silently overflow is to do checked\narithmetic everywhere, raising errors when adds, subtracts, and multiplies overflow, producing\nvalues that are not value-correct. In this blog post, Dan\nLuu analyzes this and finds that rather than the trivial cost that this approach should in theory\nhave, it ends up having a substantial cost due to compilers (LLVM and GCC) not gracefully optimizing\naround the added overflow checks. If this improves in the future, we could consider defaulting\nto checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow.\n\nIn the meantime, overflow-safe integer operations can be achieved through the use of external libraries\nsuch as SaferIntegers.jl. Note that, as stated\npreviously, the use of these libraries significantly increases the execution time of code using the\nchecked integer types. However, for limited usage, this is far less of an issue than if it were used\nfor all integer operations. You can follow the status of the discussion\nhere."},{"title":"What are the possible causes of an UndefVarError during remote execution?","page":"Frequently Asked Questions","location":"manual/faq.html#What-are-the-possible-causes-of-an-UndefVarError-during-remote-execution?","category":"section","text":"As the error states, an immediate cause of an UndefVarError on a remote node is that a binding\nby that name does not exist. Let us explore some of the possible causes.\n\njulia> module Foo\n           foo() = remotecall_fetch(x->x, 2, \"Hello\")\n       end\n\njulia> Foo.foo()\nERROR: On worker 2:\nUndefVarError: `Foo` not defined in `Main`\nStacktrace:\n[...]\n\nThe closure x->x carries a reference to Foo, and since Foo is unavailable on node 2,\nan UndefVarError is thrown.\n\nGlobals under modules other than Main are not serialized by value to the remote node. Only a reference is sent.\nFunctions which create global bindings (except under Main) may cause an UndefVarError to be thrown later.\n\njulia> @everywhere module Foo\n           function foo()\n               global gvar = \"Hello\"\n               remotecall_fetch(()->gvar, 2)\n           end\n       end\n\njulia> Foo.foo()\nERROR: On worker 2:\nUndefVarError: `gvar` not defined in `Main.Foo`\nStacktrace:\n[...]\n\nIn the above example, @everywhere module Foo defined Foo on all nodes. However the call to Foo.foo() created\na new global binding gvar on the local node, but this was not found on node 2 resulting in an UndefVarError error.\n\nNote that this does not apply to globals created under module Main. Globals under module Main are serialized\nand new bindings created under Main on the remote node.\n\njulia> gvar_self = \"Node1\"\n\"Node1\"\n\njulia> remotecall_fetch(()->gvar_self, 2)\n\"Node1\"\n\njulia> remotecall_fetch(varinfo, 2)\nname          size summary\n––––––––– –––––––– –––––––\nBase               Module\nCore               Module\nMain               Module\ngvar_self 13 bytes String\n\nThis does not apply to function or struct declarations. However, anonymous functions bound to global\nvariables are serialized as can be seen below.\n\njulia> bar() = 1\nbar (generic function with 1 method)\n\njulia> remotecall_fetch(bar, 2)\nERROR: On worker 2:\nUndefVarError: `#bar` not defined in `Main`\n[...]\n\njulia> anon_bar  = ()->1\n(::#21) (generic function with 1 method)\n\njulia> remotecall_fetch(anon_bar, 2)\n1"},{"title":"Troubleshooting \"method not matched\": parametric type invariance and MethodErrors","page":"Frequently Asked Questions","location":"manual/faq.html#Troubleshooting-\"method-not-matched\":-parametric-type-invariance-and-MethodErrors","category":"section","text":""},{"title":"Why doesn't it work to declare foo(bar::Vector{Real}) = 42 and then call foo([1])?","page":"Frequently Asked Questions","location":"manual/faq.html#Why-doesn't-it-work-to-declare-foo(bar::Vector{Real})-42-and-then-call-foo([1])?","category":"section","text":"As you'll see if you try this, the result is a MethodError:\n\njulia> foo(x::Vector{Real}) = 42\nfoo (generic function with 1 method)\n\njulia> foo([1])\nERROR: MethodError: no method matching foo(::Vector{Int64})\nThe function `foo` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  foo(!Matched::Vector{Real})\n   @ Main none:1\n\nStacktrace:\n[...]\n\nThis is because Vector{Real} is not a supertype of Vector{Int}! You can solve this problem with something\nlike foo(bar::Vector{T}) where {T<:Real} (or the short form foo(bar::Vector{<:Real}) if the static parameter T\nis not needed in the body of the function). The T is a wild card: you first specify that it must be a\nsubtype of Real, then specify the function takes a Vector of with elements of that type.\n\nThis same issue goes for any composite type Comp, not just Vector. If Comp has a parameter declared of\ntype Y, then another type Comp2 with a parameter of type X<:Y is not a subtype of Comp. This is\ntype-invariance (by contrast, Tuple is type-covariant in its parameters). See [Parametric Composite\nTypes](@ref man-parametric-composite-types) for more explanation of these."},{"title":"Why does Julia use * for string concatenation? Why not + or something else?","page":"Frequently Asked Questions","location":"manual/faq.html#Why-does-Julia-use-*-for-string-concatenation?-Why-not-or-something-else?","category":"section","text":"The main argument against + is that string concatenation is not\ncommutative, while + is generally used as a commutative operator. While the Julia community\nrecognizes that other languages use different operators and * may be unfamiliar for some\nusers, it communicates certain algebraic properties.\n\nNote that you can also use string(...) to concatenate strings (and other values converted\nto strings); similarly, repeat can be used instead of ^ to repeat strings. The\ninterpolation syntax is also useful for constructing strings."},{"title":"Packages and Modules","page":"Frequently Asked Questions","location":"manual/faq.html#Packages-and-Modules","category":"section","text":""},{"title":"What is the difference between \"using\" and \"import\"?","page":"Frequently Asked Questions","location":"manual/faq.html#What-is-the-difference-between-\"using\"-and-\"import\"?","category":"section","text":"There are several differences between using and import\n(see the Modules section),\nbut there is an important difference that may not seem intuitive at first glance,\nand on the surface (i.e. syntax-wise) it may seem very minor. When loading modules with using,\nyou need to say function Foo.bar(... to extend module Foo's function bar with a new method,\nbut with import Foo.bar, you only need to say function bar(... and it automatically extends\nmodule Foo's function bar.\n\nThe reason this is important enough to have been given separate syntax is that you don't want\nto accidentally extend a function that you didn't know existed, because that could easily cause\na bug. This is most likely to happen with a method that takes a common type like a string or integer,\nbecause both you and the other module could define a method to handle such a common type. If you\nuse import, then you'll replace the other module's implementation of bar(s::AbstractString)\nwith your new implementation, which could easily do something completely different (and break\nall/many future usages of the other functions in module Foo that depend on calling bar)."},{"title":"Nothingness and missing values","page":"Frequently Asked Questions","location":"manual/faq.html#Nothingness-and-missing-values","category":"section","text":""},{"title":"How does \"null\", \"nothingness\" or \"missingness\" work in Julia?","page":"Frequently Asked Questions","location":"manual/faq.html#faq-nothing","category":"section","text":"Unlike many languages (for example, C and Java), Julia objects cannot be \"null\" by default.\nWhen a reference (variable, object field, or array element) is uninitialized, accessing it\nwill immediately throw an error. This situation can be detected using the\nisdefined or isassigned functions.\n\nSome functions are used only for their side effects, and do not need to return a value. In these\ncases, the convention is to return the value nothing, which is just a singleton object of type\nNothing. This is an ordinary type with no fields; there is nothing special about it except for\nthis convention, and that the REPL does not print anything for it. Some language constructs that\nwould not otherwise have a value also yield nothing, for example if false; end.\n\nFor situations where a value x of type T exists only sometimes, the Union{T, Nothing}\ntype can be used for function arguments, object fields and array element types\nas the equivalent of Nullable, Option or Maybe\nin other languages. If the value itself can be nothing (notably, when T is Any),\nthe Union{Some{T}, Nothing} type is more appropriate since x == nothing then indicates\nthe absence of a value, and x == Some(nothing) indicates the presence of a value equal\nto nothing. The something function allows unwrapping Some objects and\nusing a default value instead of nothing arguments. Note that the compiler is able to\ngenerate efficient code when working with Union{T, Nothing} arguments or fields.\n\nTo represent missing data in the statistical sense (NA in R or NULL in SQL), use the\nmissing object. See the Missing Values section for more details.\n\nIn some languages, the empty tuple (()) is considered the canonical\nform of nothingness. However, in julia it is best thought of as just\na regular tuple that happens to contain zero values.\n\nThe empty (or \"bottom\") type, written as Union{} (an empty union type), is a type with\nno values and no subtypes (except itself). You will generally not need to use this type."},{"title":"Memory","page":"Frequently Asked Questions","location":"manual/faq.html#Memory","category":"section","text":""},{"title":"Why does x += y allocate memory when x and y are arrays?","page":"Frequently Asked Questions","location":"manual/faq.html#Why-does-x-y-allocate-memory-when-x-and-y-are-arrays?","category":"section","text":"In Julia, x += y gets replaced during lowering by x = x + y. For arrays, this has the consequence\nthat, rather than storing the result in the same location in memory as x, it allocates a new\narray to store the result. If you prefer to mutate x, use x .+= y to update each element\nindividually.\n\nWhile this behavior might surprise some, the choice is deliberate. The main reason is the presence\nof immutable objects within Julia, which cannot change their value once created. Indeed, a\nnumber is an immutable object; the statements x = 5; x += 1 do not modify the meaning of 5,\nthey modify the value bound to x. For an immutable, the only way to change the value is to reassign\nit.\n\nTo amplify a bit further, consider the following function:\n\nfunction power_by_squaring(x, n::Int)\n    ispow2(n) || error(\"This implementation only works for powers of 2\")\n    while n >= 2\n        x *= x\n        n >>= 1\n    end\n    x\nend\n\nAfter a call like x = 5; y = power_by_squaring(x, 4), you would get the expected result: x == 5 && y == 625.\n However, now suppose that *=, when used with matrices, instead mutated the left hand side.\n There would be two problems:\n\nFor general square matrices, A = A*B cannot be implemented without temporary storage: A[1,1]\ngets computed and stored on the left hand side before you're done using it on the right hand side.\nSuppose you were willing to allocate a temporary for the computation (which would eliminate most\nof the point of making *= work in-place); if you took advantage of the mutability of x, then\nthis function would behave differently for mutable vs. immutable inputs. In particular, for immutable\nx, after the call you'd have (in general) y != x, but for mutable x you'd have y == x.\n\nBecause supporting generic programming is deemed more important than potential performance optimizations\nthat can be achieved by other means (e.g., using broadcasting or explicit loops), operators like += and\n*= work by rebinding new values."},{"title":"Asynchronous IO and concurrent synchronous writes","page":"Frequently Asked Questions","location":"manual/faq.html#faq-async-io","category":"section","text":""},{"title":"Why do concurrent writes to the same stream result in inter-mixed output?","page":"Frequently Asked Questions","location":"manual/faq.html#Why-do-concurrent-writes-to-the-same-stream-result-in-inter-mixed-output?","category":"section","text":"While the streaming I/O API is synchronous, the underlying implementation is fully asynchronous.\n\nConsider the printed output from the following:\n\njulia> @sync for i in 1:3\n           Threads.@spawn write(stdout, string(i), \" Foo \", \" Bar \")\n       end\n123 Foo  Foo  Foo  Bar  Bar  Bar\n\nThis is happening because, while the write call is synchronous, the writing of each argument\nyields to other tasks while waiting for that part of the I/O to complete.\n\nprint and println \"lock\" the stream during a call. Consequently changing write to println\nin the above example results in:\n\njulia> @sync for i in 1:3\n           Threads.@spawn println(stdout, string(i), \" Foo \", \" Bar \")\n       end\n1 Foo  Bar\n2 Foo  Bar\n3 Foo  Bar\n\nYou can lock your writes with a ReentrantLock like this:\n\njulia> l = ReentrantLock();\n\njulia> @sync for i in 1:3\n           Threads.@spawn begin\n               lock(l)\n               try\n                   write(stdout, string(i), \" Foo \", \" Bar \")\n               finally\n                   unlock(l)\n               end\n           end\n       end\n1 Foo  Bar 2 Foo  Bar 3 Foo  Bar"},{"title":"Arrays","page":"Frequently Asked Questions","location":"manual/faq.html#Arrays","category":"section","text":""},{"title":"What are the differences between zero-dimensional arrays and scalars?","page":"Frequently Asked Questions","location":"manual/faq.html#faq-array-0dim","category":"section","text":"Zero-dimensional arrays are arrays of the form Array{T,0}. They behave similar\nto scalars, but there are important differences. They deserve a special mention\nbecause they are a special case which makes logical sense given the generic\ndefinition of arrays, but might be a bit unintuitive at first. The following\nline defines a zero-dimensional array:\n\njulia> A = zeros()\n0-dimensional Array{Float64,0}:\n0.0\n\nIn this example, A is a mutable container that contains one element, which can\nbe set by A[] = 1.0 and retrieved with A[]. All zero-dimensional arrays have\nthe same size (size(A) == ()), and length (length(A) == 1). In particular,\nzero-dimensional arrays are not empty. If you find this unintuitive, here are\nsome ideas that might help to understand Julia's definition.\n\nZero-dimensional arrays are the \"point\" to vector's \"line\" and matrix's\n\"plane\". Just as a line has no area (but still represents a set of things), a\npoint has no length or any dimensions at all (but still represents a thing).\nWe define prod(()) to be 1, and the total number of elements in an array is\nthe product of the size. The size of a zero-dimensional array is (), and\ntherefore its length is 1.\nZero-dimensional arrays don't natively have any dimensions into which you\nindex – they’re just A[]. We can apply the same \"trailing one\" rule for them\nas for all other array dimensionalities, so you can indeed index them as A[1], A[1,1], etc; see\nOmitted and extra indices.\n\nIt is also important to understand the differences to ordinary scalars. Scalars\nare not mutable containers (even though they are iterable and define things\nlike length, getindex, e.g. 1[] == 1). In particular, if x = 0.0 is\ndefined as a scalar, it is an error to attempt to change its value via\nx[] = 1.0. A scalar x can be converted into a zero-dimensional array\ncontaining it via fill(x), and conversely, a zero-dimensional array a can\nbe converted to the contained scalar via a[]. Another difference is that\na scalar can participate in linear algebra operations such as 2 * rand(2,2),\nbut the analogous operation with a zero-dimensional array\nfill(2) * rand(2,2) is an error."},{"title":"Why are my Julia benchmarks for linear algebra operations different from other languages?","page":"Frequently Asked Questions","location":"manual/faq.html#Why-are-my-Julia-benchmarks-for-linear-algebra-operations-different-from-other-languages?","category":"section","text":"You may find that simple benchmarks of linear algebra building blocks like\n\nusing BenchmarkTools\nA = randn(1000, 1000)\nB = randn(1000, 1000)\n@btime $A \\ $B\n@btime $A * $B\n\ncan be different when compared to other languages like Matlab or R.\n\nSince operations like this are very thin wrappers over the relevant BLAS functions, the reason for the discrepancy is very likely to be\n\nthe BLAS library each language is using,\nthe number of concurrent threads.\n\nJulia compiles and uses its own copy of OpenBLAS, with threads currently capped at 8 (or the number of your cores).\n\nModifying OpenBLAS settings or compiling Julia with a different BLAS library, eg Intel MKL, may provide performance improvements. You can use MKL.jl, a package that makes Julia's linear algebra use Intel MKL BLAS and LAPACK instead of OpenBLAS, or search the discussion forum for suggestions on how to set this up manually. Note that Intel MKL cannot be bundled with Julia, as it is not open source."},{"title":"Computing cluster","page":"Frequently Asked Questions","location":"manual/faq.html#Computing-cluster","category":"section","text":""},{"title":"How do I manage precompilation caches in distributed file systems?","page":"Frequently Asked Questions","location":"manual/faq.html#How-do-I-manage-precompilation-caches-in-distributed-file-systems?","category":"section","text":"When using Julia in high-performance computing (HPC) facilities with shared filesystems, it is recommended to use a shared\ndepot (via the JULIA_DEPOT_PATH environment variable). Since Julia v1.10, multiple Julia processes on functionally similar\nworkers and using the same depot will coordinate via pidfile locks to only spend effort precompiling on one process while the\nothers wait. The precompilation process will indicate when the process is precompiling or waiting for another that is\nprecompiling. If non-interactive the messages are via @debug.\n\nHowever, due to caching of binary code, the cache rejection since v1.9 is more strict and users may need to set the\nJULIA_CPU_TARGET environment variable appropriately to get a single cache that is usable throughout the HPC\nenvironment."},{"title":"Julia Releases","page":"Frequently Asked Questions","location":"manual/faq.html#Julia-Releases","category":"section","text":""},{"title":"Do I want to use the Stable, LTS, or nightly version of Julia?","page":"Frequently Asked Questions","location":"manual/faq.html#Do-I-want-to-use-the-Stable,-LTS,-or-nightly-version-of-Julia?","category":"section","text":"The Stable version of Julia is the latest released version of Julia, this is the version most people will want to run.\nIt has the latest features, including improved performance.\nThe Stable version of Julia is versioned according to SemVer as v1.x.y.\nA new minor release of Julia corresponding to a new Stable version is made approximately every 4-5 months after a few weeks of testing as a release candidate.\nUnlike the LTS version the Stable version will not normally receive bugfixes after another Stable version of Julia has been released.\nHowever, upgrading to the next Stable release will always be possible as each release of Julia v1.x will continue to run code written for earlier versions.\n\nYou may prefer the LTS (Long Term Support) version of Julia if you are looking for a very stable code base.\nThe current LTS version of Julia is versioned according to SemVer as v1.6.x;\nthis branch will continue to receive bugfixes until a new LTS branch is chosen, at which point the v1.6.x series will no longer received regular bug fixes and all but the most conservative users will be advised to upgrade to the new LTS version series.\nAs a package developer, you may prefer to develop for the LTS version, to maximize the number of users who can use your package.\nAs per SemVer, code written for v1.0 will continue to work for all future LTS and Stable versions.\nIn general, even if targeting the LTS, one can develop and run code in the latest Stable version, to take advantage of the improved performance; so long as one avoids using new features (such as added library functions or new methods).\n\nYou may prefer the nightly version of Julia if you want to take advantage of the latest updates to the language, and don't mind if the version available today occasionally doesn't actually work.\nAs the name implies, releases to the nightly version are made roughly every night (depending on build infrastructure stability).\nIn general nightly released are fairly safe to use—your code will not catch on fire.\nHowever, they may be occasional regressions and or issues that will not be found until more thorough pre-release testing.\nYou may wish to test against the nightly version to ensure that such regressions that affect your use case are caught before a release is made.\n\nFinally, you may also consider building Julia from source for yourself. This option is mainly for those individuals who are comfortable at the command line, or interested in learning.\nIf this describes you, you may also be interested in reading our guidelines for contributing.\n\nThe juliaup install manager has pre-defined channels named release and lts for the latest stable release and the current LTS release, as well as version-specific channels."},{"title":"How can I transfer the list of installed packages after updating my version of Julia?","page":"Frequently Asked Questions","location":"manual/faq.html#How-can-I-transfer-the-list-of-installed-packages-after-updating-my-version-of-Julia?","category":"section","text":"Each minor version of julia has its own default environment. As a result, upon installing a new minor version of Julia, the packages you added using the previous minor version will not be available by default. The environment for a given julia version is defined by the files Project.toml and Manifest.toml in a folder matching the version number in .julia/environments/, for instance, .julia/environments/v1.3.\n\nIf you install a new minor version of Julia, say 1.4, and want to use in its default environment the same packages as in a previous version (e.g. 1.3), you can copy the contents of the file Project.toml from the 1.3 folder to 1.4. Then, in a session of the new Julia version, enter the \"package management mode\" by typing the key ], and run the command instantiate.\n\nThis operation will resolve a set of feasible packages from the copied file that are compatible with the target Julia version, and will install or update them if suitable. If you want to reproduce not only the set of packages, but also the versions you were using in the previous Julia version, you should also copy the Manifest.toml file before running the Pkg command instantiate. However, note that packages may define compatibility constraints that may be affected by changing the version of Julia, so the exact set of versions you had in 1.3 may not work for 1.4."},{"title":"Linear Algebra","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#man-linalg","category":"section","text":"In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations\nof many common and useful linear algebra operations which can be loaded with using LinearAlgebra. Basic operations, such as tr, det,\nand inv are all supported:\n\njulia> A = [1 2 3; 4 1 6; 7 8 1]\n3×3 Matrix{Int64}:\n 1  2  3\n 4  1  6\n 7  8  1\n\njulia> tr(A)\n3\n\njulia> det(A)\n104.0\n\njulia> inv(A)\n3×3 Matrix{Float64}:\n -0.451923   0.211538    0.0865385\n  0.365385  -0.192308    0.0576923\n  0.240385   0.0576923  -0.0673077\n\nAs well as other useful operations, such as finding eigenvalues or eigenvectors:\n\njulia> A = [-4. -17.; 2. 2.]\n2×2 Matrix{Float64}:\n -4.0  -17.0\n  2.0    2.0\n\njulia> eigvals(A)\n2-element Vector{ComplexF64}:\n -1.0 - 5.0im\n -1.0 + 5.0im\n\njulia> eigvecs(A)\n2×2 Matrix{ComplexF64}:\n  0.945905-0.0im        0.945905+0.0im\n -0.166924+0.278207im  -0.166924-0.278207im\n\nIn addition, Julia provides many factorizations which can be used to\nspeed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form\nmore amenable (for performance or memory reasons) to the problem. See the documentation on factorize\nfor more information. As an example:\n\njulia> A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]\n3×3 Matrix{Float64}:\n   1.5   2.0  -4.0\n   3.0  -1.0  -6.0\n -10.0   2.3   4.0\n\njulia> factorize(A)\nLU{Float64, Matrix{Float64}, Vector{Int64}}\nL factor:\n3×3 Matrix{Float64}:\n  1.0    0.0       0.0\n -0.15   1.0       0.0\n -0.3   -0.132196  1.0\nU factor:\n3×3 Matrix{Float64}:\n -10.0  2.3     4.0\n   0.0  2.345  -3.4\n   0.0  0.0    -5.24947\n\nSince A is not Hermitian, symmetric, triangular, tridiagonal, or bidiagonal, an LU factorization may be the\nbest we can do. Compare with:\n\njulia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]\n3×3 Matrix{Float64}:\n  1.5   2.0  -4.0\n  2.0  -1.0  -3.0\n -4.0  -3.0   5.0\n\njulia> factorize(B)\nBunchKaufman{Float64, Matrix{Float64}, Vector{Int64}}\nD factor:\n3×3 Tridiagonal{Float64, Vector{Float64}}:\n -1.64286   0.0   ⋅\n  0.0      -2.8  0.0\n   ⋅        0.0  5.0\nU factor:\n3×3 UnitUpperTriangular{Float64, Matrix{Float64}}:\n 1.0  0.142857  -0.8\n  ⋅   1.0       -0.6\n  ⋅    ⋅         1.0\npermutation:\n3-element Vector{Int64}:\n 1\n 2\n 3\n\nHere, Julia was able to detect that B is in fact symmetric, and used a more appropriate factorization.\nOften it's possible to write more efficient code for a matrix that is known to have certain properties e.g.\nit is symmetric, or tridiagonal. Julia provides some special types so that you can \"tag\" matrices as having\nthese properties. For instance:\n\njulia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]\n3×3 Matrix{Float64}:\n  1.5   2.0  -4.0\n  2.0  -1.0  -3.0\n -4.0  -3.0   5.0\n\njulia> sB = Symmetric(B)\n3×3 Symmetric{Float64, Matrix{Float64}}:\n  1.5   2.0  -4.0\n  2.0  -1.0  -3.0\n -4.0  -3.0   5.0\n\nsB has been tagged as a matrix that's (real) symmetric, so for later operations we might perform on it,\nsuch as eigenfactorization or computing matrix-vector products, efficiencies can be found by only referencing\nhalf of it. For example:\n\njulia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]\n3×3 Matrix{Float64}:\n  1.5   2.0  -4.0\n  2.0  -1.0  -3.0\n -4.0  -3.0   5.0\n\njulia> sB = Symmetric(B)\n3×3 Symmetric{Float64, Matrix{Float64}}:\n  1.5   2.0  -4.0\n  2.0  -1.0  -3.0\n -4.0  -3.0   5.0\n\njulia> x = [1; 2; 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> sB\\x\n3-element Vector{Float64}:\n -1.7391304347826084\n -1.1086956521739126\n -1.4565217391304346\n\nThe \\ operation here performs the linear solution. The left-division operator is pretty\npowerful and it's easy to write compact, readable code that is flexible enough to solve all\nsorts of systems of linear equations."},{"title":"Special matrices","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Special-matrices","category":"section","text":"Matrices with special symmetries and structures\narise often in linear algebra and are frequently associated with various matrix factorizations.\nJulia features a rich collection of special matrix types, which allow for fast computation with\nspecialized routines that are specially developed for particular matrix types.\n\nThe following tables summarize the types of special matrices that have been implemented in Julia,\nas well as whether hooks to various optimized methods for them in LAPACK are available.\n\nType Description\nSymmetric Symmetric matrix\nHermitian Hermitian matrix\nUpperTriangular Upper triangular matrix\nUnitUpperTriangular Upper triangular matrix with unit diagonal\nLowerTriangular Lower triangular matrix\nUnitLowerTriangular Lower triangular matrix with unit diagonal\nUpperHessenberg Upper Hessenberg matrix\nTridiagonal Tridiagonal matrix\nSymTridiagonal Symmetric tridiagonal matrix\nBidiagonal Upper/lower bidiagonal matrix\nDiagonal Diagonal matrix\nUniformScaling Uniform scaling operator"},{"title":"Elementary operations","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Elementary-operations","category":"section","text":"Matrix type + - * \\ Other functions with optimized methods\nSymmetric    MV inv, sqrt, cbrt, exp\nHermitian    MV inv, sqrt, cbrt, exp\nUpperTriangular   MV MV inv, det, logdet\nUnitUpperTriangular   MV MV inv, det, logdet\nLowerTriangular   MV MV inv, det, logdet\nUnitLowerTriangular   MV MV inv, det, logdet\nUpperHessenberg    MM inv, det\nSymTridiagonal M M MS MV eigmax, eigmin\nTridiagonal M M MS MV \nBidiagonal M M MS MV \nDiagonal M M MV MV inv, det, logdet, /\nUniformScaling M M MVS MVS /\n\nLegend:\n\nKey Description\nM (matrix) An optimized method for matrix-matrix operations is available\nV (vector) An optimized method for matrix-vector operations is available\nS (scalar) An optimized method for matrix-scalar operations is available"},{"title":"Matrix factorizations","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Matrix-factorizations","category":"section","text":"Matrix type LAPACK eigen eigvals eigvecs svd svdvals\nSymmetric SY  ARI   \nHermitian HE  ARI   \nUpperTriangular TR A A A  \nUnitUpperTriangular TR A A A  \nLowerTriangular TR A A A  \nUnitLowerTriangular TR A A A  \nSymTridiagonal ST A ARI AV  \nTridiagonal GT     \nBidiagonal BD    A A\nDiagonal DI  A   \n\nLegend:\n\nKey Description Example\nA (all) An optimized method to find all the characteristic values and/or vectors is available e.g. eigvals(M)\nR (range) An optimized method to find the ilth through the ihth characteristic values are available eigvals(M, il, ih)\nI (interval) An optimized method to find the characteristic values in the interval [vl, vh] is available eigvals(M, vl, vh)\nV (vectors) An optimized method to find the characteristic vectors corresponding to the characteristic values x=[x1, x2,...] is available eigvecs(M, x)"},{"title":"The uniform scaling operator","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#The-uniform-scaling-operator","category":"section","text":"A UniformScaling operator represents a scalar times the identity operator, λ*I. The identity\noperator I is defined as a constant and is an instance of UniformScaling. The size of these\noperators are generic and match the other matrix in the binary operations +, -,\n* and \\. For A+I and A-I this means that A must be square. Multiplication\nwith the identity operator I is a noop (except for checking that the scaling factor is one)\nand therefore almost without overhead.\n\nTo see the UniformScaling operator in action:\n\njulia> U = UniformScaling(2);\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> a + U\n2×2 Matrix{Int64}:\n 3  2\n 3  6\n\njulia> a * U\n2×2 Matrix{Int64}:\n 2  4\n 6  8\n\njulia> [a U]\n2×4 Matrix{Int64}:\n 1  2  2  0\n 3  4  0  2\n\njulia> b = [1 2 3; 4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> b - U\nERROR: DimensionMismatch: matrix is not square: dimensions are (2, 3)\nStacktrace:\n[...]\n\nIf you need to solve many systems of the form (A+μI)x = b for the same A and different μ, it might be beneficial\nto first compute the Hessenberg factorization F of A via the hessenberg function.\nGiven F, Julia employs an efficient algorithm for (F+μ*I) \\ b (equivalent to (A+μ*I)x \\ b) and related\noperations like determinants."},{"title":"Matrix factorizations","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#man-linalg-factorizations","category":"section","text":"Matrix factorizations (a.k.a. matrix decompositions)\ncompute the factorization of a matrix into a product of matrices, and are one of the central concepts\nin (numerical) linear algebra.\n\nThe following table summarizes the types of matrix factorizations that have been implemented in\nJulia. Details of their associated methods can be found in the Standard functions section\nof the Linear Algebra documentation.\n\nType Description\nBunchKaufman Bunch-Kaufman factorization\nCholesky Cholesky factorization\nCholeskyPivoted Pivoted Cholesky factorization\nLDLt LDL(T) factorization\nLU LU factorization\nQR QR factorization\nQRCompactWY Compact WY form of the QR factorization\nQRPivoted Pivoted QR factorization\nLQ QR factorization of transpose(A)\nHessenberg Hessenberg decomposition\nEigen Spectral decomposition\nGeneralizedEigen Generalized spectral decomposition\nSVD Singular value decomposition\nGeneralizedSVD Generalized SVD\nSchur Schur decomposition\nGeneralizedSchur Generalized Schur decomposition\n\nAdjoints and transposes of Factorization objects are lazily wrapped in\nAdjointFactorization and TransposeFactorization objects, respectively. Generically,\ntranspose of real Factorizations are wrapped as AdjointFactorization."},{"title":"Orthogonal matrices (AbstractQ)","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#man-linalg-abstractq","category":"section","text":"Some matrix factorizations generate orthogonal/unitary \"matrix\" factors. These\nfactorizations include QR-related factorizations obtained from calls to qr, i.e.,\nQR, QRCompactWY and QRPivoted, the Hessenberg factorization obtained from calls to\nhessenberg, and the LQ factorization obtained from lq. While these\northogonal/unitary factors admit a matrix representation, their internal representation\nis, for performance and memory reasons, different. Hence, they should be rather viewed as\nmatrix-backed, function-based linear operators. In particular, reading, for instance, a\ncolumn of its matrix representation requires running \"matrix\"-vector multiplication code,\nrather than simply reading out data from memory (possibly filling parts of the vector with\nstructural zeros). Another clear distinction from other, non-triangular matrix types is\nthat the underlying multiplication code allows for in-place modification during multiplication.\nFurthermore, objects of specific AbstractQ subtypes as those created via qr,\nhessenberg and lq can behave like a square or a rectangular matrix\ndepending on context:\n\njulia> using LinearAlgebra\n\njulia> Q = qr(rand(3,2)).Q\n3×3 LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}, Matrix{Float64}}\n\njulia> Matrix(Q)\n3×2 Matrix{Float64}:\n -0.320597   0.865734\n -0.765834  -0.475694\n -0.557419   0.155628\n\njulia> Q*I\n3×3 Matrix{Float64}:\n -0.320597   0.865734  -0.384346\n -0.765834  -0.475694  -0.432683\n -0.557419   0.155628   0.815514\n\njulia> Q*ones(2)\n3-element Vector{Float64}:\n  0.5451367118802273\n -1.241527373086654\n -0.40179067589600226\n\njulia> Q*ones(3)\n3-element Vector{Float64}:\n  0.16079054743832022\n -1.674209978965636\n  0.41372375588835797\n\njulia> ones(1,2) * Q'\n1×3 Matrix{Float64}:\n 0.545137  -1.24153  -0.401791\n\njulia> ones(1,3) * Q'\n1×3 Matrix{Float64}:\n 0.160791  -1.67421  0.413724\n\nDue to this distinction from dense or structured matrices, the abstract AbstractQ type\ndoes not subtype AbstractMatrix, but instead has its own type hierarchy. Custom types\nthat subtype AbstractQ can rely on generic fallbacks if the following interface is satisfied.\nFor example, for\n\nstruct MyQ{T} <: LinearAlgebra.AbstractQ{T}\n    # required fields\nend\n\nprovide overloads for\n\nBase.size(Q::MyQ) # size of corresponding square matrix representation\nBase.convert(::Type{AbstractQ{T}}, Q::MyQ) # eltype promotion [optional]\nLinearAlgebra.lmul!(Q::MyQ, x::AbstractVecOrMat) # left-multiplication\nLinearAlgebra.rmul!(A::AbstractMatrix, Q::MyQ) # right-multiplication\n\nIf eltype promotion is not of interest, the convert method is unnecessary, since by\ndefault convert(::Type{AbstractQ{T}}, Q::AbstractQ{T}) returns Q itself.\nAdjoints of AbstractQ-typed objects are lazily wrapped in an AdjointQ wrapper type,\nwhich requires its own LinearAlgebra.lmul! and LinearAlgebra.rmul! methods. Given this\nset of methods, any Q::MyQ can be used like a matrix, preferably in a multiplicative\ncontext: multiplication via * with scalars, vectors and matrices from left and right,\nobtaining a matrix representation of Q via Matrix(Q) (or Q*I) and indexing into the\nmatrix representation all work. In contrast, addition and subtraction as well as more\ngenerally broadcasting over elements in the matrix representation fail because that would\nbe highly inefficient. For such use cases, consider computing the matrix representation\nup front and cache it for future reuse."},{"title":"Pivoting Strategies","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#man-linalg-pivoting-strategies","category":"section","text":"Several of Julia's matrix factorizations support\npivoting, which can be used to improve their\nnumerical stability. In fact, some matrix factorizations, such as the LU\nfactorization, may fail without pivoting.\n\nIn pivoting, first, a pivot element\nwith good numerical properties is chosen based on a pivoting strategy. Next, the rows and\ncolumns of the original matrix are permuted to bring the chosen element in place for\nsubsequent computation. Furthermore, the process is repeated for each stage of the factorization.\n\nConsequently, besides the conventional matrix factors, the outputs of\npivoted factorization schemes also include permutation matrices.\n\nIn the following, the pivoting strategies implemented in Julia are briefly described. Note\nthat not all matrix factorizations may support them. Consult the documentation of the\nrespective matrix factorization for details on the\nsupported pivoting strategies.\n\nSee also LinearAlgebra.ZeroPivotException."},{"title":"Standard functions","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Standard-functions","category":"section","text":"Linear algebra functions in Julia are largely implemented by calling functions from LAPACK.\nSparse matrix factorizations call functions from SuiteSparse.\nOther sparse solvers are available as Julia packages."},{"title":"Low-level matrix operations","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Low-level-matrix-operations","category":"section","text":"In many cases there are in-place versions of matrix operations that allow you to supply\na pre-allocated output vector or matrix. This is useful when optimizing critical code in order\nto avoid the overhead of repeated allocations. These in-place operations are suffixed with !\nbelow (e.g. mul!) according to the usual Julia convention."},{"title":"BLAS functions","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#BLAS-functions","category":"section","text":"In Julia (as in much of scientific computation), dense linear-algebra operations are based on\nthe LAPACK library, which in turn is built on top of basic linear-algebra\nbuilding-blocks known as the BLAS. There are highly optimized\nimplementations of BLAS available for every computer architecture, and sometimes in high-performance\nlinear algebra routines it is useful to call the BLAS functions directly.\n\nLinearAlgebra.BLAS provides wrappers for some of the BLAS functions. Those BLAS functions\nthat overwrite one of the input arrays have names ending in '!'. Usually, a BLAS function has\nfour methods defined, for Float32, Float64, ComplexF32,\nand ComplexF64 arrays."},{"title":"BLAS character arguments","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#stdlib-blas-chars","category":"section","text":"Many BLAS functions accept arguments that determine whether to transpose an argument (trans),\nwhich triangle of a matrix to reference (uplo or ul),\nwhether the diagonal of a triangular matrix can be assumed to\nbe all ones (dA) or which side of a matrix multiplication\nthe input argument belongs on (side). The possibilities are:"},{"title":"Multiplication order","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#stdlib-blas-side","category":"section","text":"side Meaning\n'L' The argument goes on the left side of a matrix-matrix operation.\n'R' The argument goes on the right side of a matrix-matrix operation."},{"title":"Triangle referencing","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#stdlib-blas-uplo","category":"section","text":"uplo/ul Meaning\n'U' Only the upper triangle of the matrix will be used.\n'L' Only the lower triangle of the matrix will be used."},{"title":"Transposition operation","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#stdlib-blas-trans","category":"section","text":"trans/tX Meaning\n'N' The input matrix X is not transposed or conjugated.\n'T' The input matrix X will be transposed.\n'C' The input matrix X will be conjugated and transposed."},{"title":"Unit diagonal","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#stdlib-blas-diag","category":"section","text":"diag/dX Meaning\n'N' The diagonal values of the matrix X will be read.\n'U' The diagonal of the matrix X is assumed to be all ones.\n\nBLAS functions can be divided into three groups, also called three levels,\ndepending on when they were first proposed, the type of input parameters,\nand the complexity of the operation."},{"title":"Level 1 BLAS functions","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Level-1-BLAS-functions","category":"section","text":"The level 1 BLAS functions were first proposed in (Lawson, 1979) and\ndefine operations between scalars and vectors."},{"title":"Level 2 BLAS functions","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Level-2-BLAS-functions","category":"section","text":"The level 2 BLAS functions were published in (Dongarra, 1988)\nand define matrix-vector operations.\n\nreturn a vector\n\nreturn a matrix"},{"title":"Level 3 BLAS functions","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Level-3-BLAS-functions","category":"section","text":"The level 3 BLAS functions were published in (Dongarra, 1990)\nand define matrix-matrix operations."},{"title":"LAPACK functions","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#man-linalg-lapack-functions","category":"section","text":"LinearAlgebra.LAPACK provides wrappers for some of the LAPACK functions for linear algebra.\n Those functions that overwrite one of the input arrays have names ending in '!'.\n\nUsually a function has 4 methods defined, one each for Float64, Float32,\nComplexF64 and ComplexF32 arrays.\n\nNote that the LAPACK API provided by Julia can and will change in the future. Since this API is\nnot user-facing, there is no commitment to support/deprecate this specific set of functions in\nfuture releases."},{"title":"Developer Documentation","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Developer-Documentation","category":"section","text":""},{"title":"LinearAlgebra.NoPivot","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.NoPivot","category":"type","text":"NoPivot\n\nPivoting is not performed. This is the default strategy for cholesky and\nqr factorizations. Note, however, that other matrix factorizations such as the LU\nfactorization may fail without pivoting, and may also be numerically unstable for\nfloating-point matrices in the face of roundoff error. In such cases, this pivot strategy\nis mainly useful for pedagogical purposes.\n\n\n\n\n\n"},{"title":"LinearAlgebra.RowNonZero","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.RowNonZero","category":"type","text":"RowNonZero\n\nFirst non-zero element in the remaining rows is chosen as the pivot element.\n\nBeware that for floating-point matrices, the resulting LU algorithm is numerically unstable\n— this strategy is mainly useful for comparison to hand calculations (which typically use\nthis strategy) or for other algebraic types (e.g. rational numbers) not susceptible to\nroundoff errors. Otherwise, the default RowMaximum pivoting strategy should be generally\npreferred in Gaussian elimination.\n\nNote that the element type of the matrix must admit an iszero\nmethod.\n\n\n\n\n\n"},{"title":"LinearAlgebra.RowMaximum","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.RowMaximum","category":"type","text":"RowMaximum\n\nA row (and potentially also column) pivot is chosen based on a maximum property.\nThis is the default strategy for LU factorization and for pivoted Cholesky factorization\n(though [NoPivot] is the default for cholesky).\n\nIn the LU case, the maximum-magnitude element within the current column in the remaining\nrows is chosen as the pivot element. This is sometimes referred to as the \"partial\npivoting\" algorithm. In this case, the element type of the matrix must admit\nan abs method, whose result type must admit a < method.\n\nIn the Cholesky case, the maximal element among the remaining diagonal elements is\nchosen as the pivot element. This is sometimes referred to as the \"diagonal pivoting\"\nalgorithm, and leads to complete pivoting (i.e., of both rows and columns by the same\npermutation). In this case, the (real part of the) element type of the\nmatrix must admit a < method.\n\n\n\n\n\n"},{"title":"LinearAlgebra.ColumnNorm","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.ColumnNorm","category":"type","text":"ColumnNorm\n\nThe column with the maximum norm is used for subsequent computation. This is used for\npivoted QR factorization.\n\nNote that the element type of the matrix must admit norm and\nabs methods, whose respective result types must admit a < method.\n\n\n\n\n\n"},{"title":"Base.:*","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.:*-Tuple{AbstractMatrix, AbstractMatrix}","category":"method","text":"*(A::AbstractMatrix, B::AbstractMatrix)\n\nMatrix multiplication.\n\nExamples\n\njulia> [1 1; 0 1] * [1 0; 1 1]\n2×2 Matrix{Int64}:\n 2  1\n 1  1\n\n\n\n\n\n"},{"title":"Base.:*","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.:*-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector}","category":"method","text":"*(A, B::AbstractMatrix, C)\nA * B * C * D\n\nChained multiplication of 3 or 4 matrices is done in the most efficient sequence,\nbased on the sizes of the arrays. That is, the number of scalar multiplications needed\nfor (A * B) * C (with 3 dense matrices) is compared to that for A * (B * C)\nto choose which of these to execute.\n\nIf the last factor is a vector, or the first a transposed vector, then it is efficient\nto deal with these first. In particular x' * B * y means (x' * B) * y\nfor an ordinary column-major B::Matrix. Unlike dot(x, B, y), this\nallocates an intermediate array.\n\nIf the first or last factor is a number, this will be fused with the matrix\nmultiplication, using 5-arg mul!.\n\nSee also muladd, dot.\n\ncompat: Julia 1.7\nThese optimisations require at least Julia 1.7.\n\n\n\n\n\n"},{"title":"Base.:\\","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.:\\-Tuple{AbstractMatrix, AbstractVecOrMat}","category":"method","text":"\\(A, B)\n\nMatrix division using a polyalgorithm. For input matrices A and B, the result X is\nsuch that A*X == B when A is square. The solver that is used depends upon the structure\nof A.  If A is upper or lower triangular (or diagonal), no factorization of A is\nrequired and the system is solved with either forward or backward substitution.\nFor non-triangular square matrices, an LU factorization is used.\n\nFor rectangular A the result is the minimum-norm least squares solution computed by a\npivoted QR factorization of A and a rank estimate of A based on the R factor.\n\nWhen A is sparse, a similar polyalgorithm is used. For indefinite matrices, the LDLt\nfactorization does not use pivoting during the numerical factorization and therefore the\nprocedure can fail even for invertible matrices.\n\nSee also: factorize, pinv.\n\nExamples\n\njulia> A = [1 0; 1 -2]; B = [32; -4];\n\njulia> X = A \\ B\n2-element Vector{Float64}:\n 32.0\n 18.0\n\njulia> A * X == B\ntrue\n\n\n\n\n\n"},{"title":"Base.:/","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.:/-Tuple{AbstractVecOrMat, AbstractVecOrMat}","category":"method","text":"A / B\n\nMatrix right-division: A / B is equivalent to (B' \\ A')' where \\ is the left-division operator.\nFor square matrices, the result X is such that A == X*B.\n\nSee also: rdiv!.\n\nExamples\n\njulia> A = Float64[1 4 5; 3 9 2]; B = Float64[1 4 2; 3 4 2; 8 7 1];\n\njulia> X = A / B\n2×3 Matrix{Float64}:\n -0.65   3.75  -1.2\n  3.25  -2.75   1.0\n\njulia> isapprox(A, X*B)\ntrue\n\njulia> isapprox(X, A*pinv(B))\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.SingularException","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.SingularException","category":"type","text":"SingularException\n\nException thrown when the input matrix has one or more zero-valued eigenvalues, and is not invertible.\nA linear solve involving such a matrix cannot be computed.\nThe info field indicates the location of (one of) the singular value(s).\n\n\n\n\n\n"},{"title":"LinearAlgebra.PosDefException","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.PosDefException","category":"type","text":"PosDefException\n\nException thrown when the input matrix was not positive definite.\nSome linear algebra functions and factorizations are only applicable to positive definite matrices.\nThe info field indicates the location of (one of) the eigenvalue(s) which is (are) less than/equal to 0.\n\n\n\n\n\n"},{"title":"LinearAlgebra.ZeroPivotException","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.ZeroPivotException","category":"type","text":"ZeroPivotException <: Exception\n\nException thrown when a matrix factorization/solve encounters a zero in a pivot (diagonal)\nposition and cannot proceed.  This may not mean that the matrix is singular:\nit may be fruitful to switch to a different factorization such as pivoted LU\nthat can re-order variables to eliminate spurious zero pivots.\nThe info field indicates the location of (one of) the zero pivot(s).\n\n\n\n\n\n"},{"title":"LinearAlgebra.RankDeficientException","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.RankDeficientException","category":"type","text":"RankDeficientException\n\nException thrown when the input matrix is rank deficient. Some\nlinear algebra functions, such as the Cholesky decomposition, are only applicable to matrices that are not rank\ndeficient. The info field indicates the computed rank of the matrix.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACKException","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACKException","category":"type","text":"LAPACKException\n\nGeneric LAPACK exception thrown either during direct calls to the LAPACK functions\nor during calls to other functions that use the LAPACK functions internally but lack specialized error handling. The info field\ncontains additional information on the underlying error and depends on the LAPACK function that was invoked.\n\n\n\n\n\n"},{"title":"LinearAlgebra.dot","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.dot","category":"function","text":"dot(x, y)\nx ⋅ y\n\nCompute the dot product between two vectors. For complex vectors, the first\nvector is conjugated.\n\ndot also works on arbitrary iterable objects, including arrays of any dimension,\nas long as dot is defined on the elements.\n\ndot is semantically equivalent to sum(dot(vx,vy) for (vx,vy) in zip(x, y)),\nwith the added restriction that the arguments must have equal lengths.\n\nx ⋅ y (where ⋅ can be typed by tab-completing \\cdot in the REPL) is a synonym for\ndot(x, y).\n\nExamples\n\njulia> dot([1; 1], [2; 3])\n5\n\njulia> dot([im; im], [1; 1])\n0 - 2im\n\njulia> dot(1:5, 2:6)\n70\n\njulia> x = fill(2., (5,5));\n\njulia> y = fill(3., (5,5));\n\njulia> dot(x, y)\n150.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.dot","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.dot-Tuple{Any, Any, Any}","category":"method","text":"dot(x, A, y)\n\nCompute the generalized dot product dot(x, A*y) between two vectors x and y,\nwithout storing the intermediate result of A*y. As for the two-argument\ndot(_,_), this acts recursively. Moreover, for complex vectors, the\nfirst vector is conjugated.\n\ncompat: Julia 1.4\nThree-argument dot requires at least Julia 1.4.\n\nExamples\n\njulia> dot([1; 1], [1 2; 3 4], [2; 3])\n26\n\njulia> dot(1:5, reshape(1:25, 5, 5), 2:6)\n4850\n\njulia> ⋅(1:5, reshape(1:25, 5, 5), 2:6) == dot(1:5, reshape(1:25, 5, 5), 2:6)\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.cross","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.cross","category":"function","text":"cross(x, y)\n×(x,y)\n\nCompute the cross product of two 3-vectors.\n\nExamples\n\njulia> a = [0;1;0]\n3-element Vector{Int64}:\n 0\n 1\n 0\n\njulia> b = [0;0;1]\n3-element Vector{Int64}:\n 0\n 0\n 1\n\njulia> cross(a,b)\n3-element Vector{Int64}:\n 1\n 0\n 0\n\n\n\n\n\n"},{"title":"LinearAlgebra.axpy!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.axpy!","category":"function","text":"axpy!(α, x::AbstractArray, y::AbstractArray)\n\nOverwrite y with x * α + y and return y.\nIf x and y have the same axes, it's equivalent with y .+= x .* a.\n\nExamples\n\njulia> x = [1; 2; 3];\n\njulia> y = [4; 5; 6];\n\njulia> axpy!(2, x, y)\n3-element Vector{Int64}:\n  6\n  9\n 12\n\n\n\n\n\n"},{"title":"LinearAlgebra.axpby!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.axpby!","category":"function","text":"axpby!(α, x::AbstractArray, β, y::AbstractArray)\n\nOverwrite y with x * α + y * β and return y.\nIf x and y have the same axes, it's equivalent with y .= x .* a .+ y .* β.\n\nExamples\n\njulia> x = [1; 2; 3];\n\njulia> y = [4; 5; 6];\n\njulia> axpby!(2, x, 2, y)\n3-element Vector{Int64}:\n 10\n 14\n 18\n\n\n\n\n\n"},{"title":"LinearAlgebra.rotate!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.rotate!","category":"function","text":"rotate!(x, y, c, s)\n\nOverwrite x with s*y + c*x and y with c*y - conj(s)*x.\nReturns x and y.\n\ncompat: Julia 1.5\nrotate! requires at least Julia 1.5.\n\n\n\n\n\n"},{"title":"LinearAlgebra.reflect!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.reflect!","category":"function","text":"reflect!(x, y, c, s)\n\nOverwrite x with c*x + s*y and y with conj(s)*x - c*y.\nReturns x and y.\n\ncompat: Julia 1.5\nreflect! requires at least Julia 1.5.\n\n\n\n\n\n"},{"title":"LinearAlgebra.factorize","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.factorize","category":"function","text":"factorize(A)\n\nCompute a convenient factorization of A, based upon the type of the input matrix.\nIf A is passed as a generic matrix, factorize checks to see if it is\nsymmetric/triangular/etc. To this end, factorize may check every element of A to\nverify/rule out each property. It will short-circuit as soon as it can rule out\nsymmetry/triangular structure. The return value can be reused for efficient solving\nof multiple systems. For example: A=factorize(A); x=A\\b; y=A\\C.\n\nProperties of A type of factorization\nDense Symmetric/Hermitian Bunch-Kaufman (see bunchkaufman)\nSparse Symmetric/Hermitian LDLt (see ldlt)\nTriangular Triangular\nDiagonal Diagonal\nBidiagonal Bidiagonal\nTridiagonal LU (see lu)\nSymmetric real tridiagonal LDLt (see ldlt)\nGeneral square LU (see lu)\nGeneral non-square QR (see qr)\n\nExamples\n\njulia> A = Array(Bidiagonal(fill(1.0, (5, 5)), :U))\n5×5 Matrix{Float64}:\n 1.0  1.0  0.0  0.0  0.0\n 0.0  1.0  1.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0\n 0.0  0.0  0.0  1.0  1.0\n 0.0  0.0  0.0  0.0  1.0\n\njulia> factorize(A) # factorize will check to see that A is already factorized\n5×5 Bidiagonal{Float64, Vector{Float64}}:\n 1.0  1.0   ⋅    ⋅    ⋅\n  ⋅   1.0  1.0   ⋅    ⋅\n  ⋅    ⋅   1.0  1.0   ⋅\n  ⋅    ⋅    ⋅   1.0  1.0\n  ⋅    ⋅    ⋅    ⋅   1.0\n\nThis returns a 5×5 Bidiagonal{Float64}, which can now be passed to other linear algebra\nfunctions (e.g. eigensolvers) which will use specialized methods for Bidiagonal types.\n\n\n\n\n\n"},{"title":"LinearAlgebra.Diagonal","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.Diagonal","category":"type","text":"Diagonal(V::AbstractVector)\n\nConstruct a lazy matrix with V as its diagonal.\n\nSee also UniformScaling for the lazy identity matrix I,\ndiagm to make a dense matrix, and diag to extract diagonal elements.\n\nExamples\n\njulia> d = Diagonal([1, 10, 100])\n3×3 Diagonal{Int64, Vector{Int64}}:\n 1   ⋅    ⋅\n ⋅  10    ⋅\n ⋅   ⋅  100\n\njulia> diagm([7, 13])\n2×2 Matrix{Int64}:\n 7   0\n 0  13\n\njulia> ans + I\n2×2 Matrix{Int64}:\n 8   0\n 0  14\n\njulia> I(2)\n2×2 Diagonal{Bool, Vector{Bool}}:\n 1  ⋅\n ⋅  1\n\nnote: Note\nA one-column matrix is not treated like a vector, but instead calls the\nmethod Diagonal(A::AbstractMatrix) which extracts 1-element diag(A):\n\njulia> A = transpose([7.0 13.0])\n2×1 transpose(::Matrix{Float64}) with eltype Float64:\n  7.0\n 13.0\n\njulia> Diagonal(A)\n1×1 Diagonal{Float64, Vector{Float64}}:\n 7.0\n\n\n\n\n\nDiagonal(A::AbstractMatrix)\n\nConstruct a matrix from the principal diagonal of A.\nThe input matrix A may be rectangular, but the output will\nbe square.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> D = Diagonal(A)\n2×2 Diagonal{Int64, Vector{Int64}}:\n 1  ⋅\n ⋅  4\n\njulia> A = [1 2 3; 4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> Diagonal(A)\n2×2 Diagonal{Int64, Vector{Int64}}:\n 1  ⋅\n ⋅  5\n\n\n\n\n\nDiagonal{T}(undef, n)\n\nConstruct an uninitialized Diagonal{T} of length n. See undef.\n\n\n\n\n\n"},{"title":"LinearAlgebra.Bidiagonal","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.Bidiagonal","category":"type","text":"Bidiagonal(dv::V, ev::V, uplo::Symbol) where V <: AbstractVector\n\nConstructs an upper (uplo=:U) or lower (uplo=:L) bidiagonal matrix using the\ngiven diagonal (dv) and off-diagonal (ev) vectors. The result is of type Bidiagonal\nand provides efficient specialized linear solvers, but may be converted into a regular\nmatrix with convert(Array, _) (or Array(_) for short). The length of ev\nmust be one less than the length of dv.\n\nExamples\n\njulia> dv = [1, 2, 3, 4]\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> ev = [7, 8, 9]\n3-element Vector{Int64}:\n 7\n 8\n 9\n\njulia> Bu = Bidiagonal(dv, ev, :U) # ev is on the first superdiagonal\n4×4 Bidiagonal{Int64, Vector{Int64}}:\n 1  7  ⋅  ⋅\n ⋅  2  8  ⋅\n ⋅  ⋅  3  9\n ⋅  ⋅  ⋅  4\n\njulia> Bl = Bidiagonal(dv, ev, :L) # ev is on the first subdiagonal\n4×4 Bidiagonal{Int64, Vector{Int64}}:\n 1  ⋅  ⋅  ⋅\n 7  2  ⋅  ⋅\n ⋅  8  3  ⋅\n ⋅  ⋅  9  4\n\n\n\n\n\n"},{"title":"LinearAlgebra.SymTridiagonal","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.SymTridiagonal","category":"type","text":"SymTridiagonal(dv::V, ev::V) where V <: AbstractVector\n\nConstruct a symmetric tridiagonal matrix from the diagonal (dv) and first\nsub/super-diagonal (ev), respectively. The result is of type SymTridiagonal\nand provides efficient specialized eigensolvers, but may be converted into a\nregular matrix with convert(Array, _) (or Array(_) for short).\n\nFor SymTridiagonal block matrices, the elements of dv are symmetrized.\nThe argument ev is interpreted as the superdiagonal. Blocks from the\nsubdiagonal are (materialized) transpose of the corresponding superdiagonal blocks.\n\nExamples\n\njulia> dv = [1, 2, 3, 4]\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> ev = [7, 8, 9]\n3-element Vector{Int64}:\n 7\n 8\n 9\n\njulia> SymTridiagonal(dv, ev)\n4×4 SymTridiagonal{Int64, Vector{Int64}}:\n 1  7  ⋅  ⋅\n 7  2  8  ⋅\n ⋅  8  3  9\n ⋅  ⋅  9  4\n\njulia> A = SymTridiagonal(fill([1 2; 3 4], 3), fill([1 2; 3 4], 2));\n\njulia> A[1,1]\n2×2 Symmetric{Int64, Matrix{Int64}}:\n 1  2\n 2  4\n\njulia> A[1,2]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> A[2,1]\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\n\n\n\n\n"},{"title":"LinearAlgebra.Tridiagonal","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.Tridiagonal","category":"type","text":"Tridiagonal(dl::V, d::V, du::V) where V <: AbstractVector\n\nConstruct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal,\nrespectively. The result is of type Tridiagonal and provides efficient specialized linear\nsolvers, but may be converted into a regular matrix with\nconvert(Array, _) (or Array(_) for short).\nThe lengths of dl and du must be one less than the length of d.\n\nnote: Note\nThe subdiagonal dl and the superdiagonal du must not be aliased to each other.\nIf aliasing is detected, the constructor will use a copy of du as its argument.\n\nExamples\n\njulia> dl = [1, 2, 3];\n\njulia> du = [4, 5, 6];\n\njulia> d = [7, 8, 9, 0];\n\njulia> Tridiagonal(dl, d, du)\n4×4 Tridiagonal{Int64, Vector{Int64}}:\n 7  4  ⋅  ⋅\n 1  8  5  ⋅\n ⋅  2  9  6\n ⋅  ⋅  3  0\n\n\n\n\n\n"},{"title":"LinearAlgebra.Symmetric","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.Symmetric","category":"type","text":"Symmetric(A::AbstractMatrix, uplo::Symbol=:U)\n\nConstruct a Symmetric view of the upper (if uplo = :U) or lower (if uplo = :L)\ntriangle of the matrix A.\n\nSymmetric views are mainly useful for real-symmetric matrices, for which\nspecialized algorithms (e.g. for eigenproblems) are enabled for Symmetric types.\nMore generally, see also Hermitian(A) for Hermitian matrices A == A', which\nis effectively equivalent to Symmetric for real matrices but is also useful for\ncomplex matrices.  (Whereas complex Symmetric matrices are supported but have few\nif any specialized algorithms.)\n\nTo compute the symmetric part of a real matrix, or more generally the Hermitian part (A + A') / 2 of\na real or complex matrix A, use hermitianpart.\n\nThe uplo symbol corresponding to the triangular half of A that is shared by the symmetric view may be\nfetched by using the function LinearAlgebra.uplo. The underlying matrix A may be fetched from the symmetric\nview by using parent.\n\nExamples\n\njulia> A = [1 2 3; 4 5 6; 7 8 9]\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> Supper = Symmetric(A)\n3×3 Symmetric{Int64, Matrix{Int64}}:\n 1  2  3\n 2  5  6\n 3  6  9\n\njulia> Slower = Symmetric(A, :L)\n3×3 Symmetric{Int64, Matrix{Int64}}:\n 1  4  7\n 4  5  8\n 7  8  9\n\njulia> hermitianpart(A)\n3×3 Hermitian{Float64, Matrix{Float64}}:\n 1.0  3.0  5.0\n 3.0  5.0  7.0\n 5.0  7.0  9.0\n\nNote that Supper will not be equal to Slower unless A is itself symmetric (e.g. if\nA == transpose(A)).\n\n\n\n\n\n"},{"title":"LinearAlgebra.Hermitian","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.Hermitian","category":"type","text":"Hermitian(A::AbstractMatrix, uplo::Symbol=:U)\n\nConstruct a Hermitian view of the upper (if uplo = :U) or lower (if uplo = :L)\ntriangle of the matrix A.\n\nTo compute the Hermitian part of A, use hermitianpart.\n\nThe uplo symbol corresponding to the triangular half of A that is shared by the hermitian view may be\nfetched by using the function LinearAlgebra.uplo. The underlying matrix A may be fetched from the hermitian\nview by using parent.\n\nExamples\n\njulia> A = [1 2+2im 3-3im; 4 5 6-6im; 7 8+8im 9]\n3×3 Matrix{Complex{Int64}}:\n 1+0im  2+2im  3-3im\n 4+0im  5+0im  6-6im\n 7+0im  8+8im  9+0im\n\njulia> Hupper = Hermitian(A)\n3×3 Hermitian{Complex{Int64}, Matrix{Complex{Int64}}}:\n 1+0im  2+2im  3-3im\n 2-2im  5+0im  6-6im\n 3+3im  6+6im  9+0im\n\njulia> Hlower = Hermitian(A, :L)\n3×3 Hermitian{Complex{Int64}, Matrix{Complex{Int64}}}:\n 1+0im  4+0im  7+0im\n 4+0im  5+0im  8-8im\n 7+0im  8+8im  9+0im\n\njulia> hermitianpart(A)\n3×3 Hermitian{ComplexF64, Matrix{ComplexF64}}:\n 1.0+0.0im  3.0+1.0im  5.0-1.5im\n 3.0-1.0im  5.0+0.0im  7.0-7.0im\n 5.0+1.5im  7.0+7.0im  9.0+0.0im\n\nNote that Hupper will not be equal to Hlower unless A is itself Hermitian (e.g. if A == adjoint(A)).\n\nAll non-real parts of the diagonal will be ignored.\n\nHermitian(fill(complex(1,1), 1, 1)) == fill(1, 1, 1)\n\n\n\n\n\n"},{"title":"LinearAlgebra.LowerTriangular","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LowerTriangular","category":"type","text":"LowerTriangular(A::AbstractMatrix)\n\nConstruct a LowerTriangular view of the matrix A.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]\n3×3 Matrix{Float64}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n 7.0  8.0  9.0\n\njulia> LowerTriangular(A)\n3×3 LowerTriangular{Float64, Matrix{Float64}}:\n 1.0   ⋅    ⋅\n 4.0  5.0   ⋅\n 7.0  8.0  9.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.UpperTriangular","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.UpperTriangular","category":"type","text":"UpperTriangular(A::AbstractMatrix)\n\nConstruct an UpperTriangular view of the matrix A.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]\n3×3 Matrix{Float64}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n 7.0  8.0  9.0\n\njulia> UpperTriangular(A)\n3×3 UpperTriangular{Float64, Matrix{Float64}}:\n 1.0  2.0  3.0\n  ⋅   5.0  6.0\n  ⋅    ⋅   9.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.UnitLowerTriangular","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.UnitLowerTriangular","category":"type","text":"UnitLowerTriangular(A::AbstractMatrix)\n\nConstruct a UnitLowerTriangular view of the matrix A.\nSuch a view has the oneunit of the eltype\nof A on its diagonal.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]\n3×3 Matrix{Float64}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n 7.0  8.0  9.0\n\njulia> UnitLowerTriangular(A)\n3×3 UnitLowerTriangular{Float64, Matrix{Float64}}:\n 1.0   ⋅    ⋅\n 4.0  1.0   ⋅\n 7.0  8.0  1.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.UnitUpperTriangular","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.UnitUpperTriangular","category":"type","text":"UnitUpperTriangular(A::AbstractMatrix)\n\nConstruct an UnitUpperTriangular view of the matrix A.\nSuch a view has the oneunit of the eltype\nof A on its diagonal.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]\n3×3 Matrix{Float64}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n 7.0  8.0  9.0\n\njulia> UnitUpperTriangular(A)\n3×3 UnitUpperTriangular{Float64, Matrix{Float64}}:\n 1.0  2.0  3.0\n  ⋅   1.0  6.0\n  ⋅    ⋅   1.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.UpperHessenberg","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.UpperHessenberg","category":"type","text":"UpperHessenberg(A::AbstractMatrix)\n\nConstruct an UpperHessenberg view of the matrix A.\nEntries of A below the first subdiagonal are ignored.\n\ncompat: Julia 1.3\nThis type was added in Julia 1.3.\n\nEfficient algorithms are implemented for H \\ b, det(H), and similar.\n\nSee also the hessenberg function to factor any matrix into a similar\nupper-Hessenberg matrix.\n\nIf F::Hessenberg is the factorization object, the unitary matrix can be accessed\nwith F.Q and the Hessenberg matrix with F.H. When Q is extracted, the resulting\ntype is the HessenbergQ object, and may be converted to a regular matrix with\nconvert(Array, _) (or Array(_) for short).\n\nIterating the decomposition produces the factors F.Q and F.H.\n\nExamples\n\njulia> A = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]\n4×4 Matrix{Int64}:\n  1   2   3   4\n  5   6   7   8\n  9  10  11  12\n 13  14  15  16\n\njulia> UpperHessenberg(A)\n4×4 UpperHessenberg{Int64, Matrix{Int64}}:\n 1   2   3   4\n 5   6   7   8\n ⋅  10  11  12\n ⋅   ⋅  15  16\n\n\n\n\n\n"},{"title":"LinearAlgebra.UniformScaling","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.UniformScaling","category":"type","text":"UniformScaling{T<:Number}\n\nGenerically sized uniform scaling operator defined as a scalar times\nthe identity operator, λ*I. Although without an explicit size, it\nacts similarly to a matrix in many cases and includes support for some\nindexing. See also I.\n\ncompat: Julia 1.6\nIndexing using ranges is available as of Julia 1.6.\n\nExamples\n\njulia> J = UniformScaling(2.)\nUniformScaling{Float64}\n2.0*I\n\njulia> A = [1. 2.; 3. 4.]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> J*A\n2×2 Matrix{Float64}:\n 2.0  4.0\n 6.0  8.0\n\njulia> J[1:2, 1:2]\n2×2 Matrix{Float64}:\n 2.0  0.0\n 0.0  2.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.I","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.I","category":"constant","text":"I\n\nAn object of type UniformScaling, representing an identity matrix of any size.\n\nExamples\n\njulia> fill(1, (5,6)) * I == fill(1, (5,6))\ntrue\n\njulia> [1 2im 3; 1im 2 3] * I\n2×3 Matrix{Complex{Int64}}:\n 1+0im  0+2im  3+0im\n 0+1im  2+0im  3+0im\n\n\n\n\n\n"},{"title":"LinearAlgebra.UniformScaling","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.UniformScaling-Tuple{Integer}","category":"method","text":"(I::UniformScaling)(n::Integer)\n\nConstruct a Diagonal matrix from a UniformScaling.\n\ncompat: Julia 1.2\nThis method is available as of Julia 1.2.\n\nExamples\n\njulia> I(3)\n3×3 Diagonal{Bool, Vector{Bool}}:\n 1  ⋅  ⋅\n ⋅  1  ⋅\n ⋅  ⋅  1\n\njulia> (0.7*I)(3)\n3×3 Diagonal{Float64, Vector{Float64}}:\n 0.7   ⋅    ⋅\n  ⋅   0.7   ⋅\n  ⋅    ⋅   0.7\n\n\n\n\n\n"},{"title":"LinearAlgebra.Factorization","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.Factorization","category":"type","text":"LinearAlgebra.Factorization\n\nAbstract type for matrix factorizations\na.k.a. matrix decompositions.\nSee online documentation for a list of available\nmatrix factorizations.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LU","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LU","category":"type","text":"LU <: Factorization\n\nMatrix factorization type of the LU factorization of a square matrix A. This\nis the return type of lu, the corresponding matrix factorization function.\n\nThe individual components of the factorization F::LU can be accessed via getproperty:\n\nComponent Description\nF.L L (unit lower triangular) part of LU\nF.U U (upper triangular) part of LU\nF.p (right) permutation Vector\nF.P (right) permutation Matrix\n\nIterating the factorization produces the components F.L, F.U, and F.p.\n\nExamples\n\njulia> A = [4 3; 6 3]\n2×2 Matrix{Int64}:\n 4  3\n 6  3\n\njulia> F = lu(A)\nLU{Float64, Matrix{Float64}, Vector{Int64}}\nL factor:\n2×2 Matrix{Float64}:\n 1.0       0.0\n 0.666667  1.0\nU factor:\n2×2 Matrix{Float64}:\n 6.0  3.0\n 0.0  1.0\n\njulia> F.L * F.U == A[F.p, :]\ntrue\n\njulia> l, u, p = lu(A); # destructuring via iteration\n\njulia> l == F.L && u == F.U && p == F.p\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.lu","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.lu","category":"function","text":"lu(A::AbstractSparseMatrixCSC; check = true, q = nothing, control = get_umfpack_control()) -> F::UmfpackLU\n\nCompute the LU factorization of a sparse matrix A.\n\nFor sparse A with real or complex element type, the return type of F is\nUmfpackLU{Tv, Ti}, with Tv = Float64 or ComplexF64 respectively and\nTi is an integer type (Int32 or Int64).\n\nWhen check = true, an error is thrown if the decomposition fails.\nWhen check = false, responsibility for checking the decomposition's\nvalidity (via issuccess) lies with the user.\n\nThe permutation q can either be a permutation vector or nothing. If no permutation vector\nis provided or q is nothing, UMFPACK's default is used. If the permutation is not zero-based, a\nzero-based copy is made.\n\nThe control vector defaults to the Julia SparseArrays package's default configuration for UMFPACK (NB: this is modified from the UMFPACK defaults to\ndisable iterative refinement), but can be changed by passing a vector of length UMFPACK_CONTROL, see the UMFPACK manual for possible configurations. \nFor example to reenable iterative refinement:\n\numfpack_control = SparseArrays.UMFPACK.get_umfpack_control(Float64, Int64) # read Julia default configuration for a Float64 sparse matrix\nSparseArrays.UMFPACK.show_umf_ctrl(umfpack_control) # optional - display values\numfpack_control[SparseArrays.UMFPACK.JL_UMFPACK_IRSTEP] = 2.0 # reenable iterative refinement (2 is UMFPACK default max iterative refinement steps)\n\nAlu = lu(A; control = umfpack_control)\nx = Alu \\ b   # solve Ax = b, including UMFPACK iterative refinement\n\nThe individual components of the factorization F can be accessed by indexing:\n\nComponent Description\nL L (lower triangular) part of LU\nU U (upper triangular) part of LU\np right permutation Vector\nq left permutation Vector\nRs Vector of scaling factors\n: (L,U,p,q,Rs) components\n\nThe relation between F and A is\n\nF.L*F.U == (F.Rs .* A)[F.p, F.q]\n\nF further supports the following functions:\n\n\\\ndet\n\nSee also lu!\n\nnote: Note\nlu(A::AbstractSparseMatrixCSC) uses the UMFPACK[ACM832] library that is part of\nSuiteSparse.\nAs this library only supports sparse matrices with Float64 or\nComplexF64 elements, lu converts A into a copy that is of type\nSparseMatrixCSC{Float64} or SparseMatrixCSC{ComplexF64} as appropriate.\n\n[ACM832]: Davis, Timothy A. (2004b). Algorithm 832: UMFPACK V4.3—an Unsymmetric-Pattern Multifrontal Method. ACM Trans. Math. Softw., 30(2), 196–199. doi:10.1145/992200.992206\n\n\n\n\n\nlu(A, pivot = RowMaximum(); check = true, allowsingular = false) -> F::LU\n\nCompute the LU factorization of A.\n\nWhen check = true, an error is thrown if the decomposition fails.\nWhen check = false, responsibility for checking the decomposition's\nvalidity (via issuccess) lies with the user.\n\nBy default, with check = true, an error is also thrown when the decomposition\nproduces valid factors, but the upper-triangular factor U is rank-deficient. This may be changed by\npassing allowsingular = true.\n\nIn most cases, if A is a subtype S of AbstractMatrix{T} with an element\ntype T supporting +, -, * and /, the return type is LU{T,S{T}}.\n\nIn general, LU factorization involves a permutation of the rows of the matrix\n(corresponding to the F.p output described below), known as \"pivoting\" (because it\ncorresponds to choosing which row contains the \"pivot\", the diagonal entry of F.U).\nOne of the following pivoting strategies can be selected via the optional pivot argument:\n\nRowMaximum() (default): the standard pivoting strategy; the pivot corresponds\nto the element of maximum absolute value among the remaining, to be factorized rows.\nThis pivoting strategy requires the element type to also support abs and\n<. (This is generally the only numerically stable option for floating-point\nmatrices.)\nRowNonZero(): the pivot corresponds to the first non-zero element among the remaining,\nto be factorized rows.  (This corresponds to the typical choice in hand calculations, and\nis also useful for more general algebraic number types that support iszero but\nnot abs or <.)\nNoPivot(): pivoting turned off (will fail if a zero entry is encountered in\na pivot position, even when allowsingular = true).\n\nThe individual components of the factorization F can be accessed via getproperty:\n\nComponent Description\nF.L L (lower triangular) part of LU\nF.U U (upper triangular) part of LU\nF.p (right) permutation Vector\nF.P (right) permutation Matrix\n\nIterating the factorization produces the components F.L, F.U, and F.p.\n\nThe relationship between F and A is\n\nF.L*F.U == A[F.p, :]\n\nF further supports the following functions:\n\nSupported function LU LU{T,Tridiagonal{T}}\n/ ✓ \n\\ ✓ ✓\ninv ✓ ✓\ndet ✓ ✓\nlogdet ✓ ✓\nlogabsdet ✓ ✓\nsize ✓ ✓\n\ncompat: Julia 1.11\nThe allowsingular keyword argument was added in Julia 1.11.\n\nExamples\n\njulia> A = [4 3; 6 3]\n2×2 Matrix{Int64}:\n 4  3\n 6  3\n\njulia> F = lu(A)\nLU{Float64, Matrix{Float64}, Vector{Int64}}\nL factor:\n2×2 Matrix{Float64}:\n 1.0       0.0\n 0.666667  1.0\nU factor:\n2×2 Matrix{Float64}:\n 6.0  3.0\n 0.0  1.0\n\njulia> F.L * F.U == A[F.p, :]\ntrue\n\njulia> l, u, p = lu(A); # destructuring via iteration\n\njulia> l == F.L && u == F.U && p == F.p\ntrue\n\njulia> lu([1 2; 1 2], allowsingular = true)\nLU{Float64, Matrix{Float64}, Vector{Int64}}\nL factor:\n2×2 Matrix{Float64}:\n 1.0  0.0\n 1.0  1.0\nU factor (rank-deficient):\n2×2 Matrix{Float64}:\n 1.0  2.0\n 0.0  0.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.lu!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.lu!","category":"function","text":"lu!(F::UmfpackLU, A::AbstractSparseMatrixCSC; check=true, reuse_symbolic=true, q=nothing) -> F::UmfpackLU\n\nCompute the LU factorization of a sparse matrix A, reusing the symbolic\nfactorization of an already existing LU factorization stored in F.\nUnless reuse_symbolic is set to false, the sparse matrix A must have an\nidentical nonzero pattern as the matrix used to create the LU factorization F,\notherwise an error is thrown. If the size of A and F differ, all vectors will\nbe resized accordingly.\n\nWhen check = true, an error is thrown if the decomposition fails.\nWhen check = false, responsibility for checking the decomposition's\nvalidity (via issuccess) lies with the user.\n\nThe permutation q can either be a permutation vector or nothing. If no permutation vector\nis provided or q is nothing, UMFPACK's default is used. If the permutation is not zero based, a\nzero based copy is made.\n\nSee also lu\n\nnote: Note\nlu!(F::UmfpackLU, A::AbstractSparseMatrixCSC) uses the UMFPACK library that is part of\nSuiteSparse. As this library only supports sparse matrices with Float64 or\nComplexF64 elements, lu! will automatically convert the types to those set by the LU\nfactorization or SparseMatrixCSC{ComplexF64} as appropriate.\n\ncompat: Julia 1.5\nlu! for UmfpackLU requires at least Julia 1.5.\n\nExamples\n\njulia> A = sparse(Float64[1.0 2.0; 0.0 3.0]);\n\njulia> F = lu(A);\n\njulia> B = sparse(Float64[1.0 1.0; 0.0 1.0]);\n\njulia> lu!(F, B);\n\njulia> F \\ ones(2)\n2-element Vector{Float64}:\n 0.0\n 1.0\n\n\n\n\n\nlu!(F::LU, pivot = RowMaximum(); check = true, allowsingular = false) -> LU\n\nlu! is the same as lu, but saves space by overwriting the\ninput F, instead of creating a copy.\n\ncompat: Julia 1.13\nReusing dense LU factorizations in lu! require Julia 1.13 or later.\n\nExamples\n\njulia> A = [4. 3.; 6. 3.]\n2×2 Matrix{Float64}:\n 4.0  3.0\n 6.0  3.0\n\njulia> F = lu(A)\nLU{Float64, Matrix{Float64}, Vector{Int64}}\nL factor:\n2×2 Matrix{Float64}:\n 1.0       0.0\n 0.666667  1.0\nU factor:\n2×2 Matrix{Float64}:\n 6.0  3.0\n 0.0  1.0\n\njulia> B = [8 3; 12 3]\n2×2 Matrix{Int64}:\n  8  3\n 12  3\n\njulia> F2 = lu!(F,B)\nLU{Float64, Matrix{Float64}, Vector{Int64}}\nL factor:\n2×2 Matrix{Float64}:\n 1.0       0.0\n 0.666667  1.0\nU factor:\n2×2 Matrix{Float64}:\n 12.0  3.0\n  0.0  1.0\n\n\n\n\n\nlu!(A, pivot = RowMaximum(); check = true, allowsingular = false) -> LU\n\nlu! is the same as lu, but saves space by overwriting the\ninput A, instead of creating a copy. An InexactError\nexception is thrown if the factorization produces a number not representable by the\nelement type of A, e.g. for integer types.\n\ncompat: Julia 1.11\nThe allowsingular keyword argument was added in Julia 1.11.\n\nExamples\n\njulia> A = [4. 3.; 6. 3.]\n2×2 Matrix{Float64}:\n 4.0  3.0\n 6.0  3.0\n\njulia> F = lu!(A)\nLU{Float64, Matrix{Float64}, Vector{Int64}}\nL factor:\n2×2 Matrix{Float64}:\n 1.0       0.0\n 0.666667  1.0\nU factor:\n2×2 Matrix{Float64}:\n 6.0  3.0\n 0.0  1.0\n\njulia> iA = [4 3; 6 3]\n2×2 Matrix{Int64}:\n 4  3\n 6  3\n\njulia> lu!(iA)\nERROR: InexactError: Int64(0.6666666666666666)\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"LinearAlgebra.Cholesky","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.Cholesky","category":"type","text":"Cholesky <: Factorization\n\nMatrix factorization type of the Cholesky factorization of a dense symmetric/Hermitian\npositive definite matrix A. This is the return type of cholesky,\nthe corresponding matrix factorization function.\n\nThe triangular Cholesky factor can be obtained from the factorization F::Cholesky\nvia F.L and F.U, where A ≈ F.U' * F.U ≈ F.L * F.L'.\n\nThe following functions are available for Cholesky objects: size, \\,\ninv, det, logdet and isposdef.\n\nIterating the decomposition produces the components L and U.\n\nExamples\n\njulia> A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]\n3×3 Matrix{Float64}:\n   4.0   12.0  -16.0\n  12.0   37.0  -43.0\n -16.0  -43.0   98.0\n\njulia> C = cholesky(A)\nCholesky{Float64, Matrix{Float64}}\nU factor:\n3×3 UpperTriangular{Float64, Matrix{Float64}}:\n 2.0  6.0  -8.0\n  ⋅   1.0   5.0\n  ⋅    ⋅    3.0\n\njulia> C.U\n3×3 UpperTriangular{Float64, Matrix{Float64}}:\n 2.0  6.0  -8.0\n  ⋅   1.0   5.0\n  ⋅    ⋅    3.0\n\njulia> C.L\n3×3 LowerTriangular{Float64, Adjoint{Float64, Matrix{Float64}}}:\n  2.0   ⋅    ⋅\n  6.0  1.0   ⋅\n -8.0  5.0  3.0\n\njulia> C.L * C.U == A\ntrue\n\njulia> l, u = C; # destructuring via iteration\n\njulia> l == C.L && u == C.U\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.CholeskyPivoted","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.CholeskyPivoted","category":"type","text":"CholeskyPivoted\n\nMatrix factorization type of the pivoted Cholesky factorization of a dense symmetric/Hermitian\npositive semi-definite matrix A. This is the return type of cholesky(_, ::RowMaximum),\nthe corresponding matrix factorization function.\n\nThe triangular Cholesky factor can be obtained from the factorization F::CholeskyPivoted\nvia F.L and F.U, and the permutation via F.p, where A[F.p, F.p] ≈ Ur' * Ur ≈ Lr * Lr'\nwith Ur = F.U[1:F.rank, :] and Lr = F.L[:, 1:F.rank], or alternatively\nA ≈ Up' * Up ≈ Lp * Lp' with Up = F.U[1:F.rank, invperm(F.p)] and\nLp = F.L[invperm(F.p), 1:F.rank].\n\nThe following functions are available for CholeskyPivoted objects:\nsize, \\, inv, det, and rank.\n\nIterating the decomposition produces the components L and U.\n\nExamples\n\njulia> X = [1.0, 2.0, 3.0, 4.0];\n\njulia> A = X * X';\n\njulia> C = cholesky(A, RowMaximum(), check = false)\nCholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}\nU factor with rank 1:\n4×4 UpperTriangular{Float64, Matrix{Float64}}:\n 4.0  2.0  3.0  1.0\n  ⋅   0.0  6.0  2.0\n  ⋅    ⋅   9.0  3.0\n  ⋅    ⋅    ⋅   1.0\npermutation:\n4-element Vector{Int64}:\n 4\n 2\n 3\n 1\n\njulia> C.U[1:C.rank, :]' * C.U[1:C.rank, :] ≈ A[C.p, C.p]\ntrue\n\njulia> l, u = C; # destructuring via iteration\n\njulia> l == C.L && u == C.U\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.cholesky","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.cholesky","category":"function","text":"cholesky(A::SparseMatrixCSC; shift = 0.0, check = true, perm = nothing) -> CHOLMOD.Factor\n\nCompute the Cholesky factorization of a sparse positive definite matrix A.\nA must be a SparseMatrixCSC or a Symmetric/Hermitian\nview of a SparseMatrixCSC. Note that if A doesn't\nhave the type tag, it must itself be symmetric or Hermitian.\nIf perm is not given, a fill-reducing permutation is used.\nF = cholesky(A) is most frequently used to solve systems of equations with F\\b,\nbut also the methods diag, det, and\nlogdet are defined for F.\nYou can also extract individual factors from F, using F.L.\nHowever, since pivoting is on by default, the factorization is internally\nrepresented as A == P'*L*L'*P with a permutation matrix P;\nusing just L without accounting for P will give incorrect answers.\nTo include the effects of permutation,\nit's typically preferable to extract \"combined\" factors like PtL = F.PtL\n(the equivalent of P'*L) and LtP = F.UP (the equivalent of L'*P).\nThe complete list of supported factors is :L, :PtL, :UP, :U.\nThe permutation vector is available as F.p, defined such that L*L' == A[p, p],\n\nThe L component can be materialized as a sparse matrix using sparse(F.L).\nOther components cannot be materialized directly, but can be reconstructed\nfrom sparse(F.L) and F.p if needed.\n\nWhen check = true, an error is thrown if the decomposition fails.\nWhen check = false, responsibility for checking the decomposition's\nvalidity (via issuccess) lies with the user.\n\nSetting the optional shift keyword argument computes the factorization of\nA+shift*I instead of A. If the perm argument is provided,\nit should be a permutation of 1:size(A,1) giving the ordering to use\n(instead of CHOLMOD's default AMD ordering).\n\nSee also ldlt for a similar factorization that does not require\npositive definiteness, but can be significantly slower than cholesky.\n\nExamples\n\nIn the following example, the fill-reducing permutation used is [3, 2, 1].\nIf perm is set to 1:3 to enforce no permutation, the number of nonzero\nelements in the factor is 6.\n\njulia> A = [2 1 1; 1 2 0; 1 0 2]\n3×3 Matrix{Int64}:\n 2  1  1\n 1  2  0\n 1  0  2\n\njulia> C = cholesky(sparse(A))\nSparseArrays.CHOLMOD.Factor{Float64, Int64}\ntype:    LLt\nmethod:  simplicial\nmaxnnz:  5\nnnz:     5\nsuccess: true\n\njulia> C.p\n3-element Vector{Int64}:\n 3\n 2\n 1\n\njulia> L = sparse(C.L);\n\njulia> Matrix(L)\n3×3 Matrix{Float64}:\n 1.41421   0.0       0.0\n 0.0       1.41421   0.0\n 0.707107  0.707107  1.0\n\njulia> L * L' ≈ A[C.p, C.p]\ntrue\n\njulia> P = sparse(1:3, C.p, ones(3))\n3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:\n  ⋅    ⋅   1.0\n  ⋅   1.0   ⋅\n 1.0   ⋅    ⋅\n\njulia> P' * L * L' * P ≈ A\ntrue\n\njulia> C = cholesky(sparse(A), perm=1:3)\nSparseArrays.CHOLMOD.Factor{Float64, Int64}\ntype:    LLt\nmethod:  simplicial\nmaxnnz:  6\nnnz:     6\nsuccess: true\n\njulia> L = sparse(C.L);\n\njulia> Matrix(L)\n3×3 Matrix{Float64}:\n 1.41421    0.0       0.0\n 0.707107   1.22474   0.0\n 0.707107  -0.408248  1.1547\n\njulia> L * L' ≈ A\ntrue\n\nnote: Note\nThis method uses the CHOLMOD[ACM887][DavisHager2009] library from SuiteSparse.\nCHOLMOD only supports real or complex types in single or double precision.\nInput matrices not of those element types will be\nconverted to these types as appropriate.Many other functions from CHOLMOD are wrapped but not exported from the\nBase.SparseArrays.CHOLMOD module.\n\n[ACM887]: Chen, Y., Davis, T. A., Hager, W. W., & Rajamanickam, S. (2008). Algorithm 887: CHOLMOD, Supernodal Sparse Cholesky Factorization and Update/Downdate. ACM Trans. Math. Softw., 35(3). doi:10.1145/1391989.1391995\n\n[DavisHager2009]: Davis, Timothy A., & Hager, W. W. (2009). Dynamic Supernodes in Sparse Cholesky Update/Downdate and Triangular Solves. ACM Trans. Math. Softw., 35(4). doi:10.1145/1462173.1462176\n\n\n\n\n\ncholesky(A, NoPivot(); check = true) -> Cholesky\n\nCompute the Cholesky factorization of a dense symmetric positive definite matrix A\nand return a Cholesky factorization. The matrix A can either be a Symmetric or Hermitian\nAbstractMatrix or a perfectly symmetric or Hermitian AbstractMatrix.\n\nThe triangular Cholesky factor can be obtained from the factorization F via F.L and F.U,\nwhere A ≈ F.U' * F.U ≈ F.L * F.L'.\n\nThe following functions are available for Cholesky objects: size, \\,\ninv, det, logdet and isposdef.\n\nIf you have a matrix A that is slightly non-Hermitian due to roundoff errors in its construction,\nwrap it in Hermitian(A) before passing it to cholesky in order to treat it as perfectly Hermitian.\n\nWhen check = true, an error is thrown if the decomposition fails.\nWhen check = false, responsibility for checking the decomposition's\nvalidity (via issuccess) lies with the user.\n\nExamples\n\njulia> A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]\n3×3 Matrix{Float64}:\n   4.0   12.0  -16.0\n  12.0   37.0  -43.0\n -16.0  -43.0   98.0\n\njulia> C = cholesky(A)\nCholesky{Float64, Matrix{Float64}}\nU factor:\n3×3 UpperTriangular{Float64, Matrix{Float64}}:\n 2.0  6.0  -8.0\n  ⋅   1.0   5.0\n  ⋅    ⋅    3.0\n\njulia> C.U\n3×3 UpperTriangular{Float64, Matrix{Float64}}:\n 2.0  6.0  -8.0\n  ⋅   1.0   5.0\n  ⋅    ⋅    3.0\n\njulia> C.L\n3×3 LowerTriangular{Float64, Adjoint{Float64, Matrix{Float64}}}:\n  2.0   ⋅    ⋅\n  6.0  1.0   ⋅\n -8.0  5.0  3.0\n\njulia> C.L * C.U == A\ntrue\n\n\n\n\n\ncholesky(A, RowMaximum(); tol = 0.0, check = true) -> CholeskyPivoted\n\nCompute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix A\nand return a CholeskyPivoted factorization. The matrix A can either be a Symmetric\nor Hermitian AbstractMatrix or a perfectly symmetric or Hermitian AbstractMatrix.\n\nThe triangular Cholesky factor can be obtained from the factorization F via F.L and F.U,\nand the permutation via F.p, where A[F.p, F.p] ≈ Ur' * Ur ≈ Lr * Lr' with Ur = F.U[1:F.rank, :]\nand Lr = F.L[:, 1:F.rank], or alternatively A ≈ Up' * Up ≈ Lp * Lp' with\nUp = F.U[1:F.rank, invperm(F.p)] and Lp = F.L[invperm(F.p), 1:F.rank].\n\nThe following functions are available for CholeskyPivoted objects:\nsize, \\, inv, det, and rank.\n\nThe argument tol determines the tolerance for determining the rank.\nFor negative values, the tolerance is equal to eps()*size(A,1)*maximum(diag(A)).\n\nIf you have a matrix A that is slightly non-Hermitian due to roundoff errors in its construction,\nwrap it in Hermitian(A) before passing it to cholesky in order to treat it as perfectly Hermitian.\n\nWhen check = true, an error is thrown if the decomposition fails.\nWhen check = false, responsibility for checking the decomposition's\nvalidity (via issuccess) lies with the user.\n\nExamples\n\njulia> X = [1.0, 2.0, 3.0, 4.0];\n\njulia> A = X * X';\n\njulia> C = cholesky(A, RowMaximum(), check = false)\nCholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}\nU factor with rank 1:\n4×4 UpperTriangular{Float64, Matrix{Float64}}:\n 4.0  2.0  3.0  1.0\n  ⋅   0.0  6.0  2.0\n  ⋅    ⋅   9.0  3.0\n  ⋅    ⋅    ⋅   1.0\npermutation:\n4-element Vector{Int64}:\n 4\n 2\n 3\n 1\n\njulia> C.U[1:C.rank, :]' * C.U[1:C.rank, :] ≈ A[C.p, C.p]\ntrue\n\njulia> l, u = C; # destructuring via iteration\n\njulia> l == C.L && u == C.U\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.cholesky!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.cholesky!","category":"function","text":"cholesky!(F::CHOLMOD.Factor, A::SparseMatrixCSC; shift = 0.0, check = true) -> CHOLMOD.Factor\n\nCompute the Cholesky (LL) factorization of A, reusing the symbolic\nfactorization F. A must be a SparseMatrixCSC or a Symmetric/\nHermitian view of a SparseMatrixCSC. Note that if A doesn't\nhave the type tag, it must itself be symmetric or Hermitian.\n\nSee also cholesky.\n\nnote: Note\nThis method uses the CHOLMOD library from SuiteSparse, which only supports\nreal or complex types in single or double precision.\nInput matrices not of those element types will\nbe converted to these types as appropriate.\n\n\n\n\n\ncholesky!(A::AbstractMatrix, NoPivot(); check = true) -> Cholesky\n\nThe same as cholesky, but saves space by overwriting the input A,\ninstead of creating a copy. An InexactError exception is thrown if\nthe factorization produces a number not representable by the element type of\nA, e.g. for integer types.\n\nExamples\n\njulia> A = [1 2; 2 50]\n2×2 Matrix{Int64}:\n 1   2\n 2  50\n\njulia> cholesky!(A)\nERROR: InexactError: Int64(6.782329983125268)\nStacktrace:\n[...]\n\n\n\n\n\ncholesky!(A::AbstractMatrix, RowMaximum(); tol = 0.0, check = true) -> CholeskyPivoted\n\nThe same as cholesky, but saves space by overwriting the input A,\ninstead of creating a copy. An InexactError exception is thrown if the\nfactorization produces a number not representable by the element type of A,\ne.g. for integer types.\n\n\n\n\n\n"},{"title":"LinearAlgebra.lowrankupdate","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.lowrankupdate","category":"function","text":"lowrankupdate(F::CHOLMOD.Factor, C::AbstractArray) -> FF::CHOLMOD.Factor\n\nGet an LDLt Factorization of A + C*C' given an LDLt or LLt factorization F of A.\n\nThe returned factor is always an LDLt factorization.\n\nSee also lowrankupdate!, lowrankdowndate, lowrankdowndate!.\n\n\n\n\n\nlowrankupdate(C::Cholesky, v::AbstractVector) -> CC::Cholesky\n\nUpdate a Cholesky factorization C with the vector v. If A = C.U'C.U\nthen CC = cholesky(C.U'C.U + v*v') but the computation of CC only uses\nO(n^2) operations.\n\n\n\n\n\n"},{"title":"LinearAlgebra.lowrankdowndate","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.lowrankdowndate","category":"function","text":"lowrankdowndate(F::CHOLMOD.Factor, C::AbstractArray) -> FF::CHOLMOD.Factor\n\nGet an LDLt Factorization of A + C*C' given an LDLt or LLt factorization F of A.\n\nThe returned factor is always an LDLt factorization.\n\nSee also lowrankdowndate!, lowrankupdate, lowrankupdate!.\n\n\n\n\n\nlowrankdowndate(C::Cholesky, v::AbstractVector) -> CC::Cholesky\n\nDowndate a Cholesky factorization C with the vector v. If A = C.U'C.U\nthen CC = cholesky(C.U'C.U - v*v') but the computation of CC only uses\nO(n^2) operations.\n\n\n\n\n\n"},{"title":"LinearAlgebra.lowrankupdate!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.lowrankupdate!","category":"function","text":"lowrankupdate!(F::CHOLMOD.Factor, C::AbstractArray)\n\nUpdate an LDLt or LLt Factorization F of A to a factorization of A + C*C'.\n\nLLt factorizations are converted to LDLt.\n\nSee also lowrankupdate, lowrankdowndate, lowrankdowndate!.\n\n\n\n\n\nlowrankupdate!(C::Cholesky, v::AbstractVector) -> CC::Cholesky\n\nUpdate a Cholesky factorization C with the vector v. If A = C.U'C.U then\nCC = cholesky(C.U'C.U + v*v') but the computation of CC only uses O(n^2)\noperations. The input factorization C is updated in place such that on exit C == CC.\nThe vector v is destroyed during the computation.\n\n\n\n\n\n"},{"title":"LinearAlgebra.lowrankdowndate!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.lowrankdowndate!","category":"function","text":"lowrankdowndate!(F::CHOLMOD.Factor, C::AbstractArray)\n\nUpdate an LDLt or LLt Factorization F of A to a factorization of A - C*C'.\n\nLLt factorizations are converted to LDLt.\n\nSee also lowrankdowndate, lowrankupdate, lowrankupdate!.\n\n\n\n\n\nlowrankdowndate!(C::Cholesky, v::AbstractVector) -> CC::Cholesky\n\nDowndate a Cholesky factorization C with the vector v. If A = C.U'C.U then\nCC = cholesky(C.U'C.U - v*v') but the computation of CC only uses O(n^2)\noperations. The input factorization C is updated in place such that on exit C == CC.\nThe vector v is destroyed during the computation.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LDLt","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LDLt","category":"type","text":"LDLt <: Factorization\n\nMatrix factorization type of the LDLt factorization of a real SymTridiagonal\nmatrix S such that S = L*Diagonal(d)*L', where L is a UnitLowerTriangular\nmatrix and d is a vector. The main use of an LDLt factorization F = ldlt(S)\nis to solve the linear system of equations Sx = b with F\\b. This is the\nreturn type of ldlt, the corresponding matrix factorization function.\n\nThe individual components of the factorization F::LDLt can be accessed via getproperty:\n\nComponent Description\nF.L L (unit lower triangular) part of LDLt\nF.D D (diagonal) part of LDLt\nF.Lt Lt (unit upper triangular) part of LDLt\nF.d diagonal values of D as a Vector\n\nExamples\n\njulia> S = SymTridiagonal([3., 4., 5.], [1., 2.])\n3×3 SymTridiagonal{Float64, Vector{Float64}}:\n 3.0  1.0   ⋅\n 1.0  4.0  2.0\n  ⋅   2.0  5.0\n\njulia> F = ldlt(S)\nLDLt{Float64, SymTridiagonal{Float64, Vector{Float64}}}\nL factor:\n3×3 UnitLowerTriangular{Float64, SymTridiagonal{Float64, Vector{Float64}}}:\n 1.0        ⋅         ⋅\n 0.333333  1.0        ⋅\n 0.0       0.545455  1.0\nD factor:\n3×3 Diagonal{Float64, Vector{Float64}}:\n 3.0   ⋅        ⋅\n  ⋅   3.66667   ⋅\n  ⋅    ⋅       3.90909\n\n\n\n\n\n"},{"title":"LinearAlgebra.ldlt","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.ldlt","category":"function","text":"ldlt(A::SparseMatrixCSC; shift = 0.0, check = true, perm=nothing) -> CHOLMOD.Factor\n\nCompute the LDL factorization of a sparse matrix A.\nA must be a SparseMatrixCSC or a Symmetric/Hermitian\nview of a SparseMatrixCSC. Note that if A doesn't\nhave the type tag, it must itself be symmetric or Hermitian.\nA fill-reducing permutation is used. F = ldlt(A) is most frequently\nused to solve systems of equations A*x = b with F\\b. The returned\nfactorization object F also supports the methods diag,\ndet, logdet, and inv.\nYou can extract individual factors from F using F.L.\nHowever, since pivoting is on by default, the factorization is internally\nrepresented as A == P'*L*D*L'*P with a permutation matrix P;\nusing just L without accounting for P will give incorrect answers.\nTo include the effects of permutation, it is typically preferable to extract\n\"combined\" factors like PtL = F.PtL (the equivalent of\nP'*L) and LtP = F.UP (the equivalent of L'*P).\nThe complete list of supported factors is :L, :PtL, :D, :UP, :U, :LD, :DU, :PtLD, :DUP.\nThe permutation vector is available as F.p, defined such that L*D*L' == A[p, p],\n\nThe LD component can be materialized as a sparse matrix using sparse(F.LD),\nOther components cannot be materialized directly, but can be reconstructed from\nsparse(F.LD) and F.p if needed.\n\nUnlike the related Cholesky factorization, the LDL factorization does not\nrequire A to be positive definite. However, it still requires all leading\nprincipal minors to be well-conditioned and will fail if this is not satisfied.\n\nWhen check = true, an error is thrown if the decomposition fails.\nWhen check = false, responsibility for checking the decomposition's\nvalidity (via issuccess) lies with the user.\n\nSetting the optional shift keyword argument computes the factorization of\nA+shift*I instead of A. If the perm argument is provided,\nit should be a permutation of 1:size(A,1) giving the ordering to use\n(instead of CHOLMOD's default AMD ordering).\n\nSee also cholesky for a factorization that can be significantly\nfaster than ldlt, but requires A to be positive definite.\n\nnote: Note\nThis method uses the CHOLMOD[ACM887][DavisHager2009] library from SuiteSparse.\nCHOLMOD only supports real or complex types in single or double precision.\nInput matrices not of those element types will\nbe converted to these types as appropriate.Many other functions from CHOLMOD are wrapped but not exported from the\nBase.SparseArrays.CHOLMOD module.\n\n\n\n\n\nldlt(S::SymTridiagonal) -> LDLt\n\nCompute an LDLt (i.e., LDL^T) factorization of the real symmetric tridiagonal matrix S such that S = L*Diagonal(d)*L'\nwhere L is a unit lower triangular matrix and d is a vector. The main use of an LDLt\nfactorization F = ldlt(S) is to solve the linear system of equations Sx = b with F\\b.\n\nSee also bunchkaufman for a similar, but pivoted, factorization of arbitrary symmetric or Hermitian matrices.\n\nExamples\n\njulia> S = SymTridiagonal([3., 4., 5.], [1., 2.])\n3×3 SymTridiagonal{Float64, Vector{Float64}}:\n 3.0  1.0   ⋅\n 1.0  4.0  2.0\n  ⋅   2.0  5.0\n\njulia> ldltS = ldlt(S);\n\njulia> b = [6., 7., 8.];\n\njulia> ldltS \\ b\n3-element Vector{Float64}:\n 1.7906976744186047\n 0.627906976744186\n 1.3488372093023255\n\njulia> S \\ b\n3-element Vector{Float64}:\n 1.7906976744186047\n 0.627906976744186\n 1.3488372093023255\n\n\n\n\n\n"},{"title":"LinearAlgebra.ldlt!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.ldlt!","category":"function","text":"ldlt!(F::CHOLMOD.Factor, A::SparseMatrixCSC; shift = 0.0, check = true) -> CHOLMOD.Factor\n\nCompute the LDL factorization of A, reusing the symbolic factorization F.\nA must be a SparseMatrixCSC or a Symmetric/Hermitian\nview of a SparseMatrixCSC. Note that if A doesn't\nhave the type tag, it must itself be symmetric or Hermitian.\n\nSee also ldlt.\n\nnote: Note\nThis method uses the CHOLMOD library from SuiteSparse,\nwhich only supports real or complex types in single or double precision.\nInput matrices not of those element types will\nbe converted to these types as appropriate.\n\n\n\n\n\nldlt!(S::SymTridiagonal) -> LDLt\n\nSame as ldlt, but saves space by overwriting the input S, instead of creating a copy.\n\nExamples\n\njulia> S = SymTridiagonal([3., 4., 5.], [1., 2.])\n3×3 SymTridiagonal{Float64, Vector{Float64}}:\n 3.0  1.0   ⋅\n 1.0  4.0  2.0\n  ⋅   2.0  5.0\n\njulia> ldltS = ldlt!(S);\n\njulia> ldltS === S\nfalse\n\njulia> S\n3×3 SymTridiagonal{Float64, Vector{Float64}}:\n 3.0       0.333333   ⋅\n 0.333333  3.66667   0.545455\n  ⋅        0.545455  3.90909\n\n\n\n\n\n"},{"title":"LinearAlgebra.QR","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.QR","category":"type","text":"QR <: Factorization\n\nA QR matrix factorization stored in a packed format, typically obtained from\nqr. If A is an m×n matrix, then\n\nA = Q R\n\nwhere Q is an orthogonal/unitary matrix and R is upper triangular.\nThe matrix Q is stored as a sequence of Householder reflectors v_i\nand coefficients tau_i where:\n\nQ = prod_i=1^min(mn) (I - tau_i v_i v_i^T)\n\nIterating the decomposition produces the components Q and R.\n\nThe object has two fields:\n\nfactors is an m×n matrix.\nThe upper triangular part contains the elements of R, that is R = triu(F.factors) for a QR object F.\nThe subdiagonal part contains the reflectors v_i stored in a packed format where\nv_i is the ith column of the matrix V = I + tril(F.factors, -1).\nτ is a vector  of length min(m,n) containing the coefficients tau_i.\n\n\n\n\n\n"},{"title":"LinearAlgebra.QRCompactWY","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.QRCompactWY","category":"type","text":"QRCompactWY <: Factorization\n\nA QR matrix factorization stored in a compact blocked format, typically obtained from\nqr. If A is an m×n matrix, then\n\nA = Q R\n\nwhere Q is an orthogonal/unitary matrix and R is upper triangular. It is similar\nto the QR format except that the orthogonal/unitary matrix Q is stored in\nCompact WY format [Schreiber1989].  For the block size n_b, it is stored as\na m×n lower trapezoidal matrix V and a matrix T = (T_1  T_2    T_b-1  T_b) composed of b = lceil min(mn)  n_b rceil upper triangular\nmatrices T_j of size n_b×n_b (j = 1  b-1) and an upper trapezoidal\nn_b×min(mn) - (b-1) n_b matrix T_b (j=b) whose upper square part\ndenoted with T_b satisfying\n\nQ = prod_i=1^min(mn) (I - tau_i v_i v_i^T)\n= prod_j=1^b (I - V_j T_j V_j^T)\n\nsuch that v_i is the ith column of V, tau_i is the ith element\nof [diag(T_1); diag(T_2); …; diag(T_b)], and (V_1  V_2    V_b)\nis the left m×min(m, n) block of V.  When constructed using qr,\nthe block size is given by n_b = min(m n 36).\n\nIterating the decomposition produces the components Q and R.\n\nThe object has two fields:\n\nfactors, as in the QR type, is an m×n matrix.\nThe upper triangular part contains the elements of R, that is R = triu(F.factors) for a QR object F.\nThe subdiagonal part contains the reflectors v_i stored in a packed format such\nthat V = I + tril(F.factors, -1).\nT is a n_b-by-min(mn) matrix as described above. The subdiagonal elements\nfor each triangular matrix T_j are ignored.\n\nnote: Note\nThis format should not to be confused with the older WY representation\n[Bischof1987].\n\n[Bischof1987]: C Bischof and C Van Loan, \"The WY representation for products of Householder matrices\", SIAM J Sci Stat Comput 8 (1987), s2-s13. doi:10.1137/0908009\n\n[Schreiber1989]: R Schreiber and C Van Loan, \"A storage-efficient WY representation for products of Householder transformations\", SIAM J Sci Stat Comput 10 (1989), 53-57. doi:10.1137/0910005\n\n\n\n\n\n"},{"title":"LinearAlgebra.QRPivoted","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.QRPivoted","category":"type","text":"QRPivoted <: Factorization\n\nA QR matrix factorization with column pivoting in a packed format, typically obtained from\nqr. If A is an m×n matrix, then\n\nA P = Q R\n\nwhere P is a permutation matrix, Q is an orthogonal/unitary matrix and R is\nupper triangular. The matrix Q is stored as a sequence of Householder reflectors:\n\nQ = prod_i=1^min(mn) (I - tau_i v_i v_i^T)\n\nIterating the decomposition produces the components Q, R, and p.\n\nThe object has three fields:\n\nfactors is an m×n matrix.\nThe upper triangular part contains the elements of R, that is R = triu(F.factors) for a QR object F.\nThe subdiagonal part contains the reflectors v_i stored in a packed format where\nv_i is the ith column of the matrix V = I + tril(F.factors, -1).\nτ is a vector of length min(m,n) containing the coefficients au_i.\njpvt is an integer vector of length n corresponding to the permutation P.\n\n\n\n\n\n"},{"title":"LinearAlgebra.qr","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.qr","category":"function","text":"qr(A::SparseMatrixCSC; tol=_default_tol(A), ordering=ORDERING_DEFAULT) -> QRSparse\n\nCompute the QR factorization of a sparse matrix A. Fill-reducing row and column permutations\nare used such that F.R = F.Q'*A[F.prow,F.pcol]. The main application of this type is to\nsolve least squares or underdetermined problems with \\. The function calls the C library SPQR[ACM933].\n\nnote: Note\nqr(A::SparseMatrixCSC) uses the SPQR library that is part of SuiteSparse.\nAs this library only supports sparse matrices with Float64 or\nComplexF64 elements, as of Julia v1.4 qr converts A into a copy that is\nof type SparseMatrixCSC{Float64} or SparseMatrixCSC{ComplexF64} as appropriate.\n\nExamples\n\njulia> A = sparse([1,2,3,4], [1,1,2,2], [1.0,1.0,1.0,1.0])\n4×2 SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n 1.0   ⋅\n 1.0   ⋅\n  ⋅   1.0\n  ⋅   1.0\n\njulia> qr(A)\nSparseArrays.SPQR.QRSparse{Float64, Int64}\nQ factor:\n4×4 SparseArrays.SPQR.QRSparseQ{Float64, Int64}\nR factor:\n2×2 SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n -1.41421    ⋅\n   ⋅       -1.41421\nRow permutation:\n4-element Vector{Int64}:\n 1\n 3\n 4\n 2\nColumn permutation:\n2-element Vector{Int64}:\n 1\n 2\n\n[ACM933]: Foster, L. V., & Davis, T. A. (2013). Algorithm 933: Reliable Calculation of Numerical Rank, Null Space Bases, Pseudoinverse Solutions, and Basic Solutions Using SuitesparseQR. ACM Trans. Math. Softw., 40(1). doi:10.1145/2513109.2513116\n\n\n\n\n\nqr(A, pivot = NoPivot(); blocksize) -> F\n\nCompute the QR factorization of the matrix A: an orthogonal (or unitary if A is\ncomplex-valued) matrix Q, and an upper triangular matrix R such that\n\nA = Q R\n\nThe returned object F stores the factorization in a packed format:\n\nif pivot == ColumnNorm() then F is a QRPivoted object,\notherwise if the element type of A is a BLAS type (Float32, Float64,\nComplexF32 or ComplexF64), then F is a QRCompactWY object,\notherwise F is a QR object.\n\nThe individual components of the decomposition F can be retrieved via property accessors:\n\nF.Q: the orthogonal/unitary matrix Q\nF.R: the upper triangular matrix R\nF.p: the permutation vector of the pivot (QRPivoted only)\nF.P: the permutation matrix of the pivot (QRPivoted only)\n\nnote: Note\nEach reference to the upper triangular factor via F.R allocates a new array.\nIt is therefore advisable to cache that array, say, by R = F.R and continue working\nwith R.\n\nIterating the decomposition produces the components Q, R, and if extant p.\n\nThe following functions are available for the QR objects: inv, size,\nand \\. When A is rectangular, \\ will return a least squares\nsolution and if the solution is not unique, the one with smallest norm is returned. When\nA is not full rank, factorization with (column) pivoting is required to obtain a minimum\nnorm solution.\n\nMultiplication with respect to either full/square or non-full/square Q is allowed, i.e. both F.Q*F.R\nand F.Q*A are supported. A Q matrix can be converted into a regular matrix with\nMatrix. This operation returns the \"thin\" Q factor, i.e., if A is m×n with m>=n, then\nMatrix(F.Q) yields an m×n matrix with orthonormal columns.  To retrieve the \"full\" Q factor, an\nm×m orthogonal matrix, use F.Q*I or collect(F.Q). If m<=n, then Matrix(F.Q) yields an m×m\northogonal matrix.\n\nThe block size for QR decomposition can be specified by keyword argument\nblocksize :: Integer when pivot == NoPivot() and A isa StridedMatrix{<:BlasFloat}.\nIt is ignored when blocksize > minimum(size(A)). See QRCompactWY.\n\ncompat: Julia 1.4\nThe blocksize keyword argument requires Julia 1.4 or later.\n\nExamples\n\njulia> A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]\n3×2 Matrix{Float64}:\n 3.0  -6.0\n 4.0  -8.0\n 0.0   1.0\n\njulia> F = qr(A)\nLinearAlgebra.QRCompactWY{Float64, Matrix{Float64}, Matrix{Float64}}\nQ factor: 3×3 LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}, Matrix{Float64}}\nR factor:\n2×2 Matrix{Float64}:\n -5.0  10.0\n  0.0  -1.0\n\njulia> F.Q * F.R == A\ntrue\n\nnote: Note\nqr returns multiple types because LAPACK uses several representations\nthat minimize the memory storage requirements of products of Householder\nelementary reflectors, so that the Q and R matrices can be stored\ncompactly rather than two separate dense matrices.\n\n\n\n\n\n"},{"title":"LinearAlgebra.qr!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.qr!","category":"function","text":"qr!(A, pivot = NoPivot(); blocksize)\n\nqr! is the same as qr when A is a subtype of AbstractMatrix,\nbut saves space by overwriting the input A, instead of creating a copy.\nAn InexactError exception is thrown if the factorization produces a number not\nrepresentable by the element type of A, e.g. for integer types.\n\ncompat: Julia 1.4\nThe blocksize keyword argument requires Julia 1.4 or later.\n\nExamples\n\njulia> a = [1. 2.; 3. 4.]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> qr!(a)\nLinearAlgebra.QRCompactWY{Float64, Matrix{Float64}, Matrix{Float64}}\nQ factor: 2×2 LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}, Matrix{Float64}}\nR factor:\n2×2 Matrix{Float64}:\n -3.16228  -4.42719\n  0.0      -0.632456\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> qr!(a)\nERROR: InexactError: Int64(3.1622776601683795)\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"LinearAlgebra.LQ","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LQ","category":"type","text":"LQ <: Factorization\n\nMatrix factorization type of the LQ factorization of a matrix A. The LQ\ndecomposition is the QR decomposition of transpose(A). This is the return\ntype of lq, the corresponding matrix factorization function.\n\nIf S::LQ is the factorization object, the lower triangular component can be\nobtained via S.L, and the orthogonal/unitary component via S.Q, such that\nA ≈ S.L*S.Q.\n\nIterating the decomposition produces the components S.L and S.Q.\n\nExamples\n\njulia> A = [5. 7.; -2. -4.]\n2×2 Matrix{Float64}:\n  5.0   7.0\n -2.0  -4.0\n\njulia> S = lq(A)\nLQ{Float64, Matrix{Float64}, Vector{Float64}}\nL factor:\n2×2 Matrix{Float64}:\n -8.60233   0.0\n  4.41741  -0.697486\nQ factor: 2×2 LinearAlgebra.LQPackedQ{Float64, Matrix{Float64}, Vector{Float64}}\n\njulia> S.L * S.Q\n2×2 Matrix{Float64}:\n  5.0   7.0\n -2.0  -4.0\n\njulia> l, q = S; # destructuring via iteration\n\njulia> l == S.L &&  q == S.Q\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.lq","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.lq","category":"function","text":"lq(A) -> S::LQ\n\nCompute the LQ decomposition of A. The decomposition's lower triangular\ncomponent can be obtained from the LQ object S via S.L, and the\northogonal/unitary component via S.Q, such that A ≈ S.L*S.Q.\n\nIterating the decomposition produces the components S.L and S.Q.\n\nThe LQ decomposition is the QR decomposition of transpose(A), and it is useful\nin order to compute the minimum-norm solution lq(A) \\ b to an underdetermined\nsystem of equations (A has more columns than rows, but has full row rank).\n\nExamples\n\njulia> A = [5. 7.; -2. -4.]\n2×2 Matrix{Float64}:\n  5.0   7.0\n -2.0  -4.0\n\njulia> S = lq(A)\nLQ{Float64, Matrix{Float64}, Vector{Float64}}\nL factor:\n2×2 Matrix{Float64}:\n -8.60233   0.0\n  4.41741  -0.697486\nQ factor: 2×2 LinearAlgebra.LQPackedQ{Float64, Matrix{Float64}, Vector{Float64}}\n\njulia> S.L * S.Q\n2×2 Matrix{Float64}:\n  5.0   7.0\n -2.0  -4.0\n\njulia> l, q = S; # destructuring via iteration\n\njulia> l == S.L &&  q == S.Q\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.lq!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.lq!","category":"function","text":"lq!(A) -> LQ\n\nCompute the LQ factorization of A, using the input\nmatrix as a workspace. See also lq.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BunchKaufman","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BunchKaufman","category":"type","text":"BunchKaufman <: Factorization\n\nMatrix factorization type of the Bunch-Kaufman factorization of a symmetric or\nHermitian matrix A as P'UDU'P or P'LDL'P, depending on whether the upper\n(the default) or the lower triangle is stored in A. Here, U and L are\nrespectively upper and lower triangular, P is a permutation matrix, and D\nis block diagonal with 1-by-1 and 2-by-2 blocks. If A is complex symmetric\nthen U' and L' denote the unconjugated transposes, i.e. transpose(U) and\ntranspose(L), respectively. This is the return type of bunchkaufman,\nthe corresponding matrix factorization function.\n\nIf S::BunchKaufman is the factorization object, the components can be obtained\nvia S.D, S.U or S.L as appropriate given S.uplo, and S.p.\n\nIterating the decomposition produces the components S.D, S.U or S.L\nas appropriate given S.uplo, and S.p.\n\nExamples\n\njulia> A = Float64.([1 2; 2 3])\n2×2 Matrix{Float64}:\n 1.0  2.0\n 2.0  3.0\n\njulia> S = bunchkaufman(A) # A gets wrapped internally by Symmetric(A)\nBunchKaufman{Float64, Matrix{Float64}, Vector{Int64}}\nD factor:\n2×2 Tridiagonal{Float64, Vector{Float64}}:\n -0.333333  0.0\n  0.0       3.0\nU factor:\n2×2 UnitUpperTriangular{Float64, Matrix{Float64}}:\n 1.0  0.666667\n  ⋅   1.0\npermutation:\n2-element Vector{Int64}:\n 1\n 2\n\njulia> d, u, p = S; # destructuring via iteration\n\njulia> d == S.D && u == S.U && p == S.p\ntrue\n\njulia> S = bunchkaufman(Symmetric(A, :L))\nBunchKaufman{Float64, Matrix{Float64}, Vector{Int64}}\nD factor:\n2×2 Tridiagonal{Float64, Vector{Float64}}:\n 3.0   0.0\n 0.0  -0.333333\nL factor:\n2×2 UnitLowerTriangular{Float64, Matrix{Float64}}:\n 1.0        ⋅\n 0.666667  1.0\npermutation:\n2-element Vector{Int64}:\n 2\n 1\n\n\n\n\n\n"},{"title":"LinearAlgebra.bunchkaufman","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.bunchkaufman","category":"function","text":"bunchkaufman(A, rook::Bool=false; check = true) -> S::BunchKaufman\n\nCompute the Bunch-Kaufman [Bunch1977] factorization of a symmetric or\nHermitian matrix A as P'*U*D*U'*P or P'*L*D*L'*P, depending on\nwhich triangle is stored in A, and return a BunchKaufman object.\nHere, U and L are respectively upper and lower triangular, P is a\npermutation matrix, and D is block diagonal with 1-by-1 and 2-by-2 blocks.\nNote that if A is complex symmetric then U' and L' denote\nthe unconjugated transposes, i.e. transpose(U) and transpose(L).\n\nIterating the decomposition produces the components S.D, S.U or S.L\nas appropriate given S.uplo, and S.p.\n\nIf rook is true, rook pivoting is used. If rook is false,\nrook pivoting is not used.\n\nWhen check = true, an error is thrown if the decomposition fails.\nWhen check = false, responsibility for checking the decomposition's\nvalidity (via issuccess) lies with the user.\n\nThe following functions are available for BunchKaufman objects:\nsize, \\, inv, issymmetric,\nishermitian, getindex.\n\n[Bunch1977]: J R Bunch and L Kaufman, Some stable methods for calculating inertia and solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. url.\n\nExamples\n\njulia> A = Float64.([1 2; 2 3])\n2×2 Matrix{Float64}:\n 1.0  2.0\n 2.0  3.0\n\njulia> S = bunchkaufman(A) # A gets wrapped internally by Symmetric(A)\nBunchKaufman{Float64, Matrix{Float64}, Vector{Int64}}\nD factor:\n2×2 Tridiagonal{Float64, Vector{Float64}}:\n -0.333333  0.0\n  0.0       3.0\nU factor:\n2×2 UnitUpperTriangular{Float64, Matrix{Float64}}:\n 1.0  0.666667\n  ⋅   1.0\npermutation:\n2-element Vector{Int64}:\n 1\n 2\n\njulia> d, u, p = S; # destructuring via iteration\n\njulia> d == S.D && u == S.U && p == S.p\ntrue\n\njulia> S.U * S.D * S.U' ≈ S.P * A * S.P'\ntrue\n\njulia> S = bunchkaufman(Symmetric(A, :L))\nBunchKaufman{Float64, Matrix{Float64}, Vector{Int64}}\nD factor:\n2×2 Tridiagonal{Float64, Vector{Float64}}:\n 3.0   0.0\n 0.0  -0.333333\nL factor:\n2×2 UnitLowerTriangular{Float64, Matrix{Float64}}:\n 1.0        ⋅\n 0.666667  1.0\npermutation:\n2-element Vector{Int64}:\n 2\n 1\n\njulia> S.L * S.D * S.L' ≈ A[S.p, S.p]\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.bunchkaufman!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.bunchkaufman!","category":"function","text":"bunchkaufman!(A, rook::Bool=false; check = true) -> BunchKaufman\n\nbunchkaufman! is the same as bunchkaufman, but saves space by overwriting the\ninput A, instead of creating a copy.\n\n\n\n\n\n"},{"title":"LinearAlgebra.Eigen","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.Eigen","category":"type","text":"Eigen <: Factorization\n\nMatrix factorization type of the eigenvalue/spectral decomposition of a square\nmatrix A. This is the return type of eigen, the corresponding matrix\nfactorization function.\n\nIf F::Eigen is the factorization object, the eigenvalues can be obtained via\nF.values and the eigenvectors as the columns of the matrix F.vectors.\n(The kth eigenvector can be obtained from the slice F.vectors[:, k].)\n\nIterating the decomposition produces the components F.values and F.vectors.\n\nExamples\n\njulia> F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])\nEigen{Float64, Float64, Matrix{Float64}, Vector{Float64}}\nvalues:\n3-element Vector{Float64}:\n  1.0\n  3.0\n 18.0\nvectors:\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> F.values\n3-element Vector{Float64}:\n  1.0\n  3.0\n 18.0\n\njulia> F.vectors\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> vals, vecs = F; # destructuring via iteration\n\njulia> vals == F.values && vecs == F.vectors\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.GeneralizedEigen","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.GeneralizedEigen","category":"type","text":"GeneralizedEigen <: Factorization\n\nMatrix factorization type of the generalized eigenvalue/spectral decomposition of\nA and B. This is the return type of eigen, the corresponding\nmatrix factorization function, when called with two matrix arguments.\n\nIf F::GeneralizedEigen is the factorization object, the eigenvalues can be obtained via\nF.values and the eigenvectors as the columns of the matrix F.vectors.\n(The kth eigenvector can be obtained from the slice F.vectors[:, k].)\n\nIterating the decomposition produces the components F.values and F.vectors.\n\nExamples\n\njulia> A = [1 0; 0 -1]\n2×2 Matrix{Int64}:\n 1   0\n 0  -1\n\njulia> B = [0 1; 1 0]\n2×2 Matrix{Int64}:\n 0  1\n 1  0\n\njulia> F = eigen(A, B)\nGeneralizedEigen{ComplexF64, ComplexF64, Matrix{ComplexF64}, Vector{ComplexF64}}\nvalues:\n2-element Vector{ComplexF64}:\n 0.0 - 1.0im\n 0.0 + 1.0im\nvectors:\n2×2 Matrix{ComplexF64}:\n  0.0+1.0im   0.0-1.0im\n -1.0+0.0im  -1.0-0.0im\n\njulia> F.values\n2-element Vector{ComplexF64}:\n 0.0 - 1.0im\n 0.0 + 1.0im\n\njulia> F.vectors\n2×2 Matrix{ComplexF64}:\n  0.0+1.0im   0.0-1.0im\n -1.0+0.0im  -1.0-0.0im\n\njulia> vals, vecs = F; # destructuring via iteration\n\njulia> vals == F.values && vecs == F.vectors\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.eigvals","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.eigvals","category":"function","text":"eigvals(A; permute::Bool=true, scale::Bool=true, sortby) -> values\n\nReturn the eigenvalues of A.\n\nFor general non-symmetric matrices it is possible to specify how the matrix is balanced\nbefore the eigenvalue calculation. The permute, scale, and sortby keywords are\nthe same as for eigen.\n\nExamples\n\njulia> diag_matrix = [1 0; 0 4]\n2×2 Matrix{Int64}:\n 1  0\n 0  4\n\njulia> eigvals(diag_matrix)\n2-element Vector{Float64}:\n 1.0\n 4.0\n\n\n\n\n\nFor a scalar input, eigvals will return a scalar.\n\nExamples\n\njulia> eigvals(-2)\n-2\n\n\n\n\n\neigvals(A, B) -> values\n\nCompute the generalized eigenvalues of A and B.\n\nExamples\n\njulia> A = [1 0; 0 -1]\n2×2 Matrix{Int64}:\n 1   0\n 0  -1\n\njulia> B = [0 1; 1 0]\n2×2 Matrix{Int64}:\n 0  1\n 1  0\n\njulia> eigvals(A,B)\n2-element Vector{ComplexF64}:\n 0.0 - 1.0im\n 0.0 + 1.0im\n\n\n\n\n\neigvals(A::Union{Hermitian, Symmetric}; alg::Algorithm = default_eigen_alg(A))) -> values\n\nReturn the eigenvalues of A.\n\nalg specifies which algorithm and LAPACK method to use for eigenvalue decomposition:\n\nalg = DivideAndConquer(): Calls LAPACK.syevd!.\nalg = QRIteration(): Calls LAPACK.syev!.\nalg = RobustRepresentations() (default): Multiple relatively robust representations method, Calls LAPACK.syevr!.\n\nSee James W. Demmel et al, SIAM J. Sci. Comput. 30, 3, 1508 (2008) for\na comparison of the accuracy and performance of different methods.\n\nThe default alg used may change in the future.\n\ncompat: Julia 1.12\nThe alg keyword argument requires Julia 1.12 or later.\n\n\n\n\n\neigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values\n\nReturn the eigenvalues of A. It is possible to calculate only a subset of the\neigenvalues by specifying a UnitRange irange covering indices of the sorted eigenvalues,\ne.g. the 2nd to 8th eigenvalues.\n\nExamples\n\njulia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])\n3×3 SymTridiagonal{Float64, Vector{Float64}}:\n 1.0  2.0   ⋅\n 2.0  2.0  3.0\n  ⋅   3.0  1.0\n\njulia> eigvals(A, 2:2)\n1-element Vector{Float64}:\n 0.9999999999999996\n\njulia> eigvals(A)\n3-element Vector{Float64}:\n -2.1400549446402604\n  1.0000000000000002\n  5.140054944640259\n\n\n\n\n\neigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values\n\nReturn the eigenvalues of A. It is possible to calculate only a subset of the eigenvalues\nby specifying a pair vl and vu for the lower and upper boundaries of the eigenvalues.\n\nExamples\n\njulia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])\n3×3 SymTridiagonal{Float64, Vector{Float64}}:\n 1.0  2.0   ⋅\n 2.0  2.0  3.0\n  ⋅   3.0  1.0\n\njulia> eigvals(A, -1, 2)\n1-element Vector{Float64}:\n 1.0000000000000009\n\njulia> eigvals(A)\n3-element Vector{Float64}:\n -2.1400549446402604\n  1.0000000000000002\n  5.140054944640259\n\n\n\n\n\n"},{"title":"LinearAlgebra.eigvals!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.eigvals!","category":"function","text":"eigvals!(A; permute::Bool=true, scale::Bool=true, sortby) -> values\n\nSame as eigvals, but saves space by overwriting the input A, instead of creating a copy.\nThe permute, scale, and sortby keywords are the same as for eigen.\n\nnote: Note\nThe input matrix A will not contain its eigenvalues after eigvals! is\ncalled on it - A is used as a workspace.\n\nExamples\n\njulia> A = [1. 2.; 3. 4.]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> eigvals!(A)\n2-element Vector{Float64}:\n -0.3722813232690143\n  5.372281323269014\n\njulia> A\n2×2 Matrix{Float64}:\n -0.372281  -1.0\n  0.0        5.37228\n\n\n\n\n\neigvals!(A, B; sortby) -> values\n\nSame as eigvals, but saves space by overwriting the input A (and B),\ninstead of creating copies.\n\nnote: Note\nThe input matrices A and B will not contain their eigenvalues after\neigvals! is called. They are used as workspaces.\n\nExamples\n\njulia> A = [1. 0.; 0. -1.]\n2×2 Matrix{Float64}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> B = [0. 1.; 1. 0.]\n2×2 Matrix{Float64}:\n 0.0  1.0\n 1.0  0.0\n\njulia> eigvals!(A, B)\n2-element Vector{ComplexF64}:\n 0.0 - 1.0im\n 0.0 + 1.0im\n\njulia> A\n2×2 Matrix{Float64}:\n -0.0  -1.0\n  1.0  -0.0\n\njulia> B\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\neigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values\n\nSame as eigvals, but saves space by overwriting the input A, instead of creating a copy.\nirange is a range of eigenvalue indices to search for - for instance, the 2nd to 8th eigenvalues.\n\n\n\n\n\neigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values\n\nSame as eigvals, but saves space by overwriting the input A, instead of creating a copy.\nvl is the lower bound of the interval to search for eigenvalues, and vu is the upper bound.\n\n\n\n\n\n"},{"title":"LinearAlgebra.eigmax","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.eigmax","category":"function","text":"eigmax(A; permute::Bool=true, scale::Bool=true)\n\nReturn the largest eigenvalue of A, assuming they are all real, and throwing an error otherwise.\nThe permute and scale keyword arguments are the same as for eigen.\n\nExamples\n\njulia> A = [0 im; -im 0]\n2×2 Matrix{Complex{Int64}}:\n 0+0im  0+1im\n 0-1im  0+0im\n\njulia> eigmax(A)\n1.0\n\njulia> A = [0 im; -1 0]\n2×2 Matrix{Complex{Int64}}:\n  0+0im  0+1im\n -1+0im  0+0im\n\njulia> eigmax(A)\nERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:\n`A` cannot have complex eigenvalues.\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"LinearAlgebra.eigmin","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.eigmin","category":"function","text":"eigmin(A; permute::Bool=true, scale::Bool=true)\n\nReturn the smallest eigenvalue of A, assuming they are all real, and throwing an error otherwise.\nThe permute and scale keyword arguments are the same as for eigen.\n\nExamples\n\njulia> A = [0 im; -im 0]\n2×2 Matrix{Complex{Int64}}:\n 0+0im  0+1im\n 0-1im  0+0im\n\njulia> eigmin(A)\n-1.0\n\njulia> A = [0 im; -1 0]\n2×2 Matrix{Complex{Int64}}:\n  0+0im  0+1im\n -1+0im  0+0im\n\njulia> eigmin(A)\nERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:\n`A` cannot have complex eigenvalues.\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"LinearAlgebra.eigvecs","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.eigvecs","category":"function","text":"eigvecs(A::Union{Symmetric, Hermitian, SymTridiagonal}[, eigvals])::Matrix\n\nReturn a matrix M whose columns are the eigenvectors of A. (The kth eigenvector can\nbe obtained from the slice M[:, k].)\n\nIf the optional vector of eigenvalues eigvals is specified, eigvecs\nreturns the specific corresponding eigenvectors.\n\nExamples\n\njulia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])\n3×3 SymTridiagonal{Float64, Vector{Float64}}:\n 1.0  2.0   ⋅\n 2.0  2.0  3.0\n  ⋅   3.0  1.0\n\njulia> eigvals(A)\n3-element Vector{Float64}:\n -2.1400549446402604\n  1.0000000000000002\n  5.140054944640259\n\njulia> eigvecs(A)\n3×3 Matrix{Float64}:\n  0.418304  -0.83205      0.364299\n -0.656749  -7.39009e-16  0.754109\n  0.627457   0.5547       0.546448\n\njulia> eigvecs(A, [1.])\n3×1 Matrix{Float64}:\n  0.8320502943378438\n  4.263514128092366e-17\n -0.5547001962252291\n\n\n\n\n\neigvecs(A; permute::Bool=true, scale::Bool=true, `sortby`) -> Matrix\n\nReturn a matrix M whose columns are the eigenvectors of A. (The kth eigenvector can\nbe obtained from the slice M[:, k].) The permute, scale, and sortby keywords are the same as\nfor eigen.\n\nExamples\n\njulia> eigvecs([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n\n\neigvecs(A, B) -> Matrix\n\nReturn a matrix M whose columns are the generalized eigenvectors of A and B. (The kth eigenvector can\nbe obtained from the slice M[:, k].)\n\nExamples\n\njulia> A = [1 0; 0 -1]\n2×2 Matrix{Int64}:\n 1   0\n 0  -1\n\njulia> B = [0 1; 1 0]\n2×2 Matrix{Int64}:\n 0  1\n 1  0\n\njulia> eigvecs(A, B)\n2×2 Matrix{ComplexF64}:\n  0.0+1.0im   0.0-1.0im\n -1.0+0.0im  -1.0-0.0im\n\n\n\n\n\n"},{"title":"LinearAlgebra.eigen","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.eigen","category":"function","text":"eigen(A; permute::Bool=true, scale::Bool=true, sortby) -> Eigen\n\nCompute the eigenvalue decomposition of A, returning an Eigen factorization object F\nwhich contains the eigenvalues in F.values and the normalized eigenvectors in the columns of the\nmatrix F.vectors. This corresponds to solving an eigenvalue problem of the form\nAx =  λx, where A is a matrix, x is an eigenvector, and λ is an eigenvalue.\n(The kth eigenvector can be obtained from the slice F.vectors[:, k].)\n\nIterating the decomposition produces the components F.values and F.vectors.\n\nThe following functions are available for Eigen objects: inv, det, and isposdef.\n\nFor general nonsymmetric matrices it is possible to specify how the matrix is balanced\nbefore the eigenvector calculation. The option permute=true permutes the matrix to become\ncloser to upper triangular, and scale=true scales the matrix by its diagonal elements to\nmake rows and columns more equal in norm. The default is true for both options.\n\nBy default, the eigenvalues and vectors are sorted lexicographically by (real(λ),imag(λ)).\nA different comparison function by(λ) can be passed to sortby, or you can pass\nsortby=nothing to leave the eigenvalues in an arbitrary order.   Some special matrix types\n(e.g. Diagonal or SymTridiagonal) may implement their own sorting convention and not\naccept a sortby keyword.\n\nExamples\n\njulia> F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])\nEigen{Float64, Float64, Matrix{Float64}, Vector{Float64}}\nvalues:\n3-element Vector{Float64}:\n  1.0\n  3.0\n 18.0\nvectors:\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> F.values\n3-element Vector{Float64}:\n  1.0\n  3.0\n 18.0\n\njulia> F.vectors\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> vals, vecs = F; # destructuring via iteration\n\njulia> vals == F.values && vecs == F.vectors\ntrue\n\n\n\n\n\neigen(A, B; sortby) -> GeneralizedEigen\n\nCompute the generalized eigenvalue decomposition of A and B, returning a\nGeneralizedEigen factorization object F which contains the generalized eigenvalues in\nF.values and the generalized eigenvectors in the columns of the matrix F.vectors.\nThis corresponds to solving a generalized eigenvalue problem of the form\nAx =  λBx, where A, B are matrices, x is an eigenvector, and λ is an eigenvalue.\n(The kth generalized eigenvector can be obtained from the slice F.vectors[:, k].)\n\nIterating the decomposition produces the components F.values and F.vectors.\n\nBy default, the eigenvalues and vectors are sorted lexicographically by (real(λ),imag(λ)).\nA different comparison function by(λ) can be passed to sortby, or you can pass\nsortby=nothing to leave the eigenvalues in an arbitrary order.\n\nExamples\n\njulia> A = [1 0; 0 -1]\n2×2 Matrix{Int64}:\n 1   0\n 0  -1\n\njulia> B = [0 1; 1 0]\n2×2 Matrix{Int64}:\n 0  1\n 1  0\n\njulia> F = eigen(A, B);\n\njulia> F.values\n2-element Vector{ComplexF64}:\n 0.0 - 1.0im\n 0.0 + 1.0im\n\njulia> F.vectors\n2×2 Matrix{ComplexF64}:\n  0.0+1.0im   0.0-1.0im\n -1.0+0.0im  -1.0-0.0im\n\njulia> vals, vecs = F; # destructuring via iteration\n\njulia> vals == F.values && vecs == F.vectors\ntrue\n\n\n\n\n\neigen(A::Union{Hermitian, Symmetric}; alg::LinearAlgebra.Algorithm = LinearAlgebra.default_eigen_alg(A)) -> Eigen\n\nCompute the eigenvalue decomposition of A, returning an Eigen factorization object F\nwhich contains the eigenvalues in F.values and the orthonormal eigenvectors in the columns of the\nmatrix F.vectors. (The kth eigenvector can be obtained from the slice F.vectors[:, k].)\n\nIterating the decomposition produces the components F.values and F.vectors.\n\nalg specifies which algorithm and LAPACK method to use for eigenvalue decomposition:\n\nalg = DivideAndConquer(): Calls LAPACK.syevd!.\nalg = QRIteration(): Calls LAPACK.syev!.\nalg = RobustRepresentations() (default): Multiple relatively robust representations method, Calls LAPACK.syevr!.\n\nSee James W. Demmel et al, SIAM J. Sci. Comput. 30, 3, 1508 (2008) for\na comparison of the accuracy and performance of different algorithms.\n\nThe default alg used may change in the future.\n\ncompat: Julia 1.12\nThe alg keyword argument requires Julia 1.12 or later.\n\nThe following functions are available for Eigen objects: inv, det, and isposdef.\n\n\n\n\n\neigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> Eigen\n\nCompute the eigenvalue decomposition of A, returning an Eigen factorization object F\nwhich contains the eigenvalues in F.values and the orthonormal eigenvectors in the columns of the\nmatrix F.vectors. (The kth eigenvector can be obtained from the slice F.vectors[:, k].)\n\nIterating the decomposition produces the components F.values and F.vectors.\n\nThe following functions are available for Eigen objects: inv, det, and isposdef.\n\nThe UnitRange irange specifies indices of the sorted eigenvalues to search for.\n\nnote: Note\nIf irange is not 1:n, where n is the dimension of A, then the returned factorization\nwill be a truncated factorization.\n\n\n\n\n\neigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> Eigen\n\nCompute the eigenvalue decomposition of A, returning an Eigen factorization object F\nwhich contains the eigenvalues in F.values and the orthonormal eigenvectors in the columns of the\nmatrix F.vectors. (The kth eigenvector can be obtained from the slice F.vectors[:, k].)\n\nIterating the decomposition produces the components F.values and F.vectors.\n\nThe following functions are available for Eigen objects: inv, det, and isposdef.\n\nvl is the lower bound of the window of eigenvalues to search for, and vu is the upper bound.\n\nnote: Note\nIf [vl, vu] does not contain all eigenvalues of A, then the returned factorization\nwill be a truncated factorization.\n\n\n\n\n\n"},{"title":"LinearAlgebra.eigen!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.eigen!","category":"function","text":"eigen!(A; permute, scale, sortby)\neigen!(A, B; sortby)\n\nSame as eigen, but saves space by overwriting the input A (and\nB), instead of creating a copy.\n\n\n\n\n\n"},{"title":"LinearAlgebra.Hessenberg","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.Hessenberg","category":"type","text":"Hessenberg <: Factorization\n\nA Hessenberg object represents the Hessenberg factorization QHQ' of a square\nmatrix, or a shift Q(H+μI)Q' thereof, which is produced by the hessenberg function.\n\n\n\n\n\n"},{"title":"LinearAlgebra.hessenberg","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.hessenberg","category":"function","text":"hessenberg(A) -> Hessenberg\n\nCompute the Hessenberg decomposition of A and return a Hessenberg object. If F is the\nfactorization object, the unitary matrix can be accessed with F.Q (of type LinearAlgebra.HessenbergQ)\nand the Hessenberg matrix with F.H (of type UpperHessenberg), either of\nwhich may be converted to a regular matrix with Matrix(F.H) or Matrix(F.Q).\n\nIf A is Hermitian or real-Symmetric, then the Hessenberg\ndecomposition produces a real-symmetric tridiagonal matrix and F.H is of type\nSymTridiagonal.\n\nNote that the shifted factorization A+μI = Q (H+μI) Q' can be\nconstructed efficiently by F + μ*I using the UniformScaling\nobject I, which creates a new Hessenberg object with shared storage\nand a modified shift.   The shift of a given F is obtained by F.μ.\nThis is useful because multiple shifted solves (F + μ*I) \\ b\n(for different μ and/or b) can be performed efficiently once F is created.\n\nIterating the decomposition produces the factors F.Q, F.H, F.μ.\n\nExamples\n\njulia> A = [4. 9. 7.; 4. 4. 1.; 4. 3. 2.]\n3×3 Matrix{Float64}:\n 4.0  9.0  7.0\n 4.0  4.0  1.0\n 4.0  3.0  2.0\n\njulia> F = hessenberg(A)\nHessenberg{Float64, UpperHessenberg{Float64, Matrix{Float64}}, Matrix{Float64}, Vector{Float64}, Bool}\nQ factor: 3×3 LinearAlgebra.HessenbergQ{Float64, Matrix{Float64}, Vector{Float64}, false}\nH factor:\n3×3 UpperHessenberg{Float64, Matrix{Float64}}:\n  4.0      -11.3137       -1.41421\n -5.65685    5.0           2.0\n   ⋅        -8.88178e-16   1.0\n\njulia> F.Q * F.H * F.Q'\n3×3 Matrix{Float64}:\n 4.0  9.0  7.0\n 4.0  4.0  1.0\n 4.0  3.0  2.0\n\njulia> q, h = F; # destructuring via iteration\n\njulia> q == F.Q && h == F.H\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.hessenberg!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.hessenberg!","category":"function","text":"hessenberg!(A) -> Hessenberg\n\nhessenberg! is the same as hessenberg, but saves space by overwriting\nthe input A, instead of creating a copy.\n\n\n\n\n\n"},{"title":"LinearAlgebra.Schur","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.Schur","category":"type","text":"Schur <: Factorization\n\nMatrix factorization type of the Schur factorization of a matrix A. This is the\nreturn type of schur(_), the corresponding matrix factorization function.\n\nIf F::Schur is the factorization object, the (quasi) triangular Schur factor can\nbe obtained via either F.Schur or F.T and the orthogonal/unitary Schur vectors\nvia F.vectors or F.Z such that A = F.vectors * F.Schur * F.vectors'. The\neigenvalues of A can be obtained with F.values.\n\nIterating the decomposition produces the components F.T, F.Z, and F.values.\n\nExamples\n\njulia> A = [5. 7.; -2. -4.]\n2×2 Matrix{Float64}:\n  5.0   7.0\n -2.0  -4.0\n\njulia> F = schur(A)\nSchur{Float64, Matrix{Float64}, Vector{Float64}}\nT factor:\n2×2 Matrix{Float64}:\n 3.0   9.0\n 0.0  -2.0\nZ factor:\n2×2 Matrix{Float64}:\n  0.961524  0.274721\n -0.274721  0.961524\neigenvalues:\n2-element Vector{Float64}:\n  3.0\n -2.0\n\njulia> F.vectors * F.Schur * F.vectors'\n2×2 Matrix{Float64}:\n  5.0   7.0\n -2.0  -4.0\n\njulia> t, z, vals = F; # destructuring via iteration\n\njulia> t == F.T && z == F.Z && vals == F.values\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.GeneralizedSchur","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.GeneralizedSchur","category":"type","text":"GeneralizedSchur <: Factorization\n\nMatrix factorization type of the generalized Schur factorization of two matrices\nA and B. This is the return type of schur(_, _), the corresponding\nmatrix factorization function.\n\nIf F::GeneralizedSchur is the factorization object, the (quasi) triangular Schur\nfactors can be obtained via F.S and F.T, the left unitary/orthogonal Schur\nvectors via F.left or F.Q, and the right unitary/orthogonal Schur vectors can\nbe obtained with F.right or F.Z such that A=F.left*F.S*F.right' and\nB=F.left*F.T*F.right'. The generalized eigenvalues of A and B can be obtained\nwith F.α./F.β.\n\nIterating the decomposition produces the components F.S, F.T, F.Q, F.Z,\nF.α, and F.β.\n\n\n\n\n\n"},{"title":"LinearAlgebra.schur","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.schur","category":"function","text":"schur(A) -> F::Schur\n\nComputes the Schur factorization of the matrix A. The (quasi) triangular Schur factor can\nbe obtained from the Schur object F with either F.Schur or F.T and the\northogonal/unitary Schur vectors can be obtained with F.vectors or F.Z such that\nA = F.vectors * F.Schur * F.vectors'. The eigenvalues of A can be obtained with F.values.\n\nFor real A, the Schur factorization is \"quasitriangular\", which means that it\nis upper-triangular except with 2×2 diagonal blocks for any conjugate pair\nof complex eigenvalues; this allows the factorization to be purely real even\nwhen there are complex eigenvalues.  To obtain the (complex) purely upper-triangular\nSchur factorization from a real quasitriangular factorization, you can use\nSchur{Complex}(schur(A)).\n\nIterating the decomposition produces the components F.T, F.Z, and F.values.\n\nExamples\n\njulia> A = [5. 7.; -2. -4.]\n2×2 Matrix{Float64}:\n  5.0   7.0\n -2.0  -4.0\n\njulia> F = schur(A)\nSchur{Float64, Matrix{Float64}, Vector{Float64}}\nT factor:\n2×2 Matrix{Float64}:\n 3.0   9.0\n 0.0  -2.0\nZ factor:\n2×2 Matrix{Float64}:\n  0.961524  0.274721\n -0.274721  0.961524\neigenvalues:\n2-element Vector{Float64}:\n  3.0\n -2.0\n\njulia> F.vectors * F.Schur * F.vectors'\n2×2 Matrix{Float64}:\n  5.0   7.0\n -2.0  -4.0\n\njulia> t, z, vals = F; # destructuring via iteration\n\njulia> t == F.T && z == F.Z && vals == F.values\ntrue\n\n\n\n\n\nschur(A, B) -> F::GeneralizedSchur\n\nComputes the Generalized Schur (or QZ) factorization of the matrices A and B. The\n(quasi) triangular Schur factors can be obtained from the Schur object F with F.S\nand F.T, the left unitary/orthogonal Schur vectors can be obtained with F.left or\nF.Q and the right unitary/orthogonal Schur vectors can be obtained with F.right or\nF.Z such that A=F.left*F.S*F.right' and B=F.left*F.T*F.right'. The\ngeneralized eigenvalues of A and B can be obtained with F.α./F.β.\n\nIterating the decomposition produces the components F.S, F.T, F.Q, F.Z,\nF.α, and F.β.\n\n\n\n\n\n"},{"title":"LinearAlgebra.schur!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.schur!","category":"function","text":"schur!(A) -> F::Schur\n\nSame as schur but uses the input argument A as workspace.\n\nExamples\n\njulia> A = [5. 7.; -2. -4.]\n2×2 Matrix{Float64}:\n  5.0   7.0\n -2.0  -4.0\n\njulia> F = schur!(A)\nSchur{Float64, Matrix{Float64}, Vector{Float64}}\nT factor:\n2×2 Matrix{Float64}:\n 3.0   9.0\n 0.0  -2.0\nZ factor:\n2×2 Matrix{Float64}:\n  0.961524  0.274721\n -0.274721  0.961524\neigenvalues:\n2-element Vector{Float64}:\n  3.0\n -2.0\n\njulia> A\n2×2 Matrix{Float64}:\n 3.0   9.0\n 0.0  -2.0\n\n\n\n\n\nschur!(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur\n\nSame as schur but uses the input matrices A and B as workspace.\n\n\n\n\n\n"},{"title":"LinearAlgebra.ordschur","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.ordschur","category":"function","text":"ordschur(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur\n\nReorders the Schur factorization F of a matrix A = Z*T*Z' according to the logical array\nselect returning the reordered factorization F object. The selected eigenvalues appear\nin the leading diagonal of F.Schur and the corresponding leading columns of\nF.vectors form an orthogonal/unitary basis of the corresponding right invariant\nsubspace. In the real case, a complex conjugate pair of eigenvalues must be either both\nincluded or both excluded via select.\n\n\n\n\n\nordschur(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur\n\nReorders the Generalized Schur factorization F of a matrix pair (A, B) = (Q*S*Z', Q*T*Z')\naccording to the logical array select and returns a GeneralizedSchur object F. The\nselected eigenvalues appear in the leading diagonal of both F.S and F.T, and the\nleft and right orthogonal/unitary Schur vectors are also reordered such that\n(A, B) = F.Q*(F.S, F.T)*F.Z' still holds and the generalized eigenvalues of A\nand B can still be obtained with F.α./F.β.\n\n\n\n\n\n"},{"title":"LinearAlgebra.ordschur!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.ordschur!","category":"function","text":"ordschur!(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur\n\nSame as ordschur but overwrites the factorization F.\n\n\n\n\n\nordschur!(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur\n\nSame as ordschur but overwrites the factorization F.\n\n\n\n\n\n"},{"title":"LinearAlgebra.SVD","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.SVD","category":"type","text":"SVD <: Factorization\n\nMatrix factorization type of the singular value decomposition (SVD) of a matrix A.\nThis is the return type of svd(_), the corresponding matrix factorization function.\n\nIf F::SVD is the factorization object, U, S, V and Vt can be obtained\nvia F.U, F.S, F.V and F.Vt, such that A = U * Diagonal(S) * Vt.\nThe singular values in S are sorted in descending order.\n\nIterating the decomposition produces the components U, S, and V.\n\nExamples\n\njulia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]\n4×5 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\njulia> F = svd(A)\nSVD{Float64, Float64, Matrix{Float64}, Vector{Float64}}\nU factor:\n4×4 Matrix{Float64}:\n 0.0  1.0   0.0  0.0\n 1.0  0.0   0.0  0.0\n 0.0  0.0   0.0  1.0\n 0.0  0.0  -1.0  0.0\nsingular values:\n4-element Vector{Float64}:\n 3.0\n 2.23606797749979\n 2.0\n 0.0\nVt factor:\n4×5 Matrix{Float64}:\n -0.0        0.0  1.0  -0.0  0.0\n  0.447214   0.0  0.0   0.0  0.894427\n  0.0       -1.0  0.0   0.0  0.0\n  0.0        0.0  0.0   1.0  0.0\n\njulia> F.U * Diagonal(F.S) * F.Vt\n4×5 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\njulia> u, s, v = F; # destructuring via iteration\n\njulia> u == F.U && s == F.S && v == F.V\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.GeneralizedSVD","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.GeneralizedSVD","category":"type","text":"GeneralizedSVD <: Factorization\n\nMatrix factorization type of the generalized singular value decomposition (SVD)\nof two matrices A and B, such that A = F.U*F.D1*F.R0*F.Q' and\nB = F.V*F.D2*F.R0*F.Q'. This is the return type of svd(_, _), the\ncorresponding matrix factorization function.\n\nFor an M-by-N matrix A and P-by-N matrix B,\n\nU is a M-by-M orthogonal matrix,\nV is a P-by-P orthogonal matrix,\nQ is a N-by-N orthogonal matrix,\nD1 is a M-by-(K+L) diagonal matrix with 1s in the first K entries,\nD2 is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,\nR0 is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is\n         nonsingular upper block triangular,\n\nK+L is the effective numerical rank of the matrix [A; B].\n\nIterating the decomposition produces the components U, V, Q, D1, D2, and R0.\n\nThe entries of F.D1 and F.D2 are related, as explained in the LAPACK\ndocumentation for the\ngeneralized SVD and the\nxGGSVD3\nroutine which is called underneath (in LAPACK 3.6.0 and newer).\n\nExamples\n\njulia> A = [1. 0.; 0. -1.]\n2×2 Matrix{Float64}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> B = [0. 1.; 1. 0.]\n2×2 Matrix{Float64}:\n 0.0  1.0\n 1.0  0.0\n\njulia> F = svd(A, B)\nGeneralizedSVD{Float64, Matrix{Float64}, Float64, Vector{Float64}}\nU factor:\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\nV factor:\n2×2 Matrix{Float64}:\n -0.0  -1.0\n  1.0   0.0\nQ factor:\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\nD1 factor:\n2×2 Matrix{Float64}:\n 0.707107  0.0\n 0.0       0.707107\nD2 factor:\n2×2 Matrix{Float64}:\n 0.707107  0.0\n 0.0       0.707107\nR0 factor:\n2×2 Matrix{Float64}:\n 1.41421   0.0\n 0.0      -1.41421\n\njulia> F.U*F.D1*F.R0*F.Q'\n2×2 Matrix{Float64}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> F.V*F.D2*F.R0*F.Q'\n2×2 Matrix{Float64}:\n -0.0  1.0\n  1.0  0.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.svd","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.svd","category":"function","text":"svd(A; full::Bool = false, alg::Algorithm = default_svd_alg(A), atol::Real=0, rtol::Real=0) -> SVD\n\nCompute the singular value decomposition (SVD) of A and return an SVD object.\n\nU, S, V and Vt can be obtained from the factorization F with F.U,\nF.S, F.V and F.Vt, such that A = U * Diagonal(S) * Vt.\nThe algorithm produces Vt and hence Vt is more efficient to extract than V.\nThe singular values in S are sorted in descending order.\n\nIterating the decomposition produces the components U, S, and V.\n\nIf full = false (default), a \"thin\" SVD is returned. For an M times N matrix A, in the full factorization U is M times M\nand V is N times N, while in the thin factorization U is M times K and V is N times K, where K = min(MN) is the\nnumber of singular values.\n\nalg specifies which algorithm and LAPACK method to use for SVD:\n\nalg = LinearAlgebra.DivideAndConquer() (default): Calls LAPACK.gesdd!.\nalg = LinearAlgebra.QRIteration(): Calls LAPACK.gesvd! (typically slower but more accurate).\n\nThe atol and rtol parameters specify optional tolerances to truncate the SVD,\ndropping (setting to zero) singular values less than max(atol, rtol*σ₁) where\nσ₁ is the largest singular value of A.\n\ncompat: Julia 1.3\nThe alg keyword argument requires Julia 1.3 or later.\n\ncompat: Julia 1.13\nThe atol and rtol arguments require Julia 1.13 or later.\n\nExamples\n\njulia> A = rand(4,3);\n\njulia> F = svd(A); # Store the Factorization Object\n\njulia> A ≈ F.U * Diagonal(F.S) * F.Vt\ntrue\n\njulia> U, S, V = F; # destructuring via iteration\n\njulia> A ≈ U * Diagonal(S) * V'\ntrue\n\njulia> Uonly, = svd(A); # Store U only\n\njulia> Uonly == U\ntrue\n\n\n\n\n\nsvd(A, B) -> GeneralizedSVD\n\nCompute the generalized SVD of A and B, returning a GeneralizedSVD factorization\nobject F such that [A;B] = [F.U * F.D1; F.V * F.D2] * F.R0 * F.Q'\n\nU is a M-by-M orthogonal matrix,\nV is a P-by-P orthogonal matrix,\nQ is a N-by-N orthogonal matrix,\nD1 is a M-by-(K+L) diagonal matrix with 1s in the first K entries,\nD2 is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,\nR0 is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is\n         nonsingular upper block triangular,\n\nK+L is the effective numerical rank of the matrix [A; B].\n\nIterating the decomposition produces the components U, V, Q, D1, D2, and R0.\n\nThe generalized SVD is used in applications such as when one wants to compare how much belongs\nto A vs. how much belongs to B, as in human vs yeast genome, or signal vs noise, or between\nclusters vs within clusters. (See Edelman and Wang for discussion: https://arxiv.org/abs/1901.00485)\n\nIt decomposes [A; B] into [UC; VS]H, where [UC; VS] is a natural orthogonal basis for the\ncolumn space of [A; B], and H = RQ' is a natural non-orthogonal basis for the rowspace of [A;B],\nwhere the top rows are most closely attributed to the A matrix, and the bottom to the B matrix.\nThe multi-cosine/sine matrices C and S provide a multi-measure of how much A vs how much B,\nand U and V provide directions in which these are measured.\n\nExamples\n\njulia> A = randn(3,2); B=randn(4,2);\n\njulia> F = svd(A, B);\n\njulia> U,V,Q,C,S,R = F;\n\njulia> H = R*Q';\n\njulia> [A; B] ≈ [U*C; V*S]*H\ntrue\n\njulia> [A; B] ≈ [F.U*F.D1; F.V*F.D2]*F.R0*F.Q'\ntrue\n\njulia> Uonly, = svd(A,B);\n\njulia> U == Uonly\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.svd!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.svd!","category":"function","text":"svd!(A; full::Bool = false, alg::Algorithm = default_svd_alg(A), atol::Real=0, rtol::Real=0) -> SVD\n\nsvd! is the same as svd, but saves space by\noverwriting the input A, instead of creating a copy. See documentation of svd for details.\n\n\n\n\n\nsvd!(A, B) -> GeneralizedSVD\n\nsvd! is the same as svd, but modifies the arguments\nA and B in-place, instead of making copies. See documentation of svd for details.\n\n\n\n\n\n"},{"title":"LinearAlgebra.svdvals","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.svdvals","category":"function","text":"svdvals(A)\n\nReturn the singular values of A in descending order.\n\nExamples\n\njulia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]\n4×5 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\njulia> svdvals(A)\n4-element Vector{Float64}:\n 3.0\n 2.23606797749979\n 2.0\n 0.0\n\n\n\n\n\nsvdvals(A, B)\n\nReturn the generalized singular values from the generalized singular value\ndecomposition of A and B. See also svd.\n\nExamples\n\njulia> A = [1. 0.; 0. -1.]\n2×2 Matrix{Float64}:\n 1.0   0.0\n 0.0  -1.0\n\njulia> B = [0. 1.; 1. 0.]\n2×2 Matrix{Float64}:\n 0.0  1.0\n 1.0  0.0\n\njulia> svdvals(A, B)\n2-element Vector{Float64}:\n 1.0\n 1.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.svdvals!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.svdvals!","category":"function","text":"svdvals!(A)\n\nReturn the singular values of A, saving space by overwriting the input.\nSee also svdvals and svd.\n\n\n\n\n\nsvdvals!(A, B)\n\nReturn the generalized singular values from the generalized singular value\ndecomposition of A and B, saving space by overwriting A and B.\nSee also svd and svdvals.\n\n\n\n\n\n"},{"title":"LinearAlgebra.Givens","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.Givens","category":"type","text":"LinearAlgebra.Givens(i1,i2,c,s) -> G\n\nA Givens rotation linear operator. The fields c and s represent the cosine and sine of\nthe rotation angle, respectively. The Givens type supports left multiplication G*A and\nconjugated transpose right multiplication A*G'. The type doesn't have a size and can\ntherefore be multiplied with matrices of arbitrary size as long as i2<=size(A,2) for\nG*A or i2<=size(A,1) for A*G'.\n\nSee also givens.\n\n\n\n\n\n"},{"title":"LinearAlgebra.givens","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.givens","category":"function","text":"givens(f::T, g::T, i1::Integer, i2::Integer) where {T} -> (G::Givens, r::T)\n\nComputes the Givens rotation G and scalar r such that for any vector x where\n\nx[i1] = f\nx[i2] = g\n\nthe result of the multiplication\n\ny = G*x\n\nhas the property that\n\ny[i1] = r\ny[i2] = 0\n\nSee also LinearAlgebra.Givens.\n\n\n\n\n\ngivens(A::AbstractArray, i1::Integer, i2::Integer, j::Integer) -> (G::Givens, r)\n\nComputes the Givens rotation G and scalar r such that the result of the multiplication\n\nB = G*A\n\nhas the property that\n\nB[i1,j] = r\nB[i2,j] = 0\n\nSee also LinearAlgebra.Givens.\n\n\n\n\n\ngivens(x::AbstractVector, i1::Integer, i2::Integer) -> (G::Givens, r)\n\nComputes the Givens rotation G and scalar r such that the result of the multiplication\n\nB = G*x\n\nhas the property that\n\nB[i1] = r\nB[i2] = 0\n\nSee also LinearAlgebra.Givens.\n\n\n\n\n\n"},{"title":"LinearAlgebra.triu","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.triu","category":"function","text":"triu(M, k::Integer = 0)\n\nReturn the upper triangle of M starting from the kth superdiagonal.\n\nExamples\n\njulia> a = fill(1.0, (4,4))\n4×4 Matrix{Float64}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> triu(a,3)\n4×4 Matrix{Float64}:\n 0.0  0.0  0.0  1.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n\njulia> triu(a,-3)\n4×4 Matrix{Float64}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.triu!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.triu!","category":"function","text":"triu!(M)\n\nUpper triangle of a matrix, overwriting M in the process.\nSee also triu.\n\n\n\n\n\ntriu!(M, k::Integer)\n\nReturn the upper triangle of M starting from the kth superdiagonal,\noverwriting M in the process.\n\nExamples\n\njulia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]\n5×5 Matrix{Int64}:\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n\njulia> triu!(M, 1)\n5×5 Matrix{Int64}:\n 0  2  3  4  5\n 0  0  3  4  5\n 0  0  0  4  5\n 0  0  0  0  5\n 0  0  0  0  0\n\n\n\n\n\n"},{"title":"LinearAlgebra.tril","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.tril","category":"function","text":"tril(M, k::Integer = 0)\n\nReturn the lower triangle of M starting from the kth superdiagonal.\n\nExamples\n\njulia> a = fill(1.0, (4,4))\n4×4 Matrix{Float64}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> tril(a,3)\n4×4 Matrix{Float64}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> tril(a,-3)\n4×4 Matrix{Float64}:\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 1.0  0.0  0.0  0.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.tril!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.tril!","category":"function","text":"tril!(M)\n\nLower triangle of a matrix, overwriting M in the process.\nSee also tril.\n\n\n\n\n\ntril!(M, k::Integer)\n\nReturn the lower triangle of M starting from the kth superdiagonal, overwriting M in\nthe process.\n\nExamples\n\njulia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]\n5×5 Matrix{Int64}:\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n\njulia> tril!(M, 2)\n5×5 Matrix{Int64}:\n 1  2  3  0  0\n 1  2  3  4  0\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n\n\n\n\n\n"},{"title":"LinearAlgebra.diagind","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.diagind","category":"function","text":"diagind(M::AbstractMatrix, k::Integer = 0, indstyle::IndexStyle = IndexLinear())\ndiagind(M::AbstractMatrix, indstyle::IndexStyle = IndexLinear())\ndiagind(::IndexStyle, m::Integer, n::Integer, k::Integer = 0)\ndiagind(m::Integer, n::Integer, k::Integer = 0)\n\nAn AbstractRange giving the indices of the kth diagonal of a matrix,\nspecified either by the matrix M itself or by its dimensions m and n.\nOptionally, an index style may be specified which determines the type of the range returned.\nIf indstyle isa IndexLinear (default), this returns an AbstractRange{Integer}.\nOn the other hand, if indstyle isa IndexCartesian, this returns an AbstractRange{CartesianIndex{2}}.\n\nIf k is not provided, it is assumed to be 0 (corresponding to the main diagonal).\n\nSee also: diag, diagm, Diagonal.\n\nExamples\n\nThe matrix itself may be passed to diagind:\n\njulia> A = [1 2 3; 4 5 6; 7 8 9]\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> diagind(A, -1)\n2:4:6\n\njulia> diagind(A, IndexCartesian())\nStepRangeLen(CartesianIndex(1, 1), CartesianIndex(1, 1), 3)\n\nAlternatively, dimensions m and n may be passed to get the diagonal of an m×n matrix:\n\njulia> m, n = 5, 7\n(5, 7)\n\njulia> diagind(m, n, 2)\n11:6:35\n\njulia> diagind(IndexCartesian(), m, n)\nStepRangeLen(CartesianIndex(1, 1), CartesianIndex(1, 1), 5)\n\ncompat: Julia 1.11\nSpecifying an IndexStyle requires at least Julia 1.11.\n\n\n\n\n\n"},{"title":"LinearAlgebra.diag","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.diag","category":"function","text":"diag(M, k::Integer=0)\n\nThe kth diagonal of a matrix, as a vector.\n\nSee also diagm, diagind, Diagonal, isdiag.\n\nExamples\n\njulia> A = [1 2 3; 4 5 6; 7 8 9]\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> diag(A,1)\n2-element Vector{Int64}:\n 2\n 6\n\n\n\n\n\n"},{"title":"LinearAlgebra.diagm","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.diagm","category":"function","text":"diagm(kv::Pair{<:Integer,<:AbstractVector}...)\ndiagm(m::Integer, n::Integer, kv::Pair{<:Integer,<:AbstractVector}...)\n\nConstruct a matrix from Pairs of diagonals and vectors.\nVector kv.second will be placed on the kv.first diagonal.\nBy default the matrix is square and its size is inferred\nfrom kv, but a non-square size m×n (padded with zeros as needed)\ncan be specified by passing m,n as the first arguments.\nFor repeated diagonal indices kv.first the values in the corresponding\nvectors kv.second will be added.\n\ndiagm constructs a full matrix; if you want storage-efficient\nversions with fast arithmetic, see Diagonal, Bidiagonal\nTridiagonal and SymTridiagonal.\n\nExamples\n\njulia> diagm(1 => [1,2,3])\n4×4 Matrix{Int64}:\n 0  1  0  0\n 0  0  2  0\n 0  0  0  3\n 0  0  0  0\n\njulia> diagm(1 => [1,2,3], -1 => [4,5])\n4×4 Matrix{Int64}:\n 0  1  0  0\n 4  0  2  0\n 0  5  0  3\n 0  0  0  0\n\njulia> diagm(1 => [1,2,3], 1 => [1,2,3])\n4×4 Matrix{Int64}:\n 0  2  0  0\n 0  0  4  0\n 0  0  0  6\n 0  0  0  0\n\n\n\n\n\ndiagm(v::AbstractVector)\ndiagm(m::Integer, n::Integer, v::AbstractVector)\n\nConstruct a matrix with elements of the vector as diagonal elements.\nBy default, the matrix is square and its size is given by\nlength(v), but a non-square size m×n can be specified\nby passing m,n as the first arguments.\nThe diagonal will be zero-padded if necessary.\n\nExamples\n\njulia> diagm([1,2,3])\n3×3 Matrix{Int64}:\n 1  0  0\n 0  2  0\n 0  0  3\n\njulia> diagm(4, 5, [1,2,3])\n4×5 Matrix{Int64}:\n 1  0  0  0  0\n 0  2  0  0  0\n 0  0  3  0  0\n 0  0  0  0  0\n\n\n\n\n\n"},{"title":"LinearAlgebra.rank","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.rank","category":"function","text":"rank(::QRSparse{Tv,Ti}) -> Ti\n\nReturn the rank of the QR factorization\n\n\n\n\n\nrank(S::SparseMatrixCSC{Tv,Ti}; [tol::Real]) -> Ti\n\nCalculate rank of S by calculating its QR factorization. Values smaller than tol are considered as zero. See SPQR's manual.\n\n\n\n\n\nrank(A::AbstractMatrix; atol::Real=0, rtol::Real=atol>0 ? 0 : n*ϵ)\nrank(A::AbstractMatrix, rtol::Real)\n\nCompute the numerical rank of a matrix by counting how many outputs of\nsvdvals(A) are greater than max(atol, rtol*σ₁) where σ₁ is A's largest\ncalculated singular value. atol and rtol are the absolute and relative\ntolerances, respectively. The default relative tolerance is n*ϵ, where n\nis the size of the smallest dimension of A, and ϵ is the eps of\nthe element type of A.\n\nnote: Note\nNumerical rank can be a sensitive and imprecise characterization of\nill-conditioned matrices with singular values that are close to the threshold\ntolerance max(atol, rtol*σ₁). In such cases, slight perturbations to the\nsingular-value computation or to the matrix can change the result of rank\nby pushing one or more singular values across the threshold. These variations\ncan even occur due to changes in floating-point errors between different Julia\nversions, architectures, compilers, or operating systems.\n\ncompat: Julia 1.1\nThe atol and rtol keyword arguments requires at least Julia 1.1.\nIn Julia 1.0 rtol is available as a positional argument, but this\nwill be deprecated in Julia 2.0.\n\nExamples\n\njulia> rank(Matrix(I, 3, 3))\n3\n\njulia> rank(diagm(0 => [1, 0, 2]))\n2\n\njulia> rank(diagm(0 => [1, 0.001, 2]), rtol=0.1)\n2\n\njulia> rank(diagm(0 => [1, 0.001, 2]), rtol=0.00001)\n3\n\njulia> rank(diagm(0 => [1, 0.001, 2]), atol=1.5)\n1\n\n\n\n\n\nrank(S::SVD{<:Any, T}; atol::Real=0, rtol::Real=min(n,m)*ϵ) where {T}\n\nCompute the numerical rank of the SVD object S by counting how many singular values are greater\nthan max(atol, rtol*σ₁) where σ₁ is the largest calculated singular value.\nThis is equivalent to the default rank(::AbstractMatrix) method except that it re-uses an existing SVD factorization.\natol and rtol are the absolute and relative tolerances, respectively.\nThe default relative tolerance is n*ϵ, where n is the size of the smallest dimension of UΣV'\nand ϵ is the eps of the element type of S.\n\ncompat: Julia 1.12\nThe rank(::SVD) method requires at least Julia 1.12.\n\n\n\n\n\nrank(A::QRPivoted{<:Any, T}; atol::Real=0, rtol::Real=min(n,m)*ϵ) where {T}\n\nCompute the numerical rank of the QR factorization A by counting how many diagonal entries of\nA.factors are greater than max(atol, rtol*Δ₁) where Δ₁ is the largest calculated such entry.\nThis is similar to the rank(::AbstractMatrix) method insofar as it counts the number of\n(numerically) nonzero coefficients from a matrix factorization, although the default method uses an\nSVD instead of a QR factorization. Like rank(::SVD), this method also re-uses an existing\nmatrix factorization.\n\nUsing a QR factorization to compute rank should typically produce the same result as using SVD,\nalthough it may be more prone to overestimating the rank in pathological cases where the matrix is\nill-conditioned. It is also worth noting that it is generally faster to compute a QR factorization\nthan it is to compute an SVD, so this method may be preferred when performance is a concern.\n\natol and rtol are the absolute and relative tolerances, respectively.\nThe default relative tolerance is n*ϵ, where n is the size of the smallest dimension of A\nand ϵ is the eps of the element type of A.\n\ncompat: Julia 1.12\nThe rank(::QRPivoted) method requires at least Julia 1.12.\n\n\n\n\n\n"},{"title":"LinearAlgebra.norm","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.norm","category":"function","text":"norm(A, p::Real=2)\n\nFor any iterable container A (including arrays of any dimension) of numbers (or any\nelement type for which norm is defined), compute the p-norm (defaulting to p=2) as if\nA were a vector of the corresponding length.\n\nThe p-norm is defined as\n\nA_p = left( sum_i=1^n  a_i  ^p right)^1p\n\nwith a_i the entries of A,  a_i  the norm of a_i, and\nn the length of A. Since the p-norm is computed using the norms\nof the entries of A, the p-norm of a vector of vectors is not compatible with\nthe interpretation of it as a block vector in general if p != 2.\n\np can assume any numeric value (even though not all values produce a\nmathematically valid vector norm). In particular, norm(A, Inf) returns the largest value\nin abs.(A), whereas norm(A, -Inf) returns the smallest. If A is a matrix and p=2,\nthen this is equivalent to the Frobenius norm.\n\nThe second argument p is not necessarily a part of the interface for norm, i.e. a custom\ntype may only implement norm(A) without second argument.\n\nUse opnorm to compute the operator norm of a matrix.\n\nExamples\n\njulia> v = [3, -2, 6]\n3-element Vector{Int64}:\n  3\n -2\n  6\n\njulia> norm(v)\n7.0\n\njulia> norm(v, 1)\n11.0\n\njulia> norm(v, Inf)\n6.0\n\njulia> norm([1 2 3; 4 5 6; 7 8 9])\n16.881943016134134\n\njulia> norm([1 2 3 4 5 6 7 8 9])\n16.881943016134134\n\njulia> norm(1:9)\n16.881943016134134\n\njulia> norm(hcat(v,v), 1) == norm(vcat(v,v), 1) != norm([v,v], 1)\ntrue\n\njulia> norm(hcat(v,v), 2) == norm(vcat(v,v), 2) == norm([v,v], 2)\ntrue\n\njulia> norm(hcat(v,v), Inf) == norm(vcat(v,v), Inf) != norm([v,v], Inf)\ntrue\n\n\n\n\n\nnorm(x::Number, p::Real=2)\n\nFor numbers, return left( x^p right)^1p.\n\nExamples\n\njulia> norm(2, 1)\n2.0\n\njulia> norm(-2, 1)\n2.0\n\njulia> norm(2, 2)\n2.0\n\njulia> norm(-2, 2)\n2.0\n\njulia> norm(2, Inf)\n2.0\n\njulia> norm(-2, Inf)\n2.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.opnorm","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.opnorm","category":"function","text":"opnorm(A::AbstractMatrix, p::Real=2)\n\nCompute the operator norm (or matrix norm) induced by the vector p-norm,\nwhere valid values of p are 1, 2, or Inf. (Note that for sparse matrices,\np=2 is currently not implemented.) Use norm to compute the Frobenius\nnorm.\n\nWhen p=1, the operator norm is the maximum absolute column sum of A:\n\nA_1 = max_1  j  n sum_i=1^m  a_ij \n\nwith a_ij the entries of A, and m and n its dimensions.\n\nWhen p=2, the operator norm is the spectral norm, equal to the largest\nsingular value of A.\n\nWhen p=Inf, the operator norm is the maximum absolute row sum of A:\n\nA_infty = max_1  i  m sum _j=1^n  a_ij \n\nExamples\n\njulia> A = [1 -2 -3; 2 3 -1]\n2×3 Matrix{Int64}:\n 1  -2  -3\n 2   3  -1\n\njulia> opnorm(A, Inf)\n6.0\n\njulia> opnorm(A, 1)\n5.0\n\n\n\n\n\nopnorm(x::Number, p::Real=2)\n\nFor numbers, return left( x^p right)^1p.\nThis is equivalent to norm.\n\n\n\n\n\nopnorm(A::Adjoint{<:Any,<:AbstractVector}, q::Real=2)\nopnorm(A::Transpose{<:Any,<:AbstractVector}, q::Real=2)\n\nFor Adjoint/Transpose-wrapped vectors, return the operator q-norm of A, which is\nequivalent to the p-norm with value p = q/(q-1). They coincide at p = q = 2.\nUse norm to compute the p norm of A as a vector.\n\nThe difference in norm between a vector space and its dual arises to preserve\nthe relationship between duality and the dot product, and the result is\nconsistent with the operator p-norm of a 1 × n matrix.\n\nExamples\n\njulia> v = [1; im];\n\njulia> vc = v';\n\njulia> opnorm(vc, 1)\n1.0\n\njulia> norm(vc, 1)\n2.0\n\njulia> norm(v, 1)\n2.0\n\njulia> opnorm(vc, 2)\n1.4142135623730951\n\njulia> norm(vc, 2)\n1.4142135623730951\n\njulia> norm(v, 2)\n1.4142135623730951\n\njulia> opnorm(vc, Inf)\n2.0\n\njulia> norm(vc, Inf)\n1.0\n\njulia> norm(v, Inf)\n1.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.normalize!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.normalize!","category":"function","text":"normalize!(a::AbstractArray, p::Real=2)\n\nNormalize the array a in-place so that its p-norm equals unity,\ni.e. norm(a, p) == 1.\nSee also normalize and norm.\n\n\n\n\n\n"},{"title":"LinearAlgebra.normalize","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.normalize","category":"function","text":"normalize(a, p::Real=2)\n\nNormalize a so that its p-norm equals unity,\ni.e. norm(a, p) == 1. For scalars, this is similar to sign(a),\nexcept normalize(0) = NaN.\nSee also normalize!, norm, and sign.\n\nExamples\n\njulia> a = [1,2,4];\n\njulia> b = normalize(a)\n3-element Vector{Float64}:\n 0.2182178902359924\n 0.4364357804719848\n 0.8728715609439696\n\njulia> norm(b)\n1.0\n\njulia> c = normalize(a, 1)\n3-element Vector{Float64}:\n 0.14285714285714285\n 0.2857142857142857\n 0.5714285714285714\n\njulia> norm(c, 1)\n1.0\n\njulia> a = [1 2 4 ; 1 2 4]\n2×3 Matrix{Int64}:\n 1  2  4\n 1  2  4\n\njulia> norm(a)\n6.48074069840786\n\njulia> normalize(a)\n2×3 Matrix{Float64}:\n 0.154303  0.308607  0.617213\n 0.154303  0.308607  0.617213\n\njulia> normalize(3, 1)\n1.0\n\njulia> normalize(-8, 1)\n-1.0\n\njulia> normalize(0, 1)\nNaN\n\n\n\n\n\n"},{"title":"LinearAlgebra.cond","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.cond","category":"function","text":"cond(M, p::Real=2)\n\nCondition number of the matrix M, computed using the operator p-norm. Valid values for\np are 1, 2 (default), or Inf.\n\n\n\n\n\n"},{"title":"LinearAlgebra.condskeel","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.condskeel","category":"function","text":"condskeel(M, [x, p::Real=Inf])\n\nkappa_S(M p) = leftVert leftvert M rightvert leftvert M^-1 rightvert rightVert_p \nkappa_S(M x p) = fracleftVert leftvert M rightvert leftvert M^-1 rightvert leftvert x rightvert rightVert_pleft Vert x right Vert_p\n\nSkeel condition number kappa_S of the matrix M, optionally with respect to the\nvector x, as computed using the operator p-norm. leftvert M rightvert\ndenotes the matrix of (entry wise) absolute values of M;\nleftvert M rightvert_ij = leftvert M_ij rightvert.\nValid values for p are 1, 2 and Inf (default).\n\nThis quantity is also known in the literature as the Bauer condition number, relative\ncondition number, or componentwise relative condition number.\n\n\n\n\n\n"},{"title":"LinearAlgebra.tr","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.tr","category":"function","text":"tr(M)\n\nMatrix trace. Sums the diagonal elements of M.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> tr(A)\n5\n\n\n\n\n\n"},{"title":"LinearAlgebra.det","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.det","category":"function","text":"det(M)\n\nMatrix determinant.\n\nSee also: logdet and logabsdet.\n\nExamples\n\njulia> M = [1 0; 2 2]\n2×2 Matrix{Int64}:\n 1  0\n 2  2\n\njulia> det(M)\n2.0\n\nNote that, in general, det computes a floating-point approximation of the\ndeterminant, even for integer matrices, typically via Gaussian elimination.\nJulia includes an exact algorithm for integer determinants (the Bareiss algorithm),\nbut only uses it by default for BigInt matrices (since determinants quickly\noverflow any fixed integer precision):\n\njulia> det(BigInt[1 0; 2 2]) # exact integer determinant\n2\n\n\n\n\n\n"},{"title":"LinearAlgebra.logdet","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.logdet","category":"function","text":"logdet(M)\n\nLogarithm of matrix determinant. Equivalent to log(det(M)), but may provide\nincreased accuracy and avoids overflow/underflow.\n\nExamples\n\njulia> M = [1 0; 2 2]\n2×2 Matrix{Int64}:\n 1  0\n 2  2\n\njulia> logdet(M)\n0.6931471805599453\n\njulia> logdet(Matrix(I, 3, 3))\n0.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.logabsdet","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.logabsdet","category":"function","text":"logabsdet(M)\n\nLog of absolute value of matrix determinant. Equivalent to\n(log(abs(det(M))), sign(det(M))), but may provide increased accuracy and/or speed.\n\nExamples\n\njulia> A = [-1. 0.; 0. 1.]\n2×2 Matrix{Float64}:\n -1.0  0.0\n  0.0  1.0\n\njulia> det(A)\n-1.0\n\njulia> logabsdet(A)\n(0.0, -1.0)\n\njulia> B = [2. 0.; 0. 1.]\n2×2 Matrix{Float64}:\n 2.0  0.0\n 0.0  1.0\n\njulia> det(B)\n2.0\n\njulia> logabsdet(B)\n(0.6931471805599453, 1.0)\n\n\n\n\n\n"},{"title":"Base.inv","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.inv-Tuple{AbstractMatrix}","category":"method","text":"inv(M)\n\nMatrix inverse. Computes matrix N such that\nM * N = I, where I is the identity matrix.\nComputed by solving the left-division\nN = M \\ I.\n\nA SingularException is thrown if M fails numerical inversion.\n\nExamples\n\njulia> M = [2 5; 1 3]\n2×2 Matrix{Int64}:\n 2  5\n 1  3\n\njulia> N = inv(M)\n2×2 Matrix{Float64}:\n  3.0  -5.0\n -1.0   2.0\n\njulia> M*N == N*M == Matrix(I, 2, 2)\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.pinv","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.pinv","category":"function","text":"pinv(M; atol::Real=0, rtol::Real=atol>0 ? 0 : n*ϵ)\npinv(M, rtol::Real) = pinv(M; rtol=rtol) # to be deprecated in Julia 2.0\n\nComputes the Moore-Penrose pseudoinverse.\n\nFor matrices M with floating point elements, it is convenient to compute\nthe pseudoinverse by inverting only singular values greater than\nmax(atol, rtol*σ₁) where σ₁ is the largest singular value of M.\n\nThe optimal choice of absolute (atol) and relative tolerance (rtol) varies\nboth with the value of M and the intended application of the pseudoinverse.\nThe default relative tolerance is n*ϵ, where n is the size of the smallest\ndimension of M, and ϵ is the eps of the element type of M.\n\nFor solving dense, ill-conditioned equations in a least-square sense, it\nis better to not explicitly form the pseudoinverse matrix, since this\ncan lead to numerical instability at low tolerances.  The default M \\ b\nalgorithm instead uses pivoted QR factorization (qr).  To use an\nSVD-based algorithm, it is better to employ the SVD directly via svd(M; rtol, atol) \\ b\nor ldiv!(svd(M), b; rtol, atol).\n\nOne can also pass M = svd(A) as the argument to pinv in order to re-use\nan existing SVD factorization.  In this case, pinv will return\nthe SVD of the pseudo-inverse, which can be applied accurately, instead of an explicit matrix.\n\ncompat: Julia 1.13\nPassing an SVD object to pinv requires Julia 1.13 or later.\n\nFor more information, see [pr1387], [B96], [S84], [KY88].\n\nExamples\n\njulia> M = [1.5 1.3; 1.2 1.9]\n2×2 Matrix{Float64}:\n 1.5  1.3\n 1.2  1.9\n\njulia> N = pinv(M)\n2×2 Matrix{Float64}:\n  1.47287   -1.00775\n -0.930233   1.16279\n\njulia> M * N\n2×2 Matrix{Float64}:\n 1.0          -2.22045e-16\n 4.44089e-16   1.0\n\n[pr1387]: PR 1387, \"stable pinv least-squares\", LinearAlgebra.jl#1387\n\n[B96]: Åke Björck, \"Numerical Methods for Least Squares Problems\",  SIAM Press, Philadelphia, 1996, \"Other Titles in Applied Mathematics\", Vol. 51. doi:10.1137/1.9781611971484\n\n[S84]: G. W. Stewart, \"Rank Degeneracy\", SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. doi:10.1137/0905030\n\n[KY88]: Konstantinos Konstantinides and Kung Yao, \"Statistical analysis of effective singular values in matrix rank determination\", IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. doi:10.1109/29.1585\n\n\n\n\n\n"},{"title":"LinearAlgebra.nullspace","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.nullspace","category":"function","text":"nullspace(M; atol::Real=0, rtol::Real=atol>0 ? 0 : n*ϵ)\nnullspace(M, rtol::Real) = nullspace(M; rtol=rtol) # to be deprecated in Julia 2.0\n\nComputes a basis for the nullspace of M by including the singular\nvectors of M whose singular values have magnitudes smaller than max(atol, rtol*σ₁),\nwhere σ₁ is M's largest singular value.\n\nBy default, the relative tolerance rtol is n*ϵ, where n\nis the size of the smallest dimension of M, and ϵ is the eps of\nthe element type of M.\n\nExamples\n\njulia> M = [1 0 0; 0 1 0; 0 0 0]\n3×3 Matrix{Int64}:\n 1  0  0\n 0  1  0\n 0  0  0\n\njulia> nullspace(M)\n3×1 Matrix{Float64}:\n 0.0\n 0.0\n 1.0\n\njulia> nullspace(M, rtol=3)\n3×3 Matrix{Float64}:\n 0.0  1.0  0.0\n 1.0  0.0  0.0\n 0.0  0.0  1.0\n\njulia> nullspace(M, atol=0.95)\n3×1 Matrix{Float64}:\n 0.0\n 0.0\n 1.0\n\n\n\n\n\n"},{"title":"Base.kron","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.kron","category":"function","text":"kron(A, B)\n\nComputes the Kronecker product of two vectors, matrices or numbers.\n\nFor real vectors v and w, the Kronecker product is related to the outer product by\nkron(v,w) == vec(w * transpose(v)) or\nw * transpose(v) == reshape(kron(v,w), (length(w), length(v))).\nNote how the ordering of v and w differs on the left and right\nof these expressions (due to column-major storage).\nFor complex vectors, the outer product w * v' also differs by conjugation of v.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> B = [im 1; 1 -im]\n2×2 Matrix{Complex{Int64}}:\n 0+1im  1+0im\n 1+0im  0-1im\n\njulia> kron(A, B)\n4×4 Matrix{Complex{Int64}}:\n 0+1im  1+0im  0+2im  2+0im\n 1+0im  0-1im  2+0im  0-2im\n 0+3im  3+0im  0+4im  4+0im\n 3+0im  0-3im  4+0im  0-4im\n\njulia> v = [1, 2]; w = [3, 4, 5];\n\njulia> w*transpose(v)\n3×2 Matrix{Int64}:\n 3   6\n 4   8\n 5  10\n\njulia> reshape(kron(v,w), (length(w), length(v)))\n3×2 Matrix{Int64}:\n 3   6\n 4   8\n 5  10\n\n\n\n\n\n"},{"title":"Base.kron!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.kron!","category":"function","text":"kron!(C, A, B)\n\nComputes the Kronecker product of A and B and stores the result in C,\noverwriting the existing content of C. This is the in-place version of kron.\n\ncompat: Julia 1.6\nThis function requires Julia 1.6 or later.\n\n\n\n\n\n"},{"title":"Base.exp","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.exp-Tuple{StridedMatrix{var\"#s38\"} where var\"#s38\"<:Union{Float32, Float64, ComplexF64, ComplexF32}}","category":"method","text":"exp(A::AbstractMatrix)\n\nCompute the matrix exponential of A, defined by\n\ne^A = sum_n=0^infty fracA^nn\n\nFor symmetric or Hermitian A, an eigendecomposition (eigen) is\nused, otherwise the scaling and squaring algorithm (see [H05]) is chosen.\n\n[H05]: Nicholas J. Higham, \"The squaring and scaling method for the matrix exponential revisited\", SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. doi:10.1137/090768539\n\nExamples\n\njulia> A = Matrix(1.0I, 2, 2)\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\njulia> exp(A)\n2×2 Matrix{Float64}:\n 2.71828  0.0\n 0.0      2.71828\n\n\n\n\n\n"},{"title":"Base.cis","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.cis-Tuple{AbstractMatrix}","category":"method","text":"cis(A::AbstractMatrix)\n\nMore efficient method for exp(im*A) of square matrix A\n(especially if A is Hermitian or real-Symmetric).\n\nSee also cispi, sincos, exp.\n\ncompat: Julia 1.7\nSupport for using cis with matrices was added in Julia 1.7.\n\nExamples\n\njulia> cis([π 0; 0 π]) ≈ -I\ntrue\n\n\n\n\n\n"},{"title":"Base.:^","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.:^-Tuple{AbstractMatrix, Number}","category":"method","text":"^(A::AbstractMatrix, p::Number)\n\nMatrix power, equivalent to exp(plog(A))\n\nExamples\n\njulia> [1 2; 0 3]^3\n2×2 Matrix{Int64}:\n 1  26\n 0  27\n\n\n\n\n\n"},{"title":"Base.:^","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.:^-Tuple{Number, AbstractMatrix}","category":"method","text":"^(b::Number, A::AbstractMatrix)\n\nMatrix exponential, equivalent to exp(log(b)A).\n\ncompat: Julia 1.1\nSupport for raising Irrational numbers (like ℯ)\nto a matrix was added in Julia 1.1.\n\nExamples\n\njulia> 2^[1 2; 0 3]\n2×2 Matrix{Float64}:\n 2.0  6.0\n 0.0  8.0\n\njulia> ℯ^[1 2; 0 3]\n2×2 Matrix{Float64}:\n 2.71828  17.3673\n 0.0      20.0855\n\n\n\n\n\n"},{"title":"Base.log","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.log-Tuple{StridedMatrix{T} where T}","category":"method","text":"log(A::AbstractMatrix)\n\nIf A has no negative real eigenvalue, compute the principal matrix logarithm of A, i.e.\nthe unique matrix X such that e^X = A and -pi  Im(lambda)  pi for all\nthe eigenvalues lambda of X. If A has nonpositive eigenvalues, a nonprincipal\nmatrix function is returned whenever possible.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is\nused, if A is triangular an improved version of the inverse scaling and squaring method is\nemployed (see [AH12] and [AHR13]). If A is real with no negative eigenvalues, then\nthe real Schur form is computed. Otherwise, the complex Schur form is computed. Then\nthe upper (quasi-)triangular algorithm in [AHR13] is used on the upper (quasi-)triangular\nfactor.\n\n[AH12]: Awad H. Al-Mohy and Nicholas J. Higham, \"Improved inverse  scaling and squaring algorithms for the matrix logarithm\", SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. doi:10.1137/110852553\n\n[AHR13]: Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, \"Computing the Fréchet derivative of the matrix logarithm and estimating the condition number\", SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. doi:10.1137/120885991\n\nExamples\n\njulia> A = Matrix(2.7182818*I, 2, 2)\n2×2 Matrix{Float64}:\n 2.71828  0.0\n 0.0      2.71828\n\njulia> log(A)\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n"},{"title":"Base.sqrt","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.sqrt-Tuple{StridedMatrix{T} where T}","category":"method","text":"sqrt(x)\n\nReturn sqrtx.\n\nThrow a DomainError for negative Real arguments.\nUse Complex negative arguments instead to obtain a Complex result.\n\nThe prefix operator √ is equivalent to sqrt.\n\nnote: Branch cut\nsqrt has a branch cut along the negative real axis; -0.0im is taken\nto be below the axis.\n\nSee also: hypot.\n\nExamples\n\njulia> sqrt(big(81))\n9.0\n\njulia> sqrt(big(-81))\nERROR: DomainError with -81.0:\nNaN result for non-NaN input.\nStacktrace:\n [1] sqrt(::BigFloat) at ./mpfr.jl:501\n[...]\n\njulia> sqrt(big(complex(-81)))\n0.0 + 9.0im\n\njulia> sqrt(-81 - 0.0im)  # -0.0im is below the branch cut\n0.0 - 9.0im\n\njulia> .√(1:4)\n4-element Vector{Float64}:\n 1.0\n 1.4142135623730951\n 1.7320508075688772\n 2.0\n\n\n\n\n\nsqrt(A::AbstractMatrix)\n\nIf A has no negative real eigenvalues, compute the principal matrix square root of A,\nthat is the unique matrix X with eigenvalues having positive real part such that\nX^2 = A. Otherwise, a nonprincipal square root is returned.\n\nIf A is real-symmetric or Hermitian, its eigendecomposition (eigen) is\nused to compute the square root.   For such matrices, eigenvalues λ that\nappear to be slightly negative due to roundoff errors are treated as if they were zero.\nMore precisely, matrices with all eigenvalues ≥ -rtol*(max |λ|) are treated as semidefinite\n(yielding a Hermitian square root), with negative eigenvalues taken to be zero.\nrtol is a keyword argument to sqrt (in the Hermitian/real-symmetric case only) that\ndefaults to machine precision scaled by size(A,1).\n\nOtherwise, the square root is determined by means of the\nBjörck-Hammarling method [BH83], which computes the complex Schur form (schur)\nand then the complex square root of the triangular factor.\nIf a real square root exists, then an extension of this method [H87] that computes the real\nSchur form and then the real square root of the quasi-triangular factor is instead used.\n\n[BH83]: Åke Björck and Sven Hammarling, \"A Schur method for the square root of a matrix\",\nLinear Algebra and its Applications, 52-53, 1983, 127-140.\ndoi:10.1016/0024-3795(83)80010-X\n\n[H87]: Nicholas J. Higham, \"Computing real square roots of a real matrix\",\nLinear Algebra and its Applications, 88-89, 1987, 405-430.\ndoi:10.1016/0024-3795(87)90118-2\n\nExamples\n\njulia> A = [4 0; 0 4]\n2×2 Matrix{Int64}:\n 4  0\n 0  4\n\njulia> sqrt(A)\n2×2 Matrix{Float64}:\n 2.0  0.0\n 0.0  2.0\n\n\n\n\n\n"},{"title":"Base.Math.cbrt","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.Math.cbrt-Tuple{AbstractMatrix{<:Real}}","category":"method","text":"cbrt(A::AbstractMatrix{<:Real})\n\nComputes the real-valued cube root of a real-valued matrix A. If T = cbrt(A), then\nwe have T*T*T ≈ A, see example given below.\n\nIf A is real-symmetric or Hermitian, its eigendecomposition (eigen) is used to\nfind the cube root. Otherwise, a specialized version of the p-th root algorithm [S03] is\nutilized, which exploits the real-valued Schur decomposition (schur)\nto compute the cube root.\n\n[S03]: Matthew I. Smith, \"A Schur Algorithm for Computing Matrix pth Roots\",\nSIAM Journal on Matrix Analysis and Applications, vol. 24, 2003, pp. 971–989.\ndoi:10.1137/S0895479801392697\n\nExamples\n\njulia> A = [0.927524 -0.15857; -1.3677 -1.01172]\n2×2 Matrix{Float64}:\n  0.927524  -0.15857\n -1.3677    -1.01172\n\njulia> T = cbrt(A)\n2×2 Matrix{Float64}:\n  0.910077  -0.151019\n -1.30257   -0.936818\n\njulia> T*T*T ≈ A\ntrue\n\n\n\n\n\n"},{"title":"Base.cos","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.cos-Tuple{StridedMatrix{var\"#s38\"} where var\"#s38\"<:Real}","category":"method","text":"cos(A::AbstractMatrix)\n\nCompute the matrix cosine of a square matrix A.\n\nIf A is real-symmetric or Hermitian, its eigendecomposition (eigen) is used to\ncompute the cosine. Otherwise, the cosine is determined by calling exp.\n\nExamples\n\njulia> cos(fill(1.0, (2,2)))\n2×2 Matrix{Float64}:\n  0.291927  -0.708073\n -0.708073   0.291927\n\n\n\n\n\n"},{"title":"Base.sin","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.sin-Tuple{StridedMatrix{var\"#s38\"} where var\"#s38\"<:Real}","category":"method","text":"sin(A::AbstractMatrix)\n\nCompute the matrix sine of a square matrix A.\n\nIf A is real-symmetric or Hermitian, its eigendecomposition (eigen) is used to\ncompute the sine. Otherwise, the sine is determined by calling exp.\n\nExamples\n\njulia> sin(fill(1.0, (2,2)))\n2×2 Matrix{Float64}:\n 0.454649  0.454649\n 0.454649  0.454649\n\n\n\n\n\n"},{"title":"Base.Math.sincos","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.Math.sincos-Tuple{StridedMatrix{var\"#s38\"} where var\"#s38\"<:Real}","category":"method","text":"sincos(A::AbstractMatrix)\n\nCompute the matrix sine and cosine of a square matrix A.\n\nExamples\n\njulia> S, C = sincos(fill(1.0, (2,2)));\n\njulia> S\n2×2 Matrix{Float64}:\n 0.454649  0.454649\n 0.454649  0.454649\n\njulia> C\n2×2 Matrix{Float64}:\n  0.291927  -0.708073\n -0.708073   0.291927\n\n\n\n\n\n"},{"title":"Base.tan","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.tan-Tuple{StridedMatrix{var\"#s38\"} where var\"#s38\"<:Real}","category":"method","text":"tan(A::AbstractMatrix)\n\nCompute the matrix tangent of a square matrix A.\n\nIf A is real-symmetric or Hermitian, its eigendecomposition (eigen) is used to\ncompute the tangent. Otherwise, the tangent is determined by calling exp.\n\nExamples\n\njulia> tan(fill(1.0, (2,2)))\n2×2 Matrix{Float64}:\n -1.09252  -1.09252\n -1.09252  -1.09252\n\n\n\n\n\n"},{"title":"Base.Math.sec","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.Math.sec-Tuple{StridedMatrix{T} where T}","category":"method","text":"sec(A::AbstractMatrix)\n\nCompute the matrix secant of a square matrix A.\n\n\n\n\n\n"},{"title":"Base.Math.csc","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.Math.csc-Tuple{StridedMatrix{T} where T}","category":"method","text":"csc(A::AbstractMatrix)\n\nCompute the matrix cosecant of a square matrix A.\n\n\n\n\n\n"},{"title":"Base.Math.cot","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.Math.cot-Tuple{StridedMatrix{T} where T}","category":"method","text":"cot(A::AbstractMatrix)\n\nCompute the matrix cotangent of a square matrix A.\n\n\n\n\n\n"},{"title":"Base.cosh","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.cosh-Tuple{StridedMatrix{T} where T}","category":"method","text":"cosh(A::AbstractMatrix)\n\nCompute the matrix hyperbolic cosine of a square matrix A.\n\n\n\n\n\n"},{"title":"Base.sinh","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.sinh-Tuple{StridedMatrix{T} where T}","category":"method","text":"sinh(A::AbstractMatrix)\n\nCompute the matrix hyperbolic sine of a square matrix A.\n\n\n\n\n\n"},{"title":"Base.tanh","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.tanh-Tuple{StridedMatrix{T} where T}","category":"method","text":"tanh(A::AbstractMatrix)\n\nCompute the matrix hyperbolic tangent of a square matrix A.\n\n\n\n\n\n"},{"title":"Base.Math.sech","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.Math.sech-Tuple{StridedMatrix{T} where T}","category":"method","text":"sech(A::AbstractMatrix)\n\nCompute the matrix hyperbolic secant of square matrix A.\n\n\n\n\n\n"},{"title":"Base.Math.csch","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.Math.csch-Tuple{StridedMatrix{T} where T}","category":"method","text":"csch(A::AbstractMatrix)\n\nCompute the matrix hyperbolic cosecant of square matrix A.\n\n\n\n\n\n"},{"title":"Base.Math.coth","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.Math.coth-Tuple{StridedMatrix{T} where T}","category":"method","text":"coth(A::AbstractMatrix)\n\nCompute the matrix hyperbolic cotangent of square matrix A.\n\n\n\n\n\n"},{"title":"Base.acos","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.acos-Tuple{StridedMatrix{T} where T}","category":"method","text":"acos(A::AbstractMatrix)\n\nCompute the inverse matrix cosine of a square matrix A.\n\nIf A is real-symmetric or Hermitian, its eigendecomposition (eigen) is used to\ncompute the inverse cosine. Otherwise, the inverse cosine is determined by using\nlog and sqrt.  For the theory and logarithmic formulas used to compute\nthis function, see [AH16_1].\n\n[AH16_1]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\nExamples\n\njulia> acos(cos([0.5 0.1; -0.2 0.3]))\n2×2 Matrix{ComplexF64}:\n  0.5-8.32667e-17im  0.1+0.0im\n -0.2+2.63678e-16im  0.3-3.46945e-16im\n\n\n\n\n\n"},{"title":"Base.asin","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.asin-Tuple{StridedMatrix{T} where T}","category":"method","text":"asin(A::AbstractMatrix)\n\nCompute the inverse matrix sine of a square matrix A.\n\nIf A is real-symmetric or Hermitian, its eigendecomposition (eigen) is used to\ncompute the inverse sine. Otherwise, the inverse sine is determined by using log\nand sqrt.  For the theory and logarithmic formulas used to compute this function,\nsee [AH16_2].\n\n[AH16_2]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\nExamples\n\njulia> asin(sin([0.5 0.1; -0.2 0.3]))\n2×2 Matrix{ComplexF64}:\n  0.5-4.16334e-17im  0.1-5.55112e-17im\n -0.2+9.71445e-17im  0.3-1.249e-16im\n\n\n\n\n\n"},{"title":"Base.atan","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.atan-Tuple{StridedMatrix{T} where T}","category":"method","text":"atan(A::AbstractMatrix)\n\nCompute the inverse matrix tangent of a square matrix A.\n\nIf A is real-symmetric or Hermitian, its eigendecomposition (eigen) is used to\ncompute the inverse tangent. Otherwise, the inverse tangent is determined by using\nlog.  For the theory and logarithmic formulas used to compute this function, see\n[AH16_3].\n\n[AH16_3]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\nExamples\n\njulia> atan(tan([0.5 0.1; -0.2 0.3]))\n2×2 Matrix{ComplexF64}:\n  0.5  0.1\n -0.2  0.3\n\n\n\n\n\n"},{"title":"Base.Math.asec","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.Math.asec-Tuple{StridedMatrix{T} where T}","category":"method","text":"asec(A::AbstractMatrix)\n\nCompute the inverse matrix secant of A. \n\n\n\n\n\n"},{"title":"Base.Math.acsc","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.Math.acsc-Tuple{StridedMatrix{T} where T}","category":"method","text":"acsc(A::AbstractMatrix)\n\nCompute the inverse matrix cosecant of A. \n\n\n\n\n\n"},{"title":"Base.Math.acot","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.Math.acot-Tuple{StridedMatrix{T} where T}","category":"method","text":"acot(A::AbstractMatrix)\n\nCompute the inverse matrix cotangent of A. \n\n\n\n\n\n"},{"title":"Base.acosh","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.acosh-Tuple{StridedMatrix{T} where T}","category":"method","text":"acosh(A::AbstractMatrix)\n\nCompute the inverse hyperbolic matrix cosine of a square matrix A.  For the theory and\nlogarithmic formulas used to compute this function, see [AH16_4].\n\n[AH16_4]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\n\n\n\n\n"},{"title":"Base.asinh","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.asinh-Tuple{StridedMatrix{T} where T}","category":"method","text":"asinh(A::AbstractMatrix)\n\nCompute the inverse hyperbolic matrix sine of a square matrix A.  For the theory and\nlogarithmic formulas used to compute this function, see [AH16_5].\n\n[AH16_5]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\n\n\n\n\n"},{"title":"Base.atanh","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.atanh-Tuple{StridedMatrix{T} where T}","category":"method","text":"atanh(A::AbstractMatrix)\n\nCompute the inverse hyperbolic matrix tangent of a square matrix A.  For the theory and\nlogarithmic formulas used to compute this function, see [AH16_6].\n\n[AH16_6]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\n\n\n\n\n"},{"title":"Base.Math.asech","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.Math.asech-Tuple{StridedMatrix{T} where T}","category":"method","text":"asech(A::AbstractMatrix)\n\nCompute the inverse matrix hyperbolic secant of A. \n\n\n\n\n\n"},{"title":"Base.Math.acsch","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.Math.acsch-Tuple{StridedMatrix{T} where T}","category":"method","text":"acsch(A::AbstractMatrix)\n\nCompute the inverse matrix hyperbolic cosecant of A. \n\n\n\n\n\n"},{"title":"Base.Math.acoth","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.Math.acoth-Tuple{StridedMatrix{T} where T}","category":"method","text":"acoth(A::AbstractMatrix)\n\nCompute the inverse matrix hyperbolic cotangent of A. \n\n\n\n\n\n"},{"title":"LinearAlgebra.lyap","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.lyap","category":"function","text":"lyap(A, C)\n\nComputes the solution X to the continuous Lyapunov equation AX + XA' + C = 0, where no\neigenvalue of A has a zero real part and no two eigenvalues are negative complex\nconjugates of each other.\n\nExamples\n\njulia> A = [3. 4.; 5. 6]\n2×2 Matrix{Float64}:\n 3.0  4.0\n 5.0  6.0\n\njulia> B = [1. 1.; 1. 2.]\n2×2 Matrix{Float64}:\n 1.0  1.0\n 1.0  2.0\n\njulia> X = lyap(A, B)\n2×2 Matrix{Float64}:\n  0.5  -0.5\n -0.5   0.25\n\njulia> A*X + X*A' ≈ -B\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.sylvester","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.sylvester","category":"function","text":"sylvester(A, B, C)\n\nComputes the solution X to the Sylvester equation AX + XB + C = 0, where A, B and\nC have compatible dimensions and A and -B have no eigenvalues with equal real part.\n\nExamples\n\njulia> A = [3. 4.; 5. 6]\n2×2 Matrix{Float64}:\n 3.0  4.0\n 5.0  6.0\n\njulia> B = [1. 1.; 1. 2.]\n2×2 Matrix{Float64}:\n 1.0  1.0\n 1.0  2.0\n\njulia> C = [1. 2.; -2. 1]\n2×2 Matrix{Float64}:\n  1.0  2.0\n -2.0  1.0\n\njulia> X = sylvester(A, B, C)\n2×2 Matrix{Float64}:\n -4.46667   1.93333\n  3.73333  -1.8\n\njulia> A*X + X*B ≈ -C\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.issuccess","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.issuccess","category":"function","text":"issuccess(F::Factorization)\n\nTest that a factorization of a matrix succeeded.\n\ncompat: Julia 1.6\nissuccess(::CholeskyPivoted) requires Julia 1.6 or later.\n\nExamples\n\njulia> F = cholesky([1 0; 0 1]);\n\njulia> issuccess(F)\ntrue\n\n\n\n\n\nissuccess(F::LU; allowsingular = false)\n\nTest that the LU factorization of a matrix succeeded. By default a\nfactorization that produces a valid but rank-deficient U factor is considered a\nfailure. This can be changed by passing allowsingular = true.\n\ncompat: Julia 1.11\nThe allowsingular keyword argument was added in Julia 1.11.\n\nExamples\n\njulia> F = lu([1 2; 1 2], check = false);\n\njulia> issuccess(F)\nfalse\n\njulia> issuccess(F, allowsingular = true)\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.issymmetric","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.issymmetric","category":"function","text":"issymmetric(A) -> Bool\n\nTest whether a matrix or number is symmetric.\n\nExamples\n\njulia> a = [1 2; 2 -1]\n2×2 Matrix{Int64}:\n 1   2\n 2  -1\n\njulia> issymmetric(a)\ntrue\n\njulia> b = [1 im; -im 1]\n2×2 Matrix{Complex{Int64}}:\n 1+0im  0+1im\n 0-1im  1+0im\n\njulia> issymmetric(b)\nfalse\n\n\n\n\n\n"},{"title":"LinearAlgebra.isposdef","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.isposdef","category":"function","text":"isposdef(A) -> Bool\n\nTest whether a matrix is positive definite (and Hermitian) by trying to perform a\nCholesky factorization of A.\n\nSee also isposdef!, cholesky.\n\nExamples\n\njulia> A = [1 2; 2 50]\n2×2 Matrix{Int64}:\n 1   2\n 2  50\n\njulia> isposdef(A)\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.isposdef!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.isposdef!","category":"function","text":"isposdef!(A) -> Bool\n\nTest whether a matrix is positive definite (and Hermitian) by trying to perform a\nCholesky factorization of A, overwriting A in the process.\nSee also isposdef.\n\nExamples\n\njulia> A = [1. 2.; 2. 50.];\n\njulia> isposdef!(A)\ntrue\n\njulia> A\n2×2 Matrix{Float64}:\n 1.0  2.0\n 2.0  6.78233\n\n\n\n\n\n"},{"title":"LinearAlgebra.istril","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.istril","category":"function","text":"istril(A::AbstractMatrix, k::Integer = 0) -> Bool\n\nTest whether A is lower triangular starting from the kth superdiagonal.\n\nExamples\n\njulia> a = [1 2; 2 -1]\n2×2 Matrix{Int64}:\n 1   2\n 2  -1\n\njulia> istril(a)\nfalse\n\njulia> istril(a, 1)\ntrue\n\njulia> c = [1 1 0; 1 1 1; 1 1 1]\n3×3 Matrix{Int64}:\n 1  1  0\n 1  1  1\n 1  1  1\n\njulia> istril(c)\nfalse\n\njulia> istril(c, 1)\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.istriu","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.istriu","category":"function","text":"istriu(A::AbstractMatrix, k::Integer = 0) -> Bool\n\nTest whether A is upper triangular starting from the kth superdiagonal.\n\nExamples\n\njulia> a = [1 2; 2 -1]\n2×2 Matrix{Int64}:\n 1   2\n 2  -1\n\njulia> istriu(a)\nfalse\n\njulia> istriu(a, -1)\ntrue\n\njulia> c = [1 1 1; 1 1 1; 0 1 1]\n3×3 Matrix{Int64}:\n 1  1  1\n 1  1  1\n 0  1  1\n\njulia> istriu(c)\nfalse\n\njulia> istriu(c, -1)\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.isdiag","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.isdiag","category":"function","text":"isdiag(A) -> Bool\n\nTest whether a matrix is diagonal in the sense that iszero(A[i,j]) is true unless i == j.\nNote that it is not necessary for A to be square;\nif you would also like to check that, you need to check that size(A, 1) == size(A, 2).\n\nExamples\n\njulia> a = [1 2; 2 -1]\n2×2 Matrix{Int64}:\n 1   2\n 2  -1\n\njulia> isdiag(a)\nfalse\n\njulia> b = [im 0; 0 -im]\n2×2 Matrix{Complex{Int64}}:\n 0+1im  0+0im\n 0+0im  0-1im\n\njulia> isdiag(b)\ntrue\n\njulia> c = [1 0 0; 0 2 0]\n2×3 Matrix{Int64}:\n 1  0  0\n 0  2  0\n\njulia> isdiag(c)\ntrue\n\njulia> d = [1 0 0; 0 2 3]\n2×3 Matrix{Int64}:\n 1  0  0\n 0  2  3\n\njulia> isdiag(d)\nfalse\n\n\n\n\n\n"},{"title":"LinearAlgebra.ishermitian","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.ishermitian","category":"function","text":"ishermitian(A) -> Bool\n\nTest whether a matrix is Hermitian.\n\nExamples\n\njulia> a = [1 2; 2 -1]\n2×2 Matrix{Int64}:\n 1   2\n 2  -1\n\njulia> ishermitian(a)\ntrue\n\njulia> b = [1 im; -im 1]\n2×2 Matrix{Complex{Int64}}:\n 1+0im  0+1im\n 0-1im  1+0im\n\njulia> ishermitian(b)\ntrue\n\n\n\n\n\n"},{"title":"Base.transpose","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.transpose","category":"function","text":"transpose(A)\n\nLazy transpose. Mutating the returned object should appropriately mutate A. Often,\nbut not always, yields Transpose(A), where Transpose is a lazy transpose wrapper. Note\nthat this operation is recursive.\n\nThis operation is intended for linear algebra usage - for general data manipulation see\npermutedims, which is non-recursive.\n\nExamples\n\njulia> A = [3 2; 0 0]\n2×2 Matrix{Int64}:\n 3  2\n 0  0\n\njulia> B = transpose(A)\n2×2 transpose(::Matrix{Int64}) with eltype Int64:\n 3  0\n 2  0\n\njulia> B isa Transpose\ntrue\n\njulia> transpose(B) === A # the transpose of a transpose unwraps the parent\ntrue\n\njulia> Transpose(B) # however, the constructor always wraps its argument\n2×2 transpose(transpose(::Matrix{Int64})) with eltype Int64:\n 3  2\n 0  0\n\njulia> B[1,2] = 4; # modifying B will modify A automatically\n\njulia> A\n2×2 Matrix{Int64}:\n 3  2\n 4  0\n\nFor complex matrices, the adjoint operation is equivalent to a conjugate-transpose.\n\njulia> A = reshape([Complex(x, x) for x in 1:4], 2, 2)\n2×2 Matrix{Complex{Int64}}:\n 1+1im  3+3im\n 2+2im  4+4im\n\njulia> adjoint(A) == conj(transpose(A))\ntrue\n\nThe transpose of an AbstractVector is a row-vector:\n\njulia> v = [1,2,3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> transpose(v) # returns a row-vector\n1×3 transpose(::Vector{Int64}) with eltype Int64:\n 1  2  3\n\njulia> transpose(v) * v # compute the dot product\n14\n\nFor a matrix of matrices, the individual blocks are recursively operated on:\n\njulia> C = [1 3; 2 4]\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> D = reshape([C, 2C, 3C, 4C], 2, 2) # construct a block matrix\n2×2 Matrix{Matrix{Int64}}:\n [1 3; 2 4]  [3 9; 6 12]\n [2 6; 4 8]  [4 12; 8 16]\n\njulia> transpose(D) # blocks are recursively transposed\n2×2 transpose(::Matrix{Matrix{Int64}}) with eltype Transpose{Int64, Matrix{Int64}}:\n [1 2; 3 4]   [2 4; 6 8]\n [3 6; 9 12]  [4 8; 12 16]\n\n\n\n\n\ntranspose(F::Factorization)\n\nLazy transpose of the factorization F. By default, returns a TransposeFactorization,\nexcept for Factorizations with real eltype, in which case returns an AdjointFactorization.\n\n\n\n\n\n"},{"title":"LinearAlgebra.transpose!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.transpose!","category":"function","text":"transpose!(dest,src)\n\nTranspose array src and store the result in the preallocated array dest, which should\nhave a size corresponding to (size(src,2),size(src,1)). No in-place transposition is\nsupported and unexpected results will happen if src and dest have overlapping memory\nregions.\n\nExamples\n\njulia> A = [3+2im 9+2im; 8+7im  4+6im]\n2×2 Matrix{Complex{Int64}}:\n 3+2im  9+2im\n 8+7im  4+6im\n\njulia> B = zeros(Complex{Int64}, 2, 2)\n2×2 Matrix{Complex{Int64}}:\n 0+0im  0+0im\n 0+0im  0+0im\n\njulia> transpose!(B, A);\n\njulia> B\n2×2 Matrix{Complex{Int64}}:\n 3+2im  8+7im\n 9+2im  4+6im\n\njulia> A\n2×2 Matrix{Complex{Int64}}:\n 3+2im  9+2im\n 8+7im  4+6im\n\n\n\n\n\ntranspose!(X::AbstractSparseMatrixCSC{Tv,Ti}, A::AbstractSparseMatrixCSC{Tv,Ti}) where {Tv,Ti}\n\nTranspose the matrix A and stores it in the matrix X.\nsize(X) must be equal to size(transpose(A)).\nNo additional memory is allocated other than resizing the rowval and nzval of X, if needed.\n\nSee halfperm!\n\n\n\n\n\n"},{"title":"LinearAlgebra.Transpose","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.Transpose","category":"type","text":"Transpose\n\nLazy wrapper type for a transpose view of the underlying linear algebra object,\nusually an AbstractVector/AbstractMatrix.\nUsually, the Transpose constructor should not be called directly, use transpose\ninstead. To materialize the view use copy.\n\nThis type is intended for linear algebra usage - for general data manipulation see\npermutedims.\n\nExamples\n\njulia> A = [2 3; 0 0]\n2×2 Matrix{Int64}:\n 2  3\n 0  0\n\njulia> Transpose(A)\n2×2 transpose(::Matrix{Int64}) with eltype Int64:\n 2  0\n 3  0\n\n\n\n\n\n"},{"title":"LinearAlgebra.TransposeFactorization","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.TransposeFactorization","category":"type","text":"TransposeFactorization\n\nLazy wrapper type for the transpose of the underlying Factorization object. Usually, the\nTransposeFactorization constructor should not be called directly, use\ntranspose(:: Factorization) instead.\n\n\n\n\n\n"},{"title":"Base.adjoint","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.adjoint","category":"function","text":"A'\nadjoint(A)\n\nLazy adjoint (conjugate transposition). Note that adjoint is applied recursively to\nelements.\n\nFor number types, adjoint returns the complex conjugate, and therefore it is equivalent to\nthe identity function for real numbers.\n\nThis operation is intended for linear algebra usage - for general data manipulation see\npermutedims.\n\nExamples\n\njulia> A = [3+2im 9+2im; 0  0]\n2×2 Matrix{Complex{Int64}}:\n 3+2im  9+2im\n 0+0im  0+0im\n\njulia> B = A' # equivalently adjoint(A)\n2×2 adjoint(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:\n 3-2im  0+0im\n 9-2im  0+0im\n\njulia> B isa Adjoint\ntrue\n\njulia> adjoint(B) === A # the adjoint of an adjoint unwraps the parent\ntrue\n\njulia> Adjoint(B) # however, the constructor always wraps its argument\n2×2 adjoint(adjoint(::Matrix{Complex{Int64}})) with eltype Complex{Int64}:\n 3+2im  9+2im\n 0+0im  0+0im\n\njulia> B[1,2] = 4 + 5im; # modifying B will modify A automatically\n\njulia> A\n2×2 Matrix{Complex{Int64}}:\n 3+2im  9+2im\n 4-5im  0+0im\n\nFor real matrices, the adjoint operation is equivalent to a transpose.\n\njulia> A = reshape([x for x in 1:4], 2, 2)\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> A'\n2×2 adjoint(::Matrix{Int64}) with eltype Int64:\n 1  2\n 3  4\n\njulia> adjoint(A) == transpose(A)\ntrue\n\nThe adjoint of an AbstractVector is a row-vector:\n\njulia> x = [3, 4im]\n2-element Vector{Complex{Int64}}:\n 3 + 0im\n 0 + 4im\n\njulia> x'\n1×2 adjoint(::Vector{Complex{Int64}}) with eltype Complex{Int64}:\n 3+0im  0-4im\n\njulia> x'x # compute the dot product, equivalently x' * x\n25 + 0im\n\nFor a matrix of matrices, the individual blocks are recursively operated on:\n\njulia> A = reshape([x + im*x for x in 1:4], 2, 2)\n2×2 Matrix{Complex{Int64}}:\n 1+1im  3+3im\n 2+2im  4+4im\n\njulia> C = reshape([A, 2A, 3A, 4A], 2, 2)\n2×2 Matrix{Matrix{Complex{Int64}}}:\n [1+1im 3+3im; 2+2im 4+4im]  [3+3im 9+9im; 6+6im 12+12im]\n [2+2im 6+6im; 4+4im 8+8im]  [4+4im 12+12im; 8+8im 16+16im]\n\njulia> C'\n2×2 adjoint(::Matrix{Matrix{Complex{Int64}}}) with eltype Adjoint{Complex{Int64}, Matrix{Complex{Int64}}}:\n [1-1im 2-2im; 3-3im 4-4im]    [2-2im 4-4im; 6-6im 8-8im]\n [3-3im 6-6im; 9-9im 12-12im]  [4-4im 8-8im; 12-12im 16-16im]\n\n\n\n\n\nadjoint(F::Factorization)\n\nLazy adjoint of the factorization F. By default, returns an\nAdjointFactorization wrapper.\n\n\n\n\n\n"},{"title":"LinearAlgebra.adjoint!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.adjoint!","category":"function","text":"adjoint!(dest,src)\n\nConjugate transpose array src and store the result in the preallocated array dest, which\nshould have a size corresponding to (size(src,2),size(src,1)). No in-place transposition\nis supported and unexpected results will happen if src and dest have overlapping memory\nregions.\n\nExamples\n\njulia> A = [3+2im 9+2im; 8+7im  4+6im]\n2×2 Matrix{Complex{Int64}}:\n 3+2im  9+2im\n 8+7im  4+6im\n\njulia> B = zeros(Complex{Int64}, 2, 2)\n2×2 Matrix{Complex{Int64}}:\n 0+0im  0+0im\n 0+0im  0+0im\n\njulia> adjoint!(B, A);\n\njulia> B\n2×2 Matrix{Complex{Int64}}:\n 3-2im  8-7im\n 9-2im  4-6im\n\njulia> A\n2×2 Matrix{Complex{Int64}}:\n 3+2im  9+2im\n 8+7im  4+6im\n\n\n\n\n\nadjoint!(X::AbstractSparseMatrixCSC{Tv,Ti}, A::AbstractSparseMatrixCSC{Tv,Ti}) where {Tv,Ti}\n\nTranspose the matrix A and stores the adjoint of the elements in the matrix X.\nsize(X) must be equal to size(transpose(A)).\nNo additional memory is allocated other than resizing the rowval and nzval of X, if needed.\n\nSee halfperm!\n\n\n\n\n\n"},{"title":"LinearAlgebra.Adjoint","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.Adjoint","category":"type","text":"Adjoint\n\nLazy wrapper type for an adjoint view of the underlying linear algebra object,\nusually an AbstractVector/AbstractMatrix.\nUsually, the Adjoint constructor should not be called directly, use adjoint\ninstead. To materialize the view use copy.\n\nThis type is intended for linear algebra usage - for general data manipulation see\npermutedims.\n\nExamples\n\njulia> A = [3+2im 9+2im; 0 0]\n2×2 Matrix{Complex{Int64}}:\n 3+2im  9+2im\n 0+0im  0+0im\n\njulia> Adjoint(A)\n2×2 adjoint(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:\n 3-2im  0+0im\n 9-2im  0+0im\n\n\n\n\n\n"},{"title":"LinearAlgebra.AdjointFactorization","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.AdjointFactorization","category":"type","text":"AdjointFactorization\n\nLazy wrapper type for the adjoint of the underlying Factorization object. Usually, the\nAdjointFactorization constructor should not be called directly, use\nadjoint(:: Factorization) instead.\n\n\n\n\n\n"},{"title":"Base.copy","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#Base.copy-Tuple{Union{Adjoint, Transpose}}","category":"method","text":"copy(A::Transpose)\ncopy(A::Adjoint)\n\nEagerly evaluate the lazy matrix transpose/adjoint.\nNote that the transposition is applied recursively to elements.\n\nThis operation is intended for linear algebra usage - for general data manipulation see\npermutedims, which is non-recursive.\n\nExamples\n\njulia> A = [1 2im; -3im 4]\n2×2 Matrix{Complex{Int64}}:\n 1+0im  0+2im\n 0-3im  4+0im\n\njulia> T = transpose(A)\n2×2 transpose(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:\n 1+0im  0-3im\n 0+2im  4+0im\n\njulia> copy(T)\n2×2 Matrix{Complex{Int64}}:\n 1+0im  0-3im\n 0+2im  4+0im\n\n\n\n\n\n"},{"title":"LinearAlgebra.stride1","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.stride1","category":"function","text":"stride1(A) -> Int\n\nReturn the distance between successive array elements\nin dimension 1 in units of element size.\n\nExamples\n\njulia> A = [1,2,3,4]\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> LinearAlgebra.stride1(A)\n1\n\njulia> B = view(A, 2:2:4)\n2-element view(::Vector{Int64}, 2:2:4) with eltype Int64:\n 2\n 4\n\njulia> LinearAlgebra.stride1(B)\n2\n\n\n\n\n\n"},{"title":"LinearAlgebra.checksquare","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.checksquare","category":"function","text":"LinearAlgebra.checksquare(A)\n\nChecks whether a matrix is square, returning its common dimension if it is the case, or throwing a DimensionMismatch error otherwise.\nFor multiple arguments, return a vector.\n\nExamples\n\njulia> A = fill(1, (4,4)); B = fill(1, (5,5));\n\njulia> LinearAlgebra.checksquare(A, B)\n2-element Vector{Int64}:\n 4\n 5\n\n\n\n\n\n"},{"title":"LinearAlgebra.peakflops","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.peakflops","category":"function","text":"LinearAlgebra.peakflops(n::Integer=4096; eltype::DataType=Float64, ntrials::Integer=3, parallel::Bool=false)\n\npeakflops computes the peak flop rate of the computer by using double precision\ngemm!. By default, if no arguments are specified, it\nmultiplies two Float64 matrices of size n x n, where n = 4096. If the underlying BLAS is using\nmultiple threads, higher flop rates are realized. The number of BLAS threads can be set with\nBLAS.set_num_threads(n).\n\nIf the keyword argument eltype is provided, peakflops will construct matrices with elements\nof type eltype for calculating the peak flop rate.\n\nBy default, peakflops will use the best timing from 3 trials. If the ntrials keyword argument\nis provided, peakflops will use those many trials for picking the best timing.\n\nIf the keyword argument parallel is set to true, peakflops is run in parallel on all\nthe worker processors. The flop rate of the entire parallel computer is returned. When\nrunning in parallel, only 1 BLAS thread is used. The argument n still refers to the size\nof the problem that is solved on each processor.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1. In Julia 1.0 it is available from\nthe standard library InteractiveUtils.\n\n\n\n\n\n"},{"title":"LinearAlgebra.hermitianpart","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.hermitianpart","category":"function","text":"hermitianpart(A::AbstractMatrix, uplo::Symbol=:U) -> Hermitian\nhermitianpart(x::Number) -> Number\n\nReturn the Hermitian part of the square matrix A, defined as (A + A') / 2, as a\nHermitian matrix. For real matrices A, this is also known as the symmetric part\nof A; it is also sometimes called the \"operator real part\". The optional argument uplo controls the corresponding argument of the\nHermitian view. For real matrices, the latter is equivalent to a\nSymmetric view.\n\nSee also hermitianpart! for the corresponding in-place operation.\n\ncompat: Julia 1.10\nThis function requires Julia 1.10 or later.\n\n\n\n\n\n"},{"title":"LinearAlgebra.hermitianpart!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.hermitianpart!","category":"function","text":"hermitianpart!(A::AbstractMatrix, uplo::Symbol=:U) -> Hermitian\n\nOverwrite the square matrix A in-place with its Hermitian part (A + A') / 2, and return\nHermitian(A, uplo). For real matrices A, this is also known as the symmetric\npart of A.\n\nSee also hermitianpart for the corresponding out-of-place operation.\n\ncompat: Julia 1.10\nThis function requires Julia 1.10 or later.\n\n\n\n\n\n"},{"title":"LinearAlgebra.copy_adjoint!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.copy_adjoint!","category":"function","text":"copy_adjoint!(B::AbstractVecOrMat, ir_dest::AbstractRange{Int}, jr_dest::AbstractRange{Int},\n                A::AbstractVecOrMat, ir_src::AbstractRange{Int}, jr_src::AbstractRange{Int}) -> B\n\nEfficiently copy elements of matrix A to B with adjunction as follows:\n\nB[ir_dest, jr_dest] = adjoint(A)[jr_src, ir_src]\n\nThe elements B[ir_dest, jr_dest] are overwritten. Furthermore,\nthe index range parameters must satisfy length(ir_dest) == length(jr_src) and\nlength(jr_dest) == length(ir_src).\n\n\n\n\n\n"},{"title":"LinearAlgebra.copy_transpose!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.copy_transpose!","category":"function","text":"copy_transpose!(B::AbstractVecOrMat, ir_dest::AbstractRange{Int}, jr_dest::AbstractRange{Int},\n                A::AbstractVecOrMat, ir_src::AbstractRange{Int}, jr_src::AbstractRange{Int}) -> B\n\nEfficiently copy elements of matrix A to B with transposition as follows:\n\nB[ir_dest, jr_dest] = transpose(A)[jr_src, ir_src]\n\nThe elements B[ir_dest, jr_dest] are overwritten. Furthermore,\nthe index range parameters must satisfy length(ir_dest) == length(jr_src) and\nlength(jr_dest) == length(ir_src).\n\n\n\n\n\ncopy_transpose!(B::AbstractMatrix, ir_dest::AbstractUnitRange, jr_dest::AbstractUnitRange,\n                tM::AbstractChar,\n                M::AbstractVecOrMat, ir_src::AbstractUnitRange, jr_src::AbstractUnitRange) -> B\n\nEfficiently copy elements of matrix M to B conditioned on the character\nparameter tM as follows:\n\ntM Destination Source\n'N' B[ir_dest, jr_dest] transpose(M)[jr_src, ir_src]\n'T' B[ir_dest, jr_dest] M[jr_src, ir_src]\n'C' B[ir_dest, jr_dest] conj(M)[jr_src, ir_src]\n\nThe elements B[ir_dest, jr_dest] are overwritten. Furthermore, the index\nrange parameters must satisfy length(ir_dest) == length(jr_src) and\nlength(jr_dest) == length(ir_src).\n\nSee also copyto! and copy_adjoint!.\n\n\n\n\n\n"},{"title":"LinearAlgebra.uplo","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.uplo","category":"function","text":"LinearAlgebra.uplo(S::Union{Symmetric, Hermitian})::Symbol\n\nReturn a Symbol corresponding to the stored triangular half (:U or :L) in the matrix S,\nthat is, the elements are common between S and parent(S) for that triangular half.\n\nExample\n\njulia> S = Symmetric([1 2; 3 4], :U)\n2×2 Symmetric{Int64, Matrix{Int64}}:\n 1  2\n 2  4\n\njulia> LinearAlgebra.uplo(S)\n:U\n\njulia> H = Hermitian([1 2; 3 4], :L)\n2×2 Hermitian{Int64, Matrix{Int64}}:\n 1  3\n 3  4\n\njulia> LinearAlgebra.uplo(H)\n:L\n\n\n\n\n\nLinearAlgebra.uplo(S::Bidiagonal)::Symbol\n\nReturn a Symbol corresponding to whether the upper (:U) or lower (:L) off-diagonal band is stored.\n\n\n\n\n\n"},{"title":"LinearAlgebra.mul!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.mul!","category":"function","text":"mul!(Y, A, B) -> Y\n\nCalculates the matrix-matrix or matrix-vector product A B and stores the result in Y,\noverwriting the existing value of Y. Note that Y must not be aliased with either A or\nB.\n\nExamples\n\njulia> A = [1.0 2.0; 3.0 4.0]; B = [1.0 1.0; 1.0 1.0]; Y = similar(B);\n\njulia> mul!(Y, A, B) === Y\ntrue\n\njulia> Y\n2×2 Matrix{Float64}:\n 3.0  3.0\n 7.0  7.0\n\njulia> Y == A * B\ntrue\n\nImplementation\n\nFor custom matrix and vector types, it is recommended to implement\n5-argument mul! rather than implementing 3-argument mul! directly\nif possible.\n\n\n\n\n\nmul!(C, A, B, α, β) -> C\n\nCombined inplace matrix-matrix or matrix-vector multiply-add A B α + C β.\nThe result is stored in C by overwriting it.  Note that C must not be\naliased with either A or B.\n\ncompat: Julia 1.3\nFive-argument mul! requires at least Julia 1.3.\n\nExamples\n\njulia> A = [1.0 2.0; 3.0 4.0]; B = [1.0 1.0; 1.0 1.0]; C = [1.0 2.0; 3.0 4.0];\n\njulia> α, β = 100.0, 10.0;\n\njulia> mul!(C, A, B, α, β) === C\ntrue\n\njulia> C\n2×2 Matrix{Float64}:\n 310.0  320.0\n 730.0  740.0\n\njulia> C_original = [1.0 2.0; 3.0 4.0]; # A copy of the original value of C\n\njulia> C == A * B * α + C_original * β\ntrue\n\n\n\n\n\n"},{"title":"LinearAlgebra.lmul!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.lmul!","category":"function","text":"lmul!(a::Number, B::AbstractArray)\n\nScale an array B by a scalar a overwriting B in-place.  Use\nrmul! to multiply scalar from right.  The scaling operation\nrespects the semantics of the multiplication * between a\nand an element of B.  In particular, this also applies to\nmultiplication involving non-finite numbers such as NaN and ±Inf.\n\ncompat: Julia 1.1\nPrior to Julia 1.1, NaN and ±Inf entries in B were treated\ninconsistently.\n\nExamples\n\njulia> B = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> lmul!(2, B)\n2×2 Matrix{Int64}:\n 2  4\n 6  8\n\njulia> lmul!(0.0, [Inf])\n1-element Vector{Float64}:\n NaN\n\n\n\n\n\nlmul!(A, B)\n\nCalculate the matrix-matrix product AB, overwriting B, and return the result.\nHere, A must be of special matrix type, like, e.g., Diagonal,\nUpperTriangular or LowerTriangular, or of some orthogonal type,\nsee QR.\n\nExamples\n\njulia> B = [0 1; 1 0];\n\njulia> A = UpperTriangular([1 2; 0 3]);\n\njulia> lmul!(A, B);\n\njulia> B\n2×2 Matrix{Int64}:\n 2  1\n 3  0\n\njulia> B = [1.0 2.0; 3.0 4.0];\n\njulia> F = qr([0 1; -1 0]);\n\njulia> lmul!(F.Q, B)\n2×2 Matrix{Float64}:\n 3.0  4.0\n 1.0  2.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.rmul!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.rmul!","category":"function","text":"rmul!(A::AbstractArray, b::Number)\n\nScale an array A by a scalar b overwriting A in-place.  Use\nlmul! to multiply scalar from left.  The scaling operation\nrespects the semantics of the multiplication * between an\nelement of A and b.  In particular, this also applies to\nmultiplication involving non-finite numbers such as NaN and ±Inf.\n\ncompat: Julia 1.1\nPrior to Julia 1.1, NaN and ±Inf entries in A were treated\ninconsistently.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> rmul!(A, 2)\n2×2 Matrix{Int64}:\n 2  4\n 6  8\n\njulia> rmul!([NaN], 0.0)\n1-element Vector{Float64}:\n NaN\n\n\n\n\n\nrmul!(A, B)\n\nCalculate the matrix-matrix product AB, overwriting A, and return the result.\nHere, B must be of special matrix type, like, e.g., Diagonal,\nUpperTriangular or LowerTriangular, or of some orthogonal type,\nsee QR.\n\nExamples\n\njulia> A = [0 1; 1 0];\n\njulia> B = UpperTriangular([1 2; 0 3]);\n\njulia> rmul!(A, B);\n\njulia> A\n2×2 Matrix{Int64}:\n 0  3\n 1  2\n\njulia> A = [1.0 2.0; 3.0 4.0];\n\njulia> F = qr([0 1; -1 0]);\n\njulia> rmul!(A, F.Q)\n2×2 Matrix{Float64}:\n 2.0  1.0\n 4.0  3.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.ldiv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.ldiv!","category":"function","text":"ldiv!(Y, A, B) -> Y\n\nCompute A \\ B in-place and store the result in Y, returning the result.\n\nThe argument A should not be a matrix.  Rather, instead of matrices it should be a\nfactorization object (e.g. produced by factorize or cholesky).\nThe reason for this is that factorization itself is both expensive and typically allocates memory\n(although it can also be done in-place via, e.g., lu!),\nand performance-critical situations requiring ldiv! usually also require fine-grained\ncontrol over the factorization of A.\n\nnote: Note\nCertain structured matrix types, such as Diagonal and UpperTriangular, are permitted, as\nthese are already in a factorized form\n\nExamples\n\njulia> A = [1 2.2 4; 3.1 0.2 3; 4 1 2];\n\njulia> B = [1, 2.5, 3];\n\njulia> Y = similar(B); # use similar since there is no need to read from it\n\njulia> ldiv!(Y, qr(A), B); # you may also try qr!(A) to further reduce allocation\n\njulia> Y ≈ A \\ B\ntrue\n\n\n\n\n\nldiv!(A, B)\n\nCompute A \\ B in-place and overwriting B to store the result.\n\nThe argument A should not be a matrix.  Rather, instead of matrices it should be a\nfactorization object (e.g. produced by factorize or cholesky).\nThe reason for this is that factorization itself is both expensive and typically allocates memory\n(although it can also be done in-place via, e.g., lu!),\nand performance-critical situations requiring ldiv! usually also require fine-grained\ncontrol over the factorization of A.\n\nnote: Note\nCertain structured matrix types, such as Diagonal and UpperTriangular, are permitted, as\nthese are already in a factorized form\n\nExamples\n\njulia> A = [1 2.2 4; 3.1 0.2 3; 4 1 2];\n\njulia> B = [1, 2.5, 3];\n\njulia> B0 = copy(B); # a backup copy to facilitate testing\n\njulia> ldiv!(lu(A), B); # you may also try lu!(A) to further reduce allocation\n\njulia> B ≈ A \\ B0\ntrue\n\n\n\n\n\nldiv!(a::Number, B::AbstractArray)\n\nDivide each entry in an array B by a scalar a overwriting B\nin-place.  Use rdiv! to divide scalar from right.\n\nExamples\n\njulia> B = [1.0 2.0; 3.0 4.0]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> ldiv!(2.0, B)\n2×2 Matrix{Float64}:\n 0.5  1.0\n 1.5  2.0\n\n\n\n\n\nldiv!(A::Tridiagonal, B::AbstractVecOrMat) -> B\n\nCompute A \\ B in-place by Gaussian elimination with partial pivoting and store the result\nin B, returning the result. In the process, the diagonals of A are overwritten as well.\n\ncompat: Julia 1.11\nldiv! for Tridiagonal left-hand sides requires at least Julia 1.11.\n\n\n\n\n\nldiv!(F::SVD, B; atol::Real=0, rtol::Real=atol>0 ? 0 : n*ϵ)\n\nGiven the SVD F of an m times n matrix, multiply the first m rows of B in-place\nby the Moore-Penrose pseudoinverse, storing the result in the first n rows of B, returning B.\nThis is equivalent to a least-squares solution (for m ge n) or a minimum-norm solution (for m le n).\n\nSimilar to the pinv function, the solution can be regularized by truncating the SVD,\ndropping any singular values less than max(atol, rtol*σ₁) where σ₁ is the largest singular value.\nThe default relative tolerance is n*ϵ, where n is the size of the smallest dimension of M, and\nϵ is the eps of the element type of M.\n\ncompat: Julia 1.13\nThe atol and rtol arguments require Julia 1.13 or later.\n\n\n\n\n\n"},{"title":"LinearAlgebra.rdiv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.rdiv!","category":"function","text":"rdiv!(A, B)\n\nCompute A / B in-place and overwriting A to store the result.\n\nThe argument B should not be a matrix.  Rather, instead of matrices it should be a\nfactorization object (e.g. produced by factorize or cholesky).\nThe reason for this is that factorization itself is both expensive and typically allocates memory\n(although it can also be done in-place via, e.g., lu!),\nand performance-critical situations requiring rdiv! usually also require fine-grained\ncontrol over the factorization of B.\n\nnote: Note\nCertain structured matrix types, such as Diagonal and UpperTriangular, are permitted, as\nthese are already in a factorized form\n\n\n\n\n\nrdiv!(A::AbstractArray, b::Number)\n\nDivide each entry in an array A by a scalar b overwriting A\nin-place.  Use ldiv! to divide scalar from left.\n\nExamples\n\njulia> A = [1.0 2.0; 3.0 4.0]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> rdiv!(A, 2.0)\n2×2 Matrix{Float64}:\n 0.5  1.0\n 1.5  2.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS","category":"module","text":"Interface to BLAS subroutines.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.set_num_threads","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.set_num_threads","category":"function","text":"set_num_threads(n::Integer)\nset_num_threads(::Nothing)\n\nSet the number of threads the BLAS library should use equal to n::Integer.\n\nAlso accepts nothing, in which case julia tries to guess the default number of threads.\nPassing nothing is discouraged and mainly exists for historical reasons.\n\nnote: Note\nSome BLAS libraries, such as Apple Accelerate, cannot be configured to use a fixed number of threads.\nFor these backends, set_num_threads() is a no-op. See also get_num_threads.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.get_num_threads","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.get_num_threads","category":"function","text":"get_num_threads()\n\nGet the number of threads the BLAS library is using.\n\ncompat: Julia 1.6\nget_num_threads requires at least Julia 1.6.\n\nnote: Note\nSome BLAS libraries, such as Apple Accelerate, cannot be configured to use a fixed number of threads.\nFor these backends, get_num_threads() always returns 1. See also set_num_threads.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.rot!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.rot!","category":"function","text":"rot!(n, X, incx, Y, incy, c, s)\n\nOverwrite X with c*X + s*Y and Y with -conj(s)*X + c*Y for the first n elements of array X with stride incx and\nfirst n elements of array Y with stride incy. Returns X and Y.\n\ncompat: Julia 1.5\nrot! requires at least Julia 1.5.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.scal!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.scal!","category":"function","text":"scal!(n, a, X, incx)\nscal!(a, X)\n\nOverwrite X with a*X for the first n elements of array X with stride incx. Returns X.\n\nIf n and incx are not provided, length(X) and stride(X,1) are used.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.scal","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.scal","category":"function","text":"scal(n, a, X, incx)\nscal(a, X)\n\nReturn X scaled by a for the first n elements of array X with stride incx.\n\nIf n and incx are not provided, length(X) and stride(X,1) are used.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.blascopy!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.blascopy!","category":"function","text":"blascopy!(n, X, incx, Y, incy)\n\nCopy n elements of array X with stride incx to array Y with stride incy. Returns Y.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.dot","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.dot","category":"function","text":"dot(n, X, incx, Y, incy)\n\nDot product of two vectors consisting of n elements of array X with stride incx and\nn elements of array Y with stride incy.\n\nExamples\n\njulia> BLAS.dot(10, fill(1.0, 10), 1, fill(1.0, 20), 2)\n10.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.dotu","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.dotu","category":"function","text":"dotu(n, X, incx, Y, incy)\n\nDot function for two complex vectors consisting of n elements of array X\nwith stride incx and n elements of array Y with stride incy.\n\nExamples\n\njulia> BLAS.dotu(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)\n-10.0 + 10.0im\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.dotc","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.dotc","category":"function","text":"dotc(n, X, incx, U, incy)\n\nDot function for two complex vectors, consisting of n elements of array X\nwith stride incx and n elements of array U with stride incy,\nconjugating the first vector.\n\nExamples\n\njulia> BLAS.dotc(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)\n10.0 - 10.0im\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.nrm2","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.nrm2","category":"function","text":"nrm2(n, X, incx)\n\n2-norm of a vector consisting of n elements of array X with stride incx.\n\nExamples\n\njulia> BLAS.nrm2(4, fill(1.0, 8), 2)\n2.0\n\njulia> BLAS.nrm2(1, fill(1.0, 8), 2)\n1.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.asum","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.asum","category":"function","text":"asum(n, X, incx)\n\nSum of the magnitudes of the first n elements of array X with stride incx.\n\nFor a real array, the magnitude is the absolute value. For a complex array, the\nmagnitude is the sum of the absolute value of the real part and the absolute value\nof the imaginary part.\n\nExamples\n\njulia> BLAS.asum(5, fill(1.0im, 10), 2)\n5.0\n\njulia> BLAS.asum(2, fill(1.0im, 10), 5)\n2.0\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.iamax","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.iamax","category":"function","text":"iamax(n, dx, incx)\niamax(dx)\n\nFind the index of the element of dx with the maximum absolute value. n is the length of dx, and incx is the\nstride. If n and incx are not provided, they assume default values of n=length(dx) and incx=stride1(dx).\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.gemv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemv!","category":"function","text":"gemv!(tA, alpha, A, x, beta, y)\n\nUpdate the vector y as alpha*A*x + beta*y or alpha*A'x + beta*y\naccording to tA.\nalpha and beta are scalars. Return the updated y.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.gemv","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemv-NTuple{4, Any}","category":"method","text":"gemv(tA, alpha, A, x)\n\nReturn alpha*A*x or alpha*A'x according to tA.\nalpha is a scalar.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.gemv","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemv-Tuple{Any, Any, Any}","category":"method","text":"gemv(tA, A, x)\n\nReturn A*x or A'x according to tA.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.gbmv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gbmv!","category":"function","text":"gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)\n\nUpdate vector y as alpha*A*x + beta*y or alpha*A'*x + beta*y according to trans.\nThe matrix A is a general band matrix of dimension m by size(A,2) with kl\nsub-diagonals and ku super-diagonals. alpha and beta are scalars. Return the updated y.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.gbmv","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gbmv","category":"function","text":"gbmv(trans, m, kl, ku, alpha, A, x)\n\nReturn alpha*A*x or alpha*A'*x according to trans.\nThe matrix A is a general band matrix of dimension m by size(A,2) with kl sub-diagonals and ku\nsuper-diagonals, and alpha is a scalar.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.hemv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.hemv!","category":"function","text":"hemv!(ul, alpha, A, x, beta, y)\n\nUpdate the vector y as alpha*A*x + beta*y. A is assumed to be Hermitian.\nOnly the ul triangle of A is used.\nalpha and beta are scalars. Return the updated y.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.hemv","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.hemv-NTuple{4, Any}","category":"method","text":"hemv(ul, alpha, A, x)\n\nReturn alpha*A*x. A is assumed to be Hermitian.\nOnly the ul triangle of A is used.\nalpha is a scalar.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.hemv","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.hemv-Tuple{Any, Any, Any}","category":"method","text":"hemv(ul, A, x)\n\nReturn A*x. A is assumed to be Hermitian.\nOnly the ul triangle of A is used.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.hpmv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.hpmv!","category":"function","text":"hpmv!(uplo, α, AP, x, β, y)\n\nUpdate vector y as α*A*x + β*y, where A is a Hermitian matrix provided\nin packed format AP.\n\nWith uplo = 'U', the array AP must contain the upper triangular part of the\nHermitian matrix packed sequentially, column by column, so that AP[1]\ncontains A[1, 1], AP[2] and AP[3] contain A[1, 2] and A[2, 2]\nrespectively, and so on.\n\nWith uplo = 'L', the array AP must contain the lower triangular part of the\nHermitian matrix packed sequentially, column by column, so that AP[1]\ncontains A[1, 1], AP[2] and AP[3] contain A[2, 1] and A[3, 1]\nrespectively, and so on.\n\nThe scalar inputs α and β must be complex or real numbers.\n\nThe array inputs x, y and AP must all be of ComplexF32 or ComplexF64 type.\n\nReturn the updated y.\n\ncompat: Julia 1.5\nhpmv! requires at least Julia 1.5.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.symv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symv!","category":"function","text":"symv!(ul, alpha, A, x, beta, y)\n\nUpdate the vector y as alpha*A*x + beta*y. A is assumed to be symmetric.\nOnly the ul triangle of A is used.\nalpha and beta are scalars. Return the updated y.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.symv","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symv-NTuple{4, Any}","category":"method","text":"symv(ul, alpha, A, x)\n\nReturn alpha*A*x. A is assumed to be symmetric.\nOnly the ul triangle of A is used.\nalpha is a scalar.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.symv","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symv-Tuple{Any, Any, Any}","category":"method","text":"symv(ul, A, x)\n\nReturn A*x. A is assumed to be symmetric.\nOnly the ul triangle of A is used.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.sbmv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.sbmv!","category":"function","text":"sbmv!(uplo, k, alpha, A, x, beta, y)\n\nUpdate vector y as alpha*A*x + beta*y where A is a symmetric band matrix of order\nsize(A,2) with k super-diagonals stored in the argument A. The storage layout for A\nis described the reference BLAS module, level-2 BLAS at\nhttps://www.netlib.org/lapack/explore-html/.\nOnly the uplo triangle of A is used.\n\nReturn the updated y.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.sbmv","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.sbmv-NTuple{5, Any}","category":"method","text":"sbmv(uplo, k, alpha, A, x)\n\nReturn alpha*A*x where A is a symmetric band matrix of order size(A,2) with k\nsuper-diagonals stored in the argument A.\nOnly the uplo triangle of A is used.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.sbmv","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.sbmv-NTuple{4, Any}","category":"method","text":"sbmv(uplo, k, A, x)\n\nReturn A*x where A is a symmetric band matrix of order size(A,2) with k\nsuper-diagonals stored in the argument A.\nOnly the uplo triangle of A is used.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.spmv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.spmv!","category":"function","text":"spmv!(uplo, α, AP, x, β, y)\n\nUpdate vector y as α*A*x + β*y, where A is a symmetric matrix provided\nin packed format AP.\n\nWith uplo = 'U', the array AP must contain the upper triangular part of the\nsymmetric matrix packed sequentially, column by column, so that AP[1]\ncontains A[1, 1], AP[2] and AP[3] contain A[1, 2] and A[2, 2]\nrespectively, and so on.\n\nWith uplo = 'L', the array AP must contain the lower triangular part of the\nsymmetric matrix packed sequentially, column by column, so that AP[1]\ncontains A[1, 1], AP[2] and AP[3] contain A[2, 1] and A[3, 1]\nrespectively, and so on.\n\nThe scalar inputs α and β must be real.\n\nThe array inputs x, y and AP must all be of Float32 or Float64 type.\n\nReturn the updated y.\n\ncompat: Julia 1.5\nspmv! requires at least Julia 1.5.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.trmv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trmv!","category":"function","text":"trmv!(ul, tA, dA, A, b)\n\nReturn op(A)*b, where op is determined by tA.\nOnly the ul triangle of A is used.\ndA determines if the diagonal values are read or\nare assumed to be all ones.\nThe multiplication occurs in-place on b.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.trmv","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trmv","category":"function","text":"trmv(ul, tA, dA, A, b)\n\nReturn op(A)*b, where op is determined by tA.\nOnly the ul triangle of A is used.\ndA determines if the diagonal values are read or\nare assumed to be all ones.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.trsv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trsv!","category":"function","text":"trsv!(ul, tA, dA, A, b)\n\nOverwrite b with the solution to A*x = b or one of the other two variants determined by\ntA and ul.\ndA determines if the diagonal values are read or\nare assumed to be all ones.\nReturn the updated b.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.trsv","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trsv","category":"function","text":"trsv(ul, tA, dA, A, b)\n\nReturn the solution to A*x = b or one of the other two variants determined by\ntA and ul.\ndA determines if the diagonal values are read or\nare assumed to be all ones.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.ger!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.ger!","category":"function","text":"ger!(alpha, x, y, A)\n\nRank-1 update of the matrix A with vectors x and y as alpha*x*y' + A.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.geru!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.geru!","category":"function","text":"geru!(alpha, x, y, A)\n\nRank-1 update of the matrix A with vectors x and y as alpha*x*transpose(y) + A.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.her!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.her!","category":"function","text":"her!(uplo, alpha, x, A)\n\nMethods for complex arrays only. Rank-1 update of the Hermitian matrix A with vector x\nas alpha*x*x' + A.\nuplo controls which triangle of A is updated. Returns A.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.syr!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.syr!","category":"function","text":"syr!(uplo, alpha, x, A)\n\nRank-1 update of the symmetric matrix A with vector x as alpha*x*transpose(x) + A.\nuplo controls which triangle of A is updated. Returns A.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.spr!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.spr!","category":"function","text":"spr!(uplo, α, x, AP)\n\nUpdate matrix A as A+α*x*x', where A is a symmetric matrix provided\nin packed format AP and x is a vector.\n\nWith uplo = 'U', the array AP must contain the upper triangular part of the\nsymmetric matrix packed sequentially, column by column, so that AP[1]\ncontains A[1, 1], AP[2] and AP[3] contain A[1, 2] and A[2, 2]\nrespectively, and so on.\n\nWith uplo = 'L', the array AP must contain the lower triangular part of the\nsymmetric matrix packed sequentially, column by column, so that AP[1]\ncontains A[1, 1], AP[2] and AP[3] contain A[2, 1] and A[3, 1]\nrespectively, and so on.\n\nThe scalar input α must be real.\n\nThe array inputs x and AP must all be of Float32 or Float64 type.\nReturn the updated AP.\n\ncompat: Julia 1.8\nspr! requires at least Julia 1.8.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.gemmt!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemmt!","category":"function","text":"gemmt!(uplo, tA, tB, alpha, A, B, beta, C)\n\nUpdate the lower or upper triangular part specified by uplo of C as\nalpha*A*B + beta*C or the other variants according to tA and tB.\nReturn the updated C.\n\ncompat: Julia 1.11\ngemmt! requires at least Julia 1.11.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.gemmt","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemmt-NTuple{6, Any}","category":"method","text":"gemmt(uplo, tA, tB, alpha, A, B)\n\nReturn the lower or upper triangular part specified by uplo of A*B or the other three variants according to tA and tB.\n\ncompat: Julia 1.11\ngemmt requires at least Julia 1.11.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.gemmt","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemmt-NTuple{5, Any}","category":"method","text":"gemmt(uplo, tA, tB, A, B)\n\nReturn the lower or upper triangular part specified by uplo of A*B or the other three variants according to tA and tB.\n\ncompat: Julia 1.11\ngemmt requires at least Julia 1.11.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.gemm!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemm!","category":"function","text":"gemm!(tA, tB, alpha, A, B, beta, C)\n\nUpdate C as alpha*A*B + beta*C or the other three variants according to\ntA and tB. Return the updated C.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.gemm","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemm-NTuple{5, Any}","category":"method","text":"gemm(tA, tB, alpha, A, B)\n\nReturn alpha*A*B or the other three variants according to tA and tB.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.gemm","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemm-NTuple{4, Any}","category":"method","text":"gemm(tA, tB, A, B)\n\nReturn A*B or the other three variants according to tA and tB.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.symm!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symm!","category":"function","text":"symm!(side, ul, alpha, A, B, beta, C)\n\nUpdate C as alpha*A*B + beta*C or alpha*B*A + beta*C according to side.\nA is assumed to be symmetric. Only the ul triangle of\nA is used. Return the updated C.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.symm","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symm-NTuple{5, Any}","category":"method","text":"symm(side, ul, alpha, A, B)\n\nReturn alpha*A*B or alpha*B*A according to side.\nA is assumed to be symmetric. Only\nthe ul triangle of A is used.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.symm","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symm-NTuple{4, Any}","category":"method","text":"symm(side, ul, A, B)\n\nReturn A*B or B*A according to side.\nA is assumed to be symmetric. Only the ul\ntriangle of A is used.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.hemm!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.hemm!","category":"function","text":"hemm!(side, ul, alpha, A, B, beta, C)\n\nUpdate C as alpha*A*B + beta*C or alpha*B*A + beta*C according to\nside. A is assumed to be Hermitian. Only the\nul triangle of A is used. Return the updated C.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.hemm","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.hemm-NTuple{5, Any}","category":"method","text":"hemm(side, ul, alpha, A, B)\n\nReturn alpha*A*B or alpha*B*A according to side.\nA is assumed to be Hermitian. Only the ul triangle\nof A is used.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.hemm","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.hemm-NTuple{4, Any}","category":"method","text":"hemm(side, ul, A, B)\n\nReturn A*B or B*A according to side. A is assumed\nto be Hermitian. Only the ul triangle of A is used.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.syrk!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.syrk!","category":"function","text":"syrk!(uplo, trans, alpha, A, beta, C)\n\nRank-k update of the symmetric matrix C as alpha*A*transpose(A) + beta*C or\nalpha*transpose(A)*A + beta*C according to trans.\nOnly the uplo triangle of C is used. Return C.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.syrk","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.syrk","category":"function","text":"syrk(uplo, trans, alpha, A)\n\nReturn either the upper triangle or the lower triangle of A,\naccording to uplo,\nof alpha*A*transpose(A) or alpha*transpose(A)*A,\naccording to trans.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.herk!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.herk!","category":"function","text":"herk!(uplo, trans, alpha, A, beta, C)\n\nMethods for complex arrays only. Rank-k update of the Hermitian matrix C as\nalpha*A*A' + beta*C or alpha*A'*A + beta*C according to trans.\nOnly the uplo triangle of C is updated. Returns C.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.herk","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.herk","category":"function","text":"herk(uplo, trans, alpha, A)\n\nMethods for complex arrays only. Returns the uplo\ntriangle of alpha*A*A' or alpha*A'*A, according to trans.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.syr2k!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.syr2k!","category":"function","text":"syr2k!(uplo, trans, alpha, A, B, beta, C)\n\nRank-2k update of the symmetric matrix C as\nalpha*A*transpose(B) + alpha*B*transpose(A) + beta*C or\nalpha*transpose(A)*B + alpha*transpose(B)*A + beta*C\naccording to trans.\nOnly the uplo triangle of C is used. Returns C.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.syr2k","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.syr2k","category":"function","text":"syr2k(uplo, trans, alpha, A, B)\n\nReturns the uplo triangle of\nalpha*A*transpose(B) + alpha*B*transpose(A) or\nalpha*transpose(A)*B + alpha*transpose(B)*A,\naccording to trans.\n\n\n\n\n\nsyr2k(uplo, trans, A, B)\n\nReturn the uplo triangle of A*transpose(B) + B*transpose(A)\nor transpose(A)*B + transpose(B)*A, according to trans.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.her2k!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.her2k!","category":"function","text":"her2k!(uplo, trans, alpha, A, B, beta, C)\n\nRank-2k update of the Hermitian matrix C as\nalpha*A*B' + alpha'*B*A' + beta*C or alpha*A'*B + alpha'*B'*A + beta*C\naccording to trans. The scalar beta has to be real.\nOnly the uplo triangle of C is used. Return C.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.her2k","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.her2k","category":"function","text":"her2k(uplo, trans, alpha, A, B)\n\nReturn the uplo triangle of alpha*A*B' + alpha'*B*A'\nor alpha*A'*B + alpha'*B'*A, according to trans.\n\n\n\n\n\nher2k(uplo, trans, A, B)\n\nReturn the uplo triangle of A*B' + B*A'\nor A'*B + B'*A, according to trans.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.trmm!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trmm!","category":"function","text":"trmm!(side, ul, tA, dA, alpha, A, B)\n\nUpdate B as alpha*A*B or one of the other three variants determined by\nside and tA.\nOnly the ul triangle of A is used.\ndA determines if the diagonal values are read or\nare assumed to be all ones.\nReturn the updated B.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.trmm","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trmm","category":"function","text":"trmm(side, ul, tA, dA, alpha, A, B)\n\nReturn alpha*A*B or one of the other three variants determined by\nside and tA.\nOnly the ul triangle of A is used.\ndA determines if the diagonal values are read or\nare assumed to be all ones.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.trsm!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trsm!","category":"function","text":"trsm!(side, ul, tA, dA, alpha, A, B)\n\nOverwrite B with the solution to A*X = alpha*B or one of the other three variants\ndetermined by side and tA.\nOnly the ul triangle of A is used.\ndA determines if the diagonal values are read or\nare assumed to be all ones.\nReturns the updated B.\n\n\n\n\n\n"},{"title":"LinearAlgebra.BLAS.trsm","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trsm","category":"function","text":"trsm(side, ul, tA, dA, alpha, A, B)\n\nReturn the solution to A*X = alpha*B or one of the other three variants determined by\ndetermined by side and tA.\nOnly the ul triangle of A is used.\ndA determines if the diagonal values are read or\nare assumed to be all ones.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK","category":"module","text":"Interfaces to LAPACK subroutines.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gbtrf!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gbtrf!","category":"function","text":"gbtrf!(kl, ku, m, AB) -> (AB, ipiv)\n\nCompute the LU factorization of a banded matrix AB. kl is the first\nsubdiagonal containing a nonzero band, ku is the last superdiagonal\ncontaining one, and m is the first dimension of the matrix AB. Returns\nthe LU factorization in-place and ipiv, the vector of pivots used.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gbtrs!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gbtrs!","category":"function","text":"gbtrs!(trans, kl, ku, m, AB, ipiv, B)\n\nSolve the equation AB * X = B. trans determines the orientation of AB. It may\nbe N (no transpose), T (transpose), or C (conjugate transpose). kl is the\nfirst subdiagonal containing a nonzero band, ku is the last superdiagonal\ncontaining one, and m is the first dimension of the matrix AB. ipiv is the vector\nof pivots returned from gbtrf!. Returns the vector or matrix X, overwriting B in-place.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gebal!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gebal!","category":"function","text":"gebal!(job, A) -> (ilo, ihi, scale)\n\nBalance the matrix A before computing its eigensystem or Schur factorization.\njob can be one of N (A will not be permuted or scaled), P (A will only\nbe permuted), S (A will only be scaled), or B (A will be both permuted\nand scaled). Modifies A in-place and returns ilo, ihi, and scale. If\npermuting was turned on, A[i,j] = 0 if j > i and 1 < j < ilo or j > ihi.\nscale contains information about the scaling/permutations performed.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gebak!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gebak!","category":"function","text":"gebak!(job, side, ilo, ihi, scale, V)\n\nTransform the eigenvectors V of a matrix balanced using gebal! to\nthe unscaled/unpermuted eigenvectors of the original matrix. Modifies V\nin-place. side can be L (left eigenvectors are transformed) or R\n(right eigenvectors are transformed).\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gebrd!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gebrd!","category":"function","text":"gebrd!(A) -> (A, d, e, tauq, taup)\n\nReduce A in-place to bidiagonal form A = QBP'. Returns A, containing the\nbidiagonal matrix B; d, containing the diagonal elements of B; e,\ncontaining the off-diagonal elements of B; tauq, containing the\nelementary reflectors representing Q; and taup, containing the\nelementary reflectors representing P.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gelqf!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gelqf!","category":"function","text":"gelqf!(A, tau)\n\nCompute the LQ factorization of A, A = LQ. tau contains scalars\nwhich parameterize the elementary reflectors of the factorization. tau\nmust have length greater than or equal to the smallest dimension of A.\n\nReturns\nA and tau modified in-place.\n\n\n\n\n\ngelqf!(A) -> (A, tau)\n\nCompute the LQ factorization of A, A = LQ.\n\nReturns A, modified in-place, and tau, which contains scalars\nwhich parameterize the elementary reflectors of the factorization.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.geqlf!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geqlf!","category":"function","text":"geqlf!(A, tau)\n\nCompute the QL factorization of A, A = QL. tau contains scalars\nwhich parameterize the elementary reflectors of the factorization. tau\nmust have length greater than or equal to the smallest dimension of A.\n\nReturns A and tau modified in-place.\n\n\n\n\n\ngeqlf!(A) -> (A, tau)\n\nCompute the QL factorization of A, A = QL.\n\nReturns A, modified in-place, and tau, which contains scalars\nwhich parameterize the elementary reflectors of the factorization.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.geqrf!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geqrf!","category":"function","text":"geqrf!(A, tau)\n\nCompute the QR factorization of A, A = QR. tau contains scalars\nwhich parameterize the elementary reflectors of the factorization. tau\nmust have length greater than or equal to the smallest dimension of A.\n\nReturns A and tau modified in-place.\n\n\n\n\n\ngeqrf!(A) -> (A, tau)\n\nCompute the QR factorization of A, A = QR.\n\nReturns A, modified in-place, and tau, which contains scalars\nwhich parameterize the elementary reflectors of the factorization.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.geqp3!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geqp3!","category":"function","text":"geqp3!(A, [jpvt, tau]) -> (A, tau, jpvt)\n\nCompute the pivoted QR factorization of A, AP = QR using BLAS level 3.\nP is a pivoting matrix, represented by jpvt. tau stores the elementary\nreflectors. The arguments jpvt and tau are optional and allow\nfor passing preallocated arrays. When passed, jpvt must have length greater\nthan or equal to n if A is an (m x n) matrix and tau must have length\ngreater than or equal to the smallest dimension of A. On entry, if jpvt[j]\ndoes not equal zero then the jth column of A is permuted to the front of\nAP.\n\nA, jpvt, and tau are modified in-place.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gerqf!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gerqf!","category":"function","text":"gerqf!(A, tau)\n\nCompute the RQ factorization of A, A = RQ. tau contains scalars\nwhich parameterize the elementary reflectors of the factorization. tau\nmust have length greater than or equal to the smallest dimension of A.\n\nReturns A and tau modified in-place.\n\n\n\n\n\ngerqf!(A) -> (A, tau)\n\nCompute the RQ factorization of A, A = RQ.\n\nReturns A, modified in-place, and tau, which contains scalars\nwhich parameterize the elementary reflectors of the factorization.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.geqrt!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geqrt!","category":"function","text":"geqrt!(A, T)\n\nCompute the blocked QR factorization of A, A = QR. T contains upper\ntriangular block reflectors which parameterize the elementary reflectors of\nthe factorization. The first dimension of T sets the block size and it must\nbe between 1 and n. The second dimension of T must equal the smallest\ndimension of A.\n\nReturns A and T modified in-place.\n\n\n\n\n\ngeqrt!(A, nb) -> (A, T)\n\nCompute the blocked QR factorization of A, A = QR. nb sets the block size\nand it must be between 1 and n, the second dimension of A.\n\nReturns A, modified in-place, and T, which contains upper\ntriangular block reflectors which parameterize the elementary reflectors of\nthe factorization.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.geqrt3!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geqrt3!","category":"function","text":"geqrt3!(A, T)\n\nRecursively computes the blocked QR factorization of A, A = QR. T\ncontains upper triangular block reflectors which parameterize the\nelementary reflectors of the factorization.  The first dimension of T sets the\nblock size and it must be between 1 and n. The second dimension of T must\nequal the smallest dimension of A.\n\nReturns A and T modified in-place.\n\n\n\n\n\ngeqrt3!(A) -> (A, T)\n\nRecursively computes the blocked QR factorization of A, A = QR.\n\nReturns A, modified in-place, and T, which contains upper triangular block\nreflectors which parameterize the elementary reflectors of the factorization.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.getrf!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.getrf!","category":"function","text":"getrf!(A, ipiv) -> (A, ipiv, info)\n\nCompute the pivoted LU factorization of A, A = LU. ipiv contains the pivoting\ninformation and info a code which indicates success (info = 0), a singular value\nin U (info = i, in which case U[i,i] is singular), or an error code (info < 0).\n\n\n\n\n\ngetrf!(A) -> (A, ipiv, info)\n\nCompute the pivoted LU factorization of A, A = LU.\n\nReturns A, modified in-place, ipiv, the pivoting information, and an info\ncode which indicates success (info = 0), a singular value in U\n(info = i, in which case U[i,i] is singular), or an error code (info < 0).\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.tzrzf!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.tzrzf!","category":"function","text":"tzrzf!(A) -> (A, tau)\n\nTransforms the upper trapezoidal matrix A to upper triangular form in-place.\nReturns A and tau, the scalar parameters for the elementary reflectors\nof the transformation.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.ormrz!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ormrz!","category":"function","text":"ormrz!(side, trans, A, tau, C)\n\nMultiplies the matrix C by Q from the transformation supplied by\ntzrzf!. Depending on side or trans the multiplication can be\nleft-sided (side = L, Q*C) or right-sided (side = R, C*Q) and Q\ncan be unmodified (trans = N), transposed (trans = T), or conjugate\ntransposed (trans = C). Returns matrix C which is modified in-place\nwith the result of the multiplication.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gels!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gels!","category":"function","text":"gels!(trans, A, B) -> (F, B, ssr)\n\nSolves the linear equation A * X = B, transpose(A) * X = B, or adjoint(A) * X = B using\na QR or LQ factorization. Modifies the matrix/vector B in place with the\nsolution. A is overwritten with its QR or LQ factorization. trans\nmay be one of N (no modification), T (transpose), or C (conjugate\ntranspose). gels! searches for the minimum norm/least squares solution.\nA may be under or over determined. The solution is returned in B.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gesv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gesv!","category":"function","text":"gesv!(A, B) -> (B, A, ipiv)\n\nSolves the linear equation A * X = B where A is a square matrix using\nthe LU factorization of A. A is overwritten with its LU\nfactorization and B is overwritten with the solution X. ipiv contains the\npivoting information for the LU factorization of A.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.getrs!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.getrs!","category":"function","text":"getrs!(trans, A, ipiv, B)\n\nSolves the linear equation A * X = B, transpose(A) * X = B, or adjoint(A) * X = B for\nsquare A. Modifies the matrix/vector B in place with the solution. A\nis the LU factorization from getrf!, with ipiv the pivoting\ninformation. trans may be one of N (no modification), T (transpose),\nor C (conjugate transpose).\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.getri!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.getri!","category":"function","text":"getri!(A, ipiv)\n\nComputes the inverse of A, using its LU factorization found by\ngetrf!. ipiv is the pivot information output and A\ncontains the LU factorization of getrf!. A is overwritten with\nits inverse.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gesvx!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gesvx!","category":"function","text":"gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B) -> (X, equed, R, C, B, rcond, ferr, berr, work)\n\nSolves the linear equation A * X = B (trans = N), transpose(A) * X = B\n(trans = T), or adjoint(A) * X = B (trans = C) using the LU factorization\nof A. fact may be E, in which case A will be equilibrated and copied\nto AF; F, in which case AF and ipiv from a previous LU factorization\nare inputs; or N, in which case A will be copied to AF and then\nfactored. If fact = F, equed may be N, meaning A has not been\nequilibrated; R, meaning A was multiplied by Diagonal(R) from the left;\nC, meaning A was multiplied by Diagonal(C) from the right; or B, meaning\nA was multiplied by Diagonal(R) from the left and Diagonal(C) from the right.\nIf fact = F and equed = R or B the elements of R must all be positive.\nIf fact = F and equed = C or B the elements of C must all be positive.\n\nReturns the solution X; equed, which is an output if fact is not N,\nand describes the equilibration that was performed; R, the row equilibration\ndiagonal; C, the column equilibration diagonal; B, which may be overwritten\nwith its equilibrated form Diagonal(R)*B (if trans = N and equed = R,B) or\nDiagonal(C)*B (if trans = T,C and equed = C,B); rcond, the reciprocal\ncondition number of A after equilbrating; ferr, the forward error bound for\neach solution vector in X; berr, the forward error bound for each solution\nvector in X; and work, the reciprocal pivot growth factor.\n\n\n\n\n\ngesvx!(A, B)\n\nThe no-equilibration, no-transpose simplification of gesvx!.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gelsd!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gelsd!","category":"function","text":"gelsd!(A, B, rcond) -> (B, rnk)\n\nComputes the least norm solution of A * X = B by finding the SVD\nfactorization of A, then dividing-and-conquering the problem. B\nis overwritten with the solution X. Singular values below rcond\nwill be treated as zero. Returns the solution in B and the effective rank\nof A in rnk.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gelsy!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gelsy!","category":"function","text":"gelsy!(A, B, rcond) -> (B, rnk)\n\nComputes the least norm solution of A * X = B by finding the full QR\nfactorization of A, then dividing-and-conquering the problem. B\nis overwritten with the solution X. Singular values below rcond\nwill be treated as zero. Returns the solution in B and the effective rank\nof A in rnk.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gglse!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gglse!","category":"function","text":"gglse!(A, c, B, d) -> (X,res)\n\nSolves the equation A * x = c where x is subject to the equality\nconstraint B * x = d. Uses the formula ||c - A*x||^2 = 0 to solve.\nReturns X and the residual sum-of-squares.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.geev!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geev!","category":"function","text":"geev!(jobvl, jobvr, A) -> (W, VL, VR)\n\nFinds the eigensystem of A. If jobvl = N, the left eigenvectors of\nA aren't computed. If jobvr = N, the right eigenvectors of A\naren't computed. If jobvl = V or jobvr = V, the corresponding\neigenvectors are computed. Returns the eigenvalues in W, the right\neigenvectors in VR, and the left eigenvectors in VL.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gesdd!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gesdd!","category":"function","text":"gesdd!(job, A) -> (U, S, VT)\n\nFinds the singular value decomposition of A, A = U * S * V',\nusing a divide and conquer approach. If job = A, all the columns of U and\nthe rows of V' are computed. If job = N, no columns of U or rows of V'\nare computed. If job = O, A is overwritten with the columns of (thin) U\nand the rows of (thin) V'. If job = S, the columns of (thin) U and the\nrows of (thin) V' are computed and returned separately.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gesvd!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gesvd!","category":"function","text":"gesvd!(jobu, jobvt, A) -> (U, S, VT)\n\nFinds the singular value decomposition of A, A = U * S * V'.\nIf jobu = A, all the columns of U are computed. If jobvt = A all the rows\nof V' are computed. If jobu = N, no columns of U are computed. If\njobvt = N no rows of V' are computed. If jobu = O, A is overwritten with\nthe columns of (thin) U. If jobvt = O, A is overwritten with the rows\nof (thin) V'. If jobu = S, the columns of (thin) U are computed\nand returned separately. If jobvt = S the rows of (thin) V' are\ncomputed and returned separately. jobu and jobvt can't both be O.\n\nReturns U, S, and Vt, where S are the singular values of A.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.ggsvd!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ggsvd!","category":"function","text":"ggsvd!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)\n\nFinds the generalized singular value decomposition of A and B, U'*A*Q = D1*R\nand V'*B*Q = D2*R. D1 has alpha on its diagonal and D2 has beta on its\ndiagonal. If jobu = U, the orthogonal/unitary matrix U is computed. If\njobv = V the orthogonal/unitary matrix V is computed. If jobq = Q,\nthe orthogonal/unitary matrix Q is computed. If jobu, jobv or jobq is\nN, that matrix is not computed. This function is only available in LAPACK\nversions prior to 3.6.0.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.ggsvd3!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ggsvd3!","category":"function","text":"ggsvd3!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)\n\nFinds the generalized singular value decomposition of A and B, U'*A*Q = D1*R\nand V'*B*Q = D2*R. D1 has alpha on its diagonal and D2 has beta on its\ndiagonal. If jobu = U, the orthogonal/unitary matrix U is computed. If\njobv = V the orthogonal/unitary matrix V is computed. If jobq = Q,\nthe orthogonal/unitary matrix Q is computed. If jobu, jobv, or jobq is\nN, that matrix is not computed. This function requires LAPACK 3.6.0.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.geevx!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geevx!","category":"function","text":"geevx!(balanc, jobvl, jobvr, sense, A) -> (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)\n\nFinds the eigensystem of A with matrix balancing. If jobvl = N, the\nleft eigenvectors of A aren't computed. If jobvr = N, the right\neigenvectors of A aren't computed. If jobvl = V or jobvr = V, the\ncorresponding eigenvectors are computed. If balanc = N, no balancing is\nperformed. If balanc = P, A is permuted but not scaled. If\nbalanc = S, A is scaled but not permuted. If balanc = B, A is\npermuted and scaled. If sense = N, no reciprocal condition numbers are\ncomputed. If sense = E, reciprocal condition numbers are computed for\nthe eigenvalues only. If sense = V, reciprocal condition numbers are\ncomputed for the right eigenvectors only. If sense = B, reciprocal\ncondition numbers are computed for the right eigenvectors and the\neigenvectors. If sense = E,B, the right and left eigenvectors must be\ncomputed.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.ggev!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ggev!","category":"function","text":"ggev!(jobvl, jobvr, A, B) -> (alpha, beta, vl, vr)\n\nFinds the generalized eigendecomposition of A and B. If jobvl = N,\nthe left eigenvectors aren't computed. If jobvr = N, the right\neigenvectors aren't computed. If jobvl = V or jobvr = V, the\ncorresponding eigenvectors are computed.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.ggev3!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ggev3!","category":"function","text":"ggev3!(jobvl, jobvr, A, B) -> (alpha, beta, vl, vr)\n\nFinds the generalized eigendecomposition of A and B using a blocked\nalgorithm. If jobvl = N, the left eigenvectors aren't computed. If\njobvr = N, the right eigenvectors aren't computed. If jobvl = V or\njobvr = V, the corresponding eigenvectors are computed.  This function\nrequires LAPACK 3.6.0.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gtsv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gtsv!","category":"function","text":"gtsv!(dl, d, du, B)\n\nSolves the equation A * X = B where A is a tridiagonal matrix with\ndl on the subdiagonal, d on the diagonal, and du on the\nsuperdiagonal.\n\nOverwrites B with the solution X and returns it.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gttrf!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gttrf!","category":"function","text":"gttrf!(dl, d, du) -> (dl, d, du, du2, ipiv)\n\nFinds the LU factorization of a tridiagonal matrix with dl on the\nsubdiagonal, d on the diagonal, and du on the superdiagonal.\n\nModifies dl, d, and du in-place and returns them and the second\nsuperdiagonal du2 and the pivoting vector ipiv.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gttrs!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gttrs!","category":"function","text":"gttrs!(trans, dl, d, du, du2, ipiv, B)\n\nSolves the equation A * X = B (trans = N), transpose(A) * X = B (trans = T),\nor adjoint(A) * X = B (trans = C) using the LU factorization computed by\ngttrf!. B is overwritten with the solution X.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.orglq!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.orglq!","category":"function","text":"orglq!(A, tau, k = length(tau))\n\nExplicitly finds the matrix Q of a LQ factorization after calling\ngelqf! on A. Uses the output of gelqf!. A is overwritten by Q.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.orgqr!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.orgqr!","category":"function","text":"orgqr!(A, tau, k = length(tau))\n\nExplicitly finds the matrix Q of a QR factorization after calling\ngeqrf! on A. Uses the output of geqrf!. A is overwritten by Q.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.orgql!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.orgql!","category":"function","text":"orgql!(A, tau, k = length(tau))\n\nExplicitly finds the matrix Q of a QL factorization after calling\ngeqlf! on A. Uses the output of geqlf!. A is overwritten by Q.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.orgrq!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.orgrq!","category":"function","text":"orgrq!(A, tau, k = length(tau))\n\nExplicitly finds the matrix Q of a RQ factorization after calling\ngerqf! on A. Uses the output of gerqf!. A is overwritten by Q.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.ormlq!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ormlq!","category":"function","text":"ormlq!(side, trans, A, tau, C)\n\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C\n(trans = C) for side = L or the equivalent right-sided multiplication\nfor side = R using Q from a LQ factorization of A computed using\ngelqf!. C is overwritten.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.ormqr!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ormqr!","category":"function","text":"ormqr!(side, trans, A, tau, C)\n\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C\n(trans = C) for side = L or the equivalent right-sided multiplication\nfor side = R using Q from a QR factorization of A computed using\ngeqrf!. C is overwritten.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.ormql!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ormql!","category":"function","text":"ormql!(side, trans, A, tau, C)\n\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C\n(trans = C) for side = L or the equivalent right-sided multiplication\nfor side = R using Q from a QL factorization of A computed using\ngeqlf!. C is overwritten.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.ormrq!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ormrq!","category":"function","text":"ormrq!(side, trans, A, tau, C)\n\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C\n(trans = C) for side = L or the equivalent right-sided multiplication\nfor side = R using Q from a RQ factorization of A computed using\ngerqf!. C is overwritten.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gemqrt!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gemqrt!","category":"function","text":"gemqrt!(side, trans, V, T, C)\n\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C\n(trans = C) for side = L or the equivalent right-sided multiplication\nfor side = R using Q from a QR factorization of A computed using\ngeqrt!. C is overwritten.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.posv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.posv!","category":"function","text":"posv!(uplo, A, B) -> (A, B)\n\nFinds the solution to A * X = B where A is a symmetric or Hermitian\npositive definite matrix. If uplo = U the upper Cholesky decomposition\nof A is computed. If uplo = L the lower Cholesky decomposition of A\nis computed. A is overwritten by its Cholesky decomposition. B is\noverwritten with the solution X.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.potrf!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.potrf!","category":"function","text":"potrf!(uplo, A)\n\nComputes the Cholesky (upper if uplo = U, lower if uplo = L)\ndecomposition of positive-definite matrix A. A is overwritten and\nreturned with an info code.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.potri!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.potri!","category":"function","text":"potri!(uplo, A)\n\nComputes the inverse of positive-definite matrix A after calling\npotrf! to find its (upper if uplo = U, lower if uplo = L) Cholesky\ndecomposition.\n\nA is overwritten by its inverse and returned.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.potrs!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.potrs!","category":"function","text":"potrs!(uplo, A, B)\n\nFinds the solution to A * X = B where A is a symmetric or Hermitian\npositive definite matrix whose Cholesky decomposition was computed by\npotrf!. If uplo = U the upper Cholesky decomposition of A was\ncomputed. If uplo = L the lower Cholesky decomposition of A was\ncomputed. B is overwritten with the solution X.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.pstrf!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.pstrf!","category":"function","text":"pstrf!(uplo, A, tol) -> (A, piv, rank, info)\n\nComputes the (upper if uplo = U, lower if uplo = L) pivoted Cholesky\ndecomposition of positive-definite matrix A with a user-set tolerance\ntol. A is overwritten by its Cholesky decomposition.\n\nReturns A, the pivots piv, the rank of A, and an info code. If info = 0,\nthe factorization succeeded. If info = i > 0, then A is indefinite or\nrank-deficient.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.ptsv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ptsv!","category":"function","text":"ptsv!(D, E, B)\n\nSolves A * X = B for positive-definite tridiagonal A. D is the\ndiagonal of A and E is the off-diagonal. B is overwritten with the\nsolution X and returned.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.pttrf!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.pttrf!","category":"function","text":"pttrf!(D, E)\n\nComputes the LDLt factorization of a positive-definite tridiagonal matrix\nwith D as diagonal and E as off-diagonal. D and E are overwritten\nand returned.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.pttrs!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.pttrs!","category":"function","text":"pttrs!(D, E, B)\n\nSolves A * X = B for positive-definite tridiagonal A with diagonal\nD and off-diagonal E after computing A's LDLt factorization using\npttrf!. B is overwritten with the solution X.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.trtri!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trtri!","category":"function","text":"trtri!(uplo, diag, A)\n\nFinds the inverse of (upper if uplo = U, lower if uplo = L)\ntriangular matrix A. If diag = N, A has non-unit diagonal elements.\nIf diag = U, all diagonal elements of A are one. A is overwritten\nwith its inverse.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.trtrs!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trtrs!","category":"function","text":"trtrs!(uplo, trans, diag, A, B)\n\nSolves A * X = B (trans = N), transpose(A) * X = B (trans = T), or\nadjoint(A) * X = B (trans = C) for (upper if uplo = U, lower if uplo = L)\ntriangular matrix A. If diag = N, A has non-unit diagonal elements.\nIf diag = U, all diagonal elements of A are one. B is overwritten\nwith the solution X.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.trcon!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trcon!","category":"function","text":"trcon!(norm, uplo, diag, A)\n\nFinds the reciprocal condition number of (upper if uplo = U, lower if\nuplo = L) triangular matrix A. If diag = N, A has non-unit\ndiagonal elements. If diag = U, all diagonal elements of A are one.\nIf norm = I, the condition number is found in the infinity norm. If\nnorm = O or 1, the condition number is found in the one norm.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.trevc!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trevc!","category":"function","text":"trevc!(side, howmny, select, T, VL = similar(T), VR = similar(T))\n\nFinds the eigensystem of an upper triangular matrix T. If side = R,\nthe right eigenvectors are computed. If side = L, the left\neigenvectors are computed. If side = B, both sets are computed. If\nhowmny = A, all eigenvectors are found. If howmny = B, all\neigenvectors are found and backtransformed using VL and VR. If\nhowmny = S, only the eigenvectors corresponding to the values in\nselect are computed.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.trrfs!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trrfs!","category":"function","text":"trrfs!(uplo, trans, diag, A, B, X, Ferr, Berr) -> (Ferr, Berr)\n\nEstimates the error in the solution to A * X = B (trans = N),\ntranspose(A) * X = B (trans = T), adjoint(A) * X = B (trans = C) for side = L,\nor the equivalent equations a right-handed side = R X * A after\ncomputing X using trtrs!. If uplo = U, A is upper triangular.\nIf uplo = L, A is lower triangular. If diag = N, A has non-unit\ndiagonal elements. If diag = U, all diagonal elements of A are one.\nFerr and Berr are optional inputs. Ferr is the forward error and\nBerr is the backward error, each component-wise.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.stev!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.stev!","category":"function","text":"stev!(job, dv, ev) -> (dv, Zmat)\n\nComputes the eigensystem for a symmetric tridiagonal matrix with dv as\ndiagonal and ev as off-diagonal. If job = N only the eigenvalues are\nfound and returned in dv. If job = V then the eigenvectors are also found\nand returned in Zmat.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.stebz!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.stebz!","category":"function","text":"stebz!(range, order, vl, vu, il, iu, abstol, dv, ev) -> (dv, iblock, isplit)\n\nComputes the eigenvalues for a symmetric tridiagonal matrix with dv as\ndiagonal and ev as off-diagonal. If range = A, all the eigenvalues\nare found. If range = V, the eigenvalues in the half-open interval\n(vl, vu] are found. If range = I, the eigenvalues with indices between\nil and iu are found. If order = B, eigvalues are ordered within a\nblock. If order = E, they are ordered across all the blocks.\nabstol can be set as a tolerance for convergence.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.stegr!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.stegr!","category":"function","text":"stegr!(jobz, range, dv, ev, vl, vu, il, iu) -> (w, Z)\n\nComputes the eigenvalues (jobz = N) or eigenvalues and eigenvectors\n(jobz = V) for a symmetric tridiagonal matrix with dv as diagonal\nand ev as off-diagonal. If range = A, all the eigenvalues\nare found. If range = V, the eigenvalues in the half-open interval\n(vl, vu] are found. If range = I, the eigenvalues with indices between\nil and iu are found. The eigenvalues are returned in w and the eigenvectors\nin Z.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.stein!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.stein!","category":"function","text":"stein!(dv, ev_in, w_in, iblock_in, isplit_in)\n\nComputes the eigenvectors for a symmetric tridiagonal matrix with dv\nas diagonal and ev_in as off-diagonal. w_in specifies the input\neigenvalues for which to find corresponding eigenvectors. iblock_in\nspecifies the submatrices corresponding to the eigenvalues in w_in.\nisplit_in specifies the splitting points between the submatrix blocks.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.syconv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.syconv!","category":"function","text":"syconv!(uplo, A, ipiv) -> (A, work)\n\nConverts a symmetric matrix A (which has been factorized into a\ntriangular matrix) into two matrices L and D. If uplo = U, A\nis upper triangular. If uplo = L, it is lower triangular. ipiv is\nthe pivot vector from the triangular factorization. A is overwritten\nby L and D.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.sysv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.sysv!","category":"function","text":"sysv!(uplo, A, B) -> (B, A, ipiv)\n\nFinds the solution to A * X = B for symmetric matrix A. If uplo = U,\nthe upper half of A is stored. If uplo = L, the lower half is stored.\nB is overwritten by the solution X. A is overwritten by its\nBunch-Kaufman factorization. ipiv contains pivoting information about the\nfactorization.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.sytrf!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.sytrf!","category":"function","text":"sytrf!(uplo, A) -> (A, ipiv, info)\n\nComputes the Bunch-Kaufman factorization of a symmetric matrix A. If\nuplo = U, the upper half of A is stored. If uplo = L, the lower\nhalf is stored.\n\nReturns A, overwritten by the factorization, a pivot vector ipiv, and\nthe error code info which is a non-negative integer. If info is positive\nthe matrix is singular and the diagonal part of the factorization is exactly\nzero at position info.\n\n\n\n\n\nsytrf!(uplo, A, ipiv) -> (A, ipiv, info)\n\nComputes the Bunch-Kaufman factorization of a symmetric matrix A. If\nuplo = U, the upper half of A is stored. If uplo = L, the lower\nhalf is stored.\n\nReturns A, overwritten by the factorization, the pivot vector ipiv, and\nthe error code info which is a non-negative integer. If info is positive\nthe matrix is singular and the diagonal part of the factorization is exactly\nzero at position info.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.sytri!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.sytri!","category":"function","text":"sytri!(uplo, A, ipiv)\n\nComputes the inverse of a symmetric matrix A using the results of\nsytrf!. If uplo = U, the upper half of A is stored. If uplo = L,\nthe lower half is stored. A is overwritten by its inverse.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.sytrs!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.sytrs!","category":"function","text":"sytrs!(uplo, A, ipiv, B)\n\nSolves the equation A * X = B for a symmetric matrix A using the\nresults of sytrf!. If uplo = U, the upper half of A is stored.\nIf uplo = L, the lower half is stored. B is overwritten by the\nsolution X.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.hesv!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.hesv!","category":"function","text":"hesv!(uplo, A, B) -> (B, A, ipiv)\n\nFinds the solution to A * X = B for Hermitian matrix A. If uplo = U,\nthe upper half of A is stored. If uplo = L, the lower half is stored.\nB is overwritten by the solution X. A is overwritten by its\nBunch-Kaufman factorization. ipiv contains pivoting information about the\nfactorization.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.hetrf!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.hetrf!","category":"function","text":"hetrf!(uplo, A) -> (A, ipiv, info)\n\nComputes the Bunch-Kaufman factorization of a Hermitian matrix A. If\nuplo = U, the upper half of A is stored. If uplo = L, the lower\nhalf is stored.\n\nReturns A, overwritten by the factorization, a pivot vector ipiv, and\nthe error code info which is a non-negative integer. If info is positive\nthe matrix is singular and the diagonal part of the factorization is exactly\nzero at position info.\n\n\n\n\n\nhetrf!(uplo, A, ipiv) -> (A, ipiv, info)\n\nComputes the Bunch-Kaufman factorization of a Hermitian matrix A. If\nuplo = U, the upper half of A is stored. If uplo = L, the lower\nhalf is stored.\n\nReturns A, overwritten by the factorization, the pivot vector ipiv, and\nthe error code info which is a non-negative integer. If info is positive\nthe matrix is singular and the diagonal part of the factorization is exactly\nzero at position info.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.hetri!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.hetri!","category":"function","text":"hetri!(uplo, A, ipiv)\n\nComputes the inverse of a Hermitian matrix A using the results of\nsytrf!. If uplo = U, the upper half of A is stored. If uplo = L,\nthe lower half is stored. A is overwritten by its inverse.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.hetrs!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.hetrs!","category":"function","text":"hetrs!(uplo, A, ipiv, B)\n\nSolves the equation A * X = B for a Hermitian matrix A using the\nresults of sytrf!. If uplo = U, the upper half of A is stored.\nIf uplo = L, the lower half is stored. B is overwritten by the\nsolution X.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.syev!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.syev!","category":"function","text":"syev!(jobz, uplo, A)\n\nFinds the eigenvalues (jobz = N) or eigenvalues and eigenvectors\n(jobz = V) of a symmetric matrix A. If uplo = U, the upper triangle\nof A is used. If uplo = L, the lower triangle of A is used.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.syevr!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.syevr!","category":"function","text":"syevr!(jobz, range, uplo, A, vl, vu, il, iu, abstol) -> (W, Z)\n\nFinds the eigenvalues (jobz = N) or eigenvalues and eigenvectors\n(jobz = V) of a symmetric matrix A. If uplo = U, the upper triangle\nof A is used. If uplo = L, the lower triangle of A is used. If\nrange = A, all the eigenvalues are found. If range = V, the\neigenvalues in the half-open interval (vl, vu] are found.\nIf range = I, the eigenvalues with indices between il and iu are\nfound. abstol can be set as a tolerance for convergence.\n\nThe eigenvalues are returned in W and the eigenvectors in Z.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.syevd!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.syevd!","category":"function","text":"syevd!(jobz, uplo, A)\n\nFinds the eigenvalues (jobz = N) or eigenvalues and eigenvectors\n(jobz = V) of a symmetric matrix A. If uplo = U, the upper triangle\nof A is used. If uplo = L, the lower triangle of A is used.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.sygvd!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.sygvd!","category":"function","text":"sygvd!(itype, jobz, uplo, A, B) -> (w, A, B)\n\nFinds the generalized eigenvalues (jobz = N) or eigenvalues and\neigenvectors (jobz = V) of a symmetric matrix A and symmetric\npositive-definite matrix B. If uplo = U, the upper triangles\nof A and B are used. If uplo = L, the lower triangles of A and\nB are used. If itype = 1, the problem to solve is\nA * x = lambda * B * x. If itype = 2, the problem to solve is\nA * B * x = lambda * x. If itype = 3, the problem to solve is\nB * A * x = lambda * x.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.bdsqr!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.bdsqr!","category":"function","text":"bdsqr!(uplo, d, e_, Vt, U, C) -> (d, Vt, U, C)\n\nComputes the singular value decomposition of a bidiagonal matrix with\nd on the diagonal and e_ on the off-diagonal. If uplo = U, e_ is\nthe superdiagonal. If uplo = L, e_ is the subdiagonal. Can optionally also\ncompute the product Q' * C.\n\nReturns the singular values in d, and the matrix C overwritten with Q' * C.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.bdsdc!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.bdsdc!","category":"function","text":"bdsdc!(uplo, compq, d, e_) -> (d, e, u, vt, q, iq)\n\nComputes the singular value decomposition of a bidiagonal matrix with d on the\ndiagonal and e_ on the off-diagonal using a divide and conqueq method.\nIf uplo = U, e_ is the superdiagonal. If uplo = L, e_ is the subdiagonal.\nIf compq = N, only the singular values are found. If compq = I, the singular\nvalues and vectors are found. If compq = P, the singular values\nand vectors are found in compact form. Only works for real types.\n\nReturns the singular values in d, and if compq = P, the compact singular\nvectors in iq.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gecon!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gecon!","category":"function","text":"gecon!(normtype, A, anorm)\n\nFinds the reciprocal condition number of matrix A. If normtype = I,\nthe condition number is found in the infinity norm. If normtype = O or\n1, the condition number is found in the one norm. A must be the\nresult of getrf! and anorm is the norm of A in the relevant norm.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gehrd!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gehrd!","category":"function","text":"gehrd!(ilo, ihi, A) -> (A, tau)\n\nConverts a matrix A to Hessenberg form. If A is balanced with gebal!\nthen ilo and ihi are the outputs of gebal!. Otherwise they should be\nilo = 1 and ihi = size(A,2). tau contains the elementary reflectors of\nthe factorization.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.orghr!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.orghr!","category":"function","text":"orghr!(ilo, ihi, A, tau)\n\nExplicitly finds Q, the orthogonal/unitary matrix from gehrd!. ilo,\nihi, A, and tau must correspond to the input/output to gehrd!.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gees!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gees!","category":"function","text":"gees!(jobvs, A) -> (A, vs, w)\n\nComputes the eigenvalues (jobvs = N) or the eigenvalues and Schur\nvectors (jobvs = V) of matrix A. A is overwritten by its Schur form.\n\nReturns A, vs containing the Schur vectors, and w, containing the\neigenvalues.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gges!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gges!","category":"function","text":"gges!(jobvsl, jobvsr, A, B) -> (A, B, alpha, beta, vsl, vsr)\n\nComputes the generalized eigenvalues, generalized Schur form, left Schur\nvectors (jobsvl = V), or right Schur vectors (jobvsr = V) of A and\nB.\n\nThe generalized eigenvalues are returned in alpha and beta. The left Schur\nvectors are returned in vsl and the right Schur vectors are returned in vsr.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.gges3!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gges3!","category":"function","text":"gges3!(jobvsl, jobvsr, A, B) -> (A, B, alpha, beta, vsl, vsr)\n\nComputes the generalized eigenvalues, generalized Schur form, left Schur\nvectors (jobsvl = V), or right Schur vectors (jobvsr = V) of A and\nB using a blocked algorithm. This function requires LAPACK 3.6.0.\n\nThe generalized eigenvalues are returned in alpha and beta. The left Schur\nvectors are returned in vsl and the right Schur vectors are returned in vsr.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.trexc!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trexc!","category":"function","text":"trexc!(compq, ifst, ilst, T, Q) -> (T, Q)\ntrexc!(ifst, ilst, T, Q) -> (T, Q)\n\nReorder the Schur factorization T of a matrix, such that the diagonal block\nof T with row index ifst is moved to row index ilst. If compq = V, the Schur\nvectors Q are reordered. If compq = N they are not modified. The 4-arg method\ncalls the 5-arg method with compq = V.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.trsen!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trsen!","category":"function","text":"trsen!(job, compq, select, T, Q) -> (T, Q, w, s, sep)\ntrsen!(select, T, Q) -> (T, Q, w, s, sep)\n\nReorder the Schur factorization of a matrix and optionally finds reciprocal\ncondition numbers. If job = N, no condition numbers are found. If job = E,\nonly the condition number for this cluster of eigenvalues is found. If\njob = V, only the condition number for the invariant subspace is found.\nIf job = B then the condition numbers for the cluster and subspace are\nfound. If compq = V the Schur vectors Q are updated. If compq = N\nthe Schur vectors are not modified. select determines which\neigenvalues are in the cluster. The 3-arg method calls the 5-arg method\nwith job = N and compq = V.\n\nReturns T, Q, reordered eigenvalues in w, the condition number of the\ncluster of eigenvalues s, and the condition number of the invariant subspace\nsep.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.tgsen!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.tgsen!","category":"function","text":"tgsen!(select, S, T, Q, Z) -> (S, T, alpha, beta, Q, Z)\n\nReorders the vectors of a generalized Schur decomposition. select specifies\nthe eigenvalues in each cluster.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.trsyl!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trsyl!","category":"function","text":"trsyl!(transa, transb, A, B, C, isgn=1) -> (C, scale)\n\nSolves the Sylvester matrix equation A * X +/- X * B = scale*C where A and\nB are both quasi-upper triangular. If transa = N, A is not modified.\nIf transa = T, A is transposed. If transa = C, A is conjugate\ntransposed. Similarly for transb and B. If isgn = 1, the equation\nA * X + X * B = scale * C is solved. If isgn = -1, the equation\nA * X - X * B = scale * C is solved.\n\nReturns X (overwriting C) and scale.\n\n\n\n\n\n"},{"title":"LinearAlgebra.LAPACK.hseqr!","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.hseqr!","category":"function","text":"hseqr!(job, compz, ilo, ihi, H, Z) -> (H, Z, w)\n\nComputes all eigenvalues and (optionally) the Schur factorization of a matrix\nreduced to Hessenberg form. If H is balanced with gebal!\nthen ilo and ihi are the outputs of gebal!. Otherwise they should be\nilo = 1 and ihi = size(H,2). tau contains the elementary reflectors of\nthe factorization.\n\n\n\n\n\n"},{"title":"LinearAlgebra.matprod_dest","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.matprod_dest","category":"function","text":"matprod_dest(A, B, T)\n\nReturn an appropriate AbstractArray with element type T that may be used to store the result of A * B.\n\ncompat: Compat\nThis function requires at least Julia 1.11\n\n\n\n\n\n"},{"title":"LinearAlgebra.haszero","page":"Linear Algebra","location":"stdlib/LinearAlgebra.html#LinearAlgebra.haszero","category":"function","text":"haszero(T::Type)\n\nReturn whether a type T has a unique zero element defined using zero(T).\nIf a type M specializes zero(M), it may also choose to set haszero(M) to true.\nBy default, haszero is assumed to be false, in which case the zero elements\nare deduced from values rather than the type.\n\nnote: Note\nhaszero is a conservative check that is used to dispatch to\noptimized paths. Extending it is optional, but encouraged.\n\n\n\n\n\n"},{"title":"Artifacts","page":"Artifacts","location":"stdlib/Artifacts.html#Artifacts","category":"section","text":"Starting with Julia 1.6, the artifacts support has moved from Pkg.jl to Julia itself.\nUntil proper documentation can be added here, you can learn more about artifacts in the\nPkg.jl manual at https://julialang.github.io/Pkg.jl/v1/artifacts/.\n\ncompat: Julia 1.6\nJulia's artifacts API requires at least Julia 1.6. In Julia\nversions 1.3 to 1.5, you can use Pkg.Artifacts instead."},{"title":"Artifacts.artifact_meta","page":"Artifacts","location":"stdlib/Artifacts.html#Artifacts.artifact_meta","category":"function","text":"artifact_meta(name::String, artifacts_toml::String;\n              platform::AbstractPlatform = HostPlatform(),\n              pkg_uuid::Union{Base.UUID,Nothing}=nothing)\n\nGet metadata about a given artifact (identified by name) stored within the given\n(Julia)Artifacts.toml file.  If the artifact is platform-specific, use platform to choose the\nmost appropriate mapping.  If none is found, return nothing.\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n"},{"title":"Artifacts.artifact_hash","page":"Artifacts","location":"stdlib/Artifacts.html#Artifacts.artifact_hash","category":"function","text":"artifact_hash(name::String, artifacts_toml::String;\n              platform::AbstractPlatform = HostPlatform())\n\nThin wrapper around artifact_meta() to return the hash of the specified, platform-\ncollapsed artifact.  Returns nothing if no mapping can be found.\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n"},{"title":"Artifacts.find_artifacts_toml","page":"Artifacts","location":"stdlib/Artifacts.html#Artifacts.find_artifacts_toml","category":"function","text":"find_artifacts_toml(path::String)\n\nGiven the path to a .jl file, (such as the one returned by __source__.file in a macro\ncontext), find the (Julia)Artifacts.toml that is contained within the containing project (if it\nexists), otherwise return nothing.\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n"},{"title":"Artifacts.@artifact_str","page":"Artifacts","location":"stdlib/Artifacts.html#Artifacts.@artifact_str","category":"macro","text":"macro artifact_str(name)\n\nReturn the on-disk path to an artifact. Automatically looks the artifact up by\nname in the project's (Julia)Artifacts.toml file. Throws an error on if the\nrequested artifact is not present. If run in the REPL, searches for the toml\nfile starting in the current directory, see find_artifacts_toml() for more.\n\nIf the artifact is marked \"lazy\" and the package has using LazyArtifacts\ndefined, the artifact will be downloaded on-demand with Pkg the first time\nthis macro tries to compute the path. The files will then be left installed\nlocally for later.\n\nIf name contains a forward or backward slash, all elements after the first slash will\nbe taken to be path names indexing into the artifact, allowing for an easy one-liner to\naccess a single file/directory within an artifact.  Example:\n\nffmpeg_path = @artifact\"FFMPEG/bin/ffmpeg\"\n\ncompat: Julia 1.3\nThis macro requires at least Julia 1.3.\n\ncompat: Julia 1.6\nSlash-indexing requires at least Julia 1.6.\n\n\n\n\n\n"},{"title":"Artifacts.artifact_exists","page":"Artifacts","location":"stdlib/Artifacts.html#Artifacts.artifact_exists","category":"function","text":"artifact_exists(hash::SHA1; honor_overrides::Bool=true)\n\nReturn whether or not the given artifact (identified by its sha1 git tree hash) exists\non-disk.  Note that it is possible that the given artifact exists in multiple locations\n(e.g. within multiple depots).\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n"},{"title":"Artifacts.artifact_path","page":"Artifacts","location":"stdlib/Artifacts.html#Artifacts.artifact_path","category":"function","text":"artifact_path(hash::SHA1; honor_overrides::Bool=true)\n\nGiven an artifact (identified by SHA1 git tree hash), return its installation path.  If\nthe artifact does not exist, returns the location it would be installed to.\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n"},{"title":"Artifacts.select_downloadable_artifacts","page":"Artifacts","location":"stdlib/Artifacts.html#Artifacts.select_downloadable_artifacts","category":"function","text":"select_downloadable_artifacts(artifacts_toml::String;\n                              platform = HostPlatform,\n                              include_lazy = false,\n                              pkg_uuid = nothing)\n\nReturn a dictionary where every entry is an artifact from the given Artifacts.toml\nthat should be downloaded for the requested platform.  Lazy artifacts are included if\ninclude_lazy is set.\n\n\n\n\n\n"},{"title":"Filesystem","page":"Filesystem","location":"base/file.html#Filesystem","category":"section","text":""},{"title":"Base.read","page":"Filesystem","location":"base/file.html#Base.read-Tuple{String}","category":"method","text":"read(filename::AbstractString)\n\nRead the entire contents of a file as a Vector{UInt8}.\n\nread(filename::AbstractString, String)\n\nRead the entire contents of a file as a string.\n\nread(filename::AbstractString, args...)\n\nOpen a file and read its contents. args is passed to read: this is equivalent to\nopen(io->read(io, args...), filename).\n\n\n\n\n\n"},{"title":"Base.write","page":"Filesystem","location":"base/file.html#Base.write-Tuple{String, Any}","category":"method","text":"write(filename::AbstractString, content)\n\nWrite the canonical binary representation of content to a file, which will be created if it does not exist yet or overwritten if it does exist.\n\nReturn the number of bytes written into the file.\n\n\n\n\n\n"},{"title":"Base.Filesystem.pwd","page":"Filesystem","location":"base/file.html#Base.Filesystem.pwd","category":"function","text":"pwd()::String\n\nGet the current working directory.\n\nSee also: cd, tempdir.\n\nExamples\n\njulia> pwd()\n\"/home/JuliaUser\"\n\njulia> cd(\"/home/JuliaUser/Projects/julia\")\n\njulia> pwd()\n\"/home/JuliaUser/Projects/julia\"\n\n\n\n\n\n"},{"title":"Base.Filesystem.cd","page":"Filesystem","location":"base/file.html#Base.Filesystem.cd-Tuple{AbstractString}","category":"method","text":"cd(dir::AbstractString=homedir())\n\nSet the current working directory.\n\nSee also: pwd, mkdir, mkpath, mktempdir.\n\nExamples\n\njulia> cd(\"/home/JuliaUser/Projects/julia\")\n\njulia> pwd()\n\"/home/JuliaUser/Projects/julia\"\n\njulia> cd()\n\njulia> pwd()\n\"/home/JuliaUser\"\n\n\n\n\n\n"},{"title":"Base.Filesystem.cd","page":"Filesystem","location":"base/file.html#Base.Filesystem.cd-Tuple{Function}","category":"method","text":"cd(f::Function, dir::AbstractString=homedir())\n\nTemporarily change the current working directory to dir, apply function f and\nfinally return to the original directory.\n\nExamples\n\njulia> pwd()\n\"/home/JuliaUser\"\n\njulia> cd(readdir, \"/home/JuliaUser/Projects/julia\")\n34-element Vector{String}:\n \".circleci\"\n \".freebsdci.sh\"\n \".git\"\n \".gitattributes\"\n \".github\"\n ⋮\n \"test\"\n \"ui\"\n \"usr\"\n \"usr-staging\"\n\njulia> pwd()\n\"/home/JuliaUser\"\n\n\n\n\n\n"},{"title":"Base.Filesystem.readdir","page":"Filesystem","location":"base/file.html#Base.Filesystem.readdir","category":"function","text":"readdir(dir::AbstractString=pwd();\n    join::Bool = false,\n    sort::Bool = true,\n)::Vector{String}\n\nReturn the names in the directory dir or the current working directory if not\ngiven. When join is false, readdir returns just the names in the directory\nas is; when join is true, it returns joinpath(dir, name) for each name so\nthat the returned strings are full paths. If you want to get absolute paths\nback, call readdir with an absolute directory path and join set to true.\n\nBy default, readdir sorts the list of names it returns. If you want to skip\nsorting the names and get them in the order that the file system lists them,\nyou can use readdir(dir, sort=false) to opt out of sorting.\n\nSee also: walkdir.\n\ncompat: Julia 1.4\nThe join and sort keyword arguments require at least Julia 1.4.\n\nExamples\n\njulia> cd(\"/home/JuliaUser/dev/julia\")\n\njulia> readdir()\n30-element Vector{String}:\n \".appveyor.yml\"\n \".git\"\n \".gitattributes\"\n ⋮\n \"ui\"\n \"usr\"\n \"usr-staging\"\n\njulia> readdir(join=true)\n30-element Vector{String}:\n \"/home/JuliaUser/dev/julia/.appveyor.yml\"\n \"/home/JuliaUser/dev/julia/.git\"\n \"/home/JuliaUser/dev/julia/.gitattributes\"\n ⋮\n \"/home/JuliaUser/dev/julia/ui\"\n \"/home/JuliaUser/dev/julia/usr\"\n \"/home/JuliaUser/dev/julia/usr-staging\"\n\njulia> readdir(\"base\")\n145-element Vector{String}:\n \".gitignore\"\n \"Base.jl\"\n \"Enums.jl\"\n ⋮\n \"version_git.sh\"\n \"views.jl\"\n \"weakkeydict.jl\"\n\njulia> readdir(\"base\", join=true)\n145-element Vector{String}:\n \"base/.gitignore\"\n \"base/Base.jl\"\n \"base/Enums.jl\"\n ⋮\n \"base/version_git.sh\"\n \"base/views.jl\"\n \"base/weakkeydict.jl\"\n\njulia> readdir(abspath(\"base\"), join=true)\n145-element Vector{String}:\n \"/home/JuliaUser/dev/julia/base/.gitignore\"\n \"/home/JuliaUser/dev/julia/base/Base.jl\"\n \"/home/JuliaUser/dev/julia/base/Enums.jl\"\n ⋮\n \"/home/JuliaUser/dev/julia/base/version_git.sh\"\n \"/home/JuliaUser/dev/julia/base/views.jl\"\n \"/home/JuliaUser/dev/julia/base/weakkeydict.jl\"\n\n\n\n\n\n"},{"title":"Base.Filesystem.walkdir","page":"Filesystem","location":"base/file.html#Base.Filesystem.walkdir","category":"function","text":"walkdir(dir = pwd(); topdown=true, follow_symlinks=false, onerror=throw)\n\nReturn an iterator that walks the directory tree of a directory.\n\nThe iterator returns a tuple containing (path, dirs, files).\nEach iteration path will change to the next directory in the tree;\nthen dirs and files will be vectors containing the directories and files\nin the current path directory.\nThe directory tree can be traversed top-down or bottom-up.\nIf walkdir or stat encounters a IOError it will rethrow the error by default.\nA custom error handling function can be provided through onerror keyword argument.\nonerror is called with a IOError as argument.\nThe returned iterator is stateful so when accessed repeatedly each access will\nresume where the last left off, like Iterators.Stateful.\n\nSee also: readdir.\n\ncompat: Julia 1.12\npwd() as the default directory was added in Julia 1.12.\n\nExamples\n\nfor (path, dirs, files) in walkdir(\".\")\n    println(\"Directories in $path\")\n    for dir in dirs\n        println(joinpath(path, dir)) # path to directories\n    end\n    println(\"Files in $path\")\n    for file in files\n        println(joinpath(path, file)) # path to files\n    end\nend\n\njulia> mkpath(\"my/test/dir\");\n\njulia> itr = walkdir(\"my\");\n\njulia> (path, dirs, files) = first(itr)\n(\"my\", [\"test\"], String[])\n\njulia> (path, dirs, files) = first(itr)\n(\"my/test\", [\"dir\"], String[])\n\njulia> (path, dirs, files) = first(itr)\n(\"my/test/dir\", String[], String[])\n\n\n\n\n\n"},{"title":"Base.Filesystem.mkdir","page":"Filesystem","location":"base/file.html#Base.Filesystem.mkdir","category":"function","text":"mkdir(path::AbstractString; mode::Unsigned = 0o777)\n\nMake a new directory with name path and permissions mode. mode defaults to 0o777,\nmodified by the current file creation mask. This function never creates more than one\ndirectory. If the directory already exists, or some intermediate directories do not exist,\nthis function throws an error. See mkpath for a function which creates all\nrequired intermediate directories.\nReturn path.\n\nExamples\n\njulia> mkdir(\"testingdir\")\n\"testingdir\"\n\njulia> cd(\"testingdir\")\n\njulia> pwd()\n\"/home/JuliaUser/testingdir\"\n\n\n\n\n\n"},{"title":"Base.Filesystem.mkpath","page":"Filesystem","location":"base/file.html#Base.Filesystem.mkpath","category":"function","text":"mkpath(path::AbstractString; mode::Unsigned = 0o777)\n\nCreate all intermediate directories in the path as required. Directories are created with\nthe permissions mode which defaults to 0o777 and is modified by the current file\ncreation mask. Unlike mkdir, mkpath does not error if path (or parts of it)\nalready exists. However, an error will be thrown if path (or parts of it) points to an\nexisting file. Return path.\n\nIf path includes a filename you will probably want to use mkpath(dirname(path)) to\navoid creating a directory using the filename.\n\nExamples\n\njulia> cd(mktempdir())\n\njulia> mkpath(\"my/test/dir\") # creates three directories\n\"my/test/dir\"\n\njulia> readdir()\n1-element Vector{String}:\n \"my\"\n\njulia> cd(\"my\")\n\njulia> readdir()\n1-element Vector{String}:\n \"test\"\n\njulia> readdir(\"test\")\n1-element Vector{String}:\n \"dir\"\n\njulia> mkpath(\"intermediate_dir/actually_a_directory.txt\") # creates two directories\n\"intermediate_dir/actually_a_directory.txt\"\n\njulia> isdir(\"intermediate_dir/actually_a_directory.txt\")\ntrue\n\njulia> mkpath(\"my/test/dir/\") # returns the original `path`\n\"my/test/dir/\"\n\n\n\n\n\n"},{"title":"Base.Filesystem.hardlink","page":"Filesystem","location":"base/file.html#Base.Filesystem.hardlink","category":"function","text":"hardlink(src::AbstractString, dst::AbstractString)\n\nCreate a hard link to an existing source file src with the name dst. The\ndestination, dst, must not exist.\n\nSee also: symlink.\n\ncompat: Julia 1.8\nThis method was added in Julia 1.8.\n\n\n\n\n\n"},{"title":"Base.Filesystem.symlink","page":"Filesystem","location":"base/file.html#Base.Filesystem.symlink","category":"function","text":"symlink(target::AbstractString, link::AbstractString; dir_target = false)\n\nCreate a symbolic link to target with the name link.\n\nOn Windows, symlinks must be explicitly declared as referring to a directory\nor not.  If target already exists, by default the type of link will be auto-\ndetected, however if target does not exist, this function defaults to creating\na file symlink unless dir_target is set to true.  Note that if the user\nsets dir_target but target exists and is a file, a directory symlink will\nstill be created, but dereferencing the symlink will fail, just as if the user\ncreates a file symlink (by calling symlink() with dir_target set to false\nbefore the directory is created) and tries to dereference it to a directory.\n\nAdditionally, there are two methods of making a link on Windows; symbolic links\nand junction points.  Junction points are slightly more efficient, but do not\nsupport relative paths, so if a relative directory symlink is requested (as\ndenoted by isabspath(target) returning false) a symlink will be used, else\na junction point will be used.  Best practice for creating symlinks on Windows\nis to create them only after the files/directories they reference are already\ncreated.\n\nSee also: hardlink.\n\nnote: Note\nThis function raises an error under operating systems that do not support\nsoft symbolic links, such as Windows XP.\n\ncompat: Julia 1.6\nThe dir_target keyword argument was added in Julia 1.6.  Prior to this,\nsymlinks to nonexistent paths on windows would always be file symlinks, and\nrelative symlinks to directories were not supported.\n\n\n\n\n\n"},{"title":"Base.Filesystem.readlink","page":"Filesystem","location":"base/file.html#Base.Filesystem.readlink","category":"function","text":"readlink(path::AbstractString)::String\n\nReturn the target location a symbolic link path points to.\n\n\n\n\n\n"},{"title":"Base.Filesystem.chmod","page":"Filesystem","location":"base/file.html#Base.Filesystem.chmod","category":"function","text":"chmod(path::AbstractString, mode::Integer; recursive::Bool=false)\n\nChange the permissions mode of path to mode. Only integer modes (e.g. 0o777) are\ncurrently supported. If recursive=true and the path is a directory all permissions in\nthat directory will be recursively changed.\nReturn path.\n\nnote: Note\nPrior to Julia 1.6, this did not correctly manipulate filesystem ACLs\n on Windows, therefore it would only set read-only bits on files.  It\n now is able to manipulate ACLs.\n\n\n\n\n\n"},{"title":"Base.Filesystem.chown","page":"Filesystem","location":"base/file.html#Base.Filesystem.chown","category":"function","text":"chown(path::AbstractString, owner::Integer, group::Integer=-1)\n\nChange the owner and/or group of path to owner and/or group. If the value entered for owner or group\nis -1 the corresponding ID will not change. Only integer owners and groups are currently supported.\nReturn path.\n\n\n\n\n\n"},{"title":"Base.Libc.RawFD","page":"Filesystem","location":"base/file.html#Base.Libc.RawFD","category":"type","text":"RawFD\n\nPrimitive type which wraps the native OS file descriptor.\nRawFDs can be passed to methods like stat to\ndiscover information about the underlying file, and can\nalso be used to open streams, with the RawFD describing\nthe OS file backing the stream.\n\n\n\n\n\n"},{"title":"Base.stat","page":"Filesystem","location":"base/file.html#Base.stat","category":"function","text":"stat(path)\nstat(path_elements...)\n\nReturn a structure whose fields contain information about the file.\nIf multiple arguments are given, they are joined by joinpath.\n\nThe fields of the structure are:\n\nName Type Description\ndesc Union{String, Base.OS_HANDLE} The path or OS file descriptor\nsize Int64 The size (in bytes) of the file\ndevice UInt ID of the device that contains the file\ninode UInt The inode number of the file\nmode UInt The protection mode of the file\nnlink Int The number of hard links to the file\nuid UInt The user id of the owner of the file\ngid UInt The group id of the file owner\nrdev UInt If this file refers to a device, the ID of the device it refers to\nblksize Int64 The file-system preferred block size for the file\nblocks Int64 The number of 512-byte blocks allocated\nmtime Float64 Unix timestamp of when the file was last modified\nctime Float64 Unix timestamp of when the file's metadata was changed\n\n\n\n\n\n"},{"title":"Base.Filesystem.diskstat","page":"Filesystem","location":"base/file.html#Base.Filesystem.diskstat","category":"function","text":"diskstat(path=pwd())\n\nReturn statistics in bytes about the disk that contains the file or directory pointed at by\npath. If no argument is passed, statistics about the disk that contains the current\nworking directory are returned.\n\ncompat: Julia 1.8\nThis method was added in Julia 1.8.\n\n\n\n\n\n"},{"title":"Base.Filesystem.lstat","page":"Filesystem","location":"base/file.html#Base.Filesystem.lstat","category":"function","text":"lstat(path)\nlstat(path_elements...)\n\nLike stat, but for symbolic links gets the info\nfor the link itself rather than the file it refers to.\n\nThis function must be called on a file path rather\nthan a file object or a file descriptor.\n\n\n\n\n\n"},{"title":"Base.Filesystem.ctime","page":"Filesystem","location":"base/file.html#Base.Filesystem.ctime","category":"function","text":"ctime(path)\nctime(path_elements...)\nctime(stat_struct)\n\nReturn the unix timestamp of when the metadata of the file at path was last modified,\nor the last modified metadata timestamp indicated by the file descriptor stat_struct.\n\nEquivalent to stat(path).ctime or stat_struct.ctime.\n\n\n\n\n\n"},{"title":"Base.Filesystem.mtime","page":"Filesystem","location":"base/file.html#Base.Filesystem.mtime","category":"function","text":"mtime(path)\nmtime(path_elements...)\nmtime(stat_struct)\n\nReturn the unix timestamp of when the file at path was last modified,\nor the last modified timestamp indicated by the file descriptor stat_struct.\n\nEquivalent to stat(path).mtime or stat_struct.mtime.\n\n\n\n\n\n"},{"title":"Base.Filesystem.filemode","page":"Filesystem","location":"base/file.html#Base.Filesystem.filemode","category":"function","text":"filemode(path)\nfilemode(path_elements...)\nfilemode(stat_struct)\n\nReturn the mode of the file located at path,\nor the mode indicated by the file descriptor stat_struct.\n\nEquivalent to stat(path).mode or stat_struct.mode.\n\n\n\n\n\n"},{"title":"Base.filesize","page":"Filesystem","location":"base/file.html#Base.filesize","category":"function","text":"filesize(path)\nfilesize(path_elements...)\nfilesize(stat_struct)\n\nReturn the size of the file located at path,\nor the size indicated by file descriptor stat_struct.\n\nEquivalent to stat(path).size or stat_struct.size.\n\n\n\n\n\n"},{"title":"Base.Filesystem.uperm","page":"Filesystem","location":"base/file.html#Base.Filesystem.uperm","category":"function","text":"uperm(path)\nuperm(path_elements...)\nuperm(stat_struct)\n\nReturn a bitfield of the owner permissions for the file at path or file descriptor stat_struct.\n\nValue Description\n01 Execute Permission\n02 Write Permission\n04 Read Permission\n\nThe fact that a bitfield is returned means that if the permission\nis read+write, the bitfield is \"110\", which maps to the decimal\nvalue of 0+2+4=6. This is reflected in the printing of the\nreturned UInt8 value.\n\nSee also gperm and operm.\n\njulia> touch(\"dummy_file\");  # Create test-file without contents\n\njulia> uperm(\"dummy_file\")\n0x06\n\njulia> bitstring(ans)\n\"00000110\"\n\njulia> has_read_permission(path) = uperm(path) & 0b00000100 != 0;  # Use bit mask to check specific bit\n\njulia> has_read_permission(\"dummy_file\")\ntrue\n\njulia> rm(\"dummy_file\")     # Clean up test-file\n\n\n\n\n\n"},{"title":"Base.Filesystem.gperm","page":"Filesystem","location":"base/file.html#Base.Filesystem.gperm","category":"function","text":"gperm(path)\ngperm(path_elements...)\ngperm(stat_struct)\n\nLike uperm but gets the permissions of the group owning the file.\n\nSee also operm.\n\n\n\n\n\n"},{"title":"Base.Filesystem.operm","page":"Filesystem","location":"base/file.html#Base.Filesystem.operm","category":"function","text":"operm(path)\noperm(path_elements...)\noperm(stat_struct)\n\nLike uperm but gets the permissions for people who neither own the\nfile nor are a member of the group owning the file.\n\nSee also gperm.\n\n\n\n\n\n"},{"title":"Base.Filesystem.cp","page":"Filesystem","location":"base/file.html#Base.Filesystem.cp","category":"function","text":"cp(src::AbstractString, dst::AbstractString; force::Bool=false, follow_symlinks::Bool=false)\n\nCopy the file, link, or directory from src to dst.\nforce=true will first remove an existing dst.\n\nIf follow_symlinks=false, and src is a symbolic link, dst will be created as a\nsymbolic link. If follow_symlinks=true and src is a symbolic link, dst will be a copy\nof the file or directory src refers to.\nReturn dst.\n\nnote: Note\nThe cp function is different from the cp Unix command. The cp function always operates on\nthe assumption that dst is a file, while the command does different things depending\non whether dst is a directory or a file.\nUsing force=true when dst is a directory will result in loss of all the contents present\nin the dst directory, and dst will become a file that has the contents of src instead.\n\n\n\n\n\n"},{"title":"Base.download","page":"Filesystem","location":"base/file.html#Base.download","category":"function","text":"download(url::AbstractString, [path::AbstractString = tempname()]) -> path\n\nDownload a file from the given url, saving it to the location path, or if not\nspecified, a temporary path. Returns the path of the downloaded file.\n\nnote: Note\nSince Julia 1.6, this function is deprecated and is just a thin wrapper\naround Downloads.download. In new code, you should use that function\ndirectly instead of calling this.\n\n\n\n\n\n"},{"title":"Base.Filesystem.mv","page":"Filesystem","location":"base/file.html#Base.Filesystem.mv","category":"function","text":"mv(src::AbstractString, dst::AbstractString; force::Bool=false)\n\nMove the file, link, or directory from src to dst.\nforce=true will first remove an existing dst.\nReturn dst.\n\nExamples\n\njulia> write(\"hello.txt\", \"world\");\n\njulia> mv(\"hello.txt\", \"goodbye.txt\")\n\"goodbye.txt\"\n\njulia> \"hello.txt\" in readdir()\nfalse\n\njulia> readline(\"goodbye.txt\")\n\"world\"\n\njulia> write(\"hello.txt\", \"world2\");\n\njulia> mv(\"hello.txt\", \"goodbye.txt\")\nERROR: ArgumentError: 'goodbye.txt' exists. `force=true` is required to remove 'goodbye.txt' before moving.\nStacktrace:\n [1] #checkfor_mv_cp_cptree#10(::Bool, ::Function, ::String, ::String, ::String) at ./file.jl:293\n[...]\n\njulia> mv(\"hello.txt\", \"goodbye.txt\", force=true)\n\"goodbye.txt\"\n\njulia> rm(\"goodbye.txt\");\n\n\nnote: Note\nThe mv function is different from the mv Unix command. The mv function by\ndefault will error if dst exists, while the command will delete\nan existing dst file by default.\nAlso the mv function always operates on\nthe assumption that dst is a file, while the command does different things depending\non whether dst is a directory or a file.\nUsing force=true when dst is a directory will result in loss of all the contents present\nin the dst directory, and dst will become a file that has the contents of src instead.\n\n\n\n\n\n"},{"title":"Base.Filesystem.rename","page":"Filesystem","location":"base/file.html#Base.Filesystem.rename","category":"function","text":"Base.rename(oldpath::AbstractString, newpath::AbstractString)\n\nChange the name of a file or directory from oldpath to newpath.\nIf newpath is an existing file or empty directory it may be replaced.\nEquivalent to rename(2) on Unix.\nIf a path contains a \"\\0\" throw an ArgumentError.\nOn other failures throw an IOError.\nReturn newpath.\n\nThis is a lower level filesystem operation used to implement mv.\n\nOS-specific restrictions may apply when oldpath and newpath are in different directories.\n\nCurrently there are a few differences in behavior on Windows which may be resolved in a future release.\nSpecifically, currently on Windows:\n\nrename will fail if oldpath or newpath are opened files.\nrename will fail if newpath is an existing directory.\nrename may work if newpath is a file and oldpath is a directory.\nrename may remove oldpath if it is a hardlink to newpath.\n\nSee also: mv.\n\ncompat: Julia 1.12\nThis method was made public in Julia 1.12.\n\n\n\n\n\n"},{"title":"Base.Filesystem.rm","page":"Filesystem","location":"base/file.html#Base.Filesystem.rm","category":"function","text":"rm(path::AbstractString; force::Bool=false, recursive::Bool=false)\n\nDelete the file, link, or empty directory at the given path. If force=true is passed, a\nnon-existing path is not treated as error. If recursive=true is passed and the path is a\ndirectory, then all contents are removed recursively.\n\nExamples\n\njulia> mkpath(\"my/test/dir\");\n\njulia> rm(\"my\", recursive=true)\n\njulia> rm(\"this_file_does_not_exist\", force=true)\n\njulia> rm(\"this_file_does_not_exist\")\nERROR: IOError: unlink(\"this_file_does_not_exist\"): no such file or directory (ENOENT)\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"Base.Filesystem.touch","page":"Filesystem","location":"base/file.html#Base.Filesystem.touch","category":"function","text":"Base.touch(::Pidfile.LockMonitor)\n\nUpdate the mtime on the lock, to indicate it is still fresh.\n\nSee also the refresh keyword in the mkpidlock constructor.\n\n\n\n\n\ntouch(path::AbstractString)\ntouch(fd::File)\n\nUpdate the last-modified timestamp on a file to the current time.\n\nIf the file does not exist a new file is created.\n\nReturn path.\n\nExamples\n\njulia> write(\"my_little_file\", 2);\n\njulia> mtime(\"my_little_file\")\n1.5273815391135583e9\n\njulia> touch(\"my_little_file\");\n\njulia> mtime(\"my_little_file\")\n1.527381559163435e9\n\nWe can see the mtime has been modified by touch.\n\n\n\n\n\n"},{"title":"Base.Filesystem.tempname","page":"Filesystem","location":"base/file.html#Base.Filesystem.tempname","category":"function","text":"tempname(parent=tempdir(); cleanup=true, suffix=\"\")::String\n\nGenerate a temporary file path. This function only returns a path; no file is\ncreated. The path is likely to be unique, but this cannot be guaranteed due to\nthe very remote possibility of two simultaneous calls to tempname generating\nthe same file name. The name is guaranteed to differ from all files already\nexisting at the time of the call to tempname.\n\nWhen called with no arguments, the temporary name will be an absolute path to a\ntemporary name in the system temporary directory as given by tempdir(). If a\nparent directory argument is given, the temporary path will be in that\ndirectory instead. If a suffix is given the tempname will end with that suffix\nand be tested for uniqueness with that suffix.\n\nThe cleanup option controls whether the process attempts to delete the\nreturned path automatically when the process exits. Note that the tempname\nfunction does not create any file or directory at the returned location, so\nthere is nothing to cleanup unless you create a file or directory there. If\nyou do and cleanup is true it will be deleted upon process termination.\n\ncompat: Julia 1.4\nThe parent and cleanup arguments were added in 1.4. Prior to Julia 1.4\nthe path tempname would never be cleaned up at process termination.\n\ncompat: Julia 1.12\nThe suffix keyword argument was added in Julia 1.12.\n\nwarning: Warning\nThis can lead to security holes if another process obtains the same\nfile name and creates the file before you are able to. Open the file with\nJL_O_EXCL if this is a concern. Using mktemp() is also\nrecommended instead.\n\n\n\n\n\n"},{"title":"Base.Filesystem.tempdir","page":"Filesystem","location":"base/file.html#Base.Filesystem.tempdir","category":"function","text":"tempdir()\n\nGet the path of the temporary directory. On Windows, tempdir() uses the first environment\nvariable found in the ordered list TMP, TEMP, USERPROFILE. On all other operating\nsystems, tempdir() uses the first environment variable found in the ordered list TMPDIR,\nTMP, TEMP, and TEMPDIR. If none of these are found, the path \"/tmp\" is used.\n\n\n\n\n\n"},{"title":"Base.Filesystem.mktemp","page":"Filesystem","location":"base/file.html#Base.Filesystem.mktemp-Tuple{AbstractString}","category":"method","text":"mktemp(parent=tempdir(); cleanup=true) -> (path, io)\n\nReturn (path, io), where path is the path of a new temporary file in parent\nand io is an open file object for this path. The cleanup option controls whether\nthe temporary file is automatically deleted when the process exits.\n\ncompat: Julia 1.3\nThe cleanup keyword argument was added in Julia 1.3. Relatedly, starting from 1.3,\nJulia will remove the temporary paths created by mktemp when the Julia process exits,\nunless cleanup is explicitly set to false.\n\n\n\n\n\n"},{"title":"Base.Filesystem.mktemp","page":"Filesystem","location":"base/file.html#Base.Filesystem.mktemp-Tuple{Function, AbstractString}","category":"method","text":"mktemp(f::Function, parent=tempdir())\n\nApply the function f to the result of mktemp(parent) and remove the\ntemporary file upon completion.\n\nSee also: mktempdir.\n\n\n\n\n\n"},{"title":"Base.Filesystem.mktempdir","page":"Filesystem","location":"base/file.html#Base.Filesystem.mktempdir-Tuple{AbstractString}","category":"method","text":"mktempdir(parent=tempdir(); prefix=\"jl_\", cleanup=true) -> path\n\nCreate a temporary directory in the parent directory with a name\nconstructed from the given prefix and a random suffix, and return its path.\nAdditionally, on some platforms, any trailing 'X' characters in prefix may be replaced\nwith random characters.\nIf parent does not exist, throw an error. The cleanup option controls whether\nthe temporary directory is automatically deleted when the process exits.\n\ncompat: Julia 1.2\nThe prefix keyword argument was added in Julia 1.2.\n\ncompat: Julia 1.3\nThe cleanup keyword argument was added in Julia 1.3. Relatedly, starting from 1.3,\nJulia will remove the temporary paths created by mktempdir when the Julia process\nexits, unless cleanup is explicitly set to false.\n\nSee also: mktemp, mkdir.\n\n\n\n\n\n"},{"title":"Base.Filesystem.mktempdir","page":"Filesystem","location":"base/file.html#Base.Filesystem.mktempdir-Tuple{Function, AbstractString}","category":"method","text":"mktempdir(f::Function, parent=tempdir(); prefix=\"jl_\")\n\nApply the function f to the result of mktempdir(parent; prefix) and remove the\ntemporary directory and all of its contents upon completion.\n\nSee also: mktemp, mkdir.\n\ncompat: Julia 1.2\nThe prefix keyword argument was added in Julia 1.2.\n\n\n\n\n\n"},{"title":"Base.Filesystem.isblockdev","page":"Filesystem","location":"base/file.html#Base.Filesystem.isblockdev","category":"function","text":"isblockdev(path)::Bool\nisblockdev(path_elements...)::Bool\nisblockdev(stat_struct)::Bool\n\nReturn true if the path path or file descriptor stat_struct refer to a block device, false otherwise.\n\n\n\n\n\n"},{"title":"Base.Filesystem.ischardev","page":"Filesystem","location":"base/file.html#Base.Filesystem.ischardev","category":"function","text":"ischardev(path)::Bool\nischardev(path_elements...)::Bool\nischardev(stat_struct)::Bool\n\nReturn true if the path path or file descriptor stat_struct refer to a character device, false otherwise.\n\n\n\n\n\n"},{"title":"Base.Filesystem.isdir","page":"Filesystem","location":"base/file.html#Base.Filesystem.isdir","category":"function","text":"isdir(path)::Bool\nisdir(path_elements...)::Bool\n\nReturn true if path points to a directory, false otherwise.\n\nExamples\n\njulia> isdir(homedir())\ntrue\n\njulia> isdir(\"not/a/directory\")\nfalse\n\nSee also isfile and ispath.\n\n\n\n\n\n"},{"title":"Base.Filesystem.isfifo","page":"Filesystem","location":"base/file.html#Base.Filesystem.isfifo","category":"function","text":"isfifo(path)::Bool\nisfifo(path_elements...)::Bool\nisfifo(stat_struct)::Bool\n\nReturn true if the file at path or file descriptor stat_struct is FIFO, false otherwise.\n\n\n\n\n\n"},{"title":"Base.Filesystem.isfile","page":"Filesystem","location":"base/file.html#Base.Filesystem.isfile","category":"function","text":"isfile(path)::Bool\nisfile(path_elements...)::Bool\n\nReturn true if path points to a regular file, false otherwise.\n\nExamples\n\njulia> isfile(homedir())\nfalse\n\njulia> filename = \"test_file.txt\";\n\njulia> write(filename, \"Hello world!\");\n\njulia> isfile(filename)\ntrue\n\njulia> rm(filename);\n\njulia> isfile(filename)\nfalse\n\nSee also isdir and ispath.\n\n\n\n\n\n"},{"title":"Base.Filesystem.islink","page":"Filesystem","location":"base/file.html#Base.Filesystem.islink","category":"function","text":"islink(path)::Bool\nislink(path_elements...)::Bool\n\nReturn true if path points to a symbolic link, false otherwise.\n\n\n\n\n\n"},{"title":"Base.Filesystem.ismount","page":"Filesystem","location":"base/file.html#Base.Filesystem.ismount","category":"function","text":"ismount(path)::Bool\nismount(path_elements...)::Bool\n\nReturn true if path is a mount point, false otherwise.\n\n\n\n\n\n"},{"title":"Base.Filesystem.ispath","page":"Filesystem","location":"base/file.html#Base.Filesystem.ispath","category":"function","text":"ispath(path)::Bool\nispath(path_elements...)::Bool\n\nReturn true if a valid filesystem entity exists at path,\notherwise returns false.\n\nThis is the generalization of isfile, isdir etc.\n\n\n\n\n\n"},{"title":"Base.Filesystem.issetgid","page":"Filesystem","location":"base/file.html#Base.Filesystem.issetgid","category":"function","text":"issetgid(path)::Bool\nissetgid(path_elements...)::Bool\nissetgid(stat_struct)::Bool\n\nReturn true if the file at path or file descriptor stat_struct have the setgid flag set, false otherwise.\n\n\n\n\n\n"},{"title":"Base.Filesystem.issetuid","page":"Filesystem","location":"base/file.html#Base.Filesystem.issetuid","category":"function","text":"issetuid(path)::Bool\nissetuid(path_elements...)::Bool\nissetuid(stat_struct)::Bool\n\nReturn true if the file at path or file descriptor stat_struct have the setuid flag set, false otherwise.\n\n\n\n\n\n"},{"title":"Base.Filesystem.issocket","page":"Filesystem","location":"base/file.html#Base.Filesystem.issocket","category":"function","text":"issocket(path)::Bool\nissocket(path_elements...)::Bool\n\nReturn true if path points to a socket, false otherwise.\n\n\n\n\n\n"},{"title":"Base.Filesystem.issticky","page":"Filesystem","location":"base/file.html#Base.Filesystem.issticky","category":"function","text":"issticky(path)::Bool\nissticky(path_elements...)::Bool\nissticky(stat_struct)::Bool\n\nReturn true if the file at path or file descriptor stat_struct have the sticky bit set, false otherwise.\n\n\n\n\n\n"},{"title":"Base.Filesystem.homedir","page":"Filesystem","location":"base/file.html#Base.Filesystem.homedir","category":"function","text":"homedir()::String\n\nReturn the current user's home directory.\n\nnote: Note\nhomedir determines the home directory via libuv's uv_os_homedir. For details\n(for example on how to specify the home directory via environment variables), see the\nuv_os_homedir documentation.\n\nSee also Sys.username.\n\n\n\n\n\n"},{"title":"Base.Filesystem.dirname","page":"Filesystem","location":"base/file.html#Base.Filesystem.dirname","category":"function","text":"dirname(path::AbstractString)::String\n\nGet the directory part of a path. Trailing characters ('/' or '') in the path are\ncounted as part of the path.\n\nExamples\n\njulia> dirname(\"/home/myuser\")\n\"/home\"\n\njulia> dirname(\"/home/myuser/\")\n\"/home/myuser\"\n\nSee also basename.\n\n\n\n\n\n"},{"title":"Base.Filesystem.basename","page":"Filesystem","location":"base/file.html#Base.Filesystem.basename","category":"function","text":"basename(path::AbstractString)::String\n\nGet the file name part of a path.\n\nnote: Note\nThis function differs slightly from the Unix basename program, where trailing slashes are ignored,\ni.e. $ basename /foo/bar/ returns bar, whereas basename in Julia returns an empty string \"\".\n\nExamples\n\njulia> basename(\"/home/myuser/example.jl\")\n\"example.jl\"\n\njulia> basename(\"/home/myuser/\")\n\"\"\n\nSee also dirname.\n\n\n\n\n\n"},{"title":"Base.Filesystem.isabspath","page":"Filesystem","location":"base/file.html#Base.Filesystem.isabspath","category":"function","text":"isabspath(path::AbstractString)::Bool\n\nDetermine whether a path is absolute (begins at the root directory).\n\nExamples\n\njulia> isabspath(\"/home\")\ntrue\n\njulia> isabspath(\"home\")\nfalse\n\n\n\n\n\n"},{"title":"Base.Filesystem.isdirpath","page":"Filesystem","location":"base/file.html#Base.Filesystem.isdirpath","category":"function","text":"isdirpath(path::AbstractString)::Bool\n\nDetermine whether a path refers to a directory (for example, ends with a path separator).\n\nExamples\n\njulia> isdirpath(\"/home\")\nfalse\n\njulia> isdirpath(\"/home/\")\ntrue\n\n\n\n\n\n"},{"title":"Base.Filesystem.joinpath","page":"Filesystem","location":"base/file.html#Base.Filesystem.joinpath","category":"function","text":"joinpath(parts::AbstractString...)::String\njoinpath(parts::Vector{AbstractString})::String\njoinpath(parts::Tuple{AbstractString})::String\n\nJoin path components into a full path. If some argument is an absolute path or\n(on Windows) has a drive specification that doesn't match the drive computed for\nthe join of the preceding paths, then prior components are dropped.\n\nNote on Windows since there is a current directory for each drive, joinpath(\"c:\", \"foo\")\nrepresents a path relative to the current directory on drive \"c:\" so this is equal to \"c:foo\",\nnot \"c:\\foo\". Furthermore, joinpath treats this as a non-absolute path and ignores the drive\nletter casing, hence joinpath(\"C:\\\\A\",\"c:b\") = \"C:\\\\A\\\\b\".\n\nExamples\n\njulia> joinpath(\"/home/myuser\", \"example.jl\")\n\"/home/myuser/example.jl\"\n\njulia> joinpath([\"/home/myuser\", \"example.jl\"])\n\"/home/myuser/example.jl\"\n\n\n\n\n\n"},{"title":"Base.Filesystem.abspath","page":"Filesystem","location":"base/file.html#Base.Filesystem.abspath","category":"function","text":"abspath(path::AbstractString, paths::AbstractString...)::String\n\nConvert a set of paths to an absolute path by joining them together and adding the\ncurrent directory if necessary. Equivalent to abspath(joinpath(path, paths...)).\n\n\n\n\n\nabspath(path::AbstractString)::String\n\nConvert a path to an absolute path by adding the current directory if necessary.\nAlso normalizes the path as in normpath.\n\nExamples\n\nIf you are in a directory called JuliaExample and the data you are using is two levels up relative to the JuliaExample directory, you could write:\n\nabspath(\"../../data\")\n\nWhich gives a path like \"/home/JuliaUser/data/\".\n\nSee also joinpath, pwd, expanduser.\n\n\n\n\n\n"},{"title":"Base.Filesystem.normpath","page":"Filesystem","location":"base/file.html#Base.Filesystem.normpath","category":"function","text":"normpath(path::AbstractString, paths::AbstractString...)::String\n\nConvert a set of paths to a normalized path by joining them together and removing\n\".\" and \"..\" entries. Equivalent to normpath(joinpath(path, paths...)).\n\n\n\n\n\nnormpath(path::AbstractString)::String\n\nNormalize a path, removing \".\" and \"..\" entries and changing \"/\" to the canonical path separator\nfor the system.\n\nExamples\n\njulia> normpath(\"/home/myuser/../example.jl\")\n\"/home/example.jl\"\n\njulia> normpath(\"Documents/Julia\") == joinpath(\"Documents\", \"Julia\")\ntrue\n\n\n\n\n\n"},{"title":"Base.Filesystem.realpath","page":"Filesystem","location":"base/file.html#Base.Filesystem.realpath","category":"function","text":"realpath(path::AbstractString)::String\n\nCanonicalize a path by expanding symbolic links and removing \".\" and \"..\" entries.\nOn case-insensitive case-preserving filesystems (typically Mac and Windows), the\nfilesystem's stored case for the path is returned.\n\n(This function throws an exception if path does not exist in the filesystem.)\n\n\n\n\n\n"},{"title":"Base.Filesystem.relpath","page":"Filesystem","location":"base/file.html#Base.Filesystem.relpath","category":"function","text":"relpath(path::AbstractString, startpath::AbstractString = \".\")::String\n\nReturn a relative filepath to path either from the current directory or from an optional\nstart directory. This is a path computation: the filesystem is not accessed to confirm the\nexistence or nature of path or startpath.\n\nOn Windows, case sensitivity is applied to every part of the path except drive letters. If\npath and startpath refer to different drives, the absolute path of path is returned.\n\n\n\n\n\n"},{"title":"Base.Filesystem.expanduser","page":"Filesystem","location":"base/file.html#Base.Filesystem.expanduser","category":"function","text":"expanduser(path::AbstractString)::AbstractString\n\nOn Unix systems, replace a tilde character at the start of a path with the current user's home directory.\n\nSee also: contractuser.\n\n\n\n\n\n"},{"title":"Base.Filesystem.contractuser","page":"Filesystem","location":"base/file.html#Base.Filesystem.contractuser","category":"function","text":"contractuser(path::AbstractString)::AbstractString\n\nOn Unix systems, if the path starts with homedir(), replace it with a tilde character.\n\nSee also: expanduser.\n\n\n\n\n\n"},{"title":"Base.Filesystem.samefile","page":"Filesystem","location":"base/file.html#Base.Filesystem.samefile","category":"function","text":"samefile(path_a, path_b)\n\nCheck if the paths path_a and path_b refer to the same existing file or directory.\n\n\n\n\n\n"},{"title":"Base.Filesystem.splitdir","page":"Filesystem","location":"base/file.html#Base.Filesystem.splitdir","category":"function","text":"splitdir(path::AbstractString) -> (dir::AbstractString, file::AbstractString)\n\nSplit a path into a tuple of the directory name and file name.\n\nExamples\n\njulia> splitdir(\"/home/myuser\")\n(\"/home\", \"myuser\")\n\n\n\n\n\n"},{"title":"Base.Filesystem.splitdrive","page":"Filesystem","location":"base/file.html#Base.Filesystem.splitdrive","category":"function","text":"splitdrive(path::AbstractString) -> (drive::AbstractString, path::AbstractString)\n\nOn Windows, split a path into the drive letter part and the path part. On Unix systems, the\nfirst component is always the empty string.\n\n\n\n\n\n"},{"title":"Base.Filesystem.splitext","page":"Filesystem","location":"base/file.html#Base.Filesystem.splitext","category":"function","text":"splitext(path::AbstractString) -> (path_without_extension::String, extension::String)\n\nIf the last component of a path contains one or more dots, split the path into everything before the\nlast dot and everything including and after the dot. Otherwise, return a tuple of the argument\nunmodified and the empty string. \"splitext\" is short for \"split extension\".\n\nExamples\n\njulia> splitext(\"/home/myuser/example.jl\")\n(\"/home/myuser/example\", \".jl\")\n\njulia> splitext(\"/home/myuser/example.tar.gz\")\n(\"/home/myuser/example.tar\", \".gz\")\n\njulia> splitext(\"/home/my.user/example\")\n(\"/home/my.user/example\", \"\")\n\n\n\n\n\n"},{"title":"Base.Filesystem.splitpath","page":"Filesystem","location":"base/file.html#Base.Filesystem.splitpath","category":"function","text":"splitpath(path::AbstractString)::Vector{String}\n\nSplit a file path into all its path components. This is the opposite of\njoinpath. Returns an array of substrings, one for each directory or file in\nthe path, including the root directory if present.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\nExamples\n\njulia> splitpath(\"/home/myuser/example.jl\")\n4-element Vector{String}:\n \"/\"\n \"home\"\n \"myuser\"\n \"example.jl\"\n\n\n\n\n\n"},{"title":"StackTraces","page":"StackTraces","location":"base/stacktraces.html#StackTraces","category":"section","text":"The following methods and types in Base.StackTraces are not exported and need to be called e.g.\nas StackTraces.lookup(ptr)."},{"title":"Base.StackTraces.StackFrame","page":"StackTraces","location":"base/stacktraces.html#Base.StackTraces.StackFrame","category":"type","text":"StackFrame\n\nStack information representing execution context, with the following fields:\n\nfunc::Symbol\nThe name of the function containing the execution context.\nlinfo::Union{Method, Core.MethodInstance, Core.CodeInstance, Core.CodeInfo, Nothing}\nThe Method, MethodInstance, CodeInstance, or CodeInfo containing the execution context (if it could be found),\n   or nothing (for example, if the inlining was a result of macro expansion).\nfile::Symbol\nThe path to the file containing the execution context.\nline::Int\nThe line number in the file containing the execution context.\nfrom_c::Bool\nTrue if the code is from C.\ninlined::Bool\nTrue if the code is from an inlined frame.\npointer::UInt64\nRepresentation of the pointer to the execution context as returned by backtrace.\n\n\n\n\n\n"},{"title":"Base.StackTraces.StackTrace","page":"StackTraces","location":"base/stacktraces.html#Base.StackTraces.StackTrace","category":"type","text":"StackTrace\n\nAn alias for Vector{StackFrame} provided for convenience; returned by calls to\nstacktrace.\n\n\n\n\n\n"},{"title":"Base.StackTraces.stacktrace","page":"StackTraces","location":"base/stacktraces.html#Base.StackTraces.stacktrace","category":"function","text":"stacktrace([trace::Vector{Ptr{Cvoid}},] [c_funcs::Bool=false])::StackTrace\n\nReturn a stack trace in the form of a vector of StackFrames. (By default stacktrace\ndoesn't return C functions, but this can be enabled.) When called without specifying a\ntrace, stacktrace first calls backtrace.\n\n\n\n\n\n"},{"title":"Base.StackTraces.lookup","page":"StackTraces","location":"base/stacktraces.html#Base.StackTraces.lookup","category":"function","text":"lookup(pointer::Ptr{Cvoid})::Vector{StackFrame}\n\nGiven a pointer to an execution context (usually generated by a call to backtrace), looks\nup stack frame context information. Returns an array of frame information for all functions\ninlined at that point, innermost function first.\n\n\n\n\n\n"},{"title":"Base.StackTraces.remove_frames!","page":"StackTraces","location":"base/stacktraces.html#Base.StackTraces.remove_frames!","category":"function","text":"remove_frames!(stack::StackTrace, m::Module)\n\nReturn the StackTrace with all StackFrames from the provided Module removed.\n\n\n\n\n\nremove_frames!(stack::StackTrace, name::Symbol)\n\nTakes a StackTrace (a vector of StackFrames) and a function name (a Symbol) and\nremoves the StackFrame specified by the function name from the StackTrace (also removing\nall frames above the specified function). Primarily used to remove StackTraces functions\nfrom the StackTrace prior to returning it.\n\n\n\n\n\n"},{"title":"Module loading","page":"Module loading","location":"devdocs/require.html#Module-loading","category":"section","text":"Base.require is responsible for loading modules and it also manages the\nprecompilation cache. It is the implementation of the import statement."},{"title":"Experimental features","page":"Module loading","location":"devdocs/require.html#Experimental-features","category":"section","text":"The features below are experimental and not part of the stable Julia API.\nBefore building upon them inform yourself about the current thinking and whether they might change soon."},{"title":"Package loading callbacks","page":"Module loading","location":"devdocs/require.html#Package-loading-callbacks","category":"section","text":"It is possible to listen to the packages loaded by Base.require, by registering a callback.\n\nloaded_packages = Base.PkgId[]\ncallback = (pkg::Base.PkgId) -> push!(loaded_packages, pkg)\npush!(Base.package_callbacks, callback)\n\nUsing this would look something like:\n\njulia> using Example\n\njulia> loaded_packages\n1-element Vector{Base.PkgId}:\n Example [7876af07-990d-54b4-ab0e-23690620f79a]"},{"title":"Embedding Julia","page":"Embedding Julia","location":"manual/embedding.html#Embedding-Julia","category":"section","text":"As we have seen in Calling C and Fortran Code, Julia has a simple and efficient way\nto call functions written in C. But there are situations where the opposite is needed:\ncalling Julia functions from C code. This can be used to integrate Julia code into a larger\nC/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make\nthis possible. As almost all programming languages have some way to call C functions, the\nJulia C API can also be used to build further language bridges (e.g. calling Julia from\nPython, Rust or C#). Even though Rust and C++ can use the C embedding API directly, both\nhave packages helping with it, for C++ Jluna is useful."},{"title":"High-Level Embedding","page":"Embedding Julia","location":"manual/embedding.html#High-Level-Embedding","category":"section","text":"Note: This section covers embedding Julia code in C on Unix-like operating systems. For\ndoing this on Windows, please see the section following this,\nHigh-Level Embedding on Windows with Visual Studio.\n\nWe start with a simple C program that initializes Julia and calls some Julia code:\n\n#include <julia.h>\nJULIA_DEFINE_FAST_TLS // only define this once, in an executable (not in a shared library) if you want fast code.\n\nint main(int argc, char *argv[])\n{\n    /* required: setup the Julia context */\n    jl_init();\n\n    /* run Julia commands */\n    jl_eval_string(\"print(sqrt(2.0))\");\n\n    /* strongly recommended: notify Julia that the\n         program is about to terminate. this allows\n         Julia time to cleanup pending write requests\n         and run all finalizers\n    */\n    jl_atexit_hook(0);\n    return 0;\n}\n\nIn order to build this program you must add the path to the Julia header to the include path\nand link against libjulia. For instance, when Julia is installed to $JULIA_DIR, one can\ncompile the above test program test.c with gcc using:\n\ngcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib -Wl,-rpath,$JULIA_DIR/lib test.c -ljulia\n\nAlternatively, look at the embedding.c program in the Julia source tree in the test/embedding/ folder.\nThe file cli/loader_exe.c program is another simple example of how to set jl_options options while\nlinking against libjulia.\n\nThe first thing that must be done before calling any other Julia C function is to\ninitialize Julia. This is done by calling jl_init, which tries to automatically determine\nJulia's install location. If you need to specify a custom location, or specify which system\nimage to load, use jl_init_with_image_file or jl_init_with_image_handle instead.\n\nThe second statement in the test program evaluates a Julia statement using a call to jl_eval_string.\n\nBefore the program terminates, it is strongly recommended that jl_atexit_hook is called.\nThe above example program calls this just before returning from main.\n\nnote: Note\nCurrently, dynamically linking with the libjulia shared library requires passing the RTLD_GLOBAL\noption. In Python, this looks like:>>> julia=CDLL('./libjulia.dylib',RTLD_GLOBAL)\n>>> julia.jl_init.argtypes = []\n>>> julia.jl_init()\n250593296\n\nnote: Note\nIf the julia program needs to access symbols from the main executable, it may be\nnecessary to add the -Wl,--export-dynamic linker flag at compile time on Linux in\naddition to the ones generated by julia-config.jl described below. This is not\nnecessary when compiling a shared library."},{"title":"Using julia-config to automatically determine build parameters","page":"Embedding Julia","location":"manual/embedding.html#Using-julia-config-to-automatically-determine-build-parameters","category":"section","text":"The script julia-config.jl was created to aid in determining what build parameters are\nrequired by a program that uses embedded Julia. This script uses the build parameters and\nsystem configuration of the particular Julia distribution it is invoked by to export the\nnecessary compiler flags for an embedding program to interact with that distribution. This\nscript is located in the Julia shared data directory."},{"title":"Example","page":"Embedding Julia","location":"manual/embedding.html#Example","category":"section","text":"#include <julia.h>\n\nint main(int argc, char *argv[])\n{\n    jl_init();\n    (void)jl_eval_string(\"println(sqrt(2.0))\");\n    jl_atexit_hook(0);\n    return 0;\n}"},{"title":"On the command line","page":"Embedding Julia","location":"manual/embedding.html#On-the-command-line","category":"section","text":"A simple use of this script is from the command line. Assuming that julia-config.jl is\nlocated in /usr/local/julia/share/julia, it can be invoked on the command line directly\nand takes any combination of three flags:\n\n/usr/local/julia/share/julia/julia-config.jl\nUsage: julia-config [--cflags|--ldflags|--ldlibs]\n\nIf the above example source is saved in the file embed_example.c, then the following\ncommand will compile it into an executable program on Linux and Windows (MSYS2 environment).\nOn macOS, substitute clang for gcc.:\n\n/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c"},{"title":"Use in Makefiles","page":"Embedding Julia","location":"manual/embedding.html#Use-in-Makefiles","category":"section","text":"In general, embedding projects will be more complicated than the above example, and so the\nfollowing allows general makefile support as well – assuming GNU make because of the use of\nthe shell macro expansions. Furthermore, although julia-config.jl is usually in the\n/usr/local directory, if it isn't, then Julia itself can be used to find\njulia-config.jl, and the makefile can take advantage of this. The above example is\nextended to use a makefile:\n\nJL_SHARE = $(shell julia -e 'print(joinpath(Sys.BINDIR, Base.DATAROOTDIR, \"julia\"))')\nCFLAGS   += $(shell $(JL_SHARE)/julia-config.jl --cflags)\nCXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)\nLDFLAGS  += $(shell $(JL_SHARE)/julia-config.jl --ldflags)\nLDLIBS   += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)\n\nall: embed_example\n\nNow the build command is simply make."},{"title":"High-Level Embedding on Windows with Visual Studio","page":"Embedding Julia","location":"manual/embedding.html#High-Level-Embedding-on-Windows-with-Visual-Studio","category":"section","text":"If the JULIA_DIR environment variable hasn't been setup, add it using the System panel before\nstarting Visual Studio. The bin folder under JULIA_DIR should be on the system PATH.\n\nWe start by opening Visual Studio and creating a new Console Application project. Open the\n'stdafx.h' header file, and add the following lines at the end:\n\n#include <julia.h>\n\nThen, replace the main() function in the project with this code:\n\nint main(int argc, char *argv[])\n{\n    /* required: setup the Julia context */\n    jl_init();\n\n    /* run Julia commands */\n    jl_eval_string(\"print(sqrt(2.0))\");\n\n    /* strongly recommended: notify Julia that the\n         program is about to terminate. this allows\n         Julia time to cleanup pending write requests\n         and run all finalizers\n    */\n    jl_atexit_hook(0);\n    return 0;\n}\n\nThe next step is to set up the project to find the Julia include files and the libraries. It's important to\nknow whether the Julia installation is 32- or 64-bit. Remove any platform configuration that doesn't correspond\nto the Julia installation before proceeding.\n\nUsing the project Properties dialog, go to C/C++ | General and add $(JULIA_DIR)\\include\\julia\\ to the\nAdditional Include Directories property. Then, go to the Linker | General section and add $(JULIA_DIR)\\lib\nto the Additional Library Directories property. Finally, under Linker | Input, add libjulia.dll.a;libopenlibm.dll.a;\nto the list of libraries.\n\nAt this point, the project should build and run."},{"title":"Converting Types","page":"Embedding Julia","location":"manual/embedding.html#Converting-Types","category":"section","text":"Real applications will not only need to execute expressions, but also return their values to\nthe host program. jl_eval_string returns a jl_value_t*, which is a pointer to a\nheap-allocated Julia object. Storing simple data types like Float64 in this way is\ncalled boxing, and extracting the stored primitive data is called unboxing. Our improved\nsample program that calculates the square root of 2 in Julia and reads back the result in C\nhas a body that now contains this code:\n\njl_value_t *ret = jl_eval_string(\"sqrt(2.0)\");\n\nif (jl_typeis(ret, jl_float64_type)) {\n    double ret_unboxed = jl_unbox_float64(ret);\n    printf(\"sqrt(2.0) in C: %e \\n\", ret_unboxed);\n}\nelse {\n    printf(\"ERROR: unexpected return type from sqrt(::Float64)\\n\");\n}\n\nIn order to check whether ret is of a specific Julia type, we can use the\njl_isa, jl_typeis, or jl_is_... functions.\nBy typing typeof(sqrt(2.0)) into the Julia shell we can see that the return type is\nFloat64 (double in C). To convert the boxed Julia value into a C double the\njl_unbox_float64 function is used in the above code snippet.\n\nCorresponding jl_box_... functions are used to convert the other way:\n\njl_value_t *a = jl_box_float64(3.0);\njl_value_t *b = jl_box_float32(3.0f);\njl_value_t *c = jl_box_int32(3);\n\nAs we will see next, boxing is required to call Julia functions with specific arguments."},{"title":"Calling Julia Functions","page":"Embedding Julia","location":"manual/embedding.html#Calling-Julia-Functions","category":"section","text":"While jl_eval_string allows C to obtain the result of a Julia expression, it does not allow\npassing arguments computed in C to Julia. For this you will need to invoke Julia functions directly,\nusing jl_call:\n\njl_value_t *func = jl_get_function(jl_base_module, \"sqrt\");\njl_value_t *argument = jl_box_float64(2.0);\njl_value_t *ret = jl_call1(func, argument);\n\nIn the first step, a handle to the Julia function sqrt is retrieved by calling jl_get_function.\nThe first argument passed to jl_get_function is a pointer to the Base module in which sqrt\nis defined. Then, the double value is boxed using jl_box_float64. Finally, in the last step,\nthe function is called using jl_call1. jl_call0, jl_call2, and jl_call3 functions also\nexist, to conveniently handle different numbers of arguments. To pass more arguments, use jl_call:\n\njl_value_t *jl_call(jl_value_t *f, jl_value_t **args, int32_t nargs)\n\nIts second argument args is an array of jl_value_t* arguments and nargs is the number of\narguments.\n\nThere is also an alternative, possibly simpler, way of calling Julia functions and that is via @cfunction.\nUsing @cfunction allows you to do the type conversions on the Julia side, which is typically easier than doing it on\nthe C side. The sqrt example above would with @cfunction be written as:\n\ndouble (*sqrt_jl)(double) = jl_unbox_voidpointer(jl_eval_string(\"@cfunction(sqrt, Float64, (Float64,))\"));\ndouble ret = sqrt_jl(2.0);\n\nwhere we first define a C callable function in Julia, extract the function pointer from it, and finally call it.\nIn addition to simplifying type conversions by doing them in the higher-level language, calling Julia functions\nvia @cfunction pointers eliminates the dynamic-dispatch overhead required by jl_call (for which all of the\narguments are \"boxed\"), and should have performance equivalent to native C function pointers."},{"title":"Memory Management","page":"Embedding Julia","location":"manual/embedding.html#Memory-Management","category":"section","text":"As we have seen, Julia objects are represented in C as pointers of type jl_value_t*. This raises the question of who\nis responsible for freeing these objects.\n\nTypically, Julia objects are freed by the garbage collector (GC), but the GC does not automatically\nknow that we are holding a reference to a Julia value from C. This means the GC can free objects\nout from under you, rendering pointers invalid.\n\nThe GC will only run when new Julia objects are being allocated. Calls like jl_box_float64 perform allocation,\nbut allocation might also happen at any point in running Julia code.\n\nWhen writing code that embeds Julia, it is generally safe to use jl_value_t* values in between jl_... calls\n(as GC will only get triggered by those calls). But in order to make sure that values can survive\njl_... calls, we have to tell Julia that we still hold a reference to Julia\nroot values, a process\ncalled \"GC rooting\". Rooting a value will ensure that the garbage collector does not accidentally\nidentify this value as unused and free the memory backing that value. This can be done using the\nJL_GC_PUSH macros:\n\njl_value_t *ret = jl_eval_string(\"sqrt(2.0)\");\nJL_GC_PUSH1(&ret);\n// Do something with ret\nJL_GC_POP();\n\nThe JL_GC_POP call releases the references established by the previous JL_GC_PUSH. Note that\nJL_GC_PUSH stores references on the C stack, so it must be exactly paired with a JL_GC_POP\nbefore the scope is exited. That is, before the function returns, or control flow otherwise\nleaves the block in which the JL_GC_PUSH was invoked.\n\nSeveral Julia values can be pushed at once using the JL_GC_PUSH2 to JL_GC_PUSH6 macros:\n\nJL_GC_PUSH2(&ret1, &ret2);\n// ...\nJL_GC_PUSH6(&ret1, &ret2, &ret3, &ret4, &ret5, &ret6);\n\nTo push an array of Julia values one can use the JL_GC_PUSHARGS macro, which can be used as follows:\n\njl_value_t **args;\nJL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects\nargs[0] = some_value;\nargs[1] = some_other_value;\n// Do something with args (e.g. call jl_... functions)\nJL_GC_POP();\n\nEach scope must have only one call to JL_GC_PUSH*, and should be paired with only a single JL_GC_POP call.\nIf all necessary variables you want to root cannot be pushed by a one single call to JL_GC_PUSH*, or if there are more than 6 variables to be pushed and using an array\nof arguments is not an option, then one can use inner blocks:\n\njl_value_t *ret1 = jl_eval_string(\"sqrt(2.0)\");\nJL_GC_PUSH1(&ret1);\njl_value_t *ret2 = 0;\n{\n    jl_value_t *func = jl_get_function(jl_base_module, \"exp\");\n    ret2 = jl_call1(func, ret1);\n    JL_GC_PUSH1(&ret2);\n    // Do something with ret2.\n    JL_GC_POP();    // This pops ret2.\n}\nJL_GC_POP();    // This pops ret1.\n\nNote that it is not necessary to have valid jl_value_t* values before calling\nJL_GC_PUSH*. It is fine to have a number of them initialized to NULL, pass those\nto JL_GC_PUSH* and then create the actual Julia values. For example:\n\njl_value_t *ret1 = NULL, *ret2 = NULL;\nJL_GC_PUSH2(&ret1, &ret2);\nret1 = jl_eval_string(\"sqrt(2.0)\");\nret2 = jl_eval_string(\"sqrt(3.0)\");\n// Use ret1 and ret2\nJL_GC_POP();\n\nIf it is required to hold the pointer to a variable between functions (or block scopes), then it is\nnot possible to use JL_GC_PUSH*. In this case, it is necessary to create and keep a reference to the\nvariable in the Julia global scope. One simple way to accomplish this is to use a global IdDict that\nwill hold the references, avoiding deallocation by the GC. However, this method will only work\nproperly with mutable types.\n\n// This functions shall be executed only once, during the initialization.\njl_value_t* refs = jl_eval_string(\"refs = IdDict()\");\njl_value_t* setindex = jl_get_function(jl_base_module, \"setindex!\");\n\n...\n\n// `var` is the variable we want to protect between function calls.\njl_value_t* var = 0;\n\n...\n\n// `var` is a `Vector{Float64}`, which is mutable.\nvar = jl_eval_string(\"[sqrt(2.0); sqrt(4.0); sqrt(6.0)]\");\n\n// To protect `var`, add its reference to `refs`.\njl_call3(setindex, refs, var, var);\n\nIf the variable is immutable, then it needs to be wrapped in an equivalent mutable container or,\npreferably, in a RefValue{Any} before it is pushed to IdDict. In this approach, the container has\nto be created or filled in via C code using, for example, the function jl_new_struct. If the\ncontainer is created by jl_call*, then you will need to reload the pointer to be used in C code.\n\n// This functions shall be executed only once, during the initialization.\njl_value_t* refs = jl_eval_string(\"refs = IdDict()\");\njl_value_t* setindex = jl_get_function(jl_base_module, \"setindex!\");\njl_datatype_t* reft = (jl_datatype_t*)jl_eval_string(\"Base.RefValue{Any}\");\n\n...\n\n// `var` is the variable we want to protect between function calls.\njl_value_t* var = 0;\n\n...\n\n// `var` is a `Float64`, which is immutable.\nvar = jl_eval_string(\"sqrt(2.0)\");\n\n// Protect `var` until we add its reference to `refs`.\nJL_GC_PUSH1(&var);\n\n// Wrap `var` in `RefValue{Any}` and push to `refs` to protect it.\njl_value_t* rvar = jl_new_struct(reft, var);\nJL_GC_POP();\n\njl_call3(setindex, refs, rvar, rvar);\n\nThe GC can be allowed to deallocate a variable by removing the reference to it from refs using\nthe function delete!, provided that no other reference to the variable is kept anywhere:\n\njl_value_t* delete = jl_get_function(jl_base_module, \"delete!\");\njl_call2(delete, refs, rvar);\n\nAs an alternative for very simple cases, it is possible to just create a global container of type\nVector{Any} and fetch the elements from that when necessary, or even to create one global variable\nper pointer using\n\njl_module_t *mod = jl_main_module;\njl_sym_t *var = jl_symbol(\"var\");\njl_binding_t *bp = jl_get_binding_wr(mod, var, 1);\njl_checked_assignment(bp, mod, var, val);"},{"title":"Updating fields of GC-managed objects","page":"Embedding Julia","location":"manual/embedding.html#Updating-fields-of-GC-managed-objects","category":"section","text":"The garbage collector also operates under the assumption that it is aware of every\nolder-generation object pointing to a younger-generation one. Any time a pointer is updated\nbreaking that assumption, it must be signaled to the collector with the jl_gc_wb (write\nbarrier) function like so:\n\njl_value_t *parent = some_old_value, *child = some_young_value;\n((some_specific_type*)parent)->field = child;\njl_gc_wb(parent, child);\n\nIt is in general impossible to predict which values will be old at runtime, so the write\nbarrier must be inserted after all explicit stores. One notable exception is if the parent\nobject has just been allocated and no garbage collection has run since then. Note that most\njl_... functions can sometimes invoke garbage collection.\n\nThe write barrier is also necessary for arrays of pointers when updating their data directly.\nCalling jl_array_ptr_set is usually much preferred. But direct updates can be done. For example:\n\njl_array_t *some_array = ...; // e.g. a Vector{Any}\nvoid **data = jl_array_data(some_array, void*);\njl_value_t *some_value = ...;\ndata[0] = some_value;\njl_gc_wb(jl_array_owner(some_array), some_value);"},{"title":"Controlling the Garbage Collector","page":"Embedding Julia","location":"manual/embedding.html#Controlling-the-Garbage-Collector","category":"section","text":"There are some functions to control the GC. In normal use cases, these should not be necessary.\n\nFunction Description\njl_gc_collect(JL_GC_FULL) Force a GC run on all objects\njl_gc_collect(JL_GC_INCREMENTAL) Force a GC run only on young objects\njl_gc_collect(JL_GC_AUTO) Force a GC run, automatically choosing between full and incremental\njl_gc_enable(0) Disable the GC, return previous state as int\njl_gc_enable(1) Enable the GC, return previous state as int\njl_gc_is_enabled() Return current state as int"},{"title":"Working with Arrays","page":"Embedding Julia","location":"manual/embedding.html#Working-with-Arrays","category":"section","text":"Julia and C can share array data without copying. The next example will show how this works.\n\nJulia arrays are represented in C by the datatype jl_array_t*. Basically, jl_array_t is a\nstruct that contains:\n\nInformation about the datatype\nA pointer to the data block\nInformation about the sizes of the array\n\nTo keep things simple, we start with a 1D array. Creating an array containing Float64\nelements of length 10 can be done like this:\n\njl_value_t* array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 1);\njl_array_t* x          = jl_alloc_array_1d(array_type, 10);\n\nAlternatively, if you have already allocated the array you can generate a thin wrapper around\nits data:\n\ndouble *existingArray = (double*)malloc(sizeof(double)*10);\njl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);\n\nThe last argument is a boolean indicating whether Julia should take ownership of the data. If\nthis argument is non-zero, the GC will call free on the data pointer when the array is no longer\nreferenced.\n\nIn order to access the data of x, we can use jl_array_data:\n\ndouble *xData = jl_array_data(x, double);\n\nNow we can fill the array:\n\nfor (size_t i = 0; i < jl_array_nrows(x); i++)\n    xData[i] = i;\n\nNow let us call a Julia function that performs an in-place operation on x:\n\njl_value_t *func = jl_get_function(jl_base_module, \"reverse!\");\njl_call1(func, (jl_value_t*)x);\n\nBy printing the array, one can verify that the elements of x are now reversed."},{"title":"Accessing Returned Arrays","page":"Embedding Julia","location":"manual/embedding.html#Accessing-Returned-Arrays","category":"section","text":"If a Julia function returns an array, the return value of jl_eval_string and jl_call can be\ncast to a jl_array_t*:\n\njl_value_t *func  = jl_get_function(jl_base_module, \"reverse\");\njl_array_t *y = (jl_array_t*)jl_call1(func, (jl_value_t*)x);\n\nNow the content of y can be accessed as before using jl_array_data. As always, be sure to\nkeep a reference to the array while it is in use."},{"title":"Multidimensional Arrays","page":"Embedding Julia","location":"manual/embedding.html#Multidimensional-Arrays","category":"section","text":"Julia's multidimensional arrays are stored in memory in column-major order. Here is some code\nthat creates a 2D array and accesses its properties:\n\n// Create 2D array of float64 type\njl_value_t *array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 2);\nint dims[] = {10,5};\njl_array_t *x  = jl_alloc_array_nd(array_type, dims, 2);\n\n// Get array pointer\ndouble *p = jl_array_data(x, double);\n// Get number of dimensions\nint ndims = jl_array_ndims(x);\n// Get the size of the i-th dim\nsize_t size0 = jl_array_dim(x,0);\nsize_t size1 = jl_array_dim(x,1);\n\n// Fill array with data\nfor(size_t i=0; i<size1; i++)\n    for(size_t j=0; j<size0; j++)\n        p[j + size0*i] = i + j;\n\nNotice that while Julia arrays use 1-based indexing, the C API uses 0-based indexing (for example\nin calling jl_array_dim) in order to read as idiomatic C code."},{"title":"Exceptions","page":"Embedding Julia","location":"manual/embedding.html#Exceptions","category":"section","text":"Julia code can throw exceptions. For example, consider:\n\njl_eval_string(\"this_function_does_not_exist()\");\n\nThis call will appear to do nothing. However, it is possible to check whether an exception was\nthrown:\n\nif (jl_exception_occurred())\n    printf(\"%s \\n\", jl_typeof_str(jl_exception_occurred()));\n\nIf you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++),\nit makes sense to wrap each call into libjulia with a function that checks whether an exception\nwas thrown, and then rethrows the exception in the host language."},{"title":"Throwing Julia Exceptions","page":"Embedding Julia","location":"manual/embedding.html#Throwing-Julia-Exceptions","category":"section","text":"When writing Julia callable functions, it might be necessary to validate arguments and throw exceptions\nto indicate errors. A typical type check looks like:\n\nif (!jl_typeis(val, jl_float64_type)) {\n    jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);\n}\n\nGeneral exceptions can be raised using the functions:\n\nvoid jl_error(const char *str);\nvoid jl_errorf(const char *fmt, ...);\n\njl_error takes a C string, and jl_errorf is called like printf:\n\njl_errorf(\"argument x = %d is too large\", x);\n\nwhere in this example x is assumed to be an integer."},{"title":"Thread-safety","page":"Embedding Julia","location":"manual/embedding.html#Thread-safety","category":"section","text":"In general, the Julia C API is not fully thread-safe. When embedding Julia in a multi-threaded application care needs to be taken not to violate\nthe following restrictions:\n\njl_init() may only be called once in the application life-time. The same applies to jl_atexit_hook(), and it may only be called after jl_init().\njl_...() API functions may only be called from the thread in which jl_init() was called, or from threads started by the Julia runtime. Calling Julia API functions from user-started threads is not supported, and may lead to undefined behaviour and crashes.\n\nThe second condition above implies that you can not safely call jl_...() functions from threads that were not started by Julia (the thread calling jl_init() being the exception). For example, the following is not supported and will most likely segfault:\n\nvoid *func(void*)\n{\n    // Wrong, jl_eval_string() called from thread that was not started by Julia\n    jl_eval_string(\"println(Threads.threadid())\");\n    return NULL;\n}\n\nint main()\n{\n    pthread_t t;\n\n    jl_init();\n\n    // Start a new thread\n    pthread_create(&t, NULL, func, NULL);\n    pthread_join(t, NULL);\n\n    jl_atexit_hook(0);\n}\n\nInstead, performing all Julia calls from the same user-created thread will work:\n\nvoid *func(void*)\n{\n    // Okay, all jl_...() calls from the same thread,\n    // even though it is not the main application thread\n    jl_init();\n    jl_eval_string(\"println(Threads.threadid())\");\n    jl_atexit_hook(0);\n    return NULL;\n}\n\nint main()\n{\n    pthread_t t;\n    // Create a new thread, which runs func()\n    pthread_create(&t, NULL, func, NULL);\n    pthread_join(t, NULL);\n}\n\nAn example of calling the Julia C API from a thread started by Julia itself:\n\n#include <julia/julia.h>\nJULIA_DEFINE_FAST_TLS\n\ndouble c_func(int i)\n{\n    printf(\"[C %08x] i = %d\\n\", pthread_self(), i);\n\n    // Call the Julia sqrt() function to compute the square root of i, and return it\n    jl_value_t *sqrt = jl_get_function(jl_base_module, \"sqrt\");\n    jl_value_t* arg = jl_box_int32(i);\n    double ret = jl_unbox_float64(jl_call1(sqrt, arg));\n\n    return ret;\n}\n\nint main()\n{\n    jl_init();\n\n    // Define a Julia function func() that calls our c_func() defined in C above\n    jl_eval_string(\"func(i) = ccall(:c_func, Float64, (Int32,), i)\");\n\n    // Call func() multiple times, using multiple threads to do so\n    jl_eval_string(\"println(Threads.threadpoolsize())\");\n    jl_eval_string(\"use(i) = println(\\\"[J $(Threads.threadid())] i = $(i) -> $(func(i))\\\")\");\n    jl_eval_string(\"Threads.@threads for i in 1:5 use(i) end\");\n\n    jl_atexit_hook(0);\n}\n\nIf we run this code with 2 Julia threads we get the following output (note: the output will vary per run and system):\n\n$ JULIA_NUM_THREADS=2 ./thread_example\n2\n[C 3bfd9c00] i = 1\n[C 23938640] i = 4\n[J 1] i = 1 -> 1.0\n[C 3bfd9c00] i = 2\n[J 1] i = 2 -> 1.4142135623730951\n[C 3bfd9c00] i = 3\n[J 2] i = 4 -> 2.0\n[C 23938640] i = 5\n[J 1] i = 3 -> 1.7320508075688772\n[J 2] i = 5 -> 2.23606797749979\n\nAs can be seen, Julia thread 1 corresponds to pthread ID 3bfd9c00, and Julia thread 2 corresponds to ID 23938640, showing that indeed multiple threads are used at the C level, and that we can safely call Julia C API routines from those threads."},{"title":"Installation","page":"Installation","location":"manual/installation.html#man-installation","category":"section","text":"There are many ways to install Julia. The following sections highlight the\nrecommended method for each of the main supported platforms, and then present\nalternative ways that might be useful in specialized situations.\n\nThe current installation recommendation is a solution based on Juliaup. If you\ninstalled Julia previously with a method that is not based on Juliaup and want\nto switch your system to an installation that is based on Juliaup, we recommend\nthat you uninstall all previous Julia versions, ensure that you remove anything\nJulia related from your PATH variable and then install Julia with one of the\nmethods described below."},{"title":"Windows","page":"Installation","location":"manual/installation.html#Windows","category":"section","text":"On Windows Julia can be installed directly from the Windows store\nhere. One can also install\nexactly the same version by executing\n\nwinget install --name Julia --id 9NJNWW8PVKMN -e -s msstore\n\nin any shell."},{"title":"Mac and Linux","page":"Installation","location":"manual/installation.html#Mac-and-Linux","category":"section","text":"Julia can be installed on Linux or Mac by executing\n\ncurl -fsSL https://install.julialang.org | sh\n\nin a shell."},{"title":"Command line arguments","page":"Installation","location":"manual/installation.html#Command-line-arguments","category":"section","text":"One can pass various command line arguments to the Julia installer. The syntax\nfor installer arguments is\n\ncurl -fsSL https://install.julialang.org | sh -s -- <ARGS>\n\nHere <ARGS> should be replaced with one or more of the following arguments:\n\n--yes (or -y): Run the installer in a non-interactive mode. All\nconfiguration values use their default or a value supplied as a command line\nargument.\n--default-channel=<NAME>: Configure the default Juliaup channel. For\nexample --default-channel lts would install the lts channel and configure it\nas the default.\n--add-to-path=<yes|no>: Configure whether Julia should be added to the PATH\nenvironment variable. Valid values are yes (default) and no.\n--background-selfupdate=<SECONDS>: Configure an optional CRON job that\nauto-updates Juliaup if <SECONDS> has a value larger than 0. The actual value\ncontrols how often the CRON job will run to check for a new Juliaup version in\nseconds. The default value is 0, i.e. no CRON job will be created.\n--startup-selfupdate=<MINUTES>: Configure how often Julia will check for new\nversions of Juliaup when Julia is started. The default is every 1440 minutes.\n-p=<PATH> (or --path): Configure where the Julia and Juliaup binaries are\ninstalled. The default is ~/.juliaup."},{"title":"Alternative installation methods","page":"Installation","location":"manual/installation.html#Alternative-installation-methods","category":"section","text":"Note that we recommend the following methods only if none of the installation\nmethods described above work for your system.\n\nSome of the installation methods described below recommend installing a package\ncalled juliaup. Note that this nevertheless installs a fully functional\nJulia system, not just Juliaup."},{"title":"App Installer (Windows)","page":"Installation","location":"manual/installation.html#App-Installer-(Windows)","category":"section","text":"If the Windows Store is blocked on a system, we have an alternative\nMSIX App Installer\nbased setup. To use the App Installer version, download\nthis file and open it by\ndouble clicking on it. One can also install exactly the same version by executing\nthe PowerShell command\n\nAdd-AppxPackage -AppInstallerFile https://install.julialang.org/Julia.appinstaller"},{"title":"MSI Installer (Windows)","page":"Installation","location":"manual/installation.html#MSI-Installer-(Windows)","category":"section","text":"If neither the Windows Store nor the App Installer version work on your Windows\nsystem, you can also use a MSI based installer. Note that this installation\nmethods comes with serious limitations and is generally not recommended unless\nno other method works. For example, there is no automatic update mechanism for\nJuliaup with this installation method. The 64 bit version of the MSI installer\ncan be downloaded from here and\nthe 32 bit version from here.\n\nBy default the install will be a per-user install that does not require\n elevation. You can also do a system install by running the following command\n from a shell:\n\nmsiexec /i <PATH_TO_JULIA_MSI> ALLUSERS=1"},{"title":"Homebrew (Mac and Linux)","page":"Installation","location":"manual/installation.html#[Homebrew](https://brew.sh)-(Mac-and-Linux)","category":"section","text":"On systems with brew, you can install Julia by running\n\nbrew install juliaup\n\nin a shell. Note that you will have to update Juliaup with standard brew\ncommands."},{"title":"Arch Linux - AUR (Linux)","page":"Installation","location":"manual/installation.html#[Arch-Linux-AUR](https://aur.archlinux.org/packages/juliaup/)-(Linux)","category":"section","text":"On Arch Linux, Juliaup is available in the Arch User Repository (AUR)."},{"title":"openSUSE Tumbleweed (Linux)","page":"Installation","location":"manual/installation.html#[openSUSE-Tumbleweed](https://get.opensuse.org/tumbleweed/)-(Linux)","category":"section","text":"On openSUSE Tumbleweed, you can install Julia by running\n\nzypper install juliaup\n\nin a shell with root privileges."},{"title":"cargo (Windows, Mac and Linux)","page":"Installation","location":"manual/installation.html#[cargo](https://crates.io/crates/juliaup/)-(Windows,-Mac-and-Linux)","category":"section","text":"To install Julia via Rust's cargo, run:\n\ncargo install juliaup"},{"title":"Parallel Computing","page":"Parallel Computing","location":"manual/parallel-computing.html#Parallel-Computing","category":"section","text":"Julia supports these four categories of concurrent and parallel programming:\n\nAsynchronous \"tasks\", or coroutines:\nJulia Tasks allow suspending and resuming computations\n for I/O, event handling, producer-consumer processes, and similar patterns.\n Tasks can synchronize through operations like wait and fetch, and\n communicate via Channels. While strictly not parallel computing by themselves,\n Julia lets you schedule Tasks on several threads.\nMulti-threading:\nJulia's multi-threading provides the ability to schedule Tasks\n simultaneously on more than one thread or CPU core, sharing memory. This is usually the easiest way\n to get parallelism on one's PC or on a single large multi-core server. Julia's multi-threading\n is composable. When one multi-threaded function calls another multi-threaded function, Julia\n will schedule all the threads globally on available resources, without oversubscribing.\nDistributed computing:\nDistributed computing runs multiple Julia processes with separate memory spaces. These can be on the same\n computer or multiple computers. The Distributed standard library provides the capability for remote execution\n of a Julia function. With this basic building block, it is possible to build many different kinds of\n distributed computing abstractions. Packages like DistributedArrays.jl\n are an example of such an abstraction. On the other hand, packages like MPI.jl and\n Elemental.jl provide access to the existing MPI ecosystem of libraries.\nGPU computing:\nThe Julia GPU compiler provides the ability to run Julia code natively on GPUs. There\n is a rich ecosystem of Julia packages that target GPUs. The JuliaGPU.org\n website provides a list of capabilities, supported GPUs, related packages and documentation."},{"title":"Profiling","page":"Profiling","location":"manual/profile.html#Profiling","category":"section","text":"The Profile module provides tools to help developers improve the performance of their\ncode. When used, it takes measurements on running code, and produces output that helps you understand\nhow much time is spent on individual line(s). The most common usage is to identify \"bottlenecks\"\nas targets for optimization.\n\nProfile implements what is known as a \"sampling\" or statistical profiler.\n It works by periodically taking a backtrace during the execution of any task. Each backtrace\ncaptures the currently-running function and line number, plus the complete chain of function calls\nthat led to this line, and hence is a \"snapshot\" of the current state of execution.\n\nIf much of your run time is spent executing a particular line of code, this line will show up\nfrequently in the set of all backtraces. In other words, the \"cost\" of a given line–or really,\nthe cost of the sequence of function calls up to and including this line–is proportional to how\noften it appears in the set of all backtraces.\n\nA sampling profiler does not provide complete line-by-line coverage, because the backtraces occur\nat intervals (by default, 1 ms on Unix systems and 10 ms on Windows, although the actual scheduling\nis subject to operating system load). Moreover, as discussed further below, because samples are\ncollected at a sparse subset of all execution points, the data collected by a sampling profiler\nis subject to statistical noise.\n\nDespite these limitations, sampling profilers have substantial strengths:\n\nYou do not have to make any modifications to your code to take timing measurements.\nIt can profile into Julia's core code and even (optionally) into C and Fortran libraries.\nBy running \"infrequently\" there is very little performance overhead; while profiling, your code\ncan run at nearly native speed.\n\nFor these reasons, it's recommended that you try using the built-in sampling profiler before considering\nany alternatives."},{"title":"Basic usage","page":"Profiling","location":"manual/profile.html#Basic-usage","category":"section","text":"Let's work with a simple test case:\n\njulia> function myfunc()\n           A = rand(200, 200, 400)\n           maximum(A)\n       end\n\nIt's a good idea to first run the code you intend to profile at least once (unless you want to\nprofile Julia's JIT-compiler):\n\njulia> myfunc() # run once to force compilation\n\nNow we're ready to profile this function:\n\njulia> using Profile\n\njulia> @profile myfunc()\n\nTo see the profiling results, there are several graphical browsers.\nOne \"family\" of visualizers is based on FlameGraphs.jl, with each family member providing a different user interface:\n\nVS Code is a full IDE with built-in support for profile visualization\nProfileView.jl is a stand-alone visualizer based on GTK\nProfileVega.jl uses VegaLight and integrates well with Jupyter notebooks\nStatProfilerHTML.jl produces HTML and presents some additional summaries, and also integrates well with Jupyter notebooks\nProfileSVG.jl renders SVG\nPProf.jl serves a local website for inspecting graphs, flamegraphs and more\nProfileCanvas.jl is a HTML canvas based profile viewer UI, used by the Julia VS Code extension, but can also generate interactive HTML files.\n\nAn entirely independent approach to profile visualization is PProf.jl, which uses the external pprof tool.\n\nHere, though, we'll use the text-based display that comes with the standard library:\n\njulia> Profile.print()\n80 ./event.jl:73; (::Base.REPL.##1#2{Base.REPL.REPLBackend})()\n 80 ./REPL.jl:97; macro expansion\n  80 ./REPL.jl:66; eval_user_input(::Any, ::Base.REPL.REPLBackend)\n   80 ./boot.jl:235; eval(::Module, ::Any)\n    80 ./<missing>:?; anonymous\n     80 ./profile.jl:23; macro expansion\n      52 ./REPL[1]:2; myfunc()\n       38 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type{B...\n        38 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr{F...\n       14 ./random.jl:278; rand\n        14 ./random.jl:277; rand\n         14 ./random.jl:366; rand\n          14 ./random.jl:369; rand\n      28 ./REPL[1]:3; myfunc()\n       28 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinear,...\n        3  ./reduce.jl:426; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...\n        25 ./reduce.jl:428; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...\n\nEach line of this display represents a particular spot (line number) in the code. Indentation\nis used to indicate the nested sequence of function calls, with more-indented lines being deeper\nin the sequence of calls. In each line, the first \"field\" is the number of backtraces\n(samples) taken at this line or in any functions executed by this line.\nThe second field is the file name and line number and the third field is the function name.\nNote that the specific line numbers may change as Julia's\ncode changes; if you want to follow along, it's best to run this example yourself.\n\nIn this example, we can see that the top level function called is in the file event.jl. This is the\nfunction that runs the REPL when you launch Julia. If you examine line 97 of REPL.jl,\nyou'll see this is where the function eval_user_input() is called. This is the function that evaluates\nwhat you type at the REPL, and since we're working interactively these functions were invoked\nwhen we entered @profile myfunc(). The next line reflects actions taken in the @profile\nmacro.\n\nThe first line shows that 80 backtraces were taken at line 73 of event.jl, but it's not that\nthis line was \"expensive\" on its own: the third line reveals that all 80 of these backtraces\nwere actually triggered inside its call to eval_user_input, and so on. To find out which operations\nare actually taking the time, we need to look deeper in the call chain.\n\nThe first \"important\" line in this output is this one:\n\n52 ./REPL[1]:2; myfunc()\n\nREPL refers to the fact that we defined myfunc in the REPL, rather than putting it in a file;\nif we had used a file, this would show the file name. The [1] shows that the function myfunc\nwas the first expression evaluated in this REPL session. Line 2 of myfunc() contains the call to\nrand, and there were 52 (out of 80) backtraces that occurred at this line. Below that, you can\nsee a call to dsfmt_fill_array_close_open! inside dSFMT.jl.\n\nA little further down, you see:\n\n28 ./REPL[1]:3; myfunc()\n\nLine 3 of myfunc contains the call to maximum, and there were 28 (out of 80) backtraces taken\nhere. Below that, you can see the specific places in base/reduce.jl that carry out the time-consuming\noperations in the maximum function for this type of input data.\n\nOverall, we can tentatively conclude that generating the random numbers is approximately twice as expensive\nas finding the maximum element. We could increase our confidence in this result by\ncollecting more samples:\n\njulia> @profile (for i = 1:100; myfunc(); end)\n\njulia> Profile.print()\n[....]\n 3821 ./REPL[1]:2; myfunc()\n  3511 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type...\n   3511 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr...\n  310  ./random.jl:278; rand\n   [....]\n 2893 ./REPL[1]:3; myfunc()\n  2893 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinea...\n   [....]\n\nIn general, if you have N samples collected at a line, you can expect an uncertainty on the\norder of sqrt(N) (barring other sources of noise, like how busy the computer is with other tasks).\nThe major exception to this rule is garbage collection, which runs infrequently but tends to be\nquite expensive. (Since Julia's garbage collector is written in C, such events can be detected\nusing the C=true output mode described below, or by using ProfileView.jl.)\n\nThis illustrates the default \"tree\" dump; an alternative is the \"flat\" dump, which accumulates\ncounts independent of their nesting:\n\njulia> Profile.print(format=:flat)\n Count File          Line Function\n  6714 ./<missing>     -1 anonymous\n  6714 ./REPL.jl       66 eval_user_input(::Any, ::Base.REPL.REPLBackend)\n  6714 ./REPL.jl       97 macro expansion\n  3821 ./REPL[1]        2 myfunc()\n  2893 ./REPL[1]        3 myfunc()\n  6714 ./REPL[7]        1 macro expansion\n  6714 ./boot.jl      235 eval(::Module, ::Any)\n  3511 ./dSFMT.jl      84 dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_s...\n  6714 ./event.jl      73 (::Base.REPL.##1#2{Base.REPL.REPLBackend})()\n  6714 ./profile.jl    23 macro expansion\n  3511 ./random.jl    431 rand!(::MersenneTwister, ::Array{Float64,3}, ::In...\n   310 ./random.jl    277 rand\n   310 ./random.jl    278 rand\n   310 ./random.jl    366 rand\n   310 ./random.jl    369 rand\n  2893 ./reduce.jl    270 _mapreduce(::Base.#identity, ::Base.#scalarmax, :...\n     5 ./reduce.jl    420 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n   253 ./reduce.jl    426 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n  2592 ./reduce.jl    428 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n    43 ./reduce.jl    429 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n\nIf your code has recursion, one potentially-confusing point is that a line in a \"child\" function\ncan accumulate more counts than there are total backtraces. Consider the following function definitions:\n\ndumbsum(n::Integer) = n == 1 ? 1 : 1 + dumbsum(n-1)\ndumbsum3() = dumbsum(3)\n\nIf you were to profile dumbsum3, and a backtrace was taken while it was executing dumbsum(1),\nthe backtrace would look like this:\n\ndumbsum3\n    dumbsum(3)\n        dumbsum(2)\n            dumbsum(1)\n\nConsequently, this child function gets 3 counts, even though the parent only gets one. The \"tree\"\nrepresentation makes this much clearer, and for this reason (among others) is probably the most\nuseful way to view the results."},{"title":"Accumulation and clearing","page":"Profiling","location":"manual/profile.html#Accumulation-and-clearing","category":"section","text":"Results from @profile accumulate in a buffer; if you run multiple pieces of code under\n@profile, then Profile.print() will show you the combined results. This can\nbe very useful, but sometimes you want to start fresh; you can do so with Profile.clear()."},{"title":"Options for controlling the display of profile results","page":"Profiling","location":"manual/profile.html#Options-for-controlling-the-display-of-profile-results","category":"section","text":"Profile.print has more options than we've described so far. Let's see the full declaration:\n\nfunction print(io::IO = stdout, data = fetch(); kwargs...)\n\nLet's first discuss the two positional arguments, and later the keyword arguments:\n\nio – Allows you to save the results to a buffer, e.g. a file, but the default is to print to stdout\n(the console).\ndata – Contains the data you want to analyze; by default that is obtained from Profile.fetch(),\nwhich pulls out the backtraces from a pre-allocated buffer. For example, if you want to profile\nthe profiler, you could say:\ndata = copy(Profile.fetch())\nProfile.clear()\n@profile Profile.print(stdout, data) # Prints the previous results\nProfile.print()                      # Prints results from Profile.print()\n\nThe keyword arguments can be any combination of:\n\nformat – Introduced above, determines whether backtraces are printed\n with (default, :tree) or without (:flat) indentation indicating tree\n structure.\nC – If true, backtraces from C and Fortran code are shown (normally they are excluded). Try running the introductory\nexample with Profile.print(C = true). This can be extremely helpful in deciding whether it's\nJulia code or C code that is causing a bottleneck; setting C = true also improves the interpretability\nof the nesting, at the cost of longer profile dumps.\ncombine – Some lines of code contain multiple operations; for example, s += A[i] contains both an array\nreference (A[i]) and a sum operation. These correspond to different lines in the generated\nmachine code, and hence there may be two or more different addresses captured during backtraces\non this line. combine = true lumps them together, and is probably what you typically want, but\nyou can generate an output separately for each unique instruction pointer with combine = false.\nmaxdepth – Limits frames at a depth higher than maxdepth in the :tree format.\nsortedby – Controls the order in :flat format. :filefuncline (default) sorts by the source\nline, whereas :count sorts in order of number of collected samples.\nnoisefloor – Limits frames that are below the heuristic noise floor of the sample (only applies to format :tree).\nA suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which n <= noisefloor * √N,\nwhere n is the number of samples on this line, and N is the number of samples for the callee.\nmincount – Limits frames with less than mincount occurrences.\n\nFile/function names are sometimes truncated (with ...), and indentation is truncated with a\n+n at the beginning, where n is the number of extra spaces that would have been inserted,\nhad there been room. If you want a complete profile of deeply-nested code, often a good idea is\nto save to a file using a wide displaysize in an IOContext:\n\nopen(\"/tmp/prof.txt\", \"w\") do s\n    Profile.print(IOContext(s, :displaysize => (24, 500)))\nend"},{"title":"Configuration","page":"Profiling","location":"manual/profile.html#Configuration","category":"section","text":"@profile just accumulates backtraces, and the analysis happens when you call Profile.print().\nFor a long-running computation, it's entirely possible that the pre-allocated buffer for storing\nbacktraces will be filled. If that happens, the backtraces stop but your computation continues.\nAs a consequence, you may miss some important profiling data (you will get a warning when that\nhappens).\n\nYou can obtain and configure the relevant parameters this way:\n\nProfile.init() # returns the current settings\nProfile.init(n = 10^7, delay = 0.01)\n\nn is the total number of instruction pointers you can store, with a default value of 10^6.\nIf your typical backtrace is 20 instruction pointers, then you can collect 50000 backtraces, which\nsuggests a statistical uncertainty of less than 1%. This may be good enough for most applications.\n\nConsequently, you are more likely to need to modify delay, expressed in seconds, which sets\nthe amount of time that Julia gets between snapshots to perform the requested computations. A\nvery long-running job might not need frequent backtraces. The default setting is delay = 0.001.\nOf course, you can decrease the delay as well as increase it; however, the overhead of profiling\ngrows once the delay becomes similar to the amount of time needed to take a backtrace (~30 microseconds\non the author's laptop)."},{"title":"Wall-time Profiler","page":"Profiling","location":"manual/profile.html#Wall-time-Profiler","category":"section","text":""},{"title":"Introduction & Problem Motivation","page":"Profiling","location":"manual/profile.html#Introduction-and-Problem-Motivation","category":"section","text":"The profiler described in the previous section is a sampling CPU profiler. At a high level, the profiler periodically stops all Julia compute threads to collect their backtraces and estimates the time spent in each function based on the number of backtrace samples that include a frame from that function. However, note that only tasks currently running on system threads just before the profiler stops them will have their backtraces collected.\n\nWhile this profiler is typically well-suited for workloads where the majority of tasks are compute-bound, it is less helpful for systems where most tasks are IO-heavy or for diagnosing contention on synchronization primitives in your code.\n\nLet's consider this simple workload:\n\nusing Base.Threads\nusing Profile\nusing PProf\n\nch = Channel(1)\n\nconst N_SPAWNED_TASKS = (1 << 10)\nconst WAIT_TIME_NS = 10_000_000\n\nfunction spawn_a_bunch_of_tasks_waiting_on_channel()\n    for i in 1:N_SPAWNED_TASKS\n        Threads.@spawn begin\n            take!(ch)\n        end\n    end\nend\n\nfunction busywait()\n    t0 = time_ns()\n    while true\n        if time_ns() - t0 > WAIT_TIME_NS\n            break\n        end\n    end\nend\n\nfunction main()\n    spawn_a_bunch_of_tasks_waiting_on_channel()\n    for i in 1:N_SPAWNED_TASKS\n        put!(ch, i)\n        busywait()\n    end\nend\n\nProfile.@profile main()\n\nOur goal is to detect whether there is contention on the ch channel—i.e., whether the number of waiters is excessive given the rate at which work items are being produced in the channel.\n\nIf we run this, we obtain the following PProf flame graph:\n\n(Image: CPU Profile)\n\nThis profile provides no information to help determine where contention occurs in the system’s synchronization primitives. Waiters on a channel will be blocked and descheduled, meaning no system thread will be running the tasks assigned to those waiters, and as a result, they won't be sampled by the profiler."},{"title":"Wall-time Profiler","page":"Profiling","location":"manual/profile.html#Wall-time-Profiler-2","category":"section","text":"Instead of sampling threads—and thus only sampling tasks that are running—a wall-time task profiler samples tasks independently of their scheduling state. For example, tasks that are sleeping on a synchronization primitive at the time the profiler is running will be sampled with the same probability as tasks that were actively running when the profiler attempted to capture backtraces.\n\nThis approach allows us to construct a profile where backtraces from tasks blocked on the ch channel, as in the example above, are actually represented.\n\nLet's run the same example, but now with a wall-time profiler:\n\nusing Base.Threads\nusing Profile\nusing PProf\n\nch = Channel(1)\n\nconst N_SPAWNED_TASKS = (1 << 10)\nconst WAIT_TIME_NS = 10_000_000\n\nfunction spawn_a_bunch_of_tasks_waiting_on_channel()\n    for i in 1:N_SPAWNED_TASKS\n        Threads.@spawn begin\n            take!(ch)\n        end\n    end\nend\n\nfunction busywait()\n    t0 = time_ns()\n    while true\n        if time_ns() - t0 > WAIT_TIME_NS\n            break\n        end\n    end\nend\n\nfunction main()\n    spawn_a_bunch_of_tasks_waiting_on_channel()\n    for i in 1:N_SPAWNED_TASKS\n        put!(ch, i)\n        busywait()\n    end\nend\n\nProfile.@profile_walltime main()\n\nWe obtain the following flame graph:\n\n(Image: Wall-time Profile Channel)\n\nWe see that a large number of samples come from channel-related take! functions, which allows us to determine that there is indeed an excessive number of waiters in ch."},{"title":"A Compute-Bound Workload","page":"Profiling","location":"manual/profile.html#A-Compute-Bound-Workload","category":"section","text":"Despite the wall-time profiler sampling all live tasks in the system and not just the currently running ones, it can still be helpful for identifying performance hotspots, even if your code is compute-bound. Let’s consider a simple example:\n\nusing Base.Threads\nusing Profile\nusing PProf\n\nch = Channel(1)\n\nconst MAX_ITERS = (1 << 22)\nconst N_TASKS = (1 << 12)\n\nfunction spawn_a_task_waiting_on_channel()\n    Threads.@spawn begin\n        take!(ch)\n    end\nend\n\nfunction sum_of_sqrt()\n    sum_of_sqrt = 0.0\n    for i in 1:MAX_ITERS\n        sum_of_sqrt += sqrt(i)\n    end\n    return sum_of_sqrt\nend\n\nfunction spawn_a_bunch_of_compute_heavy_tasks()\n    Threads.@sync begin\n        for i in 1:N_TASKS\n            Threads.@spawn begin\n                sum_of_sqrt()\n            end\n        end\n    end\nend\n\nfunction main()\n    spawn_a_task_waiting_on_channel()\n    spawn_a_bunch_of_compute_heavy_tasks()\nend\n\nProfile.@profile_walltime main()\n\nAfter collecting a wall-time profile, we get the following flame graph:\n\n(Image: Wall-time Profile Compute-Bound)\n\nNotice how many of the samples contain sum_of_sqrt, which is the expensive compute function in our example."},{"title":"Identifying Task Sampling Failures in your Profile","page":"Profiling","location":"manual/profile.html#Identifying-Task-Sampling-Failures-in-your-Profile","category":"section","text":"In the current implementation, the wall-time profiler attempts to sample from tasks that have been alive since the last garbage collection, along with those created afterward. However, if most tasks are extremely short-lived, you may end up sampling tasks that have already completed, resulting in missed backtrace captures.\n\nIf you encounter samples containing failed_to_sample_task_fun or failed_to_stop_thread_fun, this likely indicates a high volume of short-lived tasks, which prevented their backtraces from being collected.\n\nLet's consider this simple example:\n\nusing Base.Threads\nusing Profile\nusing PProf\n\nconst N_SPAWNED_TASKS = (1 << 16)\nconst WAIT_TIME_NS = 100_000\n\nfunction spawn_a_bunch_of_short_lived_tasks()\n    for i in 1:N_SPAWNED_TASKS\n        Threads.@spawn begin\n            # Do nothing\n        end\n    end\nend\n\nfunction busywait()\n    t0 = time_ns()\n    while true\n        if time_ns() - t0 > WAIT_TIME_NS\n            break\n        end\n    end\nend\n\nfunction main()\n    GC.enable(false)\n    spawn_a_bunch_of_short_lived_tasks()\n    for i in 1:N_SPAWNED_TASKS\n        busywait()\n    end\n    GC.enable(true)\nend\n\nProfile.@profile_walltime main()\n\nNotice that the tasks spawned in spawn_a_bunch_of_short_lived_tasks are extremely short-lived. Since these tasks constitute the majority in the system, we will likely miss capturing a backtrace for most sampled tasks.\n\nAfter collecting a wall-time profile, we obtain the following flame graph:\n\n(Image: Task Sampling Failure)\n\nThe large number of samples from failed_to_stop_thread_fun confirms that we have a significant number of short-lived tasks in the system."},{"title":"Memory allocation analysis","page":"Profiling","location":"manual/profile.html#Memory-allocation-analysis","category":"section","text":"One of the most common techniques to improve performance is to reduce memory allocation. Julia\nprovides several tools to measure this:"},{"title":"@time","page":"Profiling","location":"manual/profile.html#@time","category":"section","text":"The total amount of allocation can be measured with @time, @allocated and @allocations,\nand specific lines triggering allocation can often be inferred from profiling via the cost of garbage\ncollection that these lines incur. However, sometimes it is more efficient to directly measure\nthe amount of memory allocated by each line of code."},{"title":"GC Logging","page":"Profiling","location":"manual/profile.html#GC-Logging","category":"section","text":"While @time logs high-level stats about memory usage and garbage collection over the course\nof evaluating an expression, it can be useful to log each garbage collection event, to get an\nintuitive sense of how often the garbage collector is running, how long it's running each time,\nand how much garbage it collects each time. This can be enabled with\nGC.enable_logging(true), which causes Julia to log to stderr every time\na garbage collection happens."},{"title":"Allocation Profiler","page":"Profiling","location":"manual/profile.html#allocation-profiler","category":"section","text":"compat: Julia 1.8\nThis functionality requires at least Julia 1.8.\n\nThe allocation profiler records the stack trace, type, and size of each\nallocation while it is running. It can be invoked with\nProfile.Allocs.@profile.\n\nThis information about the allocations is returned as an array of Alloc\nobjects, wrapped in an AllocResults object. The best way to visualize these is\ncurrently with the PProf.jl and\nProfileCanvas.jl packages, which\ncan visualize the call stacks which are making the most allocations.\n\nThe allocation profiler does have significant overhead, so a sample_rate\nargument can be passed to speed it up by making it skip some allocations.\nPassing sample_rate=1.0 will make it record everything (which is slow);\nsample_rate=0.1 will record only 10% of the allocations (faster), etc.\n\ncompat: Julia 1.11\nOlder versions of Julia could not capture types in all cases. In older versions of\nJulia, if you see an allocation of type Profile.Allocs.UnknownType, it means that\nthe profiler doesn't know what type of object was allocated. This mainly happened when\nthe allocation was coming from generated code produced by the compiler. See\nissue #43688 for more info.Since Julia 1.11, all allocations should have a type reported.\n\nFor more details on how to use this tool, please see the talk from JuliaCon 2022."},{"title":"Allocation Profiler Example","page":"Profiling","location":"manual/profile.html#Allocation-Profiler-Example","category":"section","text":"In this simple example, we use PProf to visualize the alloc profile. You could use another\nvisualization tool instead. We collect the profile (specifying a sample rate), then we visualize it.\n\nusing Profile, PProf\nProfile.Allocs.clear()\nProfile.Allocs.@profile sample_rate=0.0001 my_function()\nPProf.Allocs.pprof()\n\nHere is a more in-depth example, showing how we can tune the sample rate. A\ngood number of samples to aim for is around 1 - 10 thousand. Too many, and the\nprofile visualizer can get overwhelmed, and profiling will be slow. Too few,\nand you don't have a representative sample.\n\njulia> import Profile\n\njulia> @time my_function()  # Estimate allocations from a (second-run) of the function\n  0.110018 seconds (1.50 M allocations: 58.725 MiB, 17.17% gc time)\n500000\n\njulia> Profile.Allocs.clear()\n\njulia> Profile.Allocs.@profile sample_rate=0.001 begin   # 1.5 M * 0.001 = ~1.5K allocs.\n           my_function()\n       end\n500000\n\njulia> prof = Profile.Allocs.fetch();  # If you want, you can also manually inspect the results.\n\njulia> length(prof.allocs)  # Confirm we have expected number of allocations.\n1515\n\njulia> using PProf  # Now, visualize with an external tool, like PProf or ProfileCanvas.\n\njulia> PProf.Allocs.pprof(prof; from_c=false)  # You can optionally pass in a previously fetched profile result.\nAnalyzing 1515 allocation samples... 100%|████████████████████████████████| Time: 0:00:00\nMain binary filename not available.\nServing web UI on http://localhost:62261\n\"alloc-profile.pb.gz\"\n\nThen you can view the profile by navigating to http://localhost:62261, and the profile is saved to disk.\nSee PProf package for more options."},{"title":"Allocation Profiling Tips","page":"Profiling","location":"manual/profile.html#Allocation-Profiling-Tips","category":"section","text":"As stated above, aim for around 1-10 thousand samples in your profile.\n\nNote that we are uniformly sampling in the space of all allocations, and are not weighting\nour samples by the size of the allocation. So a given allocation profile may not give a\nrepresentative profile of where most bytes are allocated in your program, unless you had set\nsample_rate=1.\n\nAllocations can come from users directly constructing objects, but can also come from inside\nthe runtime or be inserted into compiled code to handle type instability. Looking at the\n\"source code\" view can be helpful to isolate them, and then other external tools such as\nCthulhu.jl can be useful for identifying the\ncause of the allocation."},{"title":"Allocation Profile Visualization Tools","page":"Profiling","location":"manual/profile.html#Allocation-Profile-Visualization-Tools","category":"section","text":"There are several profiling visualization tools now that can all display Allocation\nProfiles. Here is a small list of some of the main ones we know about:\n\nPProf.jl\nProfileCanvas.jl\nVSCode's built-in profile visualizer (@profview_allocs) [docs needed]\nViewing the results directly in the REPL\nYou can inspect the results in the REPL via Profile.Allocs.fetch(), to view\nthe stacktrace and type of each allocation."},{"title":"Line-by-Line Allocation Tracking","page":"Profiling","location":"manual/profile.html#Line-by-Line-Allocation-Tracking","category":"section","text":"An alternative way to measure allocations is to start Julia with the --track-allocation=<setting> command-line\noption, for which you can choose none (the default, do not measure allocation), user (measure\nmemory allocation everywhere except Julia's core code), or all (measure memory allocation at\neach line of Julia code). Allocation gets measured for each line of compiled code. When you quit\nJulia, the cumulative results are written to text files with .mem appended after the file name,\nresiding in the same directory as the source file. Each line lists the total number of bytes\nallocated. The Coverage package contains some elementary\nanalysis tools, for example to sort the lines in order of number of bytes allocated.\n\nIn interpreting the results, there are a few important details. Under the user setting, the\nfirst line of any function directly called from the REPL will exhibit allocation due to events\nthat happen in the REPL code itself. More significantly, JIT-compilation also adds to allocation\ncounts, because much of Julia's compiler is written in Julia (and compilation usually requires\nmemory allocation). The recommended procedure is to force compilation by executing all the commands\nyou want to analyze, then call Profile.clear_malloc_data() to reset all allocation counters.\n Finally, execute the desired commands and quit Julia to trigger the generation of the .mem\nfiles.\n\nnote: Note\n--track-allocation changes code generation to log the allocations, and so the allocations may\nbe different than what happens without the option. We recommend using the\nallocation profiler instead."},{"title":"External Profiling","page":"Profiling","location":"manual/profile.html#External-Profiling","category":"section","text":"Currently Julia supports Intel VTune, OProfile and perf as external profiling tools.\n\nDepending on the tool you choose, compile with USE_INTEL_JITEVENTS, USE_OPROFILE_JITEVENTS and\nUSE_PERF_JITEVENTS set to 1 in Make.user. Multiple flags are supported.\n\nBefore running Julia set the environment variable ENABLE_JITPROFILING to 1.\n\nNow you have a multitude of ways to employ those tools!\nFor example with OProfile you can try a simple recording :\n\n>ENABLE_JITPROFILING=1 sudo operf -Vdebug ./julia test/fastmath.jl\n>opreport -l `which ./julia`\n\nOr similarly with perf :\n\n$ ENABLE_JITPROFILING=1 perf record -o /tmp/perf.data --call-graph dwarf -k 1 ./julia /test/fastmath.jl\n$ perf inject --jit --input /tmp/perf.data --output /tmp/perf-jit.data\n$ perf report --call-graph -G -i /tmp/perf-jit.data\n\nThere are many more interesting things that you can measure about your program, to get a comprehensive list\nplease read the Linux perf examples page.\n\nRemember that perf saves for each execution a perf.data file that, even for small programs, can get\nquite large. Also the perf LLVM module saves temporarily debug objects in ~/.debug/jit, remember\nto clean that folder frequently."},{"title":"ArgTools","page":"ArgTools","location":"stdlib/ArgTools.html#ArgTools","category":"section","text":""},{"title":"Argument Handling","page":"ArgTools","location":"stdlib/ArgTools.html#Argument-Handling","category":"section","text":""},{"title":"Function Testing","page":"ArgTools","location":"stdlib/ArgTools.html#Function-Testing","category":"section","text":""},{"title":"ArgTools.ArgRead","page":"ArgTools","location":"stdlib/ArgTools.html#ArgTools.ArgRead","category":"type","text":"ArgRead = Union{AbstractString, AbstractCmd, IO}\n\nThe ArgRead types is a union of the types that the arg_read function knows\nhow to convert into readable IO handles. See arg_read for details.\n\n\n\n\n\n"},{"title":"ArgTools.ArgWrite","page":"ArgTools","location":"stdlib/ArgTools.html#ArgTools.ArgWrite","category":"type","text":"ArgWrite = Union{AbstractString, AbstractCmd, IO}\n\nThe ArgWrite types is a union of the types that the arg_write function knows\nhow to convert into writeable IO handles, except for Nothing which arg_write\nhandles by generating a temporary file. See arg_write for details.\n\n\n\n\n\n"},{"title":"ArgTools.arg_read","page":"ArgTools","location":"stdlib/ArgTools.html#ArgTools.arg_read","category":"function","text":"arg_read(f::Function, arg::ArgRead) -> f(arg_io)\n\nThe arg_read function accepts an argument arg that can be any of these:\n\nAbstractString: a file path to be opened for reading\nAbstractCmd: a command to be run, reading from its standard output\nIO: an open IO handle to be read from\n\nWhether the body returns normally or throws an error, a path which is opened\nwill be closed before returning from arg_read and an IO handle will be\nflushed but not closed before returning from arg_read.\n\nNote: when opening a file, ArgTools will pass lock = false to the file open(...) call.\nTherefore, the object returned by this function should not be used from multiple threads.\nThis restriction may be relaxed in the future, which would not break any working code.\n\n\n\n\n\n"},{"title":"ArgTools.arg_write","page":"ArgTools","location":"stdlib/ArgTools.html#ArgTools.arg_write","category":"function","text":"arg_write(f::Function, arg::ArgWrite) -> arg\narg_write(f::Function, arg::Nothing) -> tempname()\n\nThe arg_write function accepts an argument arg that can be any of these:\n\nAbstractString: a file path to be opened for writing\nAbstractCmd: a command to be run, writing to its standard input\nIO: an open IO handle to be written to\nNothing: a temporary path should be written to\n\nIf the body returns normally, a path that is opened will be closed upon\ncompletion; an IO handle argument is left open but flushed before return. If the\nargument is nothing then a temporary path is opened for writing and closed\nopen completion and the path is returned from arg_write. In all other cases,\narg itself is returned. This is a useful pattern since you can consistently\nreturn whatever was written, whether an argument was passed or not.\n\nIf there is an error during the evaluation of the body, a path that is opened by\narg_write for writing will be deleted, whether it's passed in as a string or a\ntemporary path generated when arg is nothing.\n\nNote: when opening a file, ArgTools will pass lock = false to the file open(...) call.\nTherefore, the object returned by this function should not be used from multiple threads.\nThis restriction may be relaxed in the future, which would not break any working code.\n\n\n\n\n\n"},{"title":"ArgTools.arg_isdir","page":"ArgTools","location":"stdlib/ArgTools.html#ArgTools.arg_isdir","category":"function","text":"arg_isdir(f::Function, arg::AbstractString) -> f(arg)\n\nThe arg_isdir function takes arg which must be the path to an existing\ndirectory (an error is raised otherwise) and passes that path to f finally\nreturning the result of f(arg). This is definitely the least useful tool\noffered by ArgTools and mostly exists for symmetry with arg_mkdir and to\ngive consistent error messages.\n\n\n\n\n\n"},{"title":"ArgTools.arg_mkdir","page":"ArgTools","location":"stdlib/ArgTools.html#ArgTools.arg_mkdir","category":"function","text":"arg_mkdir(f::Function, arg::AbstractString) -> arg\narg_mkdir(f::Function, arg::Nothing) -> mktempdir()\n\nThe arg_mkdir function takes arg which must either be one of:\n\na path to an already existing empty directory,\na non-existent path which can be created as a directory, or\nnothing in which case a temporary directory is created.\n\nIn all cases the path to the directory is returned. If an error occurs during\nf(arg), the directory is returned to its original state: if it already existed\nbut was empty, it will be emptied; if it did not exist it will be deleted.\n\n\n\n\n\n"},{"title":"ArgTools.arg_readers","page":"ArgTools","location":"stdlib/ArgTools.html#ArgTools.arg_readers","category":"function","text":"arg_readers(arg :: AbstractString, [ type = ArgRead ]) do arg::Function\n    ## pre-test setup ##\n    @arg_test arg begin\n        arg :: ArgRead\n        ## test using `arg` ##\n    end\n    ## post-test cleanup ##\nend\n\nThe arg_readers function takes a path to be read and a single-argument do\nblock, which is invoked once for each test reader type that arg_read can\nhandle. If the optional type argument is given then the do block is only\ninvoked for readers that produce arguments of that type.\n\nThe arg passed to the do block is not the argument value itself, because some\nof test argument types need to be initialized and finalized for each test case.\nConsider an open file handle argument: once you've used it for one test, you\ncan't use it again; you need to close it and open the file again for the next\ntest. This function arg can be converted into an ArgRead instance using\n@arg_test arg begin ... end.\n\n\n\n\n\n"},{"title":"ArgTools.arg_writers","page":"ArgTools","location":"stdlib/ArgTools.html#ArgTools.arg_writers","category":"function","text":"arg_writers([ type = ArgWrite ]) do path::String, arg::Function\n    ## pre-test setup ##\n    @arg_test arg begin\n        arg :: ArgWrite\n        ## test using `arg` ##\n    end\n    ## post-test cleanup ##\nend\n\nThe arg_writers function takes a do block, which is invoked once for each test\nwriter type that arg_write can handle with a temporary (non-existent) path\nand arg which can be converted into various writable argument types which\nwrite to path. If the optional type argument is given then the do block is\nonly invoked for writers that produce arguments of that type.\n\nThe arg passed to the do block is not the argument value itself, because some\nof test argument types need to be initialized and finalized for each test case.\nConsider an open file handle argument: once you've used it for one test, you\ncan't use it again; you need to close it and open the file again for the next\ntest. This function arg can be converted into an ArgWrite instance using\n@arg_test arg begin ... end.\n\nThere is also an arg_writers method that takes a path name like arg_readers:\n\narg_writers(path::AbstractString, [ type = ArgWrite ]) do arg::Function\n    ## pre-test setup ##\n    @arg_test arg begin\n        # here `arg :: ArgWrite`\n        ## test using `arg` ##\n    end\n    ## post-test cleanup ##\nend\n\nThis method is useful if you need to specify path instead of using path name\ngenerated by tempname(). Since path is passed from outside of arg_writers,\nthe path is not an argument to the do block in this form.\n\n\n\n\n\n"},{"title":"ArgTools.@arg_test","page":"ArgTools","location":"stdlib/ArgTools.html#ArgTools.@arg_test","category":"macro","text":"@arg_test arg1 arg2 ... body\n\nThe @arg_test macro is used to convert arg functions provided by\narg_readers and arg_writers into actual argument values. When you write\n@arg_test arg body it is equivalent to arg(arg -> body).\n\n\n\n\n\n"},{"title":"Windows","page":"Windows","location":"devdocs/build/windows.html#Windows","category":"section","text":"This file describes how to install, or build, and use Julia on Windows.\n\nFor more general information about Julia, please see the\nmain README\nor the documentation."},{"title":"General Information for Windows","page":"Windows","location":"devdocs/build/windows.html#General-Information-for-Windows","category":"section","text":"We highly recommend running Julia using a modern terminal application, in particular Windows Terminal, which can be installed from the Microsoft Store."},{"title":"Line endings","page":"Windows","location":"devdocs/build/windows.html#Line-endings","category":"section","text":"Julia uses binary-mode files exclusively. Unlike many other Windows programs,\nif you write \\n to a file, you get a \\n in the file, not some other bit\npattern. This matches the behavior exhibited by other operating systems. If\nyou have installed Git for Windows, it is suggested, but not required, that you\nconfigure your system Git to use the same convention:\n\ngit config --global core.eol lf\ngit config --global core.autocrlf input\n\nor edit %USERPROFILE%\\.gitconfig and add/edit the lines:\n\n[core]\n    eol = lf\n    autocrlf = input"},{"title":"Binary distribution","page":"Windows","location":"devdocs/build/windows.html#Binary-distribution","category":"section","text":"For the binary distribution installation notes on Windows please see the instructions at\nhttps://julialang.org/downloads/platform/#windows. Note, however, that on all platforms using juliaup is recommended over manually installing binaries."},{"title":"Source distribution","page":"Windows","location":"devdocs/build/windows.html#Source-distribution","category":"section","text":""},{"title":"Cygwin-to-MinGW cross-compiling","page":"Windows","location":"devdocs/build/windows.html#Cygwin-to-MinGW-cross-compiling","category":"section","text":"The recommended way of compiling Julia from source on Windows is by cross\ncompiling from Cygwin, using versions of the\nMinGW-w64 compilers available through Cygwin's package manager.\n\nDownload and run Cygwin setup for 32 bit\nor 64 bit. Note, that you can compile\neither 32 or 64 bit Julia from either 32 or 64 bit Cygwin. 64 bit Cygwin\nhas a slightly smaller but often more up-to-date selection of packages.\nAdvanced: you may skip steps 2-4 by running:\nsetup-x86_64.exe -s <url> -q -P cmake,gcc-g++=12.5.0-1,git,make,patch,curl,m4,python3,p7zip,mingw64-i686-gcc-g++=12.5.0-1,mingw64-i686-gcc-fortran=12.5.0-1,mingw64-i686-gcc-core=12.5.0-1,mingw64-i686-headers=12.0.0-1,mingw64-i686-runtime=12.0.0-1,mingw64-i686-winpthreads=12.0.0-1,mingw64-x86_64-gcc-g++=12.5.0-1,mingw64-x86_64-gcc-fortran=12.5.0-1,mingw64-x86_64-gcc-core=12.5.0-1,mingw64-x86_64-headers=12.0.0-1,mingw64-x86_64-runtime=12.0.0-1,mingw64-x86_64-winpthreads=12.0.0-1\nreplacing <url> with a site from https://cygwin.com/mirrors.html\nor run setup manually first and select a mirror.\nSelect installation location and a mirror to download from.\nAt the Select Packages step, select the following:\nFrom the Devel category: cmake, gcc-g++, git, make, patch\nFrom the Net category: curl\nFrom Interpreters (or Python) category: m4, python3\nFrom the Archive category: p7zip\nFor 32 bit Julia, and also from the Devel category:\nmingw64-i686-gcc-g++ and mingw64-i686-gcc-fortran and mingw64-i686-gcc-core (version \"12.5.0-1\")\nmingw64-i686-headers and mingw64-i686-runtime and mingw64-i686-winpthreads (version \"12.0.0-1\")\nFor 64 bit Julia, and also from the Devel category:\nmingw64-x86_64-gcc-g++ and mingw64-x86_64-gcc-fortran and mingw64-x86_64-gcc-core (version \"12.5.0-1\")\nmingw64-x86_64-headers and mingw64-x86_64-runtime and mingw64-x86_64-winpthreads (version \"12.0.0-1\")\nAllow Cygwin installation to finish, then start from the installed shortcut\n'Cygwin Terminal', or 'Cygwin64 Terminal', respectively.\nBuild Julia and its dependencies from source:\nGet the Julia sources\ngit clone https://github.com/JuliaLang/julia.git\ncd julia\nTip: If you get an error: cannot fork() for fetch-pack: Resource temporarily unavailable from git, add alias git=\"env PATH=/usr/bin git\"\nto ~/.bashrc and restart Cygwin.\nSet the XC_HOST variable in Make.user to indicate MinGW-w64 cross\ncompilation\necho 'XC_HOST = i686-w64-mingw32' > Make.user     # for 32 bit Julia\n# or\necho 'XC_HOST = x86_64-w64-mingw32' > Make.user   # for 64 bit Julia\nStart the build\nmake -j 4       # Adjust the number of threads (4) to match your build environment.\nmake -j 4 debug # This builds julia-debug.exe\nRun Julia using the Julia executables directly\nusr/bin/julia.exe\nusr/bin/julia-debug.exe\n\nnote: Pro tip: build both!\nmake O=julia-win32 configure\nmake O=julia-win64 configure\necho 'XC_HOST = i686-w64-mingw32' > julia-win32/Make.user\necho 'XC_HOST = x86_64-w64-mingw32' > julia-win64/Make.user\necho 'ifeq ($(BUILDROOT),$(JULIAHOME))\n        $(error \"in-tree build disabled\")\n      endif' >> Make.user\nmake -C julia-win32  # build for Windows x86 in julia-win32 folder\nmake -C julia-win64  # build for Windows x86-64 in julia-win64 folder"},{"title":"Compiling with MinGW/MSYS2","page":"Windows","location":"devdocs/build/windows.html#Compiling-with-MinGW/MSYS2","category":"section","text":"MSYS2 is a software distribution and build environment for Windows.\n\nNote: MSYS2 requires 64 bit Windows 7 or newer.\n\nInstall and configure MSYS2.\nDownload and run the latest installer for the\n 64-bit distribution.\n The installer will have a name like msys2-x86_64-yyyymmdd.exe.\nOpen the MSYS2 shell. Update the package database and base packages:\npacman -Syu\nExit and restart MSYS2. Update the rest of the base packages:\npacman -Syu\nThen install tools required to build julia:\npacman -S diffutils git m4 make patch tar p7zip curl python\nFor 64 bit Julia, install the x86_64 version:\npacman -S mingw-w64-x86_64-gcc mingw-w64-x86_64-cmake mingw-w64-x86_64-clang\nFor 32 bit Julia, install the i686 version:\npacman -S mingw-w64-i686-gcc mingw-w64-i686-cmake mingw-w64-i686-clang\nConfiguration of MSYS2 is complete. Now exit the MSYS2 shell.\nBuild Julia and its dependencies with pre-build dependencies.\nOpen a new MINGW64/MINGW32 shell.\n Currently we can't use both mingw32 and mingw64,\n so if you want to build the x86_64 and i686 versions,\n you'll need to build them in each environment separately.\nClone the Julia sources:\ngit clone https://github.com/JuliaLang/julia.git\ncd julia\nIf you want to use clang (currently required if building LLVM from source), put the following in your Make.user\nCC=/mingw64/bin/clang   CXX=/mingw64/bin/clang++\n\nwarning: UCRT Unsupported\nDo not try to use any other clang that MSYS2 may install (which may not have the correct default target) or the \"Clang\" environment(which defaults to the currently unsupported ucrt).Start the build\nmake -j$(nproc)\n\nnote: Pro tip: build in dir\nmake O=julia-mingw-w64 configure\necho 'ifeq ($(BUILDROOT),$(JULIAHOME))\n        $(error \"in-tree build disabled\")\n      endif' >> Make.user\nmake -C julia-mingw-w64"},{"title":"Cross-compiling from Unix (Linux/Mac/WSL)","page":"Windows","location":"devdocs/build/windows.html#Cross-compiling-from-Unix-(Linux/Mac/WSL)","category":"section","text":"You can also use MinGW-w64 cross compilers to build a Windows version of Julia from\nLinux, Mac, or the Windows Subsystem for Linux (WSL).\n\nFirst, you will need to ensure your system has the required dependencies. We\nneed wine (>=1.7.5), a system compiler, and some downloaders. Note: a Cygwin install might\ninterfere with this method if using WSL.\n\nOn Ubuntu (on other Linux systems the dependency names are likely to be similar):\n\napt-get install wine-stable gcc wget p7zip-full winbind mingw-w64 gfortran-mingw-w64\ndpkg --add-architecture i386 && apt-get update && apt-get install wine32 # add sudo to each if needed\n# switch all of the following to their \"-posix\" variants (interactively):\nfor pkg in i686-w64-mingw32-g++ i686-w64-mingw32-gcc i686-w64-mingw32-gfortran x86_64-w64-mingw32-g++ x86_64-w64-mingw32-gcc x86_64-w64-mingw32-gfortran; do\n    sudo update-alternatives --config $pkg\ndone\n\nOn Mac: Install XCode, XCode command line tools, X11 (now\nXQuartz), and MacPorts\nor Homebrew. Then run port install wine wget mingw-w64, or brew install wine wget mingw-w64, as appropriate.\n\nThen run the build:\n\ngit clone https://github.com/JuliaLang/julia.git julia-win32\ncd julia-win32\necho override XC_HOST = i686-w64-mingw32 >> Make.user\nmake\nmake win-extras (Necessary before running make binary-dist)\nmake binary-dist then make exe to create the Windows installer.\nmove the julia-*.exe installer to the target machine\n\nIf you are building for 64-bit Windows, the steps are essentially the same.\nJust replace i686 in XC_HOST with x86_64. (Note: on Mac, wine only runs\nin 32-bit mode)."},{"title":"Distribution to other machines","page":"Windows","location":"devdocs/build/windows.html#Distribution-to-other-machines","category":"section","text":"If you intend to run this copy of Julia on a different x86-64 machine than it was compiled\non, add JULIA_CPU_TARGET= to Make.user. Currently, x86-64 Julia distributions are built\nwith JULIA_CPU_TARGET=generic;sandybridge,-xsaveopt,clone_all;haswell,-rdrnd,base(1);x86_64_v4,-rdrnd,base(1).\nSee here for more on this environment variable."},{"title":"Debugging a cross-compiled build under wine","page":"Windows","location":"devdocs/build/windows.html#Debugging-a-cross-compiled-build-under-wine","category":"section","text":"The most effective way to debug a cross-compiled version of Julia on the cross-compilation\nhost is to install a Windows version of GDB and run it under wine as usual. The pre-built\npackages available [as part of the MSYS2\nproject](https://packages.msys2.org/) are known to work. Apart\nfrom the GDB package you may also need the python and termcap packages. Finally, GDB's\nprompt may not work when launched from the command line. This can be worked around by\nprepending wineconsole to the regular GDB invocation."},{"title":"After compiling","page":"Windows","location":"devdocs/build/windows.html#After-compiling","category":"section","text":"Compiling using one of the options above creates a basic Julia build, but not some\nextra components that are included if you run the full Julia binary installer.\nIf you need these components, the easiest way to get them is to build the installer\nyourself using make win-extras followed by make binary-dist and make exe.\nThen run the resulting installer."},{"title":"Windows Build Debugging","page":"Windows","location":"devdocs/build/windows.html#Windows-Build-Debugging","category":"section","text":""},{"title":"GDB hangs with Cygwin mintty","page":"Windows","location":"devdocs/build/windows.html#GDB-hangs-with-Cygwin-mintty","category":"section","text":"Run GDB under the Windows console (cmd) instead. GDB [may not function\nproperly](https://www.cygwin.com/ml/cygwin/2009-02/msg00531.html) under mintty with non-\nCygwin applications. You can use cmd /c start to start the Windows console from mintty\nif necessary."},{"title":"GDB not attaching to the right process","page":"Windows","location":"devdocs/build/windows.html#GDB-not-attaching-to-the-right-process","category":"section","text":"Use the PID from the Windows task manager or WINPID from the ps command\ninstead of the PID from unix-style command line tools (e.g. pgrep). You\nmay need to add the PID column if it is not shown by default in the Windows\ntask manager."},{"title":"GDB not showing the right backtrace","page":"Windows","location":"devdocs/build/windows.html#GDB-not-showing-the-right-backtrace","category":"section","text":"When attaching to the julia process, GDB may not be attaching to the right\nthread. Use info threads command to show all the threads and\nthread <threadno> to switch threads.\nBe sure to use a 32 bit version of GDB to debug a 32 bit build of Julia, or\na 64 bit version of GDB to debug a 64 bit build of Julia."},{"title":"Build process is slow/eats memory/hangs my computer","page":"Windows","location":"devdocs/build/windows.html#Build-process-is-slow/eats-memory/hangs-my-computer","category":"section","text":"Disable the Windows\nSuperfetch and\n[Program Compatibility\nAssistant](https://blogs.msdn.com/b/cjacks/archive/2011/11/22/managing-the-windows-7-program-compatibility-assistant-pca.aspx)\nservices, as they are known to have [spurious\ninteractions](https://cygwin.com/ml/cygwin/2011-12/msg00058.html) with MinGW/Cygwin.\nAs mentioned in the link above: excessive memory use by svchost specifically\nmay be investigated in the Task Manager by clicking on the high-memory\nsvchost.exe process and selecting Go to Services. Disable child services\none-by-one until a culprit is found.\nBeware of BLODA.\nThe vmmap\ntool is indispensable for identifying such software conflicts. Use vmmap to\ninspect the list of loaded DLLs for bash, mintty, or another persistent\nprocess used to drive the build. Essentially any DLL outside of the Windows\nSystem directory is potential BLODA."},{"title":"Instrumenting Julia with DTrace, and bpftrace","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#Instrumenting-Julia-with-DTrace,-and-bpftrace","category":"section","text":"DTrace and bpftrace are tools that enable lightweight instrumentation of processes.\nYou can turn the instrumentation on and off while the process is running,\nand with instrumentation off the overhead is minimal.\n\ncompat: Julia 1.8\nSupport for probes was added in Julia 1.8\n\nnote: Note\nThis documentation has been written from a Linux perspective, most of this\nshould hold on Mac OS/Darwin and FreeBSD."},{"title":"Enabling support","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#Enabling-support","category":"section","text":"On Linux install the systemtap package that has a version of dtrace and create a Make.user file containing\n\nWITH_DTRACE=1\n\nto enable USDT probes."},{"title":"Verifying","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#Verifying","category":"section","text":"> readelf -n usr/lib/libjulia-internal.so.1\n\nDisplaying notes found in: .note.gnu.build-id\n  Owner                Data size  Description\n  GNU                  0x00000014 NT_GNU_BUILD_ID (unique build ID bitstring)\n    Build ID: 57161002f35548772a87418d2385c284ceb3ead8\n\nDisplaying notes found in: .note.stapsdt\n  Owner                Data size  Description\n  stapsdt              0x00000029 NT_STAPSDT (SystemTap probe descriptors)\n    Provider: julia\n    Name: gc__begin\n    Location: 0x000000000013213e, Base: 0x00000000002bb4da, Semaphore: 0x0000000000346cac\n    Arguments:\n  stapsdt              0x00000032 NT_STAPSDT (SystemTap probe descriptors)\n    Provider: julia\n    Name: gc__stop_the_world\n    Location: 0x0000000000132144, Base: 0x00000000002bb4da, Semaphore: 0x0000000000346cae\n    Arguments:\n  stapsdt              0x00000027 NT_STAPSDT (SystemTap probe descriptors)\n    Provider: julia\n    Name: gc__end\n    Location: 0x000000000013214a, Base: 0x00000000002bb4da, Semaphore: 0x0000000000346cb0\n    Arguments:\n  stapsdt              0x0000002d NT_STAPSDT (SystemTap probe descriptors)\n    Provider: julia\n    Name: gc__finalizer\n    Location: 0x0000000000132150, Base: 0x00000000002bb4da, Semaphore: 0x0000000000346cb2\n    Arguments:"},{"title":"Adding probes in libjulia","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#Adding-probes-in-libjulia","category":"section","text":"Probes are declared in dtraces format in the file src/uprobes.d. The generated\nheader file is included in src/julia_internal.h and if you add probes you should\nprovide a noop implementation there.\n\nThe header will contain a semaphore *_ENABLED and the actual call to the probe.\nIf the probe arguments are expensive to compute you should first check if the\nprobe is enabled and then compute the arguments and call the probe.\n\n  if (JL_PROBE_{PROBE}_ENABLED())\n    auto expensive_arg = ...;\n    JL_PROBE_{PROBE}(expensive_arg);\n\nIf your probe has no arguments it is preferred to not include the semaphore check.\nWith USDT probes enabled the cost of a semaphore is a memory load, irrespective of\nthe fact that the probe is enabled or not.\n\n#define JL_PROBE_GC_BEGIN_ENABLED() __builtin_expect (julia_gc__begin_semaphore, 0)\n__extension__ extern unsigned short julia_gc__begin_semaphore __attribute__ ((unused)) __attribute__ ((section (\".probes\")));\n\nWhereas the probe itself is a noop sled that will be patched to a trampoline to\nthe probe handler."},{"title":"Available probes","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#Available-probes","category":"section","text":""},{"title":"GC probes","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#GC-probes","category":"section","text":"julia:gc__begin: GC begins running on one thread and triggers stop-the-world.\njulia:gc__stop_the_world: All threads have reached a safepoint and GC runs.\njulia:gc__mark__begin: Beginning the mark phase\njulia:gc__mark_end(scanned_bytes, perm_scanned): Mark phase ended\njulia:gc__sweep_begin(full): Starting sweep\njulia:gc__sweep_end: Sweep phase finished\njulia:gc__end: GC is finished, other threads continue work\njulia:gc__finalizer: Initial GC thread has finished running finalizers"},{"title":"Task runtime probes","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#Task-runtime-probes","category":"section","text":"julia:rt__run__task(task): Switching to task task on current thread.\njulia:rt__pause__task(task): Switching from task task on current thread.\njulia:rt__new__task(parent, child): Task parent created task child on current thread.\njulia:rt__start__task(task): Task task started for the first time with a new stack.\njulia:rt__finish__task(task): Task task finished and will no longer execute.\njulia:rt__start__process__events(task): Task task started processing libuv events.\njulia:rt__finish__process__events(task): Task task finished processing libuv events."},{"title":"Task queue probes","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#Task-queue-probes","category":"section","text":"julia:rt__taskq__insert(ptls, task): Thread ptls attempted to insert task into a PARTR multiq.\njulia:rt__taskq__get(ptls, task): Thread ptls popped task from a PARTR multiq."},{"title":"Thread sleep/wake probes","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#Thread-sleep/wake-probes","category":"section","text":"julia:rt__sleep__check__wake(ptls, old_state): Thread (PTLS ptls) waking up, previously in state old_state.\njulia:rt__sleep__check__wakeup(ptls): Thread (PTLS ptls) woke itself up.\njulia:rt__sleep__check__sleep(ptls): Thread (PTLS ptls) is attempting to sleep.\njulia:rt__sleep__check__taskq__wake(ptls): Thread (PTLS ptls) fails to sleep due to tasks in PARTR multiq.\njulia:rt__sleep__check__task__wake(ptls): Thread (PTLS ptls) fails to sleep due to tasks in Base workqueue.\njulia:rt__sleep__check__uv__wake(ptls): Thread (PTLS ptls) fails to sleep due to libuv wakeup."},{"title":"Probe usage examples","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#Probe-usage-examples","category":"section","text":""},{"title":"GC stop-the-world latency","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#GC-stop-the-world-latency","category":"section","text":"An example bpftrace script is given in contrib/gc_stop_the_world_latency.bt\nand it creates a histogram of the latency for all threads to reach a safepoint.\n\nRunning this Julia code, with julia -t 2\n\nusing Base.Threads\n\nfib(x) = x <= 1 ? 1 : fib(x-1) + fib(x-2)\n\nbeaver = @spawn begin\n    while true\n        fib(30)\n        # A manual safepoint is necessary since otherwise this loop\n        # may never yield to GC.\n        GC.safepoint()\n    end\nend\n\nallocator = @spawn begin\n    while true\n        zeros(1024)\n    end\nend\n\nwait(allocator)\n\nand in a second terminal\n\n> sudo contrib/bpftrace/gc_stop_the_world_latency.bt\nAttaching 4 probes...\nTracing Julia GC Stop-The-World Latency... Hit Ctrl-C to end.\n^C\n\n\n@usecs[1743412]:\n[4, 8)               971 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|\n[8, 16)              837 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        |\n[16, 32)             129 |@@@@@@                                              |\n[32, 64)              10 |                                                    |\n[64, 128)              1 |                                                    |\n\nWe can see the latency distribution of the stop-the-world phase in the executed Julia process."},{"title":"Task spawn monitor","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#Task-spawn-monitor","category":"section","text":"It's sometimes useful to know when a task is spawning other tasks. This is very\neasy to see with rt__new__task. The first argument to the probe, parent, is\nthe existing task which is creating a new task. This means that if you know the\naddress of the task you want to monitor, you can easily just look at the tasks\nthat were spawned by that specific task. Let's see how to do this; first let's\nstart a Julia session and get the PID and REPL's task address:\n\n> julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.6.2 (2021-07-14)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org release\n|__/                   |\n\n1> getpid()\n997825\n\n2> current_task()\nTask (runnable) @0x00007f524d088010\n\nNow we can start bpftrace and have it monitor rt__new__task for only this parent:\n\nsudo bpftrace -p 997825 -e 'usdt:usr/lib/libjulia-internal.so:julia:rt__new__task /arg0==0x00007f524d088010/{ printf(\"Task: %x\\n\", arg0); }'\n\n(Note that in the above, arg0 is the first argument, parent).\n\nAnd if we spawn a single task:\n\nThreads.@spawn 1+1\n\nwe see this task being created:\n\nTask: 4d088010\n\nHowever, if we spawn a bunch of tasks from that newly-spawned task:\n\nThreads.@spawn for i in 1:10\n   Threads.@spawn 1+1\nend\n\nwe still only see one task from bpftrace:\n\nTask: 4d088010\n\nand it's still the same task we were monitoring! Of course, we can remove this\nfilter to see all newly-created tasks just as easily:\n\nsudo bpftrace -p 997825 -e 'usdt:usr/lib/libjulia-internal.so:julia:rt__new__task { printf(\"Task: %x\\n\", arg0); }'\n\nTask: 4d088010\nTask: 4dc4e290\nTask: 4dc4e290\nTask: 4dc4e290\nTask: 4dc4e290\nTask: 4dc4e290\nTask: 4dc4e290\nTask: 4dc4e290\nTask: 4dc4e290\nTask: 4dc4e290\nTask: 4dc4e290\n\nWe can see our root task, and the newly-spawned task as the parent of the ten\neven newer tasks."},{"title":"Thundering herd detection","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#Thundering-herd-detection","category":"section","text":"Task runtimes can often suffer from the \"thundering herd\" problem: when some\nwork is added to a quiet task runtime, all threads may be woken up from their\nslumber, even if there isn't enough work for each thread to process. This can\ncause extra latency and CPU cycles while all threads awaken (and simultaneously\ngo back to sleep, not finding any work to execute).\n\nWe can see this problem illustrated with bpftrace quite easily. First, in one terminal we start Julia with multiple threads (6 in this example), and get the PID of that process:\n\n> julia -t 6\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.6.2 (2021-07-14)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org release\n|__/                   |\n\n1> getpid()\n997825\n\nAnd in another terminal we start bpftrace monitoring our process,\nspecifically probing the rt__sleep__check__wake hook:\n\nsudo bpftrace -p 997825 -e 'usdt:usr/lib/libjulia-internal.so:julia:rt__sleep__check__wake { printf(\"Thread wake up! %x\\n\", arg0); }'\n\nNow, we create and execute a single task in Julia:\n\nThreads.@spawn 1+1\n\nAnd in bpftrace we see printed out something like:\n\nThread wake up! 3f926100\nThread wake up! 3ebd5140\nThread wake up! 3f876130\nThread wake up! 3e2711a0\nThread wake up! 3e312190\n\nEven though we only spawned a single task (which only one thread could process\nat a time), we woke up all of our other threads! In the future, a smarter task\nruntime might only wake up a single thread (or none at all; the spawning thread\ncould execute this task!), and we should see this behavior go away."},{"title":"Task Monitor with BPFnative.jl","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#Task-Monitor-with-BPFnative.jl","category":"section","text":"BPFnative.jl is able to attach to USDT probe points just like bpftrace. There\nis a demo available for monitoring the task runtime, GC, and thread sleep/wake\ntransitions here."},{"title":"Notes on using bpftrace","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#Notes-on-using-bpftrace","category":"section","text":"An example probe in the bpftrace format looks like:\n\nusdt:usr/lib/libjulia-internal.so:julia:gc__begin\n{\n  @start[pid] = nsecs;\n}\n\nThe probe declaration takes the kind usdt, then either the\npath to the library or the PID, the provider name julia\nand the probe name gc__begin. Note that I am using a\nrelative path to the libjulia-internal.so, but this might\nneed to be an absolute path on a production system."},{"title":"Useful references:","page":"Instrumenting Julia with DTrace, and bpftrace","location":"devdocs/probes.html#Useful-references:","category":"section","text":"Julia Evans blog on Linux tracing systems\nLWN article on USDT and BPF\nGDB support for probes\nBrendan Gregg – Linux Performance"},{"title":"Collections and Data Structures","page":"Collections and Data Structures","location":"base/collections.html#Collections-and-Data-Structures","category":"section","text":""},{"title":"Iteration","page":"Collections and Data Structures","location":"base/collections.html#lib-collections-iteration","category":"section","text":"Sequential iteration is implemented by the iterate function.\nThe general for loop:\n\nfor i in iter   # or  \"for i = iter\"\n    # body\nend\n\nis translated into:\n\nnext = iterate(iter)\nwhile next !== nothing\n    (i, state) = next\n    # body\n    next = iterate(iter, state)\nend\n\nThe state object may be anything, and should be chosen appropriately for each iterable type.\nSee the manual section on the iteration interface for more details about defining a custom\niterable type.\n\nFully implemented by:\n\nAbstractRange\nUnitRange\nTuple\nNumber\nAbstractArray\nBitSet\nIdDict\nDict\nWeakKeyDict\nEachLine\nAbstractString\nSet\nPair\nNamedTuple"},{"title":"Ranges","page":"Collections and Data Structures","location":"base/collections.html#Ranges","category":"section","text":""},{"title":"Constructing Ranges","page":"Collections and Data Structures","location":"base/collections.html#Constructing-Ranges","category":"section","text":""},{"title":"Range Types","page":"Collections and Data Structures","location":"base/collections.html#Range-Types","category":"section","text":""},{"title":"General Collections","page":"Collections and Data Structures","location":"base/collections.html#General-Collections","category":"section","text":"Fully implemented by:\n\nAbstractRange\nUnitRange\nTuple\nNumber\nAbstractArray\nBitSet\nIdDict\nDict\nWeakKeyDict\nAbstractString\nSet\nNamedTuple"},{"title":"Iterable Collections","page":"Collections and Data Structures","location":"base/collections.html#Iterable-Collections","category":"section","text":""},{"title":"Indexable Collections","page":"Collections and Data Structures","location":"base/collections.html#Indexable-Collections","category":"section","text":"Fully implemented by:\n\nArray\nBitArray\nAbstractArray\nSubArray\n\nPartially implemented by:\n\nAbstractRange\nUnitRange\nTuple\nAbstractString\nDict\nIdDict\nWeakKeyDict\nNamedTuple"},{"title":"Dictionaries","page":"Collections and Data Structures","location":"base/collections.html#Dictionaries","category":"section","text":"Dict is the standard dictionary. Its implementation uses hash\nas the hashing function for the key, and isequal to determine equality. Define these\ntwo functions for custom types to override how they are stored in a hash table.\n\nIdDict is a special hash table where the keys are always object identities.\n\nWeakKeyDict is a hash table implementation where the keys are weak references to objects, and\nthus may be garbage collected even when referenced in a hash table.\nLike Dict it uses hash for hashing and isequal for equality, unlike Dict it does\nnot convert keys on insertion.\n\nDicts can be created by passing pair objects constructed with => to a Dict\nconstructor: Dict(\"A\"=>1, \"B\"=>2). This call will attempt to infer type information from the\nkeys and values (i.e. this example creates a Dict{String, Int64}). To explicitly specify types\nuse the syntax Dict{KeyType,ValueType}(...). For example, Dict{String,Int32}(\"A\"=>1, \"B\"=>2).\n\nDictionaries may also be created with generators. For example, Dict(i => f(i) for i = 1:10).\n\nGiven a dictionary D, the syntax D[x] returns the value of key x (if it exists) or throws\nan error, and D[x] = y stores the key-value pair x => y in D (replacing any existing value\nfor the key x). Multiple arguments to D[...] are converted to tuples; for example, the syntax\nD[x,y]  is equivalent to D[(x,y)], i.e. it refers to the value keyed by the tuple (x,y).\n\nFully implemented by:\n\nDict\nIdDict\nWeakKeyDict\n\nPartially implemented by:\n\nSet\nBitSet\nIdSet\nEnvDict\nArray\nBitArray\nImmutableDict\nPersistentDict\nIterators.Pairs"},{"title":"Set-Like Collections","page":"Collections and Data Structures","location":"base/collections.html#Set-Like-Collections","category":"section","text":"Fully implemented by:\n\nSet\nBitSet\nIdSet\n\nPartially implemented by:\n\nArray"},{"title":"Deques","page":"Collections and Data Structures","location":"base/collections.html#Deques","category":"section","text":"Fully implemented by:\n\nVector (a.k.a. 1-dimensional Array)\nBitVector (a.k.a. 1-dimensional BitArray)"},{"title":"Utility Collections","page":"Collections and Data Structures","location":"base/collections.html#Utility-Collections","category":"section","text":""},{"title":"Base.iterate","page":"Collections and Data Structures","location":"base/collections.html#Base.iterate","category":"function","text":"iterate(iter [, state])::Union{Nothing, Tuple{Any, Any}}\n\nAdvance the iterator to obtain the next element. If no elements\nremain, nothing should be returned. Otherwise, a 2-tuple of the\nnext element and the new iteration state should be returned.\n\n\n\n\n\n"},{"title":"Base.IteratorSize","page":"Collections and Data Structures","location":"base/collections.html#Base.IteratorSize","category":"type","text":"IteratorSize(itertype::Type)::IteratorSize\n\nGiven the type of an iterator, return one of the following values:\n\nSizeUnknown() if the length (number of elements) cannot be determined in advance.\nHasLength() if there is a fixed, finite length.\nHasShape{N}() if there is a known length plus a notion of multidimensional shape (as for an array).\n In this case N should give the number of dimensions, and the axes function is valid\n for the iterator.\nIsInfinite() if the iterator yields values forever.\n\nThe default value (for iterators that do not define this function) is HasLength().\nThis means that most iterators are assumed to implement length.\n\nThis trait is generally used to select between algorithms that pre-allocate space for their\nresult, and algorithms that resize their result incrementally.\n\njulia> Base.IteratorSize(1:5)\nBase.HasShape{1}()\n\njulia> Base.IteratorSize((2,3))\nBase.HasLength()\n\n\n\n\n\n"},{"title":"Base.IteratorEltype","page":"Collections and Data Structures","location":"base/collections.html#Base.IteratorEltype","category":"type","text":"IteratorEltype(itertype::Type)::IteratorEltype\n\nGiven the type of an iterator, return one of the following values:\n\nEltypeUnknown() if the type of elements yielded by the iterator is not known in advance.\nHasEltype() if the element type is known, and eltype would return a meaningful value.\n\nHasEltype() is the default, since iterators are assumed to implement eltype.\n\nThis trait is generally used to select between algorithms that pre-allocate a specific\ntype of result, and algorithms that pick a result type based on the types of yielded\nvalues.\n\njulia> Base.IteratorEltype(1:5)\nBase.HasEltype()\n\n\n\n\n\n"},{"title":"Base.::","page":"Collections and Data Structures","location":"base/collections.html#Base.::-Tuple{Any, Any, Any}","category":"method","text":"(:)(start, [step], stop)\n\nRange operator. a:b constructs a range from a to b with a step size\nequal to +1, which produces:\n\na UnitRange when a and b are integers, or\na StepRange when a and b are characters, or\na StepRangeLen when a and/or b are floating-point.\n\na:s:b is similar but uses a step size of s (a StepRange or\nStepRangeLen). See also range for more control.\n\nTo create a descending range, use reverse(a:b) or a negative step size, e.g. b:-1:a.\nOtherwise, when b < a, an empty range will be constructed and normalized to a:a-1.\n\nThe operator : is also used in indexing to select whole dimensions, e.g. in A[:, 1].\n\n: is also used to quote code, e.g. :(x + y) isa Expr and :x isa Symbol.\nSince :2 isa Int, it does not create a range in indexing: v[:2] == v[2] != v[begin:2].\n\n\n\n\n\n"},{"title":"Base.::","page":"Collections and Data Structures","location":"base/collections.html#Base.::-Tuple{CartesianIndex, CartesianIndex, CartesianIndex}","category":"method","text":"(:)(start::CartesianIndex, [step::CartesianIndex], stop::CartesianIndex)\n\nConstruct CartesianIndices from two CartesianIndex and an optional step.\n\ncompat: Julia 1.1\nThis method requires at least Julia 1.1.\n\ncompat: Julia 1.6\nThe step range method start:step:stop requires at least Julia 1.6.\n\nExamples\n\njulia> I = CartesianIndex(2,1);\n\njulia> J = CartesianIndex(3,3);\n\njulia> I:J\nCartesianIndices((2:3, 1:3))\n\njulia> I:CartesianIndex(1, 2):J\nCartesianIndices((2:1:3, 1:2:3))\n\n\n\n\n\n"},{"title":"Base.range","page":"Collections and Data Structures","location":"base/collections.html#Base.range","category":"function","text":"range(start, stop, length)\nrange(start, stop; length, step)\nrange(start; length, stop, step)\nrange(;start, length, stop, step)\n\nConstruct a specialized array with evenly spaced elements and optimized storage (an AbstractRange) from the arguments.\nMathematically a range is uniquely determined by any three of start, step, stop and length.\nValid invocations of range are:\n\nCall range with any three of start, step, stop, length.\nCall range with two of start, stop, length. In this case step will be assumed\nto be positive one. If both arguments are Integers, a UnitRange will be returned.\nCall range with one of stop or length. start and step will be assumed to be positive one.\n\nTo construct a descending range, specify a negative step size, e.g. range(5, 1; step = -1) => [5,4,3,2,1]. Otherwise,\na stop value less than the start value, with the default step of +1, constructs an empty range. Empty ranges\nare normalized such that the stop is one less than the start, e.g. range(5, 1) == 5:4.\n\nSee Extended Help for additional details on the returned type.\nSee also logrange for logarithmically spaced points.\n\nExamples\n\njulia> range(1, length=100)\n1:100\n\njulia> range(1, stop=100)\n1:100\n\njulia> range(1, step=5, length=100)\n1:5:496\n\njulia> range(1, step=5, stop=100)\n1:5:96\n\njulia> range(1, 10, length=101)\n1.0:0.09:10.0\n\njulia> range(1, 100, step=5)\n1:5:96\n\njulia> range(stop=10, length=5)\n6:10\n\njulia> range(stop=10, step=1, length=5)\n6:1:10\n\njulia> range(start=1, step=1, stop=10)\n1:1:10\n\njulia> range(; length = 10)\nBase.OneTo(10)\n\njulia> range(; stop = 6)\nBase.OneTo(6)\n\njulia> range(; stop = 6.5)\n1.0:1.0:6.0\n\nIf length is not specified and stop - start is not an integer multiple of step, a range that ends before stop will be produced.\n\njulia> range(1, 3.5, step=2)\n1.0:2.0:3.0\n\nSpecial care is taken to ensure intermediate values are computed rationally.\nTo avoid this induced overhead, see the LinRange constructor.\n\ncompat: Julia 1.1\nstop as a positional argument requires at least Julia 1.1.\n\ncompat: Julia 1.7\nThe versions without keyword arguments and start as a keyword argument\nrequire at least Julia 1.7.\n\ncompat: Julia 1.8\nThe versions with stop as a sole keyword argument,\nor length as a sole keyword argument require at least Julia 1.8.\n\nExtended Help\n\nrange will produce a Base.OneTo when the arguments are Integers and\n\nOnly length is provided\nOnly stop is provided\n\nrange will produce a UnitRange when the arguments are Integers and\n\nOnly start  and stop are provided\nOnly length and stop are provided\n\nA UnitRange is not produced if step is provided even if specified as one.\n\n\n\n\n\n"},{"title":"Base.logrange","page":"Collections and Data Structures","location":"base/collections.html#Base.logrange","category":"function","text":"logrange(start, stop, length)\nlogrange(start, stop; length)\n\nConstruct a specialized array whose elements are spaced logarithmically\nbetween the given endpoints. That is, the ratio of successive elements is\na constant, calculated from the length.\n\nThis is similar to geomspace in Python. Unlike PowerRange in Mathematica,\nyou specify the number of elements not the ratio.\nUnlike logspace in Python and Matlab, the start and stop arguments are\nalways the first and last elements of the result, not powers applied to some base.\n\nExamples\n\njulia> logrange(10, 4000, length=3)\n3-element Base.LogRange{Float64, Base.TwicePrecision{Float64}}:\n 10.0, 200.0, 4000.0\n\njulia> ans[2] ≈ sqrt(10 * 4000)  # middle element is the geometric mean\ntrue\n\njulia> range(10, 40, length=3)[2] ≈ (10 + 40)/2  # arithmetic mean\ntrue\n\njulia> logrange(1f0, 32f0, 11)\n11-element Base.LogRange{Float32, Float64}:\n 1.0, 1.41421, 2.0, 2.82843, 4.0, 5.65685, 8.0, 11.3137, 16.0, 22.6274, 32.0\n\njulia> logrange(1, 1000, length=4) ≈ 10 .^ (0:3)\ntrue\n\nSee the LogRange type for further details.\n\nSee also range for linearly spaced points.\n\ncompat: Julia 1.11\nThis function requires at least Julia 1.11.\n\n\n\n\n\n"},{"title":"Base.AbstractRange","page":"Collections and Data Structures","location":"base/collections.html#Base.AbstractRange","category":"type","text":"AbstractRange{T} <: AbstractVector{T}\n\nSupertype for linear ranges with elements of type T.\nUnitRange, LinRange and other types are subtypes of this.\n\nAll subtypes must define step.\nThus LogRange is not a subtype of AbstractRange.\n\n\n\n\n\n"},{"title":"Base.OrdinalRange","page":"Collections and Data Structures","location":"base/collections.html#Base.OrdinalRange","category":"type","text":"OrdinalRange{T, S} <: AbstractRange{T}\n\nSupertype for ordinal ranges with elements of type T with\nspacing(s) of type S. The steps should be always-exact\nmultiples of oneunit, and T should be a \"discrete\"\ntype, which cannot have values smaller than oneunit. For example,\nInteger or Date types would qualify, whereas Float64 would not (since this\ntype can represent values smaller than oneunit(Float64).\nUnitRange, StepRange, and other types are subtypes of this.\n\n\n\n\n\n"},{"title":"Base.AbstractUnitRange","page":"Collections and Data Structures","location":"base/collections.html#Base.AbstractUnitRange","category":"type","text":"AbstractUnitRange{T} <: OrdinalRange{T, T}\n\nSupertype for ranges with a step size of oneunit(T) with elements of type T.\nUnitRange and other types are subtypes of this.\n\n\n\n\n\n"},{"title":"Base.StepRange","page":"Collections and Data Structures","location":"base/collections.html#Base.StepRange","category":"type","text":"StepRange{T, S} <: OrdinalRange{T, S}\n\nRanges with elements of type T with spacing of type S. The step\nbetween each element is constant, and the range is defined in terms\nof a start and stop of type T and a step of type S. Neither\nT nor S should be floating point types. The syntax a:b:c with b != 0\nand a, b, and c all integers creates a StepRange.\n\nExamples\n\njulia> collect(StepRange(1, Int8(2), 10))\n5-element Vector{Int64}:\n 1\n 3\n 5\n 7\n 9\n\njulia> typeof(StepRange(1, Int8(2), 10))\nStepRange{Int64, Int8}\n\njulia> typeof(1:3:6)\nStepRange{Int64, Int64}\n\n\n\n\n\n"},{"title":"Base.StepRangeLen","page":"Collections and Data Structures","location":"base/collections.html#Base.StepRangeLen","category":"type","text":"StepRangeLen(         ref::R, step::S, len, [offset=1]) where {  R,S}\nStepRangeLen{T,R,S}(  ref::R, step::S, len, [offset=1]) where {T,R,S}\nStepRangeLen{T,R,S,L}(ref::R, step::S, len, [offset=1]) where {T,R,S,L}\n\nA range r where r[i] produces values of type T (in the first\nform, T is deduced automatically), parameterized by a reference\nvalue, a step, and the length. By default ref is the starting\nvalue r[1], but alternatively you can supply it as the value of\nr[offset] for some other index 1 <= offset <= len. The syntax a:b\nor a:b:c, where any of a, b, or c are floating-point numbers, creates a\nStepRangeLen.\n\ncompat: Julia 1.7\nThe 4th type parameter L requires at least Julia 1.7.\n\n\n\n\n\n"},{"title":"Base.UnitRange","page":"Collections and Data Structures","location":"base/collections.html#Base.UnitRange","category":"type","text":"UnitRange{T<:Real}\n\nA range parameterized by a start and stop of type T, filled\nwith elements spaced by 1 from start until stop is exceeded.\nThe syntax a:b with a and b both Integers creates a UnitRange.\n\nExamples\n\njulia> collect(UnitRange(2.3, 5.2))\n3-element Vector{Float64}:\n 2.3\n 3.3\n 4.3\n\njulia> typeof(1:10)\nUnitRange{Int64}\n\n\n\n\n\n"},{"title":"Base.OneTo","page":"Collections and Data Structures","location":"base/collections.html#Base.OneTo","category":"type","text":"Base.OneTo(n)\n\nDefine an AbstractUnitRange that behaves like 1:n, with the added\ndistinction that the lower limit is guaranteed (by the type system) to\nbe 1.\n\n\n\n\n\n"},{"title":"Base.LinRange","page":"Collections and Data Structures","location":"base/collections.html#Base.LinRange","category":"type","text":"LinRange{T,L}\n\nA range with len linearly spaced elements between its start and stop.\nThe size of the spacing is controlled by len, which must\nbe an Integer.\n\nExamples\n\njulia> LinRange(1.5, 5.5, 9)\n9-element LinRange{Float64, Int64}:\n 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5\n\nCompared to using range, directly constructing a LinRange should\nhave less overhead but won't try to correct for floating point errors:\n\njulia> collect(range(-0.1, 0.3, length=5))\n5-element Vector{Float64}:\n -0.1\n  0.0\n  0.1\n  0.2\n  0.3\n\njulia> collect(LinRange(-0.1, 0.3, 5))\n5-element Vector{Float64}:\n -0.1\n -1.3877787807814457e-17\n  0.09999999999999999\n  0.19999999999999998\n  0.3\n\nSee also Base.LogRange for logarithmically spaced points.\n\n\n\n\n\n"},{"title":"Base.LogRange","page":"Collections and Data Structures","location":"base/collections.html#Base.LogRange","category":"type","text":"LogRange{T}(start, stop, len) <: AbstractVector{T}\n\nA range whose elements are spaced logarithmically between start and stop,\nwith spacing controlled by len. Returned by logrange.\n\nLike LinRange, the first and last elements will be exactly those\nprovided, but intermediate values may have small floating-point errors.\nThese are calculated using the logs of the endpoints, which are\nstored on construction, often in higher precision than T.\n\nExamples\n\njulia> logrange(1, 4, length=5)\n5-element Base.LogRange{Float64, Base.TwicePrecision{Float64}}:\n 1.0, 1.41421, 2.0, 2.82843, 4.0\n\njulia> Base.LogRange{Float16}(1, 4, 5)\n5-element Base.LogRange{Float16, Float64}:\n 1.0, 1.414, 2.0, 2.828, 4.0\n\njulia> logrange(1e-310, 1e-300, 11)[1:2:end]\n6-element Vector{Float64}:\n 1.0e-310\n 9.999999999999974e-309\n 9.999999999999981e-307\n 9.999999999999988e-305\n 9.999999999999994e-303\n 1.0e-300\n\njulia> prevfloat(1e-308, 5) == ans[2]\ntrue\n\nNote that integer eltype T is not allowed.\nUse for instance round.(Int, xs), or explicit powers of some integer base:\n\njulia> xs = logrange(1, 512, 4)\n4-element Base.LogRange{Float64, Base.TwicePrecision{Float64}}:\n 1.0, 8.0, 64.0, 512.0\n\njulia> 2 .^ (0:3:9) |> println\n[1, 8, 64, 512]\n\ncompat: Julia 1.11\nThis type requires at least Julia 1.11.\n\n\n\n\n\n"},{"title":"Base.isempty","page":"Collections and Data Structures","location":"base/collections.html#Base.isempty","category":"function","text":"isempty(condition)\n\nReturn true if no tasks are waiting on the condition, false otherwise.\n\n\n\n\n\nisempty(collection)::Bool\n\nDetermine whether a collection is empty (has no elements).\n\nwarning: Warning\nisempty(itr) may consume the next element of a stateful iterator itr\nunless an appropriate Base.isdone(itr) method is defined.\nStateful iterators should implement isdone, but you may want to avoid\nusing isempty when writing generic code which should support any iterator\ntype.\n\nExamples\n\njulia> isempty([])\ntrue\n\njulia> isempty([1 2 3])\nfalse\n\n\n\n\n\n"},{"title":"Base.isdone","page":"Collections and Data Structures","location":"base/collections.html#Base.isdone","category":"function","text":"isdone(itr, [state])::Union{Bool, Missing}\n\nThis function provides a fast-path hint for iterator completion.\nThis is useful for stateful iterators that want to avoid having elements\nconsumed if they are not going to be exposed to the user (e.g. when checking\nfor done-ness in isempty or zip).\n\nStateful iterators that want to opt into this feature should define an isdone\nmethod that returns true/false depending on whether the iterator is done or\nnot. Stateless iterators need not implement this function.\n\nIf the result is missing, then isdone cannot determine whether the iterator\nstate is terminal, and callers must compute iterate(itr, state) === nothing\nto obtain a definitive answer.\n\nSee also iterate, isempty\n\n\n\n\n\n"},{"title":"Base.empty!","page":"Collections and Data Structures","location":"base/collections.html#Base.empty!","category":"function","text":"empty!(c::Channel)\n\nEmpty a Channel c by calling empty! on the internal buffer.\nReturn the empty channel.\n\n\n\n\n\nempty!(collection) -> collection\n\nRemove all elements from a collection.\n\nExamples\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String, Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> empty!(A);\n\njulia> A\nDict{String, Int64}()\n\n\n\n\n\n"},{"title":"Base.length","page":"Collections and Data Structures","location":"base/collections.html#Base.length","category":"function","text":"length(collection)::Integer\n\nReturn the number of elements in the collection.\n\nUse lastindex to get the last valid index of an indexable collection.\n\nSee also: size, ndims, eachindex.\n\nExamples\n\njulia> length(1:5)\n5\n\njulia> length([1, 2, 3, 4])\n4\n\njulia> length([1 2; 3 4])\n4\n\n\n\n\n\n"},{"title":"Base.checked_length","page":"Collections and Data Structures","location":"base/collections.html#Base.checked_length","category":"function","text":"Base.checked_length(r)\n\nCalculates length(r), but may check for overflow errors where applicable when\nthe result doesn't fit into Union{Integer(eltype(r)),Int}.\n\n\n\n\n\n"},{"title":"Base.in","page":"Collections and Data Structures","location":"base/collections.html#Base.in","category":"function","text":"in(item, collection)::Bool\n∈(item, collection)::Bool\n\nDetermine whether an item is in the given collection, in the sense that it is\n== to one of the values generated by iterating over the collection.\nCan equivalently be used with infix syntax:\n\nitem in collection\nitem ∈ collection\n\nReturn a Bool value, except if item is missing or collection\ncontains missing but not item, in which case missing is returned\n(three-valued logic,\nmatching the behavior of any and ==).\nSome collections follow a slightly different definition. For example,\nSets check whether the item isequal to one of the elements;\nDicts look for key=>value pairs, and the key is compared using\nisequal.\n\nTo test for the presence of a key in a dictionary, use haskey\nor k in keys(dict). For the collections mentioned above,\nthe result is always a Bool.\n\nWhen broadcasting with in.(items, collection) or items .∈ collection, both\nitems and collection are broadcasted over, which is often not what is intended.\nFor example, if both arguments are vectors (and the dimensions match), the result is\na vector indicating whether each value in collection items is in the value at the\ncorresponding position in collection. To get a vector indicating whether each value\nin items is in collection, wrap collection in a tuple or a Ref like this:\nin.(items, Ref(collection)) or items .∈ Ref(collection).\n\nSee also: ∉, insorted, contains, occursin, issubset.\n\nExamples\n\njulia> a = 1:3:20\n1:3:19\n\njulia> 4 in a\ntrue\n\njulia> 5 in a\nfalse\n\njulia> missing in [1, 2]\nmissing\n\njulia> 1 in [2, missing]\nmissing\n\njulia> 1 in [1, missing]\ntrue\n\njulia> missing in Set([1, 2])\nfalse\n\njulia> (1=>missing) in Dict(1=>10, 2=>20)\nmissing\n\njulia> [1, 2] .∈ [2, 3]\n2-element BitVector:\n 0\n 0\n\njulia> [1, 2] .∈ ([2, 3],)\n2-element BitVector:\n 0\n 1\n\n\n\n\n\n"},{"title":"Base.:∉","page":"Collections and Data Structures","location":"base/collections.html#Base.:∉","category":"function","text":"∉(item, collection)::Bool\n∌(collection, item)::Bool\n\nNegation of ∈ and ∋, i.e. checks that item is not in collection.\n\nWhen broadcasting with items .∉ collection, both items and collection are\nbroadcasted over, which is often not what is intended. For example, if both arguments\nare vectors (and the dimensions match), the result is a vector indicating whether\neach value in collection items is not in the value at the corresponding position\nin collection. To get a vector indicating whether each value in items is not in\ncollection, wrap collection in a tuple or a Ref like this:\nitems .∉ Ref(collection).\n\nExamples\n\njulia> 1 ∉ 2:4\ntrue\n\njulia> 1 ∉ 1:3\nfalse\n\njulia> [1, 2] .∉ [2, 3]\n2-element BitVector:\n 1\n 1\n\njulia> [1, 2] .∉ ([2, 3],)\n2-element BitVector:\n 1\n 0\n\n\n\n\n\n"},{"title":"Base.hasfastin","page":"Collections and Data Structures","location":"base/collections.html#Base.hasfastin","category":"function","text":"Base.hasfastin(T)\n\nDetermine whether the computation x ∈ collection where collection::T can be considered\nas a \"fast\" operation (typically constant or logarithmic complexity).\nThe definition hasfastin(x) = hasfastin(typeof(x)) is provided for convenience so that instances\ncan be passed instead of types.\nHowever the form that accepts a type argument should be defined for new types.\n\nThe default for hasfastin(T) is true for subtypes of\nAbstractSet, AbstractDict and AbstractRange\nand false otherwise.\n\n\n\n\n\n"},{"title":"Base.eltype","page":"Collections and Data Structures","location":"base/collections.html#Base.eltype","category":"function","text":"eltype(type)\n\nDetermine the type of the elements generated by iterating a collection of the given type.\nFor dictionary types, this will be a Pair{KeyType,ValType}. The definition\neltype(x) = eltype(typeof(x)) is provided for convenience so that instances can be passed\ninstead of types. However the form that accepts a type argument should be defined for new\ntypes.\n\nSee also: keytype, typeof.\n\nExamples\n\njulia> eltype(fill(1f0, (2,2)))\nFloat32\n\njulia> eltype(fill(0x1, (2,2)))\nUInt8\n\n\n\n\n\n"},{"title":"Base.indexin","page":"Collections and Data Structures","location":"base/collections.html#Base.indexin","category":"function","text":"indexin(a, b)\n\nReturn an array containing the first index in b for\neach value in a that is a member of b. The output\narray contains nothing wherever a is not a member of b.\n\nSee also: sortperm, findfirst.\n\nExamples\n\njulia> a = ['a', 'b', 'c', 'b', 'd', 'a'];\n\njulia> b = ['a', 'b', 'c'];\n\njulia> indexin(a, b)\n6-element Vector{Union{Nothing, Int64}}:\n 1\n 2\n 3\n 2\n  nothing\n 1\n\njulia> indexin(b, a)\n3-element Vector{Union{Nothing, Int64}}:\n 1\n 2\n 3\n\n\n\n\n\n"},{"title":"Base.unique","page":"Collections and Data Structures","location":"base/collections.html#Base.unique","category":"function","text":"unique(A::AbstractArray; dims::Int)\n\nReturn unique regions of A along dimension dims.\n\nExamples\n\njulia> A = map(isodd, reshape(Vector(1:8), (2,2,2)))\n2×2×2 Array{Bool, 3}:\n[:, :, 1] =\n 1  1\n 0  0\n\n[:, :, 2] =\n 1  1\n 0  0\n\njulia> unique(A)\n2-element Vector{Bool}:\n 1\n 0\n\njulia> unique(A, dims=2)\n2×1×2 Array{Bool, 3}:\n[:, :, 1] =\n 1\n 0\n\n[:, :, 2] =\n 1\n 0\n\njulia> unique(A, dims=3)\n2×2×1 Array{Bool, 3}:\n[:, :, 1] =\n 1  1\n 0  0\n\n\n\n\n\nunique(f, itr)\n\nReturn an array containing one value from itr for each unique value produced by f\napplied to elements of itr.\n\nExamples\n\njulia> unique(x -> x^2, [1, -1, 3, -3, 4])\n3-element Vector{Int64}:\n 1\n 3\n 4\n\nThis functionality can also be used to extract the indices of the first\noccurrences of unique elements in an array:\n\njulia> a = [3.1, 4.2, 5.3, 3.1, 3.1, 3.1, 4.2, 1.7];\n\njulia> i = unique(i -> a[i], eachindex(a))\n4-element Vector{Int64}:\n 1\n 2\n 3\n 8\n\njulia> a[i]\n4-element Vector{Float64}:\n 3.1\n 4.2\n 5.3\n 1.7\n\njulia> a[i] == unique(a)\ntrue\n\n\n\n\n\nunique(itr)\n\nReturn an array containing only the unique elements of collection itr,\nas determined by isequal and hash, in the order that the first of each\nset of equivalent elements originally appears. The element type of the\ninput is preserved.\n\nSee also: unique!, allunique, allequal.\n\nExamples\n\njulia> unique([1, 2, 6, 2])\n3-element Vector{Int64}:\n 1\n 2\n 6\n\njulia> unique(Real[1, 1.0, 2])\n2-element Vector{Real}:\n 1\n 2\n\n\n\n\n\n"},{"title":"Base.unique!","page":"Collections and Data Structures","location":"base/collections.html#Base.unique!","category":"function","text":"unique!(A::AbstractVector)\n\nRemove duplicate items as determined by isequal and hash, then return the modified A.\nunique! will return the elements of A in the order that they occur. If you do not care\nabout the order of the returned data, then calling (sort!(A); unique!(A)) will be much\nmore efficient as long as the elements of A can be sorted.\n\nExamples\n\njulia> unique!([1, 1, 1])\n1-element Vector{Int64}:\n 1\n\njulia> A = [7, 3, 2, 3, 7, 5];\n\njulia> unique!(A)\n4-element Vector{Int64}:\n 7\n 3\n 2\n 5\n\njulia> B = [7, 6, 42, 6, 7, 42];\n\njulia> sort!(B);  # unique! is able to process sorted data much more efficiently.\n\njulia> unique!(B)\n3-element Vector{Int64}:\n  6\n  7\n 42\n\n\n\n\n\nunique!(f, A::AbstractVector)\n\nSelects one value from A for each unique value produced by f applied to\nelements of A, then return the modified A.\n\ncompat: Julia 1.1\nThis method is available as of Julia 1.1.\n\nExamples\n\njulia> unique!(x -> x^2, [1, -1, 3, -3, 4])\n3-element Vector{Int64}:\n 1\n 3\n 4\n\njulia> unique!(n -> n%3, [5, 1, 8, 9, 3, 4, 10, 7, 2, 6])\n3-element Vector{Int64}:\n 5\n 1\n 9\n\njulia> unique!(iseven, [2, 3, 5, 7, 9])\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n\n"},{"title":"Base.allunique","page":"Collections and Data Structures","location":"base/collections.html#Base.allunique","category":"function","text":"allunique(itr)::Bool\nallunique(f, itr)::Bool\n\nReturn true if all values from itr are distinct when compared with isequal.\nOr if all of [f(x) for x in itr] are distinct, for the second method.\n\nNote that allunique(f, itr) may call f fewer than length(itr) times.\nThe precise number of calls is regarded as an implementation detail.\n\nallunique may use a specialized implementation when the input is sorted.\n\nSee also: unique, issorted, allequal.\n\ncompat: Julia 1.11\nThe method allunique(f, itr) requires at least Julia 1.11.\n\nExamples\n\njulia> allunique([1, 2, 3])\ntrue\n\njulia> allunique([1, 2, 1, 2])\nfalse\n\njulia> allunique(Real[1, 1.0, 2])\nfalse\n\njulia> allunique([NaN, 2.0, NaN, 4.0])\nfalse\n\njulia> allunique(abs, [1, -1, 2])\nfalse\n\n\n\n\n\n"},{"title":"Base.allequal","page":"Collections and Data Structures","location":"base/collections.html#Base.allequal","category":"function","text":"allequal(itr)::Bool\nallequal(f, itr)::Bool\n\nReturn true if all values from itr are equal when compared with isequal.\nOr if all of [f(x) for x in itr] are equal, for the second method.\n\nNote that allequal(f, itr) may call f fewer than length(itr) times.\nThe precise number of calls is regarded as an implementation detail.\n\nSee also: unique, allunique.\n\ncompat: Julia 1.8\nThe allequal function requires at least Julia 1.8.\n\ncompat: Julia 1.11\nThe method allequal(f, itr) requires at least Julia 1.11.\n\nExamples\n\njulia> allequal([])\ntrue\n\njulia> allequal([1])\ntrue\n\njulia> allequal([1, 1])\ntrue\n\njulia> allequal([1, 2])\nfalse\n\njulia> allequal(Dict(:a => 1, :b => 1))\nfalse\n\njulia> allequal(abs2, [1, -1])\ntrue\n\n\n\n\n\n"},{"title":"Base.reduce","page":"Collections and Data Structures","location":"base/collections.html#Base.reduce-Tuple{Any, Any}","category":"method","text":"reduce(op, itr; [init])\n\nReduce the given collection itr with the given binary operator op. If provided, the\ninitial value init must be a neutral element for op that will be returned for empty\ncollections. It is unspecified whether init is used for non-empty collections.\n\nFor empty collections, providing init will be necessary, except for some special cases\n(e.g. when op is one of +, *, max, min, &, |) when Julia can determine the\nneutral element of op.\n\nReductions for certain commonly-used operators may have special implementations, and\nshould be used instead: maximum(itr), minimum(itr), sum(itr),\nprod(itr), any(itr), all(itr).\nThere are efficient methods for concatenating certain arrays of arrays\nby calling reduce(vcat, arr) or reduce(hcat, arr).\n\nThe associativity of the reduction is implementation dependent. This means that you can't\nuse non-associative operations like - because it is undefined whether reduce(-,[1,2,3])\nshould be evaluated as (1-2)-3 or 1-(2-3). Use foldl or\nfoldr instead for guaranteed left or right associativity.\n\nSome operations accumulate error. Parallelism will be easier if the reduction can be\nexecuted in groups. Future versions of Julia might change the algorithm. Note that the\nelements are not reordered if you use an ordered collection.\n\nExamples\n\njulia> reduce(*, [2; 3; 4])\n24\n\njulia> reduce(*, Int[]; init=1)\n1\n\n\n\n\n\n"},{"title":"Base.reduce","page":"Collections and Data Structures","location":"base/collections.html#Base.reduce-Tuple{Any, AbstractArray}","category":"method","text":"reduce(f, A::AbstractArray; dims=:, [init])\n\nReduce 2-argument function f along dimensions of A. dims is a vector specifying the\ndimensions to reduce, and the keyword argument init is the initial value to use in the\nreductions. For +, *, max and min the init argument is optional.\n\nThe associativity of the reduction is implementation-dependent; if you need a particular\nassociativity, e.g. left-to-right, you should write your own loop or consider using\nfoldl or foldr. See documentation for reduce.\n\nExamples\n\njulia> a = reshape(Vector(1:16), (4,4))\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> reduce(max, a, dims=2)\n4×1 Matrix{Int64}:\n 13\n 14\n 15\n 16\n\njulia> reduce(max, a, dims=1)\n1×4 Matrix{Int64}:\n 4  8  12  16\n\n\n\n\n\n"},{"title":"Base.foldl","page":"Collections and Data Structures","location":"base/collections.html#Base.foldl-Tuple{Any, Any}","category":"method","text":"foldl(op, itr; [init])\n\nLike reduce, but with guaranteed left associativity. If provided, the keyword\nargument init will be used exactly once. In general, it will be necessary to provide\ninit to work with empty collections.\n\nSee also mapfoldl, foldr, accumulate.\n\nExamples\n\njulia> foldl(=>, 1:4)\n((1 => 2) => 3) => 4\n\njulia> foldl(=>, 1:4; init=0)\n(((0 => 1) => 2) => 3) => 4\n\njulia> accumulate(=>, (1,2,3,4))\n(1, 1 => 2, (1 => 2) => 3, ((1 => 2) => 3) => 4)\n\n\n\n\n\n"},{"title":"Base.foldr","page":"Collections and Data Structures","location":"base/collections.html#Base.foldr-Tuple{Any, Any}","category":"method","text":"foldr(op, itr; [init])\n\nLike reduce, but with guaranteed right associativity. If provided, the keyword\nargument init will be used exactly once. In general, it will be necessary to provide\ninit to work with empty collections.\n\nExamples\n\njulia> foldr(=>, 1:4)\n1 => (2 => (3 => 4))\n\njulia> foldr(=>, 1:4; init=0)\n1 => (2 => (3 => (4 => 0)))\n\n\n\n\n\n"},{"title":"Base.maximum","page":"Collections and Data Structures","location":"base/collections.html#Base.maximum","category":"function","text":"maximum(f, A::AbstractArray; dims)\n\nCompute the maximum value by calling the function f on each element of an array over the given\ndimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> maximum(abs2, A, dims=1)\n1×2 Matrix{Int64}:\n 9  16\n\njulia> maximum(abs2, A, dims=2)\n2×1 Matrix{Int64}:\n  4\n 16\n\n\n\n\n\nmaximum(A::AbstractArray; dims)\n\nCompute the maximum value of an array over the given dimensions. See also the\nmax(a,b) function to take the maximum of two or more arguments,\nwhich can be applied elementwise to arrays via max.(a,b).\n\nSee also: maximum!, extrema, findmax, argmax.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> maximum(A, dims=1)\n1×2 Matrix{Int64}:\n 3  4\n\njulia> maximum(A, dims=2)\n2×1 Matrix{Int64}:\n 2\n 4\n\n\n\n\n\nmaximum(itr; [init])\n\nReturn the largest element in a collection.\n\nThe value returned for empty itr can be specified by init. It must be\na neutral element for max (i.e. which is less than or equal to any\nother element) as it is unspecified whether init is used\nfor non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> maximum(-20.5:10)\n9.5\n\njulia> maximum([1,2,3])\n3\n\njulia> maximum(())\nERROR: ArgumentError: reducing over an empty collection is not allowed; consider supplying `init` to the reducer\nStacktrace:\n[...]\n\njulia> maximum((); init=-Inf)\n-Inf\n\n\n\n\n\nmaximum(f, itr; [init])\n\nReturn the largest result of calling function f on each element of itr.\n\nThe value returned for empty itr can be specified by init. It must be\na neutral element for max (i.e. which is less than or equal to any\nother element) as it is unspecified whether init is used\nfor non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> maximum(length, [\"Julion\", \"Julia\", \"Jule\"])\n6\n\njulia> maximum(length, []; init=-1)\n-1\n\njulia> maximum(sin, Real[]; init=-1.0)  # good, since output of sin is >= -1\n-1.0\n\n\n\n\n\n"},{"title":"Base.maximum!","page":"Collections and Data Structures","location":"base/collections.html#Base.maximum!","category":"function","text":"maximum!(r, A)\n\nCompute the maximum value of A over the singleton dimensions of r, and write results to r.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> maximum!([1; 1], A)\n2-element Vector{Int64}:\n 2\n 4\n\njulia> maximum!([1 1], A)\n1×2 Matrix{Int64}:\n 3  4\n\n\n\n\n\n"},{"title":"Base.minimum","page":"Collections and Data Structures","location":"base/collections.html#Base.minimum","category":"function","text":"minimum(f, A::AbstractArray; dims)\n\nCompute the minimum value by calling the function f on each element of an array over the given\ndimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> minimum(abs2, A, dims=1)\n1×2 Matrix{Int64}:\n 1  4\n\njulia> minimum(abs2, A, dims=2)\n2×1 Matrix{Int64}:\n 1\n 9\n\n\n\n\n\nminimum(A::AbstractArray; dims)\n\nCompute the minimum value of an array over the given dimensions. See also the\nmin(a,b) function to take the minimum of two or more arguments,\nwhich can be applied elementwise to arrays via min.(a,b).\n\nSee also: minimum!, extrema, findmin, argmin.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> minimum(A, dims=1)\n1×2 Matrix{Int64}:\n 1  2\n\njulia> minimum(A, dims=2)\n2×1 Matrix{Int64}:\n 1\n 3\n\n\n\n\n\nminimum(itr; [init])\n\nReturn the smallest element in a collection.\n\nThe value returned for empty itr can be specified by init. It must be\na neutral element for min (i.e. which is greater than or equal to any\nother element) as it is unspecified whether init is used\nfor non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> minimum(-20.5:10)\n-20.5\n\njulia> minimum([1,2,3])\n1\n\njulia> minimum([])\nERROR: ArgumentError: reducing over an empty collection is not allowed; consider supplying `init` to the reducer\nStacktrace:\n[...]\n\njulia> minimum([]; init=Inf)\nInf\n\n\n\n\n\nminimum(f, itr; [init])\n\nReturn the smallest result of calling function f on each element of itr.\n\nThe value returned for empty itr can be specified by init. It must be\na neutral element for min (i.e. which is greater than or equal to any\nother element) as it is unspecified whether init is used\nfor non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> minimum(length, [\"Julion\", \"Julia\", \"Jule\"])\n4\n\njulia> minimum(length, []; init=typemax(Int64))\n9223372036854775807\n\njulia> minimum(sin, Real[]; init=1.0)  # good, since output of sin is <= 1\n1.0\n\n\n\n\n\n"},{"title":"Base.minimum!","page":"Collections and Data Structures","location":"base/collections.html#Base.minimum!","category":"function","text":"minimum!(r, A)\n\nCompute the minimum value of A over the singleton dimensions of r, and write results to r.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> minimum!([1; 1], A)\n2-element Vector{Int64}:\n 1\n 3\n\njulia> minimum!([1 1], A)\n1×2 Matrix{Int64}:\n 1  2\n\n\n\n\n\n"},{"title":"Base.extrema","page":"Collections and Data Structures","location":"base/collections.html#Base.extrema","category":"function","text":"extrema(f, A::AbstractArray; dims) -> Array{Tuple}\n\nCompute the minimum and maximum of f applied to each element in the given dimensions\nof A.\n\ncompat: Julia 1.2\nThis method requires Julia 1.2 or later.\n\n\n\n\n\nextrema(A::AbstractArray; dims) -> Array{Tuple}\n\nCompute the minimum and maximum elements of an array over the given dimensions.\n\nSee also: minimum, maximum, extrema!.\n\nExamples\n\njulia> A = reshape(Vector(1:2:16), (2,2,2))\n2×2×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  5\n 3  7\n\n[:, :, 2] =\n  9  13\n 11  15\n\njulia> extrema(A, dims = (1,2))\n1×1×2 Array{Tuple{Int64, Int64}, 3}:\n[:, :, 1] =\n (1, 7)\n\n[:, :, 2] =\n (9, 15)\n\n\n\n\n\nextrema(f, itr; [init]) -> (mn, mx)\n\nCompute both the minimum mn and maximum mx of f applied to each element in itr and\nreturn them as a 2-tuple. Only one pass is made over itr.\n\nThe value returned for empty itr can be specified by init. It must be a 2-tuple whose\nfirst and second elements are neutral elements for min and max respectively\n(i.e. which are greater/less than or equal to any other element). It is used for non-empty\ncollections. Note: it implies that, for empty itr, the returned value (mn, mx) satisfies\nmn ≥ mx even though for non-empty itr it  satisfies mn ≤ mx.  This is a \"paradoxical\"\nbut yet expected result.\n\ncompat: Julia 1.2\nThis method requires Julia 1.2 or later.\n\ncompat: Julia 1.8\nKeyword argument init requires Julia 1.8 or later.\n\nExamples\n\njulia> extrema(sin, 0:π)\n(0.0, 0.9092974268256817)\n\njulia> extrema(sin, Real[]; init = (1.0, -1.0))  # good, since -1 ≤ sin(::Real) ≤ 1\n(1.0, -1.0)\n\n\n\n\n\nextrema(itr; [init]) -> (mn, mx)\n\nCompute both the minimum mn and maximum mx element in a single pass, and return them\nas a 2-tuple.\n\nThe value returned for empty itr can be specified by init. It must be a 2-tuple whose\nfirst and second elements are neutral elements for min and max respectively\n(i.e. which are greater/less than or equal to any other element). As a consequence, when\nitr is empty the returned (mn, mx) tuple will satisfy mn ≥ mx. When init is\nspecified it may be used even for non-empty itr.\n\ncompat: Julia 1.8\nKeyword argument init requires Julia 1.8 or later.\n\nExamples\n\njulia> extrema(2:10)\n(2, 10)\n\njulia> extrema([9,pi,4.5])\n(3.141592653589793, 9.0)\n\njulia> extrema([]; init = (Inf, -Inf))\n(Inf, -Inf)\n\n\n\n\n\n"},{"title":"Base.extrema!","page":"Collections and Data Structures","location":"base/collections.html#Base.extrema!","category":"function","text":"extrema!(r, A)\n\nCompute the minimum and maximum value of A over the singleton dimensions of r, and write results to r.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\ncompat: Julia 1.8\nThis method requires Julia 1.8 or later.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> extrema!([(1, 1); (1, 1)], A)\n2-element Vector{Tuple{Int64, Int64}}:\n (1, 2)\n (3, 4)\n\njulia> extrema!([(1, 1);; (1, 1)], A)\n1×2 Matrix{Tuple{Int64, Int64}}:\n (1, 3)  (2, 4)\n\n\n\n\n\n"},{"title":"Base.argmax","page":"Collections and Data Structures","location":"base/collections.html#Base.argmax","category":"function","text":"argmax(A; dims) -> indices\n\nFor an array input, return the indices of the maximum elements over the given dimensions.\nNaN is treated as greater than all other values except missing.\n\nExamples\n\njulia> A = [1.0 2; 3 4]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> argmax(A, dims=1)\n1×2 Matrix{CartesianIndex{2}}:\n CartesianIndex(2, 1)  CartesianIndex(2, 2)\n\njulia> argmax(A, dims=2)\n2×1 Matrix{CartesianIndex{2}}:\n CartesianIndex(1, 2)\n CartesianIndex(2, 2)\n\n\n\n\n\nargmax(itr)\n\nReturn the index or key of the maximal element in a collection.\nIf there are multiple maximal elements, then the first one will be returned.\n\nThe collection must not be empty.\n\nIndices are of the same type as those returned by keys(itr)\nand pairs(itr).\n\nValues are compared with isless.\n\nSee also: argmin, findmax.\n\nExamples\n\njulia> argmax([8, 0.1, -9, pi])\n1\n\njulia> argmax([1, 7, 7, 6])\n2\n\njulia> argmax([1, 7, 7, NaN])\n4\n\n\n\n\n\nargmax(f, domain)\n\nReturn a value x from domain for which f(x) is maximised.\nIf there are multiple maximal values for f(x) then the first one will be found.\n\ndomain must be a non-empty iterable.\n\nValues are compared with isless.\n\ncompat: Julia 1.7\nThis method requires Julia 1.7 or later.\n\nSee also argmin, findmax.\n\nExamples\n\njulia> argmax(abs, -10:5)\n-10\n\njulia> argmax(cos, 0:π/2:2π)\n0.0\n\n\n\n\n\nargmax(r::AbstractRange)\n\nRanges can have multiple maximal elements. In that case\nargmax will return a maximal index, but not necessarily the\nfirst one.\n\n\n\n\n\n"},{"title":"Base.argmin","page":"Collections and Data Structures","location":"base/collections.html#Base.argmin","category":"function","text":"argmin(A; dims) -> indices\n\nFor an array input, return the indices of the minimum elements over the given dimensions.\nNaN is treated as less than all other values except missing.\n\nExamples\n\njulia> A = [1.0 2; 3 4]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> argmin(A, dims=1)\n1×2 Matrix{CartesianIndex{2}}:\n CartesianIndex(1, 1)  CartesianIndex(1, 2)\n\njulia> argmin(A, dims=2)\n2×1 Matrix{CartesianIndex{2}}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 1)\n\n\n\n\n\nargmin(itr)\n\nReturn the index or key of the minimal element in a collection.\nIf there are multiple minimal elements, then the first one will be returned.\n\nThe collection must not be empty.\n\nIndices are of the same type as those returned by keys(itr)\nand pairs(itr).\n\nNaN is treated as less than all other values except missing.\n\nSee also: argmax, findmin.\n\nExamples\n\njulia> argmin([8, 0.1, -9, pi])\n3\n\njulia> argmin([7, 1, 1, 6])\n2\n\njulia> argmin([7, 1, 1, NaN])\n4\n\n\n\n\n\nargmin(f, domain)\n\nReturn a value x from domain for which f(x) is minimised.\nIf there are multiple minimal values for f(x) then the first one will be found.\n\ndomain must be a non-empty iterable.\n\nNaN is treated as less than all other values except missing.\n\ncompat: Julia 1.7\nThis method requires Julia 1.7 or later.\n\nSee also argmax, findmin.\n\nExamples\n\njulia> argmin(sign, -10:5)\n-10\n\njulia> argmin(x -> -x^3 + x^2 - 10, -5:5)\n5\n\njulia> argmin(acos, 0:0.1:1)\n1.0\n\n\n\n\n\nargmin(r::AbstractRange)\n\nRanges can have multiple minimal elements. In that case\nargmin will return a minimal index, but not necessarily the\nfirst one.\n\n\n\n\n\n"},{"title":"Base.findmax","page":"Collections and Data Structures","location":"base/collections.html#Base.findmax","category":"function","text":"findmax(f, A; dims) -> (f(x), index)\n\nFor an array input, returns the value in the codomain and index of the corresponding value\nwhich maximize f over the given dimensions.\n\nExamples\n\njulia> A = [-1.0 1; -0.5 2]\n2×2 Matrix{Float64}:\n -1.0  1.0\n -0.5  2.0\n\njulia> findmax(abs2, A, dims=1)\n([1.0 4.0], CartesianIndex{2}[CartesianIndex(1, 1) CartesianIndex(2, 2)])\n\njulia> findmax(abs2, A, dims=2)\n([1.0; 4.0;;], CartesianIndex{2}[CartesianIndex(1, 1); CartesianIndex(2, 2);;])\n\n\n\n\n\nfindmax(A; dims) -> (maxval, index)\n\nFor an array input, returns the value and index of the maximum over the given dimensions.\nNaN is treated as greater than all other values except missing.\n\nExamples\n\njulia> A = [1.0 2; 3 4]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> findmax(A, dims=1)\n([3.0 4.0], CartesianIndex{2}[CartesianIndex(2, 1) CartesianIndex(2, 2)])\n\njulia> findmax(A, dims=2)\n([2.0; 4.0;;], CartesianIndex{2}[CartesianIndex(1, 2); CartesianIndex(2, 2);;])\n\n\n\n\n\nfindmax(itr) -> (x, index)\n\nReturn the maximal element of the collection itr and its index or key.\nIf there are multiple maximal elements, then the first one will be returned.\nValues are compared with isless.\n\nIndices are of the same type as those returned by keys(itr)\nand pairs(itr).\n\nSee also: findmin, argmax, maximum.\n\nExamples\n\njulia> findmax([8, 0.1, -9, pi])\n(8.0, 1)\n\njulia> findmax([1, 7, 7, 6])\n(7, 2)\n\njulia> findmax([1, 7, 7, NaN])\n(NaN, 4)\n\n\n\n\n\nfindmax(f, domain) -> (f(x), index)\n\nReturn a pair of a value in the codomain (outputs of f) and the index or key of\nthe corresponding value in the domain (inputs to f) such that f(x) is maximised.\nIf there are multiple maximal points, then the first one will be returned.\n\ndomain must be a non-empty iterable supporting keys. Indices\nare of the same type as those returned by keys(domain).\n\nValues are compared with isless.\n\ncompat: Julia 1.7\nThis method requires Julia 1.7 or later.\n\nExamples\n\njulia> findmax(identity, 5:9)\n(9, 5)\n\njulia> findmax(-, 1:10)\n(-1, 1)\n\njulia> findmax(first, [(1, :a), (3, :b), (3, :c)])\n(3, 2)\n\njulia> findmax(cos, 0:π/2:2π)\n(1.0, 1)\n\n\n\n\n\n"},{"title":"Base.findmin","page":"Collections and Data Structures","location":"base/collections.html#Base.findmin","category":"function","text":"findmin(f, A; dims) -> (f(x), index)\n\nFor an array input, returns the value in the codomain and index of the corresponding value\nwhich minimize f over the given dimensions.\n\nExamples\n\njulia> A = [-1.0 1; -0.5 2]\n2×2 Matrix{Float64}:\n -1.0  1.0\n -0.5  2.0\n\njulia> findmin(abs2, A, dims=1)\n([0.25 1.0], CartesianIndex{2}[CartesianIndex(2, 1) CartesianIndex(1, 2)])\n\njulia> findmin(abs2, A, dims=2)\n([1.0; 0.25;;], CartesianIndex{2}[CartesianIndex(1, 1); CartesianIndex(2, 1);;])\n\n\n\n\n\nfindmin(A; dims) -> (minval, index)\n\nFor an array input, returns the value and index of the minimum over the given dimensions.\nNaN is treated as less than all other values except missing.\n\nExamples\n\njulia> A = [1.0 2; 3 4]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> findmin(A, dims=1)\n([1.0 2.0], CartesianIndex{2}[CartesianIndex(1, 1) CartesianIndex(1, 2)])\n\njulia> findmin(A, dims=2)\n([1.0; 3.0;;], CartesianIndex{2}[CartesianIndex(1, 1); CartesianIndex(2, 1);;])\n\n\n\n\n\nfindmin(itr) -> (x, index)\n\nReturn the minimal element of the collection itr and its index or key.\nIf there are multiple minimal elements, then the first one will be returned.\nNaN is treated as less than all other values except missing.\n\nIndices are of the same type as those returned by keys(itr)\nand pairs(itr).\n\nSee also: findmax, argmin, minimum.\n\nExamples\n\njulia> findmin([8, 0.1, -9, pi])\n(-9.0, 3)\n\njulia> findmin([1, 7, 7, 6])\n(1, 1)\n\njulia> findmin([1, 7, 7, NaN])\n(NaN, 4)\n\n\n\n\n\nfindmin(f, domain) -> (f(x), index)\n\nReturn a pair of a value in the codomain (outputs of f) and the index or key of\nthe corresponding value in the domain (inputs to f) such that f(x) is minimised.\nIf there are multiple minimal points, then the first one will be returned.\n\ndomain must be a non-empty iterable.\n\nIndices are of the same type as those returned by keys(domain)\nand pairs(domain).\n\nNaN is treated as less than all other values except missing.\n\ncompat: Julia 1.7\nThis method requires Julia 1.7 or later.\n\nExamples\n\njulia> findmin(identity, 5:9)\n(5, 1)\n\njulia> findmin(-, 1:10)\n(-10, 10)\n\njulia> findmin(first, [(2, :a), (2, :b), (3, :c)])\n(2, 1)\n\njulia> findmin(cos, 0:π/2:2π)\n(-1.0, 3)\n\n\n\n\n\n"},{"title":"Base.findmax!","page":"Collections and Data Structures","location":"base/collections.html#Base.findmax!","category":"function","text":"findmax!(rval, rind, A) -> (maxval, index)\n\nFind the maximum of A and the corresponding linear index along singleton\ndimensions of rval and rind, and store the results in rval and rind.\nNaN is treated as greater than all other values except missing.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\n\n\n\n\n"},{"title":"Base.findmin!","page":"Collections and Data Structures","location":"base/collections.html#Base.findmin!","category":"function","text":"findmin!(rval, rind, A) -> (minval, index)\n\nFind the minimum of A and the corresponding linear index along singleton\ndimensions of rval and rind, and store the results in rval and rind.\nNaN is treated as less than all other values except missing.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\n\n\n\n\n"},{"title":"Base.sum","page":"Collections and Data Structures","location":"base/collections.html#Base.sum","category":"function","text":"sum(f, A::AbstractArray; dims)\n\nSum the results of calling function f on each element of an array over the given\ndimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> sum(abs2, A, dims=1)\n1×2 Matrix{Int64}:\n 10  20\n\njulia> sum(abs2, A, dims=2)\n2×1 Matrix{Int64}:\n  5\n 25\n\n\n\n\n\nsum(A::AbstractArray; dims)\n\nSum elements of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> sum(A, dims=1)\n1×2 Matrix{Int64}:\n 4  6\n\njulia> sum(A, dims=2)\n2×1 Matrix{Int64}:\n 3\n 7\n\n\n\n\n\nsum(itr; [init])\n\nReturn the sum of all elements in a collection.\n\nThe return type is Int for signed integers of less than system word size, and\nUInt for unsigned integers of less than system word size.  For all other\narguments, a common return type is found to which all arguments are promoted.\n\nThe value returned for empty itr can be specified by init. It must be\nthe additive identity (i.e. zero) as it is unspecified whether init is used\nfor non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nSee also: reduce, mapreduce, count, union.\n\nExamples\n\njulia> sum(1:20)\n210\n\njulia> sum(1:20; init = 0.0)\n210.0\n\n\n\n\n\nsum(f, itr; [init])\n\nSum the results of calling function f on each element of itr.\n\nThe return type is Int for signed integers of less than system word size, and\nUInt for unsigned integers of less than system word size.  For all other\narguments, a common return type is found to which all arguments are promoted.\n\nThe value returned for empty itr can be specified by init. It must be\nthe additive identity (i.e. zero) as it is unspecified whether init is used\nfor non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> sum(abs2, [2; 3; 4])\n29\n\nNote the important difference between sum(A) and reduce(+, A) for arrays\nwith small integer eltype:\n\njulia> sum(Int8[100, 28])\n128\n\njulia> reduce(+, Int8[100, 28])\n-128\n\nIn the former case, the integers are widened to system word size and therefore\nthe result is 128. In the latter case, no such widening happens and integer\noverflow results in -128.\n\n\n\n\n\n"},{"title":"Base.sum!","page":"Collections and Data Structures","location":"base/collections.html#Base.sum!","category":"function","text":"sum!(r, A)\n\nSum elements of A over the singleton dimensions of r, and write results to r.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> sum!([1; 1], A)\n2-element Vector{Int64}:\n 3\n 7\n\njulia> sum!([1 1], A)\n1×2 Matrix{Int64}:\n 4  6\n\n\n\n\n\n"},{"title":"Base.prod","page":"Collections and Data Structures","location":"base/collections.html#Base.prod","category":"function","text":"prod(f, A::AbstractArray; dims)\n\nMultiply the results of calling the function f on each element of an array over the given\ndimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> prod(abs2, A, dims=1)\n1×2 Matrix{Int64}:\n 9  64\n\njulia> prod(abs2, A, dims=2)\n2×1 Matrix{Int64}:\n   4\n 144\n\n\n\n\n\nprod(A::AbstractArray; dims)\n\nMultiply elements of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> prod(A, dims=1)\n1×2 Matrix{Int64}:\n 3  8\n\njulia> prod(A, dims=2)\n2×1 Matrix{Int64}:\n  2\n 12\n\n\n\n\n\nprod(itr; [init])\n\nReturn the product of all elements of a collection.\n\nThe return type is Int for signed integers of less than system word size, and\nUInt for unsigned integers of less than system word size.  For all other\narguments, a common return type is found to which all arguments are promoted.\n\nThe value returned for empty itr can be specified by init. It must be the\nmultiplicative identity (i.e. one) as it is unspecified whether init is used\nfor non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nSee also: reduce, cumprod, any.\n\nExamples\n\njulia> prod(1:5)\n120\n\njulia> prod(1:5; init = 1.0)\n120.0\n\n\n\n\n\nprod(f, itr; [init])\n\nReturn the product of f applied to each element of itr.\n\nThe return type is Int for signed integers of less than system word size, and\nUInt for unsigned integers of less than system word size.  For all other\narguments, a common return type is found to which all arguments are promoted.\n\nThe value returned for empty itr can be specified by init. It must be the\nmultiplicative identity (i.e. one) as it is unspecified whether init is used\nfor non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> prod(abs2, [2; 3; 4])\n576\n\n\n\n\n\n"},{"title":"Base.prod!","page":"Collections and Data Structures","location":"base/collections.html#Base.prod!","category":"function","text":"prod!(r, A)\n\nMultiply elements of A over the singleton dimensions of r, and write results to r.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> prod!([1; 1], A)\n2-element Vector{Int64}:\n  2\n 12\n\njulia> prod!([1 1], A)\n1×2 Matrix{Int64}:\n 3  8\n\n\n\n\n\n"},{"title":"Base.any","page":"Collections and Data Structures","location":"base/collections.html#Base.any-Tuple{Any}","category":"method","text":"any(itr)::Bool\n\nTest whether any elements of a boolean collection are true, returning true as\nsoon as the first true value in itr is encountered (short-circuiting). To\nshort-circuit on false, use all.\n\nIf the input contains missing values, return missing if all non-missing\nvalues are false (or equivalently, if the input contains no true value), following\nthree-valued logic.\n\nSee also: all, count, sum, |, ||.\n\nExamples\n\njulia> a = [true,false,false,true]\n4-element Vector{Bool}:\n 1\n 0\n 0\n 1\n\njulia> any(a)\ntrue\n\njulia> any((println(i); v) for (i, v) in enumerate(a))\n1\ntrue\n\njulia> any([missing, true])\ntrue\n\njulia> any([false, missing])\nmissing\n\n\n\n\n\n"},{"title":"Base.any","page":"Collections and Data Structures","location":"base/collections.html#Base.any-Tuple{AbstractArray, Any}","category":"method","text":"any(p, itr)::Bool\n\nDetermine whether predicate p returns true for any elements of itr, returning\ntrue as soon as the first item in itr for which p returns true is encountered\n(short-circuiting). To short-circuit on false, use all.\n\nIf the input contains missing values, return missing if all non-missing\nvalues are false (or equivalently, if the input contains no true value), following\nthree-valued logic.\n\nExamples\n\njulia> any(i->(4<=i<=6), [3,5,7])\ntrue\n\njulia> any(i -> (println(i); i > 3), 1:10)\n1\n2\n3\n4\ntrue\n\njulia> any(i -> i > 0, [1, missing])\ntrue\n\njulia> any(i -> i > 0, [-1, missing])\nmissing\n\njulia> any(i -> i > 0, [-1, 0])\nfalse\n\n\n\n\n\n"},{"title":"Base.any!","page":"Collections and Data Structures","location":"base/collections.html#Base.any!","category":"function","text":"any!(r, A)\n\nTest whether any values in A along the singleton dimensions of r are true, and write\nresults to r.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nExamples\n\njulia> A = [true false; true false]\n2×2 Matrix{Bool}:\n 1  0\n 1  0\n\njulia> any!(Bool[1; 1], A)\n2-element Vector{Bool}:\n 1\n 1\n\njulia> any!(Bool[1 1], A)\n1×2 Matrix{Bool}:\n 1  0\n\n\n\n\n\n"},{"title":"Base.all","page":"Collections and Data Structures","location":"base/collections.html#Base.all-Tuple{Any}","category":"method","text":"all(itr)::Bool\n\nTest whether all elements of a boolean collection are true, returning false as\nsoon as the first false value in itr is encountered (short-circuiting). To\nshort-circuit on true, use any.\n\nIf the input contains missing values, return missing if all non-missing\nvalues are true (or equivalently, if the input contains no false value), following\nthree-valued logic.\n\nSee also: all!, any, count, &, &&, allunique.\n\nExamples\n\njulia> a = [true,false,false,true]\n4-element Vector{Bool}:\n 1\n 0\n 0\n 1\n\njulia> all(a)\nfalse\n\njulia> all((println(i); v) for (i, v) in enumerate(a))\n1\n2\nfalse\n\njulia> all([missing, false])\nfalse\n\njulia> all([true, missing])\nmissing\n\n\n\n\n\n"},{"title":"Base.all","page":"Collections and Data Structures","location":"base/collections.html#Base.all-Tuple{AbstractArray, Any}","category":"method","text":"all(p, itr)::Bool\n\nDetermine whether predicate p returns true for all elements of itr, returning\nfalse as soon as the first item in itr for which p returns false is encountered\n(short-circuiting). To short-circuit on true, use any.\n\nIf the input contains missing values, return missing if all non-missing\nvalues are true (or equivalently, if the input contains no false value), following\nthree-valued logic.\n\nExamples\n\njulia> all(i->(4<=i<=6), [4,5,6])\ntrue\n\njulia> all(i -> (println(i); i < 3), 1:10)\n1\n2\n3\nfalse\n\njulia> all(i -> i > 0, [1, missing])\nmissing\n\njulia> all(i -> i > 0, [-1, missing])\nfalse\n\njulia> all(i -> i > 0, [1, 2])\ntrue\n\n\n\n\n\n"},{"title":"Base.all!","page":"Collections and Data Structures","location":"base/collections.html#Base.all!","category":"function","text":"all!(r, A)\n\nTest whether all values in A along the singleton dimensions of r are true, and write results to r.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nExamples\n\njulia> A = [true false; true false]\n2×2 Matrix{Bool}:\n 1  0\n 1  0\n\njulia> all!(Bool[1; 1], A)\n2-element Vector{Bool}:\n 0\n 0\n\njulia> all!(Bool[1 1], A)\n1×2 Matrix{Bool}:\n 1  0\n\n\n\n\n\n"},{"title":"Base.count","page":"Collections and Data Structures","location":"base/collections.html#Base.count","category":"function","text":"count([f=identity,] A::AbstractArray; dims=:)\n\nCount the number of elements in A for which f returns true over the given\ndimensions.\n\ncompat: Julia 1.5\ndims keyword was added in Julia 1.5.\n\ncompat: Julia 1.6\ninit keyword was added in Julia 1.6.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> count(<=(2), A, dims=1)\n1×2 Matrix{Int64}:\n 1  1\n\njulia> count(<=(2), A, dims=2)\n2×1 Matrix{Int64}:\n 2\n 0\n\n\n\n\n\ncount(\n    pattern::Union{AbstractChar,AbstractString,AbstractPattern},\n    string::AbstractString;\n    overlap::Bool = false,\n)\n\nReturn the number of matches for pattern in string. This is equivalent to\ncalling length(findall(pattern, string)) but more efficient.\n\nIf overlap=true, the matching sequences are allowed to overlap indices in the\noriginal string, otherwise they must be from disjoint character ranges.\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\ncompat: Julia 1.7\nUsing a character as the pattern requires at least Julia 1.7.\n\nExamples\n\njulia> count('a', \"JuliaLang\")\n2\n\njulia> count(r\"a(.)a\", \"cabacabac\", overlap=true)\n3\n\njulia> count(r\"a(.)a\", \"cabacabac\")\n2\n\nSee also\n\neachmatch, occursin, findall\n\n\n\n\n\ncount([f=identity,] itr; init=0)::Integer\n\nCount the number of elements in itr for which the function f returns true.\nIf f is omitted, count the number of true elements in itr (which\nshould be a collection of boolean values). init optionally specifies the value\nto start counting from and therefore also determines the output type.\n\ncompat: Julia 1.6\ninit keyword was added in Julia 1.6.\n\nSee also: any, sum.\n\nExamples\n\njulia> count(i->(4<=i<=6), [2,3,4,5,6])\n3\n\njulia> count([true, false, true, true])\n3\n\njulia> count(>(3), 1:7, init=UInt(0))\n0x0000000000000004\n\n\n\n\n\n"},{"title":"Base.foreach","page":"Collections and Data Structures","location":"base/collections.html#Base.foreach","category":"function","text":"foreach(f, c...) -> nothing\n\nCall function f on each element of iterable c.\nFor multiple iterable arguments, f is called elementwise, and iteration stops when\nany iterator is finished.\n\nforeach should be used instead of map when the results of f are not\nneeded, for example in foreach(println, array).\n\nExamples\n\njulia> tri = 1:3:7; res = Int[];\n\njulia> foreach(x -> push!(res, x^2), tri)\n\njulia> res\n3-element Vector{Int64}:\n  1\n 16\n 49\n\njulia> foreach((x, y) -> println(x, \" with \", y), tri, 'a':'z')\n1 with a\n4 with b\n7 with c\n\n\n\n\n\n"},{"title":"Base.map","page":"Collections and Data Structures","location":"base/collections.html#Base.map","category":"function","text":"map(f, A::AbstractArray...) -> N-array\n\nWhen acting on multi-dimensional arrays of the same ndims,\nthey must all have the same axes, and the answer will too.\n\nSee also broadcast, which allows mismatched sizes.\n\nExamples\n\njulia> map(//, [1 2; 3 4], [4 3; 2 1])\n2×2 Matrix{Rational{Int64}}:\n 1//4  2//3\n 3//2  4//1\n\njulia> map(+, [1 2; 3 4], zeros(2,1))\nERROR: DimensionMismatch\n\njulia> map(+, [1 2; 3 4], [1,10,100,1000], zeros(3,1))  # iterates until 3rd is exhausted\n3-element Vector{Float64}:\n   2.0\n  13.0\n 102.0\n\n\n\n\n\nmap(f, c...) -> collection\n\nTransform collection c by applying f to each element. For multiple collection arguments,\napply f elementwise, and stop when any of them is exhausted.\n\nThe element type of the result is determined in the same manner as in collect.\n\nSee also map!, foreach, mapreduce, mapslices, zip, Iterators.map.\n\nExamples\n\njulia> map(x -> x * 2, [1, 2, 3])\n3-element Vector{Int64}:\n 2\n 4\n 6\n\njulia> map(+, [1, 2, 3], [10, 20, 30, 400, 5000])\n3-element Vector{Int64}:\n 11\n 22\n 33\n\n\n\n\n\n"},{"title":"Base.map!","page":"Collections and Data Structures","location":"base/collections.html#Base.map!","category":"function","text":"map!(f, values(dict::AbstractDict))\n\nModifies dict by transforming each value from val to f(val).\nNote that the type of dict cannot be changed: if f(val) is not an instance of the value type\nof dict then it will be converted to the value type if possible and otherwise raise an error.\n\ncompat: Julia 1.2\nmap!(f, values(dict::AbstractDict)) requires Julia 1.2 or later.\n\nExamples\n\njulia> d = Dict(:a => 1, :b => 2)\nDict{Symbol, Int64} with 2 entries:\n  :a => 1\n  :b => 2\n\njulia> map!(v -> v-1, values(d))\nValueIterator for a Dict{Symbol, Int64} with 2 entries. Values:\n  0\n  1\n\n\n\n\n\nmap!(function, array)\n\nLike map, but stores the result in the same array.\n\ncompat: Julia 1.12\nThis method requires Julia 1.12 or later. To support previous versions too,\nuse the equivalent map!(function, array, array).\n\nExamples\n\njulia> a = [1 2 3; 4 5 6];\n\njulia> map!(x -> x^3, a);\n\njulia> a\n2×3 Matrix{Int64}:\n  1    8   27\n 64  125  216\n\n\n\n\n\nmap!(function, destination, collection...)\n\nLike map, but stores the result in destination rather than a new\ncollection. destination must be at least as large as the smallest collection.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nSee also: map, foreach, zip, copyto!.\n\nExamples\n\njulia> a = zeros(3);\n\njulia> map!(x -> x * 2, a, [1, 2, 3]);\n\njulia> a\n3-element Vector{Float64}:\n 2.0\n 4.0\n 6.0\n\njulia> map!(+, zeros(Int, 5), 100:999, 1:3)\n5-element Vector{Int64}:\n 101\n 103\n 105\n   0\n   0\n\n\n\n\n\n"},{"title":"Base.mapreduce","page":"Collections and Data Structures","location":"base/collections.html#Base.mapreduce-Tuple{Any, Any, Any}","category":"method","text":"mapreduce(f, op, itrs...; [init])\n\nApply function f to each element(s) in itrs, and then reduce the result using the binary\nfunction op. If provided, init must be a neutral element for op that will be returned\nfor empty collections. It is unspecified whether init is used for non-empty collections.\nIn general, it will be necessary to provide init to work with empty collections.\n\nmapreduce is functionally equivalent to calling\nreduce(op, map(f, itr); init=init), but will in general execute faster since no\nintermediate collection needs to be created. See documentation for reduce and\nmap.\n\ncompat: Julia 1.2\nmapreduce with multiple iterators requires Julia 1.2 or later.\n\nExamples\n\njulia> mapreduce(x->x^2, +, [1:3;]) # == 1 + 4 + 9\n14\n\nThe associativity of the reduction is implementation-dependent. Additionally, some\nimplementations may reuse the return value of f for elements that appear multiple times in\nitr. Use mapfoldl or mapfoldr instead for\nguaranteed left or right associativity and invocation of f for every value.\n\n\n\n\n\n"},{"title":"Base.mapfoldl","page":"Collections and Data Structures","location":"base/collections.html#Base.mapfoldl-Tuple{Any, Any, Any}","category":"method","text":"mapfoldl(f, op, itr; [init])\n\nLike mapreduce, but with guaranteed left associativity, as in foldl.\nIf provided, the keyword argument init will be used exactly once. In general, it will be\nnecessary to provide init to work with empty collections.\n\n\n\n\n\n"},{"title":"Base.mapfoldr","page":"Collections and Data Structures","location":"base/collections.html#Base.mapfoldr-Tuple{Any, Any, Any}","category":"method","text":"mapfoldr(f, op, itr; [init])\n\nLike mapreduce, but with guaranteed right associativity, as in foldr. If\nprovided, the keyword argument init will be used exactly once. In general, it will be\nnecessary to provide init to work with empty collections.\n\n\n\n\n\n"},{"title":"Base.first","page":"Collections and Data Structures","location":"base/collections.html#Base.first","category":"function","text":"first(s::AbstractString, n::Integer)\n\nGet a string consisting of the first n characters of s.\n\nExamples\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 0)\n\"\"\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 1)\n\"∀\"\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 3)\n\"∀ϵ≠\"\n\n\n\n\n\nfirst(itr, n::Integer)\n\nGet the first n elements of the iterable collection itr, or fewer elements if itr is not\nlong enough.\n\nSee also: startswith, Iterators.take.\n\ncompat: Julia 1.6\nThis method requires at least Julia 1.6.\n\nExamples\n\njulia> first([\"foo\", \"bar\", \"qux\"], 2)\n2-element Vector{String}:\n \"foo\"\n \"bar\"\n\njulia> first(1:6, 10)\n1:6\n\njulia> first(Bool[], 1)\nBool[]\n\n\n\n\n\nfirst(coll)\n\nGet the first element of an iterable collection. Return the start point of an\nAbstractRange even if it is empty.\n\nSee also: only, firstindex, last.\n\nExamples\n\njulia> first(2:2:10)\n2\n\njulia> first([1; 2; 3; 4])\n1\n\n\n\n\n\n"},{"title":"Base.last","page":"Collections and Data Structures","location":"base/collections.html#Base.last","category":"function","text":"last(s::AbstractString, n::Integer)\n\nGet a string consisting of the last n characters of s.\n\nExamples\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 0)\n\"\"\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 1)\n\"0\"\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 3)\n\"²>0\"\n\n\n\n\n\nlast(itr, n::Integer)\n\nGet the last n elements of the iterable collection itr, or fewer elements if itr is not\nlong enough.\n\ncompat: Julia 1.6\nThis method requires at least Julia 1.6.\n\nExamples\n\njulia> last([\"foo\", \"bar\", \"qux\"], 2)\n2-element Vector{String}:\n \"bar\"\n \"qux\"\n\njulia> last(1:6, 10)\n1:6\n\njulia> last(Float64[], 1)\nFloat64[]\n\n\n\n\n\nlast(coll)\n\nGet the last element of an ordered collection, if it can be computed in O(1) time. This is\naccomplished by calling lastindex to get the last index. Return the end\npoint of an AbstractRange even if it is empty.\n\nSee also first, endswith.\n\nExamples\n\njulia> last(1:2:10)\n9\n\njulia> last([1; 2; 3; 4])\n4\n\n\n\n\n\n"},{"title":"Base.front","page":"Collections and Data Structures","location":"base/collections.html#Base.front","category":"function","text":"front(x::Tuple)::Tuple\n\nReturn a Tuple consisting of all but the last component of x.\n\nSee also: first, tail.\n\nExamples\n\njulia> Base.front((1,2,3))\n(1, 2)\n\njulia> Base.front(())\nERROR: ArgumentError: Cannot call front on an empty tuple.\n\n\n\n\n\n"},{"title":"Base.tail","page":"Collections and Data Structures","location":"base/collections.html#Base.tail","category":"function","text":"tail(x::Tuple)::Tuple\n\nReturn a Tuple consisting of all but the first component of x.\n\nSee also: front, rest, first, Iterators.peel.\n\nExamples\n\njulia> Base.tail((1,2,3))\n(2, 3)\n\njulia> Base.tail(())\nERROR: ArgumentError: Cannot call tail on an empty tuple.\n\n\n\n\n\n"},{"title":"Base.step","page":"Collections and Data Structures","location":"base/collections.html#Base.step","category":"function","text":"step(r)\n\nGet the step size of an AbstractRange object.\n\nExamples\n\njulia> step(1:10)\n1\n\njulia> step(1:2:10)\n2\n\njulia> step(2.5:0.3:10.9)\n0.3\n\njulia> step(range(2.5, stop=10.9, length=85))\n0.1\n\n\n\n\n\n"},{"title":"Base.collect","page":"Collections and Data Structures","location":"base/collections.html#Base.collect-Tuple{Any}","category":"method","text":"collect(iterator)\n\nReturn an Array of all items in a collection or iterator. For dictionaries, returns\na Vector of key=>value Pairs. If the argument is array-like or is an iterator\nwith the HasShape trait, the result will have the same shape\nand number of dimensions as the argument.\n\nUsed by comprehensions to turn a generator expression\ninto an Array. Thus, on generators, the square-brackets notation may be used instead of calling collect,\nsee second example.\n\nThe element type of the returned array is based on the types of the values collected. However, if the\niterator is empty then the element type of the returned (empty) array is determined by type inference.\n\nExamples\n\nCollect items from a UnitRange{Int64} collection:\n\njulia> collect(1:3)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\nCollect items from a generator (same output as [x^2 for x in 1:3]):\n\njulia> collect(x^2 for x in 1:3)\n3-element Vector{Int64}:\n 1\n 4\n 9\n\nCollecting an empty iterator where the result type depends on type inference:\n\njulia> [rand(Bool) ? 1 : missing for _ in []]\nUnion{Missing, Int64}[]\n\nWhen the iterator is non-empty, the result type depends only on values:\n\njulia> [rand(Bool) ? 1 : missing for _ in [\"\"]]\n1-element Vector{Int64}:\n 1\n\n\n\n\n\n"},{"title":"Base.collect","page":"Collections and Data Structures","location":"base/collections.html#Base.collect-Tuple{Type, Any}","category":"method","text":"collect(element_type, collection)\n\nReturn an Array with the given element type of all items in a collection or iterable.\nThe result has the same shape and number of dimensions as collection.\n\nExamples\n\njulia> collect(Float64, 1:2:5)\n3-element Vector{Float64}:\n 1.0\n 3.0\n 5.0\n\n\n\n\n\n"},{"title":"Base.filter","page":"Collections and Data Structures","location":"base/collections.html#Base.filter","category":"function","text":"filter(f, itr::SkipMissing{<:AbstractArray})\n\nReturn a vector similar to the array wrapped by the given SkipMissing iterator\nbut with all missing elements and those for which f returns false removed.\n\ncompat: Julia 1.2\nThis method requires Julia 1.2 or later.\n\nExamples\n\njulia> x = [1 2; missing 4]\n2×2 Matrix{Union{Missing, Int64}}:\n 1         2\n  missing  4\n\njulia> filter(isodd, skipmissing(x))\n1-element Vector{Int64}:\n 1\n\n\n\n\n\nfilter(f, d::AbstractDict)\n\nReturn a copy of d, removing elements for which f is false.\nThe function f is passed key=>value pairs.\n\nExamples\n\njulia> d = Dict(1=>\"a\", 2=>\"b\")\nDict{Int64, String} with 2 entries:\n  2 => \"b\"\n  1 => \"a\"\n\njulia> filter(p->isodd(p.first), d)\nDict{Int64, String} with 1 entry:\n  1 => \"a\"\n\n\n\n\n\nfilter(f)\n\nCreate a function that filters its arguments with function f using filter, i.e.\na function equivalent to x -> filter(f, x).\n\nThe returned function is of type Base.Fix1{typeof(filter)}, which can be\nused to implement specialized methods.\n\nExamples\n\njulia> (1, 2, Inf, 4, NaN, 6) |> filter(isfinite)\n(1, 2, 4, 6)\n\njulia> map(filter(iseven), [1:3, 2:4, 3:5])\n3-element Vector{Vector{Int64}}:\n [2]\n [2, 4]\n [4]\n\ncompat: Julia 1.9\nThis method requires at least Julia 1.9.\n\n\n\n\n\nfilter(f, a)\n\nReturn a copy of collection a, removing elements for which f is false.\nThe function f is passed one argument.\n\ncompat: Julia 1.4\nSupport for a as a tuple requires at least Julia 1.4.\n\nSee also: filter!, Iterators.filter.\n\nExamples\n\njulia> a = 1:10\n1:10\n\njulia> filter(isodd, a)\n5-element Vector{Int64}:\n 1\n 3\n 5\n 7\n 9\n\n\n\n\n\n"},{"title":"Base.filter!","page":"Collections and Data Structures","location":"base/collections.html#Base.filter!","category":"function","text":"filter!(f, d::AbstractDict)\n\nUpdate d, removing elements for which f is false.\nThe function f is passed key=>value pairs.\n\nExamples\n\njulia> d = Dict(1=>\"a\", 2=>\"b\", 3=>\"c\")\nDict{Int64, String} with 3 entries:\n  2 => \"b\"\n  3 => \"c\"\n  1 => \"a\"\n\njulia> filter!(p->isodd(p.first), d)\nDict{Int64, String} with 2 entries:\n  3 => \"c\"\n  1 => \"a\"\n\n\n\n\n\nfilter!(f, a)\n\nUpdate collection a, removing elements for which f is false.\nThe function f is passed one argument.\n\nExamples\n\njulia> filter!(isodd, Vector(1:10))\n5-element Vector{Int64}:\n 1\n 3\n 5\n 7\n 9\n\n\n\n\n\n"},{"title":"Base.replace","page":"Collections and Data Structures","location":"base/collections.html#Base.replace-Tuple{Any, Vararg{Pair}}","category":"method","text":"replace(A, old_new::Pair...; [count::Integer])\n\nReturn a copy of collection A where, for each pair old=>new in old_new,\nall occurrences of old are replaced by new.\nEquality is determined using isequal.\nIf count is specified, then replace at most count occurrences in total.\n\nThe element type of the result is chosen using promotion (see promote_type)\nbased on the element type of A and on the types of the new values in pairs.\nIf count is omitted and the element type of A is a Union, the element type\nof the result will not include singleton types which are replaced with values of\na different type: for example, Union{T,Missing} will become T if missing is\nreplaced.\n\nSee also replace!, splice!, delete!, insert!.\n\ncompat: Julia 1.7\nVersion 1.7 is required to replace elements of a Tuple.\n\nExamples\n\njulia> replace([1, 2, 1, 3], 1=>0, 2=>4, count=2)\n4-element Vector{Int64}:\n 0\n 4\n 1\n 3\n\njulia> replace([1, missing], missing=>0)\n2-element Vector{Int64}:\n 1\n 0\n\n\n\n\n\n"},{"title":"Base.replace","page":"Collections and Data Structures","location":"base/collections.html#Base.replace-Tuple{Union{Function, Type}, Any}","category":"method","text":"replace(new::Union{Function, Type}, A; [count::Integer])\n\nReturn a copy of A where each value x in A is replaced by new(x).\nIf count is specified, then replace at most count values in total\n(replacements being defined as new(x) !== x).\n\ncompat: Julia 1.7\nVersion 1.7 is required to replace elements of a Tuple.\n\nExamples\n\njulia> replace(x -> isodd(x) ? 2x : x, [1, 2, 3, 4])\n4-element Vector{Int64}:\n 2\n 2\n 6\n 4\n\njulia> replace(Dict(1=>2, 3=>4)) do kv\n           first(kv) < 3 ? first(kv)=>3 : kv\n       end\nDict{Int64, Int64} with 2 entries:\n  3 => 4\n  1 => 3\n\n\n\n\n\n"},{"title":"Base.replace!","page":"Collections and Data Structures","location":"base/collections.html#Base.replace!","category":"function","text":"replace!(new::Union{Function, Type}, A; [count::Integer])\n\nReplace each element x in collection A by new(x).\nIf count is specified, then replace at most count values in total\n(replacements being defined as new(x) !== x).\n\nExamples\n\njulia> replace!(x -> isodd(x) ? 2x : x, [1, 2, 3, 4])\n4-element Vector{Int64}:\n 2\n 2\n 6\n 4\n\njulia> replace!(Dict(1=>2, 3=>4)) do kv\n           first(kv) < 3 ? first(kv)=>3 : kv\n       end\nDict{Int64, Int64} with 2 entries:\n  3 => 4\n  1 => 3\n\njulia> replace!(x->2x, Set([3, 6]))\nSet{Int64} with 2 elements:\n  6\n  12\n\n\n\n\n\nreplace!(A, old_new::Pair...; [count::Integer])\n\nFor each pair old=>new in old_new, replace all occurrences\nof old in collection A by new.\nEquality is determined using isequal.\nIf count is specified, then replace at most count occurrences in total.\nSee also replace.\n\nExamples\n\njulia> replace!([1, 2, 1, 3], 1=>0, 2=>4, count=2)\n4-element Vector{Int64}:\n 0\n 4\n 1\n 3\n\njulia> replace!(Set([1, 2, 3]), 1=>0)\nSet{Int64} with 3 elements:\n  0\n  2\n  3\n\n\n\n\n\n"},{"title":"Base.rest","page":"Collections and Data Structures","location":"base/collections.html#Base.rest","category":"function","text":"Base.rest(collection[, itr_state])\n\nGeneric function for taking the tail of collection, starting from a specific iteration\nstate itr_state. Return a Tuple, if collection itself is a Tuple, a subtype of\nAbstractVector, if collection is an AbstractArray, a subtype of AbstractString\nif collection is an AbstractString, and an arbitrary iterator, falling back to\nIterators.rest(collection[, itr_state]), otherwise.\n\nCan be overloaded for user-defined collection types to customize the behavior of [slurping\nin assignments](@ref destructuring-assignment) in final position, like a, b... = collection.\n\ncompat: Julia 1.6\nBase.rest requires at least Julia 1.6.\n\nSee also: first, Iterators.rest, Base.split_rest.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> first, state = iterate(a)\n(1, 2)\n\njulia> first, Base.rest(a, state)\n(1, [3, 2, 4])\n\n\n\n\n\n"},{"title":"Base.split_rest","page":"Collections and Data Structures","location":"base/collections.html#Base.split_rest","category":"function","text":"Base.split_rest(collection, n::Int[, itr_state]) -> (rest_but_n, last_n)\n\nGeneric function for splitting the tail of collection, starting from a specific iteration\nstate itr_state. Returns a tuple of two new collections. The first one contains all\nelements of the tail but the n last ones, which make up the second collection.\n\nThe type of the first collection generally follows that of Base.rest, except that\nthe fallback case is not lazy, but is collected eagerly into a vector.\n\nCan be overloaded for user-defined collection types to customize the behavior of [slurping\nin assignments](@ref destructuring-assignment) in non-final position, like a, b..., c = collection.\n\ncompat: Julia 1.9\nBase.split_rest requires at least Julia 1.9.\n\nSee also: Base.rest.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> first, state = iterate(a)\n(1, 2)\n\njulia> first, Base.split_rest(a, 1, state)\n(1, ([3, 2], [4]))\n\n\n\n\n\n"},{"title":"Base.getindex","page":"Collections and Data Structures","location":"base/collections.html#Base.getindex","category":"function","text":"getindex(collection, key...)\n\nRetrieve the value(s) stored at the given key or index within a collection. The syntax\na[i,j,...] is converted by the compiler to getindex(a, i, j, ...).\n\nSee also get, keys, eachindex.\n\nExamples\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String, Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> getindex(A, \"a\")\n1\n\n\n\n\n\n"},{"title":"Base.setindex!","page":"Collections and Data Structures","location":"base/collections.html#Base.setindex!","category":"function","text":"setindex!(collection, value, key...)\n\nStore the given value at the given key or index within a collection. The syntax a[i,j,...] = x is converted by the compiler to (setindex!(a, x, i, j, ...); x).\n\nExamples\n\njulia> a = Dict(\"a\"=>1)\nDict{String, Int64} with 1 entry:\n  \"a\" => 1\n\njulia> setindex!(a, 2, \"b\")\nDict{String, Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\n\n\n\n\n"},{"title":"Base.firstindex","page":"Collections and Data Structures","location":"base/collections.html#Base.firstindex","category":"function","text":"firstindex(collection)::Integer\nfirstindex(collection, d)::Integer\n\nReturn the first index of collection. If d is given, return the first index of collection along dimension d.\n\nThe syntaxes A[begin] and A[1, begin] lower to A[firstindex(A)] and\nA[1, firstindex(A, 2)], respectively.\n\nSee also: first, axes, lastindex, nextind.\n\nExamples\n\njulia> firstindex([1,2,4])\n1\n\njulia> firstindex(rand(3,4,5), 2)\n1\n\n\n\n\n\n"},{"title":"Base.lastindex","page":"Collections and Data Structures","location":"base/collections.html#Base.lastindex","category":"function","text":"lastindex(collection)::Integer\nlastindex(collection, d)::Integer\n\nReturn the last index of collection. If d is given, return the last index of collection along dimension d.\n\nThe syntaxes A[end] and A[end, end] lower to A[lastindex(A)] and\nA[lastindex(A, 1), lastindex(A, 2)], respectively.\n\nSee also: axes, firstindex, eachindex, prevind.\n\nExamples\n\njulia> lastindex([1,2,4])\n3\n\njulia> lastindex(rand(3,4,5), 2)\n4\n\n\n\n\n\n"},{"title":"Base.AbstractDict","page":"Collections and Data Structures","location":"base/collections.html#Base.AbstractDict","category":"type","text":"AbstractDict{K, V}\n\nSupertype for dictionary-like types with keys of type K and values of type V.\nDict, IdDict and other types are subtypes of this.\nAn AbstractDict{K, V} should be an iterator of Pair{K, V}.\n\n\n\n\n\n"},{"title":"Base.Dict","page":"Collections and Data Structures","location":"base/collections.html#Base.Dict","category":"type","text":"Dict([itr])\n\nDict{K,V}() constructs a hash table with keys of type K and values of type V.\nKeys are compared with isequal and hashed with hash.\n\nGiven a single iterable argument, constructs a Dict whose key-value pairs\nare taken from 2-tuples (key,value) generated by the argument.\n\nExamples\n\njulia> Dict([(\"A\", 1), (\"B\", 2)])\nDict{String, Int64} with 2 entries:\n  \"B\" => 2\n  \"A\" => 1\n\nAlternatively, a sequence of pair arguments may be passed.\n\njulia> Dict(\"A\"=>1, \"B\"=>2)\nDict{String, Int64} with 2 entries:\n  \"B\" => 2\n  \"A\" => 1\n\nwarning: Warning\nKeys are allowed to be mutable, but if you do mutate stored\nkeys, the hash table may become internally inconsistent, in which case\nthe Dict will not work properly. IdDict can be an\nalternative if you need to mutate keys.\n\n\n\n\n\n"},{"title":"Base.IdDict","page":"Collections and Data Structures","location":"base/collections.html#Base.IdDict","category":"type","text":"IdDict([itr])\n\nIdDict{K,V}() constructs a hash table using objectid as hash and\n=== as equality with keys of type K and values of type V. See Dict\nfor further help and IdSet for the set version of this.\n\nIn the example below, the Dict keys are all isequal and therefore get hashed\nthe same, so they get overwritten. The IdDict hashes by object-id, and thus\npreserves the 3 different keys.\n\nExamples\n\njulia> Dict(true => \"yes\", 1 => \"no\", 1.0 => \"maybe\")\nDict{Real, String} with 1 entry:\n  1.0 => \"maybe\"\n\njulia> IdDict(true => \"yes\", 1 => \"no\", 1.0 => \"maybe\")\nIdDict{Any, String} with 3 entries:\n  true => \"yes\"\n  1.0  => \"maybe\"\n  1    => \"no\"\n\n\n\n\n\n"},{"title":"Base.WeakKeyDict","page":"Collections and Data Structures","location":"base/collections.html#Base.WeakKeyDict","category":"type","text":"WeakKeyDict([itr])\n\nWeakKeyDict() constructs a hash table where the keys are weak\nreferences to objects which may be garbage collected even when\nreferenced in a hash table.\n\nSee Dict for further help.  Note, unlike Dict,\nWeakKeyDict does not convert keys on insertion, as this would imply the key\nobject was unreferenced anywhere before insertion.\n\nSee also WeakRef.\n\n\n\n\n\n"},{"title":"Base.ImmutableDict","page":"Collections and Data Structures","location":"base/collections.html#Base.ImmutableDict","category":"type","text":"ImmutableDict\n\nImmutableDict is a dictionary implemented as an immutable linked list,\nwhich is optimal for small dictionaries that are constructed over many individual insertions.\nNote that it is not possible to remove a value, although it can be partially overridden and hidden\nby inserting a new value with the same key.\n\nImmutableDict(KV::Pair)\n\nCreate a new entry in the ImmutableDict for a key => value pair\n\nuse (key => value) in dict to see if this particular combination is in the properties set\nuse get(dict, key, default) to retrieve the most recent value for a particular key\n\n\n\n\n\n"},{"title":"Base.PersistentDict","page":"Collections and Data Structures","location":"base/collections.html#Base.PersistentDict","category":"type","text":"PersistentDict\n\nPersistentDict is a dictionary implemented as a hash array mapped trie,\nwhich is optimal for situations where you need persistence, each operation\nreturns a new dictionary separate from the previous one, but the underlying\nimplementation is space-efficient and may share storage across multiple\nseparate dictionaries.\n\nnote: Note\nIt behaves like an IdDict.\n\nPersistentDict(KV::Pair)\n\nExamples\n\njulia> dict = Base.PersistentDict(:a=>1)\nBase.PersistentDict{Symbol, Int64} with 1 entry:\n  :a => 1\n\njulia> dict2 = Base.delete(dict, :a)\nBase.PersistentDict{Symbol, Int64}()\n\njulia> dict3 = Base.PersistentDict(dict, :a=>2)\nBase.PersistentDict{Symbol, Int64} with 1 entry:\n  :a => 2\n\n\n\n\n\n"},{"title":"Base.haskey","page":"Collections and Data Structures","location":"base/collections.html#Base.haskey","category":"function","text":"haskey(collection, key)::Bool\n\nDetermine whether a collection has a mapping for a given key.\n\nExamples\n\njulia> D = Dict('a'=>2, 'b'=>3)\nDict{Char, Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> haskey(D, 'a')\ntrue\n\njulia> haskey(D, 'c')\nfalse\n\n\n\n\n\n"},{"title":"Base.get","page":"Collections and Data Structures","location":"base/collections.html#Base.get","category":"function","text":"get(f::Union{Function, Type}, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, return\nf().  Use get! to also store the default value in the dictionary.\n\nThis is intended to be called using do block syntax\n\nget(dict, key) do\n    # default value calculated here\n    time()\nend\n\n\n\n\n\nget(collection, key, default)\n\nReturn the value stored for the given key, or the given default value if no mapping for the\nkey is present.\n\ncompat: Julia 1.7\nFor tuples and numbers, this function requires at least Julia 1.7.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2);\n\njulia> get(d, \"a\", 3)\n1\n\njulia> get(d, \"c\", 3)\n3\n\n\n\n\n\n"},{"title":"Base.get!","page":"Collections and Data Structures","location":"base/collections.html#Base.get!","category":"function","text":"get!(f::Union{Function, Type}, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store\nkey => f(), and return f().\n\nThis is intended to be called using do block syntax.\n\nExamples\n\njulia> squares = Dict{Int, Int}();\n\njulia> function get_square!(d, i)\n           get!(d, i) do\n               i^2\n           end\n       end\nget_square! (generic function with 1 method)\n\njulia> get_square!(squares, 2)\n4\n\njulia> squares\nDict{Int64, Int64} with 1 entry:\n  2 => 4\n\n\n\n\n\nget!(collection, key, default)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store\nkey => default, and return default.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> get!(d, \"a\", 5)\n1\n\njulia> get!(d, \"d\", 4)\n4\n\njulia> d\nDict{String, Int64} with 4 entries:\n  \"c\" => 3\n  \"b\" => 2\n  \"a\" => 1\n  \"d\" => 4\n\n\n\n\n\n"},{"title":"Base.getkey","page":"Collections and Data Structures","location":"base/collections.html#Base.getkey","category":"function","text":"getkey(collection, key, default)\n\nReturn the key matching argument key if one exists in collection, otherwise return default.\n\nExamples\n\njulia> D = Dict('a'=>2, 'b'=>3)\nDict{Char, Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> getkey(D, 'a', 1)\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> getkey(D, 'd', 'a')\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\n\n\n\n\n"},{"title":"Base.delete!","page":"Collections and Data Structures","location":"base/collections.html#Base.delete!","category":"function","text":"delete!(collection, key)\n\nDelete the mapping for the given key in a collection, if any, and return the collection.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2)\nDict{String, Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> delete!(d, \"b\")\nDict{String, Int64} with 1 entry:\n  \"a\" => 1\n\njulia> delete!(d, \"b\") # d is left unchanged\nDict{String, Int64} with 1 entry:\n  \"a\" => 1\n\n\n\n\n\n"},{"title":"Base.pop!","page":"Collections and Data Structures","location":"base/collections.html#Base.pop!-Tuple{Any, Any, Any}","category":"method","text":"pop!(collection, key[, default])\n\nDelete and return the mapping for key if it exists in collection, otherwise return\ndefault, or throw an error if default is not specified.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> pop!(d, \"a\")\n1\n\njulia> pop!(d, \"d\")\nERROR: KeyError: key \"d\" not found\nStacktrace:\n[...]\n\njulia> pop!(d, \"e\", 4)\n4\n\n\n\n\n\n"},{"title":"Base.keys","page":"Collections and Data Structures","location":"base/collections.html#Base.keys","category":"function","text":"keys(iterator)\n\nFor an iterator or collection that has keys and values (e.g. arrays and dictionaries),\nreturn an iterator over the keys.\n\n\n\n\n\n"},{"title":"Base.values","page":"Collections and Data Structures","location":"base/collections.html#Base.values","category":"function","text":"values(a::AbstractDict)\n\nReturn an iterator over all values in a collection.\ncollect(values(a)) returns an array of values.\nWhen the values are stored internally in a hash table,\nas is the case for Dict,\nthe order in which they are returned may vary.\nBut keys(a), values(a) and pairs(a) all iterate a\nand return the elements in the same order.\n\nExamples\n\njulia> D = Dict('a'=>2, 'b'=>3)\nDict{Char, Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> collect(values(D))\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n\nvalues(iterator)\n\nFor an iterator or collection that has keys and values, return an iterator\nover the values.\nThis function simply returns its argument by default, since the elements\nof a general iterator are normally considered its \"values\".\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2);\n\njulia> values(d)\nValueIterator for a Dict{String, Int64} with 2 entries. Values:\n  2\n  1\n\njulia> values([2])\n1-element Vector{Int64}:\n 2\n\n\n\n\n\n"},{"title":"Base.pairs","page":"Collections and Data Structures","location":"base/collections.html#Base.pairs","category":"function","text":"pairs(collection)\n\nReturn an iterator over key => value pairs for any\ncollection that maps a set of keys to a set of values.\nThis includes arrays, where the keys are the array indices.\nWhen the entries are stored internally in a hash table,\nas is the case for Dict, the order in which they are returned may vary.\nBut keys(a), values(a) and pairs(a) all iterate a\nand return the elements in the same order.\n\nExamples\n\njulia> a = Dict(zip([\"a\", \"b\", \"c\"], [1, 2, 3]))\nDict{String, Int64} with 3 entries:\n  \"c\" => 3\n  \"b\" => 2\n  \"a\" => 1\n\njulia> pairs(a)\nDict{String, Int64} with 3 entries:\n  \"c\" => 3\n  \"b\" => 2\n  \"a\" => 1\n\njulia> foreach(println, pairs([\"a\", \"b\", \"c\"]))\n1 => \"a\"\n2 => \"b\"\n3 => \"c\"\n\njulia> (;a=1, b=2, c=3) |> pairs |> collect\n3-element Vector{Pair{Symbol, Int64}}:\n :a => 1\n :b => 2\n :c => 3\n\njulia> (;a=1, b=2, c=3) |> collect\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\n\npairs(IndexLinear(), A)\npairs(IndexCartesian(), A)\npairs(IndexStyle(A), A)\n\nAn iterator that accesses each element of the array A, returning\ni => x, where i is the index for the element and x = A[i].\nIdentical to pairs(A), except that the style of index can be selected.\nAlso similar to enumerate(A), except i will be a valid index\nfor A, while enumerate always counts from 1 regardless of the indices\nof A.\n\nSpecifying IndexLinear() ensures that i will be an integer;\nspecifying IndexCartesian() ensures that i will be a\nBase.CartesianIndex; specifying IndexStyle(A) chooses whichever has\nbeen defined as the native indexing style for array A.\n\nMutation of the bounds of the underlying array will invalidate this iterator.\n\nExamples\n\njulia> A = [\"a\" \"d\"; \"b\" \"e\"; \"c\" \"f\"];\n\njulia> for (index, value) in pairs(IndexStyle(A), A)\n           println(\"$index $value\")\n       end\n1 a\n2 b\n3 c\n4 d\n5 e\n6 f\n\njulia> S = view(A, 1:2, :);\n\njulia> for (index, value) in pairs(IndexStyle(S), S)\n           println(\"$index $value\")\n       end\nCartesianIndex(1, 1) a\nCartesianIndex(2, 1) b\nCartesianIndex(1, 2) d\nCartesianIndex(2, 2) e\n\nSee also IndexStyle, axes.\n\n\n\n\n\n"},{"title":"Base.merge","page":"Collections and Data Structures","location":"base/collections.html#Base.merge","category":"function","text":"merge(initial::StyledStrings.Face, others::StyledStrings.Face...)\n\nMerge the properties of the initial face and others, with later faces taking priority.\n\nThis is used to combine the styles of multiple faces, and to resolve inheritance.\n\n\n\n\n\nmerge(a::NamedTuple, iterable)\n\nInterpret an iterable of key-value pairs as a named tuple, and perform a merge.\n\njulia> merge((a=1, b=2, c=3), [:b=>4, :d=>5])\n(a = 1, b = 4, c = 3, d = 5)\n\n\n\n\n\nmerge(a::NamedTuple, bs::NamedTuple...)\n\nConstruct a new named tuple by merging two or more existing ones, in a left-associative\nmanner. Merging proceeds left-to-right, between pairs of named tuples, and so the order of fields\npresent in both the leftmost and rightmost named tuples take the same position as they are found in the\nleftmost named tuple. However, values are taken from matching fields in the rightmost named tuple that\ncontains that field. Fields present in only the rightmost named tuple of a pair are appended at the end.\nA fallback is implemented for when only a single named tuple is supplied,\nwith signature merge(a::NamedTuple).\n\ncompat: Julia 1.1\nMerging 3 or more NamedTuple requires at least Julia 1.1.\n\nExamples\n\njulia> merge((a=1, b=2, c=3), (b=4, d=5))\n(a = 1, b = 4, c = 3, d = 5)\n\njulia> merge((a=1, b=2), (b=3, c=(d=1,)), (c=(d=2,),))\n(a = 1, b = 3, c = (d = 2,))\n\n\n\n\n\nmerge(d::AbstractDict, others::AbstractDict...)\n\nConstruct a merged collection from the given collections. If necessary, the\ntypes of the resulting collection will be promoted to accommodate the types of\nthe merged collections. If the same key is present in another collection, the\nvalue for that key will be the value it has in the last collection listed.\nSee also mergewith for custom handling of values with the same key.\n\nExamples\n\njulia> a = Dict(\"foo\" => 0.0, \"bar\" => 42.0)\nDict{String, Float64} with 2 entries:\n  \"bar\" => 42.0\n  \"foo\" => 0.0\n\njulia> b = Dict(\"baz\" => 17, \"bar\" => 4711)\nDict{String, Int64} with 2 entries:\n  \"bar\" => 4711\n  \"baz\" => 17\n\njulia> merge(a, b)\nDict{String, Float64} with 3 entries:\n  \"bar\" => 4711.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\njulia> merge(b, a)\nDict{String, Float64} with 3 entries:\n  \"bar\" => 42.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\n\n\n\n\n"},{"title":"Base.mergewith","page":"Collections and Data Structures","location":"base/collections.html#Base.mergewith","category":"function","text":"mergewith(combine, d::AbstractDict, others::AbstractDict...)\nmergewith(combine)\n\nConstruct a merged collection from the given collections. If necessary, the\ntypes of the resulting collection will be promoted to accommodate the types of\nthe merged collections. Values with the same key will be combined using the\ncombiner function.  The curried form mergewith(combine) returns the function\n(args...) -> mergewith(combine, args...).\n\ncompat: Julia 1.5\nmergewith requires Julia 1.5 or later.\n\nExamples\n\njulia> a = Dict(\"foo\" => 0.0, \"bar\" => 42.0)\nDict{String, Float64} with 2 entries:\n  \"bar\" => 42.0\n  \"foo\" => 0.0\n\njulia> b = Dict(\"baz\" => 17, \"bar\" => 4711)\nDict{String, Int64} with 2 entries:\n  \"bar\" => 4711\n  \"baz\" => 17\n\njulia> mergewith(+, a, b)\nDict{String, Float64} with 3 entries:\n  \"bar\" => 4753.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\njulia> ans == mergewith(+)(a, b)\ntrue\n\njulia> mergewith(-, Dict(), Dict(:a=>1))  # Combining function only used if key is present in both\nDict{Any, Any} with 1 entry:\n  :a => 1\n\n\n\n\n\n"},{"title":"Base.merge!","page":"Collections and Data Structures","location":"base/collections.html#Base.merge!","category":"function","text":"merge!(d::AbstractDict, others::AbstractDict...)\n\nUpdate collection with pairs from the other collections.\nSee also merge.\n\nExamples\n\njulia> d1 = Dict(1 => 2, 3 => 4);\n\njulia> d2 = Dict(1 => 4, 4 => 5);\n\njulia> merge!(d1, d2);\n\njulia> d1\nDict{Int64, Int64} with 3 entries:\n  4 => 5\n  3 => 4\n  1 => 4\n\n\n\n\n\n"},{"title":"Base.mergewith!","page":"Collections and Data Structures","location":"base/collections.html#Base.mergewith!","category":"function","text":"mergewith!(combine, d::AbstractDict, others::AbstractDict...) -> d\nmergewith!(combine)\nmerge!(combine, d::AbstractDict, others::AbstractDict...) -> d\n\nUpdate collection with pairs from the other collections.\nValues with the same key will be combined using the\ncombiner function.  The curried form mergewith!(combine) returns the\nfunction (args...) -> mergewith!(combine, args...).\n\nMethod merge!(combine::Union{Function,Type}, args...) as an alias of\nmergewith!(combine, args...) is still available for backward\ncompatibility.\n\ncompat: Julia 1.5\nmergewith! requires Julia 1.5 or later.\n\nExamples\n\njulia> d1 = Dict(1 => 2, 3 => 4);\n\njulia> d2 = Dict(1 => 4, 4 => 5);\n\njulia> mergewith!(+, d1, d2);\n\njulia> d1\nDict{Int64, Int64} with 3 entries:\n  4 => 5\n  3 => 4\n  1 => 6\n\njulia> mergewith!(-, d1, d1);\n\njulia> d1\nDict{Int64, Int64} with 3 entries:\n  4 => 0\n  3 => 0\n  1 => 0\n\njulia> foldl(mergewith!(+), [d1, d2]; init=Dict{Int64, Int64}())\nDict{Int64, Int64} with 3 entries:\n  4 => 5\n  3 => 0\n  1 => 4\n\n\n\n\n\n"},{"title":"Base.sizehint!","page":"Collections and Data Structures","location":"base/collections.html#Base.sizehint!","category":"function","text":"sizehint!(s, n; first::Bool=false, shrink::Bool=true) -> s\n\nSuggest that collection s reserve capacity for at least n elements. That is, if\nyou expect that you're going to have to push a lot of values onto s, you can avoid\nthe cost of incremental reallocation by doing it once up front; this can improve\nperformance.\n\nIf first is true, then any additional space is reserved before the start of the collection.\nThis way, subsequent calls to pushfirst! (instead of push!) may become faster.\nSupplying this keyword may result in an error if the collection is not ordered\nor if pushfirst! is not supported for this collection.\n\nIf shrink=true (the default), the collection's capacity may be reduced if its current\ncapacity is greater than n.\n\nSee also resize!.\n\nNotes on the performance model\n\nFor types that support sizehint!,\n\npush! and append! methods generally may (but are not required to) preallocate extra\nstorage. For types implemented in Base, they typically do, using a heuristic optimized for\na general use case.\nsizehint! may control this preallocation. Again, it typically does this for types in\nBase.\nempty! is nearly costless (and O(1)) for types that support this kind of preallocation.\n\ncompat: Julia 1.11\nThe shrink and first arguments were added in Julia 1.11.\n\n\n\n\n\n"},{"title":"Base.keytype","page":"Collections and Data Structures","location":"base/collections.html#Base.keytype","category":"function","text":"keytype(type)\n\nGet the key type of a dictionary type. Behaves similarly to eltype.\n\nExamples\n\njulia> keytype(Dict(Int32(1) => \"foo\"))\nInt32\n\n\n\n\n\nkeytype(T::Type{<:AbstractArray})\nkeytype(A::AbstractArray)\n\nReturn the key type of an array. This is equal to the\neltype of the result of keys(...), and is provided\nmainly for compatibility with the dictionary interface.\n\nExamples\n\njulia> keytype([1, 2, 3]) == Int\ntrue\n\njulia> keytype([1 2; 3 4])\nCartesianIndex{2}\n\ncompat: Julia 1.2\nFor arrays, this function requires at least Julia 1.2.\n\n\n\n\n\n"},{"title":"Base.valtype","page":"Collections and Data Structures","location":"base/collections.html#Base.valtype","category":"function","text":"valtype(type)\n\nGet the value type of a dictionary type. Behaves similarly to eltype.\n\nExamples\n\njulia> valtype(Dict(Int32(1) => \"foo\"))\nString\n\n\n\n\n\nvaltype(T::Type{<:AbstractArray})\nvaltype(A::AbstractArray)\n\nReturn the value type of an array. This is identical to eltype and is\nprovided mainly for compatibility with the dictionary interface.\n\nExamples\n\njulia> valtype([\"one\", \"two\", \"three\"])\nString\n\ncompat: Julia 1.2\nFor arrays, this function requires at least Julia 1.2.\n\n\n\n\n\n"},{"title":"Base.AbstractSet","page":"Collections and Data Structures","location":"base/collections.html#Base.AbstractSet","category":"type","text":"AbstractSet{T}\n\nSupertype for set-like types whose elements are of type T.\nSet, BitSet and other types are subtypes of this.\n\n\n\n\n\n"},{"title":"Base.Set","page":"Collections and Data Structures","location":"base/collections.html#Base.Set","category":"type","text":"Set{T} <: AbstractSet{T}\n\nSets are mutable containers that provide fast membership testing.\n\nSets have efficient implementations of set operations such as in, union and intersect.\nElements in a Set are unique, as determined by the elements' definition of isequal.\nThe order of elements in a Set is an implementation detail and cannot be relied on.\n\nSee also: AbstractSet, BitSet, Dict,\npush!, empty!, union!, in, isequal\n\nExamples\n\njulia> s = Set(\"aaBca\")\nSet{Char} with 3 elements:\n  'a'\n  'c'\n  'B'\n\njulia> push!(s, 'b')\nSet{Char} with 4 elements:\n  'a'\n  'b'\n  'B'\n  'c'\n\njulia> s = Set([NaN, 0.0, 1.0, 2.0]);\n\njulia> -0.0 in s # isequal(0.0, -0.0) is false\nfalse\n\njulia> NaN in s # isequal(NaN, NaN) is true\ntrue\n\n\n\n\n\n"},{"title":"Base.BitSet","page":"Collections and Data Structures","location":"base/collections.html#Base.BitSet","category":"type","text":"BitSet([itr])\n\nConstruct a sorted set of Ints generated by the given iterable object, or an\nempty set. Implemented as a bit string, and therefore designed for dense integer sets.\nIf the set will be sparse (for example, holding a few\nvery large integers), use Set instead.\n\n\n\n\n\n"},{"title":"Base.IdSet","page":"Collections and Data Structures","location":"base/collections.html#Base.IdSet","category":"type","text":"IdSet{T}([itr])\nIdSet()\n\nIdSet{T}() constructs a set (see Set) using\n=== as equality with values of type T.\n\nIn the example below, the values are all isequal so they get overwritten in the ordinary Set.\nThe IdSet compares by === and so preserves the 3 different values.\n\ncompat: Julia 1.11\nExported in Julia 1.11 and later.\n\nExamples\n\njulia> Set(Any[true, 1, 1.0])\nSet{Any} with 1 element:\n  1.0\n\njulia> IdSet{Any}(Any[true, 1, 1.0])\nIdSet{Any} with 3 elements:\n  1.0\n  1\n  true\n\n\n\n\n\n"},{"title":"Base.union","page":"Collections and Data Structures","location":"base/collections.html#Base.union","category":"function","text":"union(s, itrs...)\n∪(s, itrs...)\n\nConstruct an object containing all distinct elements from all of the arguments.\n\nThe first argument controls what kind of container is returned.\nIf this is an array, it maintains the order in which elements first appear.\n\nUnicode ∪ can be typed by writing \\cup then pressing tab in the Julia REPL, and in many editors.\nThis is an infix operator, allowing s ∪ itr.\n\nSee also unique, intersect, isdisjoint, vcat, Iterators.flatten.\n\nExamples\n\njulia> union([1, 2], [3])\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> union([4 2 3 4 4], 1:3, 3.0)\n4-element Vector{Float64}:\n 4.0\n 2.0\n 3.0\n 1.0\n\njulia> (0, 0.0) ∪ (-0.0, NaN)\n3-element Vector{Real}:\n   0\n  -0.0\n NaN\n\njulia> union(Set([1, 2]), 2:3)\nSet{Int64} with 3 elements:\n  2\n  3\n  1\n\n\n\n\n\n"},{"title":"Base.union!","page":"Collections and Data Structures","location":"base/collections.html#Base.union!","category":"function","text":"union!(s::Union{AbstractSet,AbstractVector}, itrs...)\n\nConstruct the union of passed in sets and overwrite s with the result.\nMaintain order with arrays.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nExamples\n\njulia> a = Set([3, 4, 5]);\n\njulia> union!(a, 1:2:7);\n\njulia> a\nSet{Int64} with 5 elements:\n  5\n  4\n  7\n  3\n  1\n\n\n\n\n\nunion!(s::IntDisjointSet{T}, x::T, y::T)\n\nMerge the subset containing x and that containing y into one\nand return the root of the new set.\n\n\n\n\n\n"},{"title":"Base.intersect","page":"Collections and Data Structures","location":"base/collections.html#Base.intersect","category":"function","text":"intersect(s, itrs...)\n∩(s, itrs...)\n\nConstruct the set containing those elements which appear in all of the arguments.\n\nThe first argument controls what kind of container is returned.\nIf this is an array, it maintains the order in which elements first appear.\n\nUnicode ∩ can be typed by writing \\cap then pressing tab in the Julia REPL, and in many editors.\nThis is an infix operator, allowing s ∩ itr.\n\nSee also setdiff, isdisjoint, issubset, issetequal.\n\ncompat: Julia 1.8\nAs of Julia 1.8 intersect returns a result with the eltype of the\ntype-promoted eltypes of the two inputs\n\nExamples\n\njulia> intersect([1, 2, 3], [3, 4, 5])\n1-element Vector{Int64}:\n 3\n\njulia> intersect([1, 4, 4, 5, 6], [6, 4, 6, 7, 8])\n2-element Vector{Int64}:\n 4\n 6\n\njulia> intersect(1:16, 7:99)\n7:16\n\njulia> (0, 0.0) ∩ (-0.0, 0)\n1-element Vector{Real}:\n 0\n\njulia> intersect(Set([1, 2]), BitSet([2, 3]), 1.0:10.0)\nSet{Float64} with 1 element:\n  2.0\n\n\n\n\n\n"},{"title":"Base.setdiff","page":"Collections and Data Structures","location":"base/collections.html#Base.setdiff","category":"function","text":"setdiff(s, itrs...)\n\nConstruct the set of elements in s but not in any of the iterables in itrs.\nMaintain order with arrays. The result will have the same element type as s.\n\nSee also setdiff!, union and intersect.\n\nExamples\n\njulia> setdiff([1,2,3], [3,4,5])\n2-element Vector{Int64}:\n 1\n 2\n\njulia> setdiff([1,2,3], [1.0, 2.0])\n1-element Vector{Int64}:\n 3\n\n\n\n\n\n"},{"title":"Base.setdiff!","page":"Collections and Data Structures","location":"base/collections.html#Base.setdiff!","category":"function","text":"setdiff!(s, itrs...)\n\nRemove from set s (in-place) each element of each iterable from itrs.\nMaintain order with arrays.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nExamples\n\njulia> a = Set([1, 3, 4, 5]);\n\njulia> setdiff!(a, 1:2:6);\n\njulia> a\nSet{Int64} with 1 element:\n  4\n\n\n\n\n\n"},{"title":"Base.symdiff","page":"Collections and Data Structures","location":"base/collections.html#Base.symdiff","category":"function","text":"symdiff(s, itrs...)\n\nConstruct the symmetric difference of elements in the passed in sets.\nWhen s is not an AbstractSet, the order is maintained.\n\nSee also symdiff!, setdiff, union and intersect.\n\nExamples\n\njulia> symdiff([1,2,3], [3,4,5], [4,5,6])\n3-element Vector{Int64}:\n 1\n 2\n 6\n\njulia> symdiff([1,2,1], [2, 1, 2])\nInt64[]\n\n\n\n\n\n"},{"title":"Base.symdiff!","page":"Collections and Data Structures","location":"base/collections.html#Base.symdiff!","category":"function","text":"symdiff!(s::Union{AbstractSet,AbstractVector}, itrs...)\n\nConstruct the symmetric difference of the passed in sets, and overwrite s with the result.\nWhen s is an array, the order is maintained.\nNote that in this case the multiplicity of elements matters.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\n\n\n\n\n"},{"title":"Base.intersect!","page":"Collections and Data Structures","location":"base/collections.html#Base.intersect!","category":"function","text":"intersect!(s::Union{AbstractSet,AbstractVector}, itrs...)\n\nIntersect all passed in sets and overwrite s with the result.\nMaintain order with arrays.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\n\n\n\n\n"},{"title":"Base.issubset","page":"Collections and Data Structures","location":"base/collections.html#Base.issubset","category":"function","text":"issubset(a, b)::Bool\n⊆(a, b)::Bool\n⊇(b, a)::Bool\n\nDetermine whether every element of a is also in b, using in.\n\nSee also ⊊, ⊈, ∩, ∪, contains.\n\nExamples\n\njulia> issubset([1, 2], [1, 2, 3])\ntrue\n\njulia> [1, 2, 3] ⊆ [1, 2]\nfalse\n\njulia> [1, 2, 3] ⊇ [1, 2]\ntrue\n\n\n\n\n\n"},{"title":"Base.in!","page":"Collections and Data Structures","location":"base/collections.html#Base.in!","category":"function","text":"in!(x, s::AbstractSet)::Bool\n\nIf x is in s, return true. If not, push x into s and return false.\nThis is equivalent to in(x, s) ? true : (push!(s, x); false), but may have a\nmore efficient implementation.\n\nSee also: in, push!, Set\n\ncompat: Julia 1.11\nThis function requires at least 1.11.\n\nExamples\n\njulia> s = Set{Any}([1, 2, 3]); in!(4, s)\nfalse\n\njulia> length(s)\n4\n\njulia> in!(0x04, s)\ntrue\n\njulia> s\nSet{Any} with 4 elements:\n  4\n  2\n  3\n  1\n\n\n\n\n\n"},{"title":"Base.:⊈","page":"Collections and Data Structures","location":"base/collections.html#Base.:⊈","category":"function","text":"⊈(a, b)::Bool\n⊉(b, a)::Bool\n\nNegation of ⊆ and ⊇, i.e. checks that a is not a subset of b.\n\nSee also issubset (⊆), ⊊.\n\nExamples\n\njulia> (1, 2) ⊈ (2, 3)\ntrue\n\njulia> (1, 2) ⊈ (1, 2, 3)\nfalse\n\n\n\n\n\n"},{"title":"Base.:⊊","page":"Collections and Data Structures","location":"base/collections.html#Base.:⊊","category":"function","text":"⊊(a, b)::Bool\n⊋(b, a)::Bool\n\nDetermine if a is a subset of, but not equal to, b.\n\nSee also issubset (⊆), ⊈.\n\nExamples\n\njulia> (1, 2) ⊊ (1, 2, 3)\ntrue\n\njulia> (1, 2) ⊊ (1, 2)\nfalse\n\n\n\n\n\n"},{"title":"Base.issetequal","page":"Collections and Data Structures","location":"base/collections.html#Base.issetequal","category":"function","text":"issetequal(x)\n\nCreate a function that compares its argument to x using issetequal, i.e.\na function equivalent to y -> issetequal(y, x).\nThe returned function is of type Base.Fix2{typeof(issetequal)}, which can be\nused to implement specialized methods.\n\ncompat: Julia 1.11\nThis functionality requires at least Julia 1.11.\n\n\n\n\n\nissetequal(a, b)::Bool\n\nDetermine whether a and b have the same elements. Equivalent\nto a ⊆ b && b ⊆ a but more efficient when possible.\n\nSee also: isdisjoint, union.\n\nExamples\n\njulia> issetequal([1, 2], [1, 2, 3])\nfalse\n\njulia> issetequal([1, 2], [2, 1])\ntrue\n\n\n\n\n\n"},{"title":"Base.isdisjoint","page":"Collections and Data Structures","location":"base/collections.html#Base.isdisjoint","category":"function","text":"isdisjoint(x)\n\nCreate a function that compares its argument to x using isdisjoint, i.e.\na function equivalent to y -> isdisjoint(y, x).\nThe returned function is of type Base.Fix2{typeof(isdisjoint)}, which can be\nused to implement specialized methods.\n\ncompat: Julia 1.11\nThis functionality requires at least Julia 1.11.\n\n\n\n\n\nisdisjoint(a, b)::Bool\n\nDetermine whether the collections a and b are disjoint.\nEquivalent to isempty(a ∩ b) but more efficient when possible.\n\nSee also: intersect, isempty, issetequal.\n\ncompat: Julia 1.5\nThis function requires at least Julia 1.5.\n\nExamples\n\njulia> isdisjoint([1, 2], [2, 3, 4])\nfalse\n\njulia> isdisjoint([3, 1], [2, 4])\ntrue\n\n\n\n\n\n"},{"title":"Base.push!","page":"Collections and Data Structures","location":"base/collections.html#Base.push!","category":"function","text":"push!(collection, items...) -> collection\n\nInsert one or more items in collection. If collection is an ordered container,\nthe items are inserted at the end (in the given order).\n\nExamples\n\njulia> push!([1, 2, 3], 4, 5, 6)\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nIf collection is ordered, use append! to add all the elements of another\ncollection to it. The result of the preceding example is equivalent to append!([1, 2, 3], [4, 5, 6]). For AbstractSet objects, union! can be used instead.\n\nSee sizehint! for notes about the performance model.\n\nSee also pushfirst!.\n\n\n\n\n\n"},{"title":"Base.pop!","page":"Collections and Data Structures","location":"base/collections.html#Base.pop!","category":"function","text":"pop!(collection, key[, default])\n\nDelete and return the mapping for key if it exists in collection, otherwise return\ndefault, or throw an error if default is not specified.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> pop!(d, \"a\")\n1\n\njulia> pop!(d, \"d\")\nERROR: KeyError: key \"d\" not found\nStacktrace:\n[...]\n\njulia> pop!(d, \"e\", 4)\n4\n\n\n\n\n\npop!(collection) -> item\n\nRemove an item in collection and return it. If collection is an\nordered container, the last item is returned; for unordered containers,\nan arbitrary element is returned.\n\nSee also: popfirst!, popat!, delete!, deleteat!, splice!, and push!.\n\nExamples\n\njulia> A=[1, 2, 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> pop!(A)\n3\n\njulia> A\n2-element Vector{Int64}:\n 1\n 2\n\njulia> S = Set([1, 2])\nSet{Int64} with 2 elements:\n  2\n  1\n\njulia> pop!(S)\n2\n\njulia> S\nSet{Int64} with 1 element:\n  1\n\njulia> pop!(Dict(1=>2))\n1 => 2\n\n\n\n\n\n"},{"title":"Base.popat!","page":"Collections and Data Structures","location":"base/collections.html#Base.popat!","category":"function","text":"popat!(a::Vector, i::Integer, [default])\n\nRemove the item at the given i and return it. Subsequent items\nare shifted to fill the resulting gap.\nWhen i is not a valid index for a, return default, or throw an error if\ndefault is not specified.\n\nSee also: pop!, popfirst!, deleteat!, splice!.\n\ncompat: Julia 1.5\nThis function is available as of Julia 1.5.\n\nExamples\n\njulia> a = [4, 3, 2, 1]; popat!(a, 2)\n3\n\njulia> a\n3-element Vector{Int64}:\n 4\n 2\n 1\n\njulia> popat!(a, 4, missing)\nmissing\n\njulia> popat!(a, 4)\nERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]\n[...]\n\n\n\n\n\n"},{"title":"Base.pushfirst!","page":"Collections and Data Structures","location":"base/collections.html#Base.pushfirst!","category":"function","text":"pushfirst!(collection, items...) -> collection\n\nInsert one or more items at the beginning of collection.\n\nThis function is called unshift in many other programming languages.\n\nExamples\n\njulia> pushfirst!([1, 2, 3, 4], 5, 6)\n6-element Vector{Int64}:\n 5\n 6\n 1\n 2\n 3\n 4\n\n\n\n\n\n"},{"title":"Base.popfirst!","page":"Collections and Data Structures","location":"base/collections.html#Base.popfirst!","category":"function","text":"popfirst!(collection) -> item\n\nRemove the first item from collection.\n\nThis function is called shift in many other programming languages.\n\nSee also: pop!, popat!, delete!.\n\nExamples\n\njulia> A = [1, 2, 3, 4, 5, 6]\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> popfirst!(A)\n1\n\njulia> A\n5-element Vector{Int64}:\n 2\n 3\n 4\n 5\n 6\n\n\n\n\n\n"},{"title":"Base.insert!","page":"Collections and Data Structures","location":"base/collections.html#Base.insert!","category":"function","text":"insert!(a::Vector, index::Integer, item)\n\nInsert an item into a at the given index. index is the index of item in\nthe resulting a.\n\nSee also: push!, replace, popat!, splice!.\n\nExamples\n\njulia> insert!(Any[1:6;], 3, \"here\")\n7-element Vector{Any}:\n 1\n 2\n  \"here\"\n 3\n 4\n 5\n 6\n\n\n\n\n\n"},{"title":"Base.deleteat!","page":"Collections and Data Structures","location":"base/collections.html#Base.deleteat!","category":"function","text":"deleteat!(a::Vector, inds)\n\nRemove the items at the indices given by inds, and return the modified a.\nSubsequent items are shifted to fill the resulting gap.\n\ninds can be either an iterator or a collection of sorted and unique integer indices,\nor a boolean vector of the same length as a with true indicating entries to delete.\n\nExamples\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)\n3-element Vector{Int64}:\n 5\n 3\n 1\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])\n3-element Vector{Int64}:\n 5\n 3\n 1\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], (2, 2))\nERROR: ArgumentError: indices must be unique and sorted\nStacktrace:\n[...]\n\n\n\n\n\ndeleteat!(a::Vector, i::Integer)\n\nRemove the item at the given i and return the modified a. Subsequent items\nare shifted to fill the resulting gap.\n\nSee also: keepat!, delete!, popat!, splice!.\n\nExamples\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], 2)\n5-element Vector{Int64}:\n 6\n 4\n 3\n 2\n 1\n\n\n\n\n\n"},{"title":"Base.keepat!","page":"Collections and Data Structures","location":"base/collections.html#Base.keepat!","category":"function","text":"keepat!(a::Vector, m::AbstractVector{Bool})\nkeepat!(a::BitVector, m::AbstractVector{Bool})\n\nThe in-place version of logical indexing a = a[m]. That is, keepat!(a, m) on\nvectors of equal length a and m will remove all elements from a for which\nm at the corresponding index is false.\n\nExamples\n\njulia> a = [:a, :b, :c];\n\njulia> keepat!(a, [true, false, true])\n2-element Vector{Symbol}:\n :a\n :c\n\njulia> a\n2-element Vector{Symbol}:\n :a\n :c\n\n\n\n\n\nkeepat!(a::Vector, inds)\nkeepat!(a::BitVector, inds)\n\nRemove the items at all the indices which are not given by inds,\nand return the modified a.\nItems which are kept are shifted to fill the resulting gaps.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\ninds must be an iterator of sorted and unique integer indices.\nSee also deleteat!.\n\ncompat: Julia 1.7\nThis function is available as of Julia 1.7.\n\nExamples\n\njulia> keepat!([6, 5, 4, 3, 2, 1], 1:2:5)\n3-element Vector{Int64}:\n 6\n 4\n 2\n\n\n\n\n\n"},{"title":"Base.splice!","page":"Collections and Data Structures","location":"base/collections.html#Base.splice!","category":"function","text":"splice!(a::Vector, indices, [replacement]) -> items\n\nRemove items at specified indices, and return a collection containing\nthe removed items.\nSubsequent items are shifted left to fill the resulting gaps.\nIf specified, replacement values from an ordered collection will be spliced in\nplace of the removed items; in this case, indices must be a AbstractUnitRange.\n\nTo insert replacement before an index n without removing any items, use\nsplice!(collection, n:n-1, replacement).\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\ncompat: Julia 1.5\nPrior to Julia 1.5, indices must always be a UnitRange.\n\ncompat: Julia 1.8\nPrior to Julia 1.8, indices must be a UnitRange if splicing in replacement values.\n\nExamples\n\njulia> A = [-1, -2, -3, 5, 4, 3, -1]; splice!(A, 4:3, 2)\nInt64[]\n\njulia> A\n8-element Vector{Int64}:\n -1\n -2\n -3\n  2\n  5\n  4\n  3\n -1\n\n\n\n\n\nsplice!(a::Vector, index::Integer, [replacement]) -> item\n\nRemove the item at the given index, and return the removed item.\nSubsequent items are shifted left to fill the resulting gap.\nIf specified, replacement values from an ordered\ncollection will be spliced in place of the removed item.\n\nSee also: replace, delete!, deleteat!, pop!, popat!.\n\nExamples\n\njulia> A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)\n2\n\njulia> A\n5-element Vector{Int64}:\n 6\n 5\n 4\n 3\n 1\n\njulia> splice!(A, 5, -1)\n1\n\njulia> A\n5-element Vector{Int64}:\n  6\n  5\n  4\n  3\n -1\n\njulia> splice!(A, 1, [-1, -2, -3])\n6\n\njulia> A\n7-element Vector{Int64}:\n -1\n -2\n -3\n  5\n  4\n  3\n -1\n\nTo insert replacement before an index n without removing any items, use\nsplice!(collection, n:n-1, replacement).\n\n\n\n\n\n"},{"title":"Base.resize!","page":"Collections and Data Structures","location":"base/collections.html#Base.resize!","category":"function","text":"resize!(a::Vector, n::Integer) -> a\n\nResize a to contain n elements. If n is smaller than the current collection\nlength, the first n elements will be retained. If n is larger, the new elements are not\nguaranteed to be initialized.\n\nExamples\n\njulia> resize!([6, 5, 4, 3, 2, 1], 3)\n3-element Vector{Int64}:\n 6\n 5\n 4\n\njulia> a = resize!([6, 5, 4, 3, 2, 1], 8);\n\njulia> length(a)\n8\n\njulia> a[1:6]\n6-element Vector{Int64}:\n 6\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\n"},{"title":"Base.append!","page":"Collections and Data Structures","location":"base/collections.html#Base.append!","category":"function","text":"append!(collection, collections...) -> collection.\n\nFor an ordered container collection, add the elements of each collections\nto the end of it.\n\ncompat: Julia 1.6\nSpecifying multiple collections to be appended requires at least Julia 1.6.\n\nExamples\n\njulia> append!([1], [2, 3])\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> append!([1, 2, 3], [4, 5], [6])\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nUse push! to add individual items to collection which are not already\nthemselves in another collection. The result of the preceding example is equivalent to\npush!([1, 2, 3], 4, 5, 6).\n\nSee sizehint! for notes about the performance model.\n\nSee also vcat for vectors, union! for sets,\nand prepend! and pushfirst! for the opposite order.\n\n\n\n\n\n"},{"title":"Base.prepend!","page":"Collections and Data Structures","location":"base/collections.html#Base.prepend!","category":"function","text":"prepend!(a::Vector, collections...) -> collection\n\nInsert the elements of each collections to the beginning of a.\n\nWhen collections specifies multiple collections, order is maintained:\nelements of collections[1] will appear leftmost in a, and so on.\n\ncompat: Julia 1.6\nSpecifying multiple collections to be prepended requires at least Julia 1.6.\n\nExamples\n\njulia> prepend!([3], [1, 2])\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> prepend!([6], [1, 2], [3, 4, 5])\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\n\n\n\n\n"},{"title":"Core.Pair","page":"Collections and Data Structures","location":"base/collections.html#Core.Pair","category":"type","text":"Pair(x, y)\nx => y\n\nConstruct a Pair object with type Pair{typeof(x), typeof(y)}. The elements\nare stored in the fields first and second. They can also be accessed via\niteration (but a Pair is treated as a single \"scalar\" for broadcasting operations).\n\nSee also Dict.\n\nExamples\n\njulia> p = \"foo\" => 7\n\"foo\" => 7\n\njulia> typeof(p)\nPair{String, Int64}\n\njulia> p.first\n\"foo\"\n\njulia> for x in p\n           println(x)\n       end\nfoo\n7\n\njulia> replace.([\"xops\", \"oxps\"], \"x\" => \"o\")\n2-element Vector{String}:\n \"oops\"\n \"oops\"\n\n\n\n\n\n"},{"title":"Base.Pairs","page":"Collections and Data Structures","location":"base/collections.html#Base.Pairs","category":"type","text":"Base.Pairs(values, keys) <: AbstractDict{eltype(keys), eltype(values)}\n\nTransform an indexable container into a Dictionary-view of the same data.\nModifying the key-space of the underlying data may invalidate this object.\n\n\n\n\n\n"},{"title":"Running External Programs","page":"Running External Programs","location":"manual/running-external-programs.html#Running-External-Programs","category":"section","text":"Julia borrows backtick notation for commands from the shell, Perl, and Ruby. However, in Julia,\nwriting\n\njulia> `echo hello`\n`echo hello`\n\ndiffers in several aspects from the behavior in various shells, Perl, or Ruby:\n\nInstead of immediately running the command, backticks create a Cmd object to represent the command.\nYou can use this object to connect the command to others via pipes, run it, and read or write\nto it.\nWhen the command is run, Julia does not capture its output unless you specifically arrange for\nit to. Instead, the output of the command by default goes to stdout as it would using\nlibc's system call.\nThe command is never run with a shell. Instead, Julia parses the command syntax directly, appropriately\ninterpolating variables and splitting on words as the shell would, respecting shell quoting syntax.\nThe command is run as julia's immediate child process, using fork and exec calls.\n\nnote: Note\nThe following assumes a Posix environment as on Linux or MacOS.\nOn Windows, many similar commands, such as echo and dir, are not external programs and instead are built into the shell cmd.exe itself.\nOne option to run these commands is to invoke cmd.exe, for example cmd /C echo hello.\nAlternatively Julia can be run inside a Posix environment such as Cygwin.\n\nHere's a simple example of running an external program:\n\njulia> mycommand = `echo hello`\n`echo hello`\n\njulia> typeof(mycommand)\nCmd\n\njulia> run(mycommand);\nhello\n\nThe hello is the output of the echo command, sent to stdout. If the external command fails to run\nsuccessfully, the run method throws an ProcessFailedException.\n\nIf you want to read the output of the external command, read or readchomp\ncan be used instead:\n\njulia> read(`echo hello`, String)\n\"hello\\n\"\n\njulia> readchomp(`echo hello`)\n\"hello\"\n\nMore generally, you can use open to read from or write to an external command.\n\njulia> open(`less`, \"w\", stdout) do io\n           for i = 1:3\n               println(io, i)\n           end\n       end\n1\n2\n3\n\nThe program name and the individual arguments in a command can be accessed\nand iterated over as if the command were an array of strings:\n\njulia> collect(`echo \"foo bar\"`)\n2-element Vector{String}:\n \"echo\"\n \"foo bar\"\n\njulia> `echo \"foo bar\"`[2]\n\"foo bar\"\n\nYou can also pass a IOBuffer, and later read from it:\n\njulia> io = PipeBuffer(); # PipeBuffer is a type of IOBuffer\n\njulia> run(`echo world`, devnull, io, stderr);\n\njulia> readlines(io)\n1-element Vector{String}:\n \"world\""},{"title":"Interpolation","page":"Running External Programs","location":"manual/running-external-programs.html#command-interpolation","category":"section","text":"Suppose you want to do something a bit more complicated and use the name of a file in the variable\nfile as an argument to a command. You can use $ for interpolation much as you would in a string\nliteral (see Strings):\n\njulia> file = \"/etc/passwd\"\n\"/etc/passwd\"\n\njulia> `sort $file`\n`sort /etc/passwd`\n\nA common pitfall when running external programs via a shell is that if a file name contains characters\nthat are special to the shell, they may cause undesirable behavior. Suppose, for example, rather\nthan /etc/passwd, we wanted to sort the contents of the file /Volumes/External HD/data.csv.\nLet's try it:\n\njulia> file = \"/Volumes/External HD/data.csv\"\n\"/Volumes/External HD/data.csv\"\n\njulia> `sort $file`\n`sort '/Volumes/External HD/data.csv'`\n\nHow did the file name get quoted? Julia knows that file is meant to be interpolated as a single\nargument, so it quotes the word for you. Actually, that is not quite accurate: the value of file\nis never interpreted by a shell, so there's no need for actual quoting; the quotes are inserted\nonly for presentation to the user. This will even work if you interpolate a value as part of a\nshell word:\n\njulia> path = \"/Volumes/External HD\"\n\"/Volumes/External HD\"\n\njulia> name = \"data\"\n\"data\"\n\njulia> ext = \"csv\"\n\"csv\"\n\njulia> `sort $path/$name.$ext`\n`sort '/Volumes/External HD/data.csv'`\n\nAs you can see, the space in the path variable is appropriately escaped. But what if you want\nto interpolate multiple words? In that case, just use an array (or any other iterable container):\n\njulia> files = [\"/etc/passwd\",\"/Volumes/External HD/data.csv\"]\n2-element Vector{String}:\n \"/etc/passwd\"\n \"/Volumes/External HD/data.csv\"\n\njulia> `grep foo $files`\n`grep foo /etc/passwd '/Volumes/External HD/data.csv'`\n\nIf you interpolate an array as part of a shell word, Julia emulates the shell's {a,b,c} argument\ngeneration:\n\njulia> names = [\"foo\",\"bar\",\"baz\"]\n3-element Vector{String}:\n \"foo\"\n \"bar\"\n \"baz\"\n\njulia> `grep xylophone $names.txt`\n`grep xylophone foo.txt bar.txt baz.txt`\n\nMoreover, if you interpolate multiple arrays into the same word, the shell's Cartesian product\ngeneration behavior is emulated:\n\njulia> names = [\"foo\",\"bar\",\"baz\"]\n3-element Vector{String}:\n \"foo\"\n \"bar\"\n \"baz\"\n\njulia> exts = [\"aux\",\"log\"]\n2-element Vector{String}:\n \"aux\"\n \"log\"\n\njulia> `rm -f $names.$exts`\n`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`\n\nSince you can interpolate literal arrays, you can use this generative functionality without needing\nto create temporary array objects first:\n\njulia> `rm -rf $[\"foo\",\"bar\",\"baz\",\"qux\"].$[\"aux\",\"log\",\"pdf\"]`\n`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log qux.pdf`"},{"title":"Quoting","page":"Running External Programs","location":"manual/running-external-programs.html#Quoting","category":"section","text":"Inevitably, one wants to write commands that aren't quite so simple, and it becomes necessary\nto use quotes. Here's a simple example of a Perl one-liner at a shell prompt:\n\nsh$ perl -le '$|=1; for (0..3) { print }'\n0\n1\n2\n3\n\nThe Perl expression needs to be in single quotes for two reasons: so that spaces don't break the\nexpression into multiple shell words, and so that uses of Perl variables like $| (yes, that's\nthe name of a variable in Perl), don't cause interpolation. In other instances, you may want to\nuse double quotes so that interpolation does occur:\n\nsh$ first=\"A\"\nsh$ second=\"B\"\nsh$ perl -le '$|=1; print for @ARGV' \"1: $first\" \"2: $second\"\n1: A\n2: B\n\nIn general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste\nshell commands as is into backticks and they will work: the escaping, quoting, and interpolation\nbehaviors are the same as the shell's. The only difference is that the interpolation is integrated\nand aware of Julia's notion of what is a single string value, and what is a container for multiple\nvalues. Let's try the above two examples in Julia:\n\njulia> A = `perl -le '$|=1; for (0..3) { print }'`\n`perl -le '$|=1; for (0..3) { print }'`\n\njulia> run(A);\n0\n1\n2\n3\n\njulia> first = \"A\"; second = \"B\";\n\njulia> B = `perl -le 'print for @ARGV' \"1: $first\" \"2: $second\"`\n`perl -le 'print for @ARGV' '1: A' '2: B'`\n\njulia> run(B);\n1: A\n2: B\n\nThe results are identical, and Julia's interpolation behavior mimics the shell's with some improvements\ndue to the fact that Julia supports first-class iterable objects while most shells use strings\nsplit on spaces for this, which introduces ambiguities. When trying to port shell commands to\nJulia, try cut and pasting first. Since Julia shows commands to you before running them, you can\neasily and safely just examine its interpretation without doing any damage."},{"title":"Pipelines","page":"Running External Programs","location":"manual/running-external-programs.html#Pipelines","category":"section","text":"Shell metacharacters, such as |, &, and >, need to be quoted (or escaped) inside of Julia's backticks:\n\njulia> run(`echo hello '|' sort`);\nhello | sort\n\njulia> run(`echo hello \\| sort`);\nhello | sort\n\nThis expression invokes the echo command with three words as arguments: hello, |, and sort.\nThe result is that a single line is printed: hello | sort. How, then, does one construct a\npipeline? Instead of using '|' inside of backticks, one uses pipeline:\n\njulia> run(pipeline(`echo hello`, `sort`));\nhello\n\nThis pipes the output of the echo command to the sort command. Of course, this isn't terribly\ninteresting since there's only one line to sort, but we can certainly do much more interesting\nthings:\n\njulia> run(pipeline(`cut -d: -f3 /etc/passwd`, `sort -n`, `tail -n5`))\n210\n211\n212\n213\n214\n\nThis prints the highest five user IDs on a UNIX system. The cut, sort and tail commands\nare all spawned as immediate children of the current julia process, with no intervening shell\nprocess. Julia itself does the work to setup pipes and connect file descriptors that is normally\ndone by the shell. Since Julia does this itself, it retains better control and can do some things\nthat shells cannot.\n\nJulia can run multiple commands in parallel:\n\njulia> run(`echo hello` & `echo world`);\nworld\nhello\n\nThe order of the output here is non-deterministic because the two echo processes are started\nnearly simultaneously, and race to make the first write to the stdout descriptor they\nshare with each other and the julia parent process. Julia lets you pipe the output from both\nof these processes to another program:\n\njulia> run(pipeline(`echo world` & `echo hello`, `sort`));\nhello\nworld\n\nIn terms of UNIX plumbing, what's happening here is that a single UNIX pipe object is created\nand written to by both echo processes, and the other end of the pipe is read from by the sort\ncommand.\n\nIO redirection can be accomplished by passing keyword arguments stdin, stdout, and stderr to the\npipeline function:\n\npipeline(`do_work`, stdout=pipeline(`sort`, \"out.txt\"), stderr=\"errs.txt\")"},{"title":"Avoiding Deadlock in Pipelines","page":"Running External Programs","location":"manual/running-external-programs.html#Avoiding-Deadlock-in-Pipelines","category":"section","text":"When reading and writing to both ends of a pipeline from a single process, it is important to\navoid forcing the kernel to buffer all of the data.\n\nFor example, when reading all of the output from a command, call read(out, String), not wait(process),\nsince the former will actively consume all of the data written by the process, whereas the latter\nwill attempt to store the data in the kernel's buffers while waiting for a reader to be connected.\n\nAnother common solution is to separate the reader and writer of the pipeline into separate Tasks:\n\nwriter = Threads.@spawn write(process, \"data\")\nreader = Threads.@spawn do_compute(read(process, String))\nwait(writer)\nfetch(reader)\n\n(commonly also, reader is not a separate task, since we immediately fetch it anyways)."},{"title":"Complex Example","page":"Running External Programs","location":"manual/running-external-programs.html#Complex-Example","category":"section","text":"The combination of a high-level programming language, a first-class command abstraction, and automatic\nsetup of pipes between processes is a powerful one. To give some sense of the complex pipelines\nthat can be created easily, here are some more sophisticated examples, with apologies for the\nexcessive use of Perl one-liners:\n\njulia> prefixer(prefix, sleep) = `perl -nle '$|=1; print \"'$prefix' \", $_; sleep '$sleep';'`;\n\njulia> run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`, prefixer(\"A\",2) & prefixer(\"B\",2)));\nB 0\nA 1\nB 2\nA 3\nB 4\nA 5\n\nThis is a classic example of a single producer feeding two concurrent consumers: one perl process\ngenerates lines with the numbers 0 through 5 on them, while two parallel processes consume that\noutput, one prefixing lines with the letter \"A\", the other with the letter \"B\". Which consumer\ngets the first line is non-deterministic, but once that race has been won, the lines are consumed\nalternately by one process and then the other. (Setting $|=1 in Perl causes each print statement\nto flush the stdout handle, which is necessary for this example to work. Otherwise all\nthe output is buffered and printed to the pipe at once, to be read by just one consumer process.)\n\nHere is an even more complex multi-stage producer-consumer example:\n\njulia> run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`,\n           prefixer(\"X\",3) & prefixer(\"Y\",3) & prefixer(\"Z\",3),\n           prefixer(\"A\",2) & prefixer(\"B\",2)));\nA X 0\nB Y 1\nA Z 2\nB X 3\nA Y 4\nB Z 5\n\nThis example is similar to the previous one, except there are two stages of consumers, and the\nstages have different latency so they use a different number of parallel workers, to maintain\nsaturated throughput.\n\nWe strongly encourage you to try all these examples to see how they work."},{"title":"Cmd Objects","page":"Running External Programs","location":"manual/running-external-programs.html#Cmd-Objects","category":"section","text":"The backtick syntax create an object of type Cmd. Such object may also be constructed directly from\nan existing Cmd or list of arguments:\n\nrun(Cmd(`pwd`, dir=\"..\"))\nrun(Cmd([\"pwd\"], detach=true, ignorestatus=true))\n\nThis allows you to specify several aspects of the Cmd's execution environment via keyword arguments. For\nexample, the dir keyword provides control over the Cmd's working directory:\n\njulia> run(Cmd(`pwd`, dir=\"/\"));\n/\n\nAnd the env keyword allows you to set execution environment variables:\n\njulia> run(Cmd(`sh -c \"echo foo \\$HOWLONG\"`, env=(\"HOWLONG\" => \"ever!\",)));\nfoo ever!\n\nSee Cmd for additional keyword arguments. The setenv and addenv commands\nprovide another means for replacing or adding to the Cmd execution environment variables, respectively:\n\njulia> run(setenv(`sh -c \"echo foo \\$HOWLONG\"`, (\"HOWLONG\" => \"ever!\",)));\nfoo ever!\n\njulia> run(addenv(`sh -c \"echo foo \\$HOWLONG\"`, \"HOWLONG\" => \"ever!\"));\nfoo ever!"},{"title":"Integers and Floating-Point Numbers","page":"Integers and Floating-Point Numbers","location":"manual/integers-and-floating-point-numbers.html#Integers-and-Floating-Point-Numbers","category":"section","text":"Integers and floating-point values are the basic building blocks of arithmetic and computation.\nBuilt-in representations of such values are called numeric primitives, while representations of\nintegers and floating-point numbers as immediate values in code are known as numeric literals.\nFor example, 1 is an integer literal, while 1.0 is a floating-point literal; their binary\nin-memory representations as objects are numeric primitives.\n\nJulia provides a broad range of primitive numeric types, and a full complement of arithmetic and\nbitwise operators as well as standard mathematical functions are defined over them. These map\ndirectly onto numeric types and operations that are natively supported on modern computers, thus\nallowing Julia to take full advantage of computational resources. Additionally, Julia provides\nsoftware support for Arbitrary Precision Arithmetic, which can handle operations on numeric\nvalues that cannot be represented effectively in native hardware representations, but at the cost\nof relatively slower performance.\n\nThe following are Julia's primitive numeric types:\n\nInteger types:\n\nType Signed? Number of bits Smallest value Largest value\nInt8 ✓ 8 -2^7 2^7 - 1\nUInt8  8 0 2^8 - 1\nInt16 ✓ 16 -2^15 2^15 - 1\nUInt16  16 0 2^16 - 1\nInt32 ✓ 32 -2^31 2^31 - 1\nUInt32  32 0 2^32 - 1\nInt64 ✓ 64 -2^63 2^63 - 1\nUInt64  64 0 2^64 - 1\nInt128 ✓ 128 -2^127 2^127 - 1\nUInt128  128 0 2^128 - 1\nBool N/A 8 false (0) true (1)\n\nFloating-point types:\n\nType Precision Number of bits\nFloat16 half 16\nFloat32 single 32\nFloat64 double 64\n\nAdditionally, full support for Complex and Rational Numbers is built on top of these primitive\nnumeric types. All numeric types interoperate naturally without explicit casting, thanks to a\nflexible, user-extensible type promotion system."},{"title":"Integers","page":"Integers and Floating-Point Numbers","location":"manual/integers-and-floating-point-numbers.html#Integers","category":"section","text":"Literal integers are represented in the standard manner:\n\njulia> 1\n1\n\njulia> 1234\n1234\n\nThe default type for an integer literal depends on whether the target system has a 32-bit architecture\nor a 64-bit architecture:\n\n# 32-bit system:\njulia> typeof(1)\nInt32\n\n# 64-bit system:\njulia> typeof(1)\nInt64\n\nThe Julia internal variable Sys.WORD_SIZE indicates whether the target system is 32-bit\nor 64-bit:\n\n# 32-bit system:\njulia> Sys.WORD_SIZE\n32\n\n# 64-bit system:\njulia> Sys.WORD_SIZE\n64\n\nJulia also defines the types Int and UInt, which are aliases for the system's signed and unsigned\nnative integer types respectively:\n\n# 32-bit system:\njulia> Int\nInt32\njulia> UInt\nUInt32\n\n# 64-bit system:\njulia> Int\nInt64\njulia> UInt\nUInt64\n\nLarger integer literals that cannot be represented using only 32 bits but can be represented in\n64 bits always create 64-bit integers, regardless of the system type:\n\n# 32-bit or 64-bit system:\njulia> typeof(3000000000)\nInt64\n\nUnsigned integers are input and output using the 0x prefix and hexadecimal (base 16) digits\n0-9a-f (the capitalized digits A-F also work for input). The size of the unsigned value is\ndetermined by the number of hex digits used:\n\njulia> x = 0x1\n0x01\n\njulia> typeof(x)\nUInt8\n\njulia> x = 0x123\n0x0123\n\njulia> typeof(x)\nUInt16\n\njulia> x = 0x1234567\n0x01234567\n\njulia> typeof(x)\nUInt32\n\njulia> x = 0x123456789abcdef\n0x0123456789abcdef\n\njulia> typeof(x)\nUInt64\n\njulia> x = 0x11112222333344445555666677778888\n0x11112222333344445555666677778888\n\njulia> typeof(x)\nUInt128\n\nThis behavior is based on the observation that when one uses unsigned hex literals for integer\nvalues, one typically is using them to represent a fixed numeric byte sequence, rather than just\nan integer value.\n\nBinary and octal literals are also supported:\n\njulia> x = 0b10\n0x02\n\njulia> typeof(x)\nUInt8\n\njulia> x = 0o010\n0x08\n\njulia> typeof(x)\nUInt8\n\njulia> x = 0x00000000000000001111222233334444\n0x00000000000000001111222233334444\n\njulia> typeof(x)\nUInt128\n\nAs for hexadecimal literals, binary and octal literals produce unsigned integer types. The size\nof the binary data item is the minimal needed size, if the leading digit of the literal is not\n0. In the case of leading zeros, the size is determined by the minimal needed size for a\nliteral, which has the same length but leading digit 1. It means that:\n\n0x1 and 0x12 are UInt8 literals,\n0x123 and 0x1234 are UInt16 literals,\n0x12345 and 0x12345678 are UInt32 literals,\n0x123456789 and 0x1234567890adcdef are UInt64 literals, etc.\n\nEven if there are leading zero digits which don’t contribute to the value, they count for\ndetermining storage size of a literal. So 0x01 is a UInt8 while 0x0001 is a UInt16.\n\nThat allows the user to control the size.\n\nUnsigned literals (starting with 0x) that encode integers too large to be represented as\nUInt128 values will construct BigInt values instead. This is not an unsigned type but\nit is the only built-in type big enough to represent such large integer values.\n\nBinary, octal, and hexadecimal literals may be signed by a - immediately preceding the\nunsigned literal. They produce an unsigned integer of the same size as the unsigned literal\nwould do, with the two's complement of the value:\n\njulia> -0x2\n0xfe\n\njulia> -0x0002\n0xfffe\n\nThe minimum and maximum representable values of primitive numeric types such as integers are given\nby the typemin and typemax functions:\n\njulia> (typemin(Int32), typemax(Int32))\n(-2147483648, 2147483647)\n\njulia> for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]\n           println(\"$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]\")\n       end\n   Int8: [-128,127]\n  Int16: [-32768,32767]\n  Int32: [-2147483648,2147483647]\n  Int64: [-9223372036854775808,9223372036854775807]\n Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]\n  UInt8: [0,255]\n UInt16: [0,65535]\n UInt32: [0,4294967295]\n UInt64: [0,18446744073709551615]\nUInt128: [0,340282366920938463463374607431768211455]\n\nThe values returned by typemin and typemax are always of the given argument\ntype. (The above expression uses several features that have yet to be introduced, including for loops,\nStrings, and Interpolation, but should be easy enough to understand for users\nwith some existing programming experience.)"},{"title":"Overflow behavior","page":"Integers and Floating-Point Numbers","location":"manual/integers-and-floating-point-numbers.html#Overflow-behavior","category":"section","text":"In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:\n\njulia> x = typemax(Int64)\n9223372036854775807\n\njulia> x + 1\n-9223372036854775808\n\njulia> x + 1 == typemin(Int64)\ntrue\n\nArithmetic operations with Julia's integer types inherently perform modular arithmetic,\nmirroring the characteristics of integer arithmetic on modern computer hardware. In scenarios where overflow is a possibility,\nit is crucial to explicitly check for wraparound effects that can result from such overflows.\nThe Base.Checked module provides a suite of arithmetic operations equipped with overflow checks, which trigger errors if an overflow occurs. For use cases where overflow cannot be tolerated under any circumstances, utilizing the BigInt type, as detailed in Arbitrary Precision Arithmetic, is advisable.\n\nAn example of overflow behavior and how to potentially resolve it is as follows:\n\njulia> 10^19\n-8446744073709551616\n\njulia> big(10)^19\n10000000000000000000"},{"title":"Division errors","page":"Integers and Floating-Point Numbers","location":"manual/integers-and-floating-point-numbers.html#Division-errors","category":"section","text":"Integer division (the div function) has two exceptional cases: dividing by zero, and dividing\nthe lowest negative number (typemin) by -1. Both of these cases throw a DivideError.\nThe remainder and modulus functions (rem and mod) throw a DivideError when their\nsecond argument is zero."},{"title":"Floating-Point Numbers","page":"Integers and Floating-Point Numbers","location":"manual/integers-and-floating-point-numbers.html#Floating-Point-Numbers","category":"section","text":"Literal floating-point numbers are represented in the standard formats, using\nE-notation when necessary:\n\njulia> 1.0\n1.0\n\njulia> 1.\n1.0\n\njulia> 0.5\n0.5\n\njulia> .5\n0.5\n\njulia> -1.23\n-1.23\n\njulia> 1e10\n1.0e10\n\njulia> 2.5e-4\n0.00025\n\nThe above results are all Float64 values. Literal Float32 values can be\nentered by writing an f in place of e:\n\njulia> x = 0.5f0\n0.5f0\n\njulia> typeof(x)\nFloat32\n\njulia> 2.5f-4\n0.00025f0\n\nValues can be converted to Float32 easily:\n\njulia> x = Float32(-1.5)\n-1.5f0\n\njulia> typeof(x)\nFloat32\n\nHexadecimal floating-point literals are also valid, but only as Float64 values,\nwith p preceding the base-2 exponent:\n\njulia> 0x1p0\n1.0\n\njulia> 0x1.8p3\n12.0\n\njulia> x = 0x.4p-1\n0.125\n\njulia> typeof(x)\nFloat64\n\nHalf-precision floating-point numbers are also supported (Float16) on all platforms, with native instructions used on hardware which supports this number format. Otherwise, operations are implemented in software, and use Float32 for intermediate calculations.\nAs an internal implementation detail, this is achieved under the hood by using LLVM's half type, which behaves similarly to what the GCC -fexcess-precision=16 flag does for C/C++ code.\n\njulia> sizeof(Float16(4.))\n2\n\njulia> 2*Float16(4.)\nFloat16(8.0)\n\nThe underscore _ can be used as digit separator:\n\njulia> 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010\n(10000, 5.0e-9, 0xdeadbeef, 0xb2)"},{"title":"Floating-point zero","page":"Integers and Floating-Point Numbers","location":"manual/integers-and-floating-point-numbers.html#Floating-point-zero","category":"section","text":"Floating-point numbers have two zeros, positive zero\nand negative zero. They are equal to each other but have different binary representations, as\ncan be seen using the bitstring function:\n\njulia> 0.0 == -0.0\ntrue\n\njulia> bitstring(0.0)\n\"0000000000000000000000000000000000000000000000000000000000000000\"\n\njulia> bitstring(-0.0)\n\"1000000000000000000000000000000000000000000000000000000000000000\""},{"title":"Special floating-point values","page":"Integers and Floating-Point Numbers","location":"manual/integers-and-floating-point-numbers.html#Special-floating-point-values","category":"section","text":"There are three specified standard floating-point values that do not correspond to any point on\nthe real number line:\n\nFloat16 Float32 Float64 Name Description\nInf16 Inf32 Inf positive infinity a value greater than all finite floating-point values\n-Inf16 -Inf32 -Inf negative infinity a value less than all finite floating-point values\nNaN16 NaN32 NaN not a number a value not == to any floating-point value (including itself)\n\nFor further discussion of how these non-finite floating-point values are ordered with respect\nto each other and other floats, see Numeric Comparisons. By the IEEE 754 standard,\nthese floating-point values are the results of certain arithmetic operations:\n\njulia> 1/Inf\n0.0\n\njulia> 1/0\nInf\n\njulia> -5/0\n-Inf\n\njulia> 0.000001/0\nInf\n\njulia> 0/0\nNaN\n\njulia> 500 + Inf\nInf\n\njulia> 500 - Inf\n-Inf\n\njulia> Inf + Inf\nInf\n\njulia> Inf - Inf\nNaN\n\njulia> Inf * Inf\nInf\n\njulia> Inf / Inf\nNaN\n\njulia> 0 * Inf\nNaN\n\njulia> NaN == NaN\nfalse\n\njulia> NaN != NaN\ntrue\n\njulia> NaN < NaN\nfalse\n\njulia> NaN > NaN\nfalse\n\nThe typemin and typemax functions also apply to floating-point types:\n\njulia> (typemin(Float16),typemax(Float16))\n(-Inf16, Inf16)\n\njulia> (typemin(Float32),typemax(Float32))\n(-Inf32, Inf32)\n\njulia> (typemin(Float64),typemax(Float64))\n(-Inf, Inf)"},{"title":"Machine epsilon","page":"Integers and Floating-Point Numbers","location":"manual/integers-and-floating-point-numbers.html#Machine-epsilon","category":"section","text":"Most real numbers cannot be represented exactly with floating-point numbers, and so for many purposes\nit is important to know the distance between two adjacent representable floating-point numbers,\nwhich is often known as machine epsilon.\n\nJulia provides eps, which gives the distance between 1.0 and the next larger representable\nfloating-point value:\n\njulia> eps(Float32)\n1.1920929f-7\n\njulia> eps(Float64)\n2.220446049250313e-16\n\njulia> eps() # same as eps(Float64)\n2.220446049250313e-16\n\nThese values are 2.0^-23 and 2.0^-52 as Float32 and Float64 values,\nrespectively. The eps function can also take a floating-point value as an\nargument, and gives the absolute difference between that value and the next representable\nfloating point value. That is, eps(x) yields a value of the same type as x such that\nx + eps(x) is the next representable floating-point value larger than x:\n\njulia> eps(1.0)\n2.220446049250313e-16\n\njulia> eps(1000.)\n1.1368683772161603e-13\n\njulia> eps(1e-27)\n1.793662034335766e-43\n\njulia> eps(0.0)\n5.0e-324\n\nThe distance between two adjacent representable floating-point numbers is not constant, but is\nsmaller for smaller values and larger for larger values. In other words, the representable floating-point\nnumbers are densest in the real number line near zero, and grow sparser exponentially as one moves\nfarther away from zero. By definition, eps(1.0) is the same as eps(Float64) since 1.0 is\na 64-bit floating-point value.\n\nJulia also provides the nextfloat and prevfloat functions which return\nthe next largest or smallest representable floating-point number to the argument respectively:\n\njulia> x = 1.25f0\n1.25f0\n\njulia> nextfloat(x)\n1.2500001f0\n\njulia> prevfloat(x)\n1.2499999f0\n\njulia> bitstring(prevfloat(x))\n\"00111111100111111111111111111111\"\n\njulia> bitstring(x)\n\"00111111101000000000000000000000\"\n\njulia> bitstring(nextfloat(x))\n\"00111111101000000000000000000001\"\n\nThis example highlights the general principle that the adjacent representable floating-point numbers\nalso have adjacent binary integer representations."},{"title":"Rounding modes","page":"Integers and Floating-Point Numbers","location":"manual/integers-and-floating-point-numbers.html#Rounding-modes","category":"section","text":"If a number doesn't have an exact floating-point representation, it must be rounded to an\nappropriate representable value. However, the manner in which this rounding is done can be\nchanged if required according to the rounding modes presented in the [IEEE 754\nstandard](https://en.wikipedia.org/wiki/IEEE_754-2008).\n\nThe default mode used is always RoundNearest, which rounds to the nearest representable\nvalue, with ties rounded towards the nearest value with an even least significant bit."},{"title":"Background and References","page":"Integers and Floating-Point Numbers","location":"manual/integers-and-floating-point-numbers.html#Background-and-References","category":"section","text":"Floating-point arithmetic entails many subtleties which can be surprising to users who are unfamiliar\nwith the low-level implementation details. However, these subtleties are described in detail in\nmost books on scientific computation, and also in the following references:\n\nThe definitive guide to floating point arithmetic is the IEEE 754-2008 Standard;\nhowever, it is not available for free online.\nFor a brief but lucid presentation of how floating-point numbers are represented, see John D.\nCook's article\non the subject as well as his introduction\nto some of the issues arising from how this representation differs in behavior from the idealized\nabstraction of real numbers.\nAlso recommended is Bruce Dawson's series of blog posts on floating-point numbers.\nFor an excellent, in-depth discussion of floating-point numbers and issues of numerical accuracy\nencountered when computing with them, see David Goldberg's paper What Every Computer Scientist Should Know About Floating-Point Arithmetic.\nFor even more extensive documentation of the history of, rationale for, and issues with floating-point\nnumbers, as well as discussion of many other topics in numerical computing, see the collected writings\nof William Kahan, commonly known as the \"Father\nof Floating-Point\". Of particular interest may be An Interview with the Old Man of Floating-Point."},{"title":"Arbitrary Precision Arithmetic","page":"Integers and Floating-Point Numbers","location":"manual/integers-and-floating-point-numbers.html#Arbitrary-Precision-Arithmetic","category":"section","text":"To allow computations with arbitrary-precision integers and floating point numbers, Julia wraps\nthe GNU Multiple Precision Arithmetic Library (GMP) and the GNU MPFR Library,\nrespectively. The BigInt and BigFloat types are available in Julia for arbitrary\nprecision integer and floating point numbers respectively.\n\nConstructors exist to create these types from primitive numerical types, and the\nstring literal @big_str or parse\ncan be used to construct them from AbstractStrings.\nBigInts can also be input as integer literals when\nthey are too big for other built-in integer types. Note that as there\nis no unsigned arbitrary-precision integer type in Base (BigInt is\nsufficient in most cases), hexadecimal, octal and binary literals can\nbe used (in addition to decimal literals).\n\nOnce created, they participate in arithmetic\nwith all other numeric types thanks to Julia's\ntype promotion and conversion mechanism:\n\njulia> BigInt(typemax(Int64)) + 1\n9223372036854775808\n\njulia> big\"123456789012345678901234567890\" + 1\n123456789012345678901234567891\n\njulia> parse(BigInt, \"123456789012345678901234567890\") + 1\n123456789012345678901234567891\n\njulia> string(big\"2\"^200, base=16)\n\"100000000000000000000000000000000000000000000000000\"\n\njulia> 0x100000000000000000000000000000000-1 == typemax(UInt128)\ntrue\n\njulia> 0x000000000000000000000000000000000\n0\n\njulia> typeof(ans)\nBigInt\n\njulia> big\"1.23456789012345678901\"\n1.234567890123456789010000000000000000000000000000000000000000000000000000000004\n\njulia> parse(BigFloat, \"1.23456789012345678901\")\n1.234567890123456789010000000000000000000000000000000000000000000000000000000004\n\njulia> BigFloat(2.0^66) / 3\n2.459565876494606882133333333333333333333333333333333333333333333333333333333344e19\n\njulia> factorial(BigInt(40))\n815915283247897734345611269596115894272000000000\n\nHowever, type promotion between the primitive types above and BigInt/BigFloat\nis not automatic and must be explicitly stated.\n\njulia> x = typemin(Int64)\n-9223372036854775808\n\njulia> x = x - 1\n9223372036854775807\n\njulia> typeof(x)\nInt64\n\njulia> y = BigInt(typemin(Int64))\n-9223372036854775808\n\njulia> y = y - 1\n-9223372036854775809\n\njulia> typeof(y)\nBigInt\n\nThe default precision (in number of bits of the significand) and rounding mode of BigFloat\noperations can be changed globally by calling setprecision and setrounding,\nand all further calculations will take these changes in account. Alternatively, the precision\nor the rounding can be changed only within the execution of a particular block of code by using\nthe same functions with a do block:\n\njulia> setrounding(BigFloat, RoundUp) do\n           BigFloat(1) + parse(BigFloat, \"0.1\")\n       end\n1.100000000000000000000000000000000000000000000000000000000000000000000000000003\n\njulia> setrounding(BigFloat, RoundDown) do\n           BigFloat(1) + parse(BigFloat, \"0.1\")\n       end\n1.099999999999999999999999999999999999999999999999999999999999999999999999999986\n\njulia> setprecision(40) do\n           BigFloat(1) + parse(BigFloat, \"0.1\")\n       end\n1.1000000000004\n\nwarning: Warning\nThe relation between setprecision or setrounding and\n@big_str, the macro used for big string literals (such as\nbig\"0.3\"), might not be intuitive, as a consequence of the fact that\n@big_str is a macro. See the @big_str documentation for\ndetails."},{"title":"Numeric Literal Coefficients","page":"Integers and Floating-Point Numbers","location":"manual/integers-and-floating-point-numbers.html#man-numeric-literal-coefficients","category":"section","text":"To make common numeric formulae and expressions clearer, Julia allows variables to be immediately\npreceded by a numeric literal, implying multiplication. This makes writing polynomial expressions\nmuch cleaner:\n\njulia> x = 3\n3\n\njulia> 2x^2 - 3x + 1\n10\n\njulia> 1.5x^2 - .5x + 1\n13.0\n\nIt also makes writing exponential functions more elegant:\n\njulia> 2^2x\n64\n\nThe precedence of numeric literal coefficients is slightly lower than that of\nunary operators such as negation.\nSo -2x is parsed as (-2) * x and √2x is parsed as (√2) * x.\nHowever, numeric literal coefficients parse similarly to unary operators when\ncombined with exponentiation.\nFor example 2^3x is parsed as 2^(3x), and 2x^3 is parsed as 2*(x^3).\n\nNumeric literals also work as coefficients to parenthesized expressions:\n\njulia> 2(x-1)^2 - 3(x-1) + 1\n3\n\nnote: Note\nThe precedence of numeric literal coefficients used for implicit\nmultiplication is higher than other binary operators such as multiplication\n(*), and division (/, \\, and //). This means, for example, that\n1 / 2im equals -0.5im and 6 // 2(2 + 1) equals 1 // 1.\n\nAdditionally, parenthesized expressions can be used as coefficients to variables, implying multiplication\nof the expression by the variable:\n\njulia> (x-1)x\n6\n\nNeither juxtaposition of two parenthesized expressions, nor placing a variable before a parenthesized\nexpression, however, can be used to imply multiplication:\n\njulia> (x-1)(x+1)\nERROR: MethodError: objects of type Int64 are not callable\n\njulia> x(x+1)\nERROR: MethodError: objects of type Int64 are not callable\n\nBoth expressions are interpreted as function application: any expression that is not a numeric\nliteral, when immediately followed by a parenthetical, is interpreted as a function applied to\nthe values in parentheses (see Functions for more about functions). Thus, in both of these\ncases, an error occurs since the left-hand value is not a function.\n\nThe above syntactic enhancements significantly reduce the visual noise incurred when writing common\nmathematical formulae. Note that no whitespace may come between a numeric literal coefficient\nand the identifier or parenthesized expression which it multiplies."},{"title":"Syntax Conflicts","page":"Integers and Floating-Point Numbers","location":"manual/integers-and-floating-point-numbers.html#Syntax-Conflicts","category":"section","text":"Juxtaposed literal coefficient syntax may conflict with some numeric literal syntaxes: hexadecimal,\noctal and binary integer literals and engineering notation for floating-point literals. Here are some situations\nwhere syntactic conflicts arise:\n\nThe hexadecimal integer literal expression 0xff could be interpreted as the numeric literal\n0 multiplied by the variable xff. Similar ambiguities arise with octal and binary literals like\n0o777 or 0b01001010.\nThe floating-point literal expression 1e10 could be interpreted as the numeric literal 1 multiplied\nby the variable e10, and similarly with the equivalent E form.\nThe 32-bit floating-point literal expression 1.5f22 could be interpreted as the numeric literal\n1.5 multiplied by the variable f22.\n\nIn all cases the ambiguity is resolved in favor of interpretation as numeric literals:\n\nExpressions starting with 0x/0o/0b are always hexadecimal/octal/binary literals.\nExpressions starting with a numeric literal followed by e or E are always floating-point literals.\nExpressions starting with a numeric literal followed by f are always 32-bit floating-point literals.\n\nUnlike E, which is equivalent to e in numeric literals for historical reasons, F is just another\nletter and does not behave like f in numeric literals. Hence, expressions starting with a numeric literal\nfollowed by F are interpreted as the numerical literal multiplied by a variable, which means that, for\nexample, 1.5F22 is equal to 1.5 * F22."},{"title":"Literal zero and one","page":"Integers and Floating-Point Numbers","location":"manual/integers-and-floating-point-numbers.html#Literal-zero-and-one","category":"section","text":"Julia provides functions which return literal 0 and 1 corresponding to a specified type or the\ntype of a given variable.\n\nFunction Description\nzero(x) Literal zero of type x or type of variable x\none(x) Literal one of type x or type of variable x\n\nThese functions are useful in Numeric Comparisons to avoid overhead from unnecessary\ntype conversion.\n\nExamples:\n\njulia> zero(Float32)\n0.0f0\n\njulia> zero(1.0)\n0.0\n\njulia> one(Int32)\n1\n\njulia> one(BigFloat)\n1.0"},{"title":"Memory Management and Garbage Collection","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#man-memory-management","category":"section","text":"Julia uses automatic memory management through its built-in garbage collector (GC). This section provides an overview of how Julia manages memory and how you can configure and optimize memory usage for your applications."},{"title":"Garbage Collection Overview","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#man-gc-overview","category":"section","text":"Julia features a garbage collector with the following characteristics:\n\nNon-moving: Objects are not relocated in memory during garbage collection\nGenerational: Younger objects are collected more frequently than older ones\nParallel and partially concurrent: The GC can use multiple threads and run concurrently with your program\nMostly precise: The GC accurately identifies object references for pure Julia code, and it provides conservative scanning APIs for users calling Julia from C\n\nThe garbage collector automatically reclaims memory used by objects that are no longer reachable from your program, freeing you from manual memory management in most cases."},{"title":"Memory Architecture","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#man-memory-architecture","category":"section","text":"Julia uses a two-tier allocation strategy:\n\nSmall objects (currently ≤ 2032 bytes but may change): Allocated using a fast per-thread pool allocator\nLarge objects : Allocated directly through the system's malloc\n\nThis hybrid approach optimizes for both allocation speed and memory efficiency, with the pool allocator providing fast allocation for the many small objects typical in Julia programs."},{"title":"System Memory Requirements","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#man-system-memory","category":"section","text":""},{"title":"Swap Space","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#Swap-Space","category":"section","text":"Julia's garbage collector is designed with the expectation that your system has adequate swap space configured. The GC uses heuristics that assume it can allocate memory beyond physical RAM when needed, relying on the operating system's virtual memory management.\n\nIf your system has limited or no swap space, you may experience out-of-memory errors during garbage collection. In such cases, you can use the --heap-size-hint option to limit Julia's memory usage."},{"title":"Memory Hints","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#Memory-Hints","category":"section","text":"You can provide a hint to Julia about the maximum amount of memory to use:\n\njulia --heap-size-hint=4G  # To set the hint to ~4GB\njulia --heap-size-hint=50% # or to 50% of physical memory\n\nThe --heap-size-hint option tells the garbage collector to trigger collection more aggressively when approaching the specified limit. This is particularly useful in:\n\nContainers with memory limits\nSystems without swap space\nShared systems where you want to limit Julia's memory footprint\n\nYou can also set this via the JULIA_HEAP_SIZE_HINT environment variable:\n\nexport JULIA_HEAP_SIZE_HINT=2G\njulia"},{"title":"Multithreaded Garbage Collection","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#man-gc-multithreading","category":"section","text":"Julia's garbage collector can leverage multiple threads to improve performance on multi-core systems."},{"title":"GC Thread Configuration","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#GC-Thread-Configuration","category":"section","text":"By default, Julia uses multiple threads for garbage collection:\n\nMark threads: Used during the mark phase to trace object references (default: 1, which is shared with the compute thread if there is only one, otherwise half the number of compute threads)\nSweep threads: Used for concurrent sweeping of freed memory (default: 0, disabled)\n\nYou can configure GC threading using:\n\njulia --gcthreads=4,1  # 4 mark threads, 1 sweep thread\njulia --gcthreads=8    # 8 mark threads, 0 sweep threads\n\nOr via environment variable:\n\nexport JULIA_NUM_GC_THREADS=4,1\njulia"},{"title":"Recommendations","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#Recommendations","category":"section","text":"For compute-intensive workloads:\n\nUse multiple mark threads (the default configuration is usually appropriate)\nConsider enabling concurrent sweeping with 1 sweep thread for allocation-heavy workloads\n\nFor memory-intensive workloads:\n\nEnable concurrent sweeping to reduce GC pauses\nMonitor GC time using @time and adjust thread counts accordingly"},{"title":"Monitoring and Debugging","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#man-gc-monitoring","category":"section","text":""},{"title":"Basic Memory Monitoring","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#Basic-Memory-Monitoring","category":"section","text":"Use the @time macro to see memory allocation and GC overhead:\n\njulia> @time some_computation()\n  2.123456 seconds (1.50 M allocations: 58.725 MiB, 17.17% gc time)"},{"title":"GC Logging","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#GC-Logging","category":"section","text":"Enable detailed GC logging to understand collection patterns:\n\njulia> GC.enable_logging(true)\njulia> # Run your code\njulia> GC.enable_logging(false)\n\nThis logs each garbage collection event with timing and memory statistics."},{"title":"Manual GC Control","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#Manual-GC-Control","category":"section","text":"While generally not recommended, you can manually trigger garbage collection:\n\nGC.gc()          # Force a garbage collection\nGC.enable(false) # Disable automatic GC (use with caution!)\nGC.enable(true)  # Re-enable automatic GC\n\nWarning: Disabling GC can lead to memory exhaustion. Only use this for specific performance measurements or debugging."},{"title":"Performance Considerations","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#man-gc-performance","category":"section","text":""},{"title":"Reducing Allocations","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#Reducing-Allocations","category":"section","text":"The best way to minimize GC impact is to reduce unnecessary allocations:\n\nUse in-place operations when possible (e.g., x .+= y instead of x = x + y)\nPre-allocate arrays and reuse them\nAvoid creating temporary objects in tight loops\nConsider using StaticArrays.jl for small, fixed-size arrays"},{"title":"Memory-Efficient Patterns","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#Memory-Efficient-Patterns","category":"section","text":"Avoid global variables that change type\nUse const for global constants"},{"title":"Profiling Memory Usage","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#Profiling-Memory-Usage","category":"section","text":"For detailed guidance on profiling memory allocations and identifying performance bottlenecks, see the Profiling section."},{"title":"Advanced Configuration","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#man-gc-advanced","category":"section","text":""},{"title":"Integration with System Memory Management","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#Integration-with-System-Memory-Management","category":"section","text":"Julia works best when:\n\nThe system has adequate swap space (recommended: 2x physical RAM)\nVirtual memory is properly configured\nOther processes leave sufficient memory available\nContainer memory limits are set appropriately with --heap-size-hint"},{"title":"Troubleshooting Memory Issues","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#man-gc-troubleshooting","category":"section","text":""},{"title":"High GC Overhead","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#High-GC-Overhead","category":"section","text":"If garbage collection is taking too much time:\n\nReduce allocation rate: Focus on algorithmic improvements\nAdjust GC threads: Experiment with different --gcthreads settings\nUse concurrent sweeping: Enable background sweeping with --gcthreads=N,1\nProfile memory patterns: Identify allocation hotspots and optimize them"},{"title":"Memory Leaks","page":"Memory Management and Garbage Collection","location":"manual/memory-management.html#Memory-Leaks","category":"section","text":"While Julia's GC prevents most memory leaks, issues can still occur:\n\nGlobal references: Avoid holding references to large objects in global variables\nClosures: Be careful with closures that capture large amounts of data\nC interop: Ensure proper cleanup when interfacing with C libraries\n\nFor more detailed information about Julia's garbage collector internals, see the Garbage Collection section in the Developer Documentation."},{"title":"Initialization of the Julia runtime","page":"Initialization of the Julia runtime","location":"devdocs/init.html#Initialization-of-the-Julia-runtime","category":"section","text":"How does the Julia runtime execute julia -e 'println(\"Hello World!\")' ?"},{"title":"main()","page":"Initialization of the Julia runtime","location":"devdocs/init.html#main()","category":"section","text":"Execution starts at main() in cli/loader_exe.c,\nwhich calls jl_load_repl() in cli/loader_lib.c\nwhich loads a few libraries, eventually calling jl_repl_entrypoint() in src/jlapi.c.\n\njl_repl_entrypoint() calls libsupport_init()\nto set the C library locale and to initialize the \"ios\" library (see ios_init_stdstreams()\nand Legacy ios.c library).\n\nNext jl_parse_opts() is called to process\ncommand line options. Note that jl_parse_opts() only deals with options that affect code generation\nor early initialization. Other options are handled later by exec_options() in base/client.jl.\n\njl_parse_opts() stores command line options in the global jl_options struct."},{"title":"julia_init()","page":"Initialization of the Julia runtime","location":"devdocs/init.html#julia_init()","category":"section","text":"julia_init() in init.c is called\nby main() and calls _julia_init() in init.c.\n\n_julia_init() begins by calling libsupport_init() again (it does nothing the second time).\n\nrestore_signals() is called\nto zero the signal handler mask.\n\njl_resolve_sysimg_location() searches\nconfigured paths for the base system image. See Building the Julia system image.\n\njl_gc_init() sets up allocation pools\nand lists for weak refs, preserved values and finalization.\n\njl_init_frontend() loads and initializes\na pre-compiled femtolisp image containing the scanner/parser.\n\njl_init_types() creates jl_datatype_t\ntype description objects for the built-in types defined in julia.h.\ne.g.\n\njl_any_type = jl_new_abstracttype(jl_symbol(\"Any\"), core, NULL, jl_emptysvec);\njl_any_type->super = jl_any_type;\n\njl_type_type = jl_new_abstracttype(jl_symbol(\"Type\"), core, jl_any_type, jl_emptysvec);\n\njl_int32_type = jl_new_primitivetype(jl_symbol(\"Int32\"), core,\n                                     jl_any_type, jl_emptysvec, 32);\n\njl_init_tasks() creates the jl_datatype_t* jl_task_type\nobject; initializes the global jl_root_task struct; and sets jl_current_task to the root task.\n\njl_init_codegen() initializes\nthe LLVM library.\n\njl_init_serializer() initializes\n8-bit serialization tags for builtin jl_value_t values.\n\nIf there is no sysimg file (!jl_options.image_file) then the Core and Main modules are\ncreated and boot.jl is evaluated:\n\njl_core_module = jl_new_module(jl_symbol(\"Core\"), NULL) creates the Julia Core module.\n\njl_init_intrinsic_functions()\ncreates a new Julia module Intrinsics containing constant jl_intrinsic_type symbols. These define\nan integer code for each intrinsic function.\nemit_intrinsic() translates\nthese symbols into LLVM instructions during code generation.\n\njl_init_primitives() hooks C\nfunctions up to Julia function symbols. e.g. the symbol Core.:(===)() is bound to C function pointer\njl_f_is() by calling add_builtin_func(\"===\", jl_f_is).\n\njl_new_main_module() creates\nthe global \"Main\" module and sets jl_current_task->current_module = jl_main_module.\n\nNote: _julia_init() then sets jl_root_task->current_module = jl_core_module.\njl_root_task is an alias of jl_current_task at this point, so the current_module set by jl_new_main_module()\nabove is overwritten.\n\njl_load(\"boot.jl\", sizeof(\"boot.jl\"))\ncalls jl_parse_eval_all which repeatedly\ncalls jl_toplevel_eval_flex()\nto execute boot.jl. <!– TODO – drill\ndown into eval? –>\n\njl_get_builtin_hooks() initializes\nglobal C pointers to Julia globals defined in boot.jl.\n\njl_init_box_caches() pre-allocates\nglobal boxed integer value objects for values up to 1024. This speeds up allocation of boxed ints\nlater on. e.g.:\n\njl_value_t *jl_box_uint8(uint32_t x)\n{\n    return boxed_uint8_cache[(uint8_t)x];\n}\n\n_julia_init() iterates over the\njl_core_module->bindings.table looking for jl_datatype_t values and sets the type name's module\nprefix to jl_core_module.\n\njl_add_standard_imports(jl_main_module)\ndoes \"using Base\" in the \"Main\" module.\n\nNote: _julia_init() now reverts to jl_root_task->current_module = jl_main_module as it was\nbefore being set to jl_core_module above.\n\nPlatform specific signal handlers are initialized for SIGSEGV (OSX, Linux), and SIGFPE (Windows).\n\nOther signals (SIGINFO, SIGBUS, SIGILL, SIGTERM, SIGABRT, SIGQUIT, SIGSYS and SIGPIPE) are\nhooked up to sigdie_handler()\nwhich prints a backtrace.\n\njl_init_restored_module() calls\njl_module_run_initializer() for\neach deserialized module to run the __init__() function.\n\nFinally sigint_handler()\nis hooked up to SIGINT and calls jl_throw(jl_interrupt_exception).\n\n_julia_init() then returns back to main() in cli/loader_exe.c\nand main() calls repl_entrypoint(argc, (char**)argv).\n\nsidebar: sysimg\nIf there is a sysimg file, it contains a pre-cooked image of the Core and Main modules (and\nwhatever else is created by boot.jl). See Building the Julia system image.jl_restore_system_image() deserializes\nthe saved sysimg into the current Julia runtime environment and initialization continues after\njl_init_box_caches() below...Note: jl_restore_system_image() (and staticdata.c in general)\nuses the Legacy ios.c library."},{"title":"repl_entrypoint()","page":"Initialization of the Julia runtime","location":"devdocs/init.html#repl_entrypoint()","category":"section","text":"repl_entrypoint() loads the contents of\nargv[] into Base.ARGS.\n\nIf a .jl \"program\" file was supplied on the command line, then exec_program()\ncalls jl_load(program,len) which\ncalls jl_parse_eval_all which repeatedly\ncalls jl_toplevel_eval_flex()\nto execute the program.\n\nHowever, in our example (julia -e 'println(\"Hello World!\")'), jl_get_global(jl_base_module, jl_symbol(\"_start\"))\nlooks up Base._start and jl_apply()\nexecutes it."},{"title":"Base._start","page":"Initialization of the Julia runtime","location":"devdocs/init.html#Base._start","category":"section","text":"Base._start calls Base.exec_options\nwhich calls jl_parse_input_line(\"println(\"Hello World!\")\")\nto create an expression object and Core.eval(Main, ex) to execute the parsed expression ex in the module context of Main."},{"title":"Core.eval","page":"Initialization of the Julia runtime","location":"devdocs/init.html#Core.eval","category":"section","text":"Core.eval(Main, ex) calls jl_toplevel_eval_in(m, ex),\nwhich calls jl_toplevel_eval_flex.\njl_toplevel_eval_flex implements a simple heuristic to decide whether to compile a given code thunk or run it by interpreter.\nWhen given println(\"Hello World!\"), it would usually decide to run the code by interpreter, in which case it calls\njl_interpret_toplevel_thunk, which then calls\neval_body.\n\nThe stack dump below shows how the interpreter works its way through various methods of Base.println()\nand Base.print() before arriving at write(s::IO, a::Array{T}) where T\n which does ccall(jl_uv_write()).\n\njl_uv_write() calls uv_write()\nto write \"Hello World!\" to JL_STDOUT. See Libuv wrappers for stdio.:\n\nHello World!\n\nStack frame Source code Notes\njl_uv_write() jl_uv.c called though ccall\njulia_write_282942 stream.jl function write!(s::IO, a::Array{T}) where T\njulia_print_284639 ascii.jl print(io::IO, s::String) = (write(io, s); nothing)\njlcall_print_284639  \njl_apply() julia.h \njl_trampoline() builtins.c \njl_apply() julia.h \njl_apply_generic() gf.c Base.print(Base.TTY, String)\njl_apply() julia.h \njl_trampoline() builtins.c \njl_apply() julia.h \njl_apply_generic() gf.c Base.print(Base.TTY, String, Char, Char...)\njl_apply() julia.h \njl_f_apply() builtins.c \njl_apply() julia.h \njl_trampoline() builtins.c \njl_apply() julia.h \njl_apply_generic() gf.c Base.println(Base.TTY, String, String...)\njl_apply() julia.h \njl_trampoline() builtins.c \njl_apply() julia.h \njl_apply_generic() gf.c Base.println(String,)\njl_apply() julia.h \ndo_call() interpreter.c \neval_body() interpreter.c \njl_interpret_toplevel_thunk interpreter.c \njl_toplevel_eval_flex toplevel.c \njl_toplevel_eval_in toplevel.c \nCore.eval boot.jl \n\nSince our example has just one function call, which has done its job of printing \"Hello World!\",\nthe stack now rapidly unwinds back to main()."},{"title":"jl_atexit_hook()","page":"Initialization of the Julia runtime","location":"devdocs/init.html#jl_atexit_hook()","category":"section","text":"main() calls jl_atexit_hook().\nThis calls Base._atexit, then calls jl_gc_run_all_finalizers()\nand cleans up libuv handles."},{"title":"julia_save()","page":"Initialization of the Julia runtime","location":"devdocs/init.html#julia_save()","category":"section","text":"Finally, main() calls julia_save(),\nwhich if requested on the command line, saves the runtime state to a new system image. See jl_compile_all()\nand jl_save_system_image()."},{"title":"Multi-Threading","page":"Multi-Threading","location":"manual/multi-threading.html#man-multithreading","category":"section","text":"Visit this blog post for a presentation\nof Julia multi-threading features."},{"title":"Starting Julia with multiple threads","page":"Multi-Threading","location":"manual/multi-threading.html#Starting-Julia-with-multiple-threads","category":"section","text":"By default, Julia starts up with 2 threads of execution; 1 worker thread and 1 interactive thread.\nThis can be verified by using the command Threads.nthreads():\n\njulia> Threads.nthreads(:default)\n1\njulia> Threads.nthreads(:interactive)\n1\n\nThe number of execution threads is controlled either by using the\n-t/--threads command line argument or by using the\nJULIA_NUM_THREADS environment variable. When both are\nspecified, then -t/--threads takes precedence.\n\nThe number of threads can either be specified as an integer (--threads=4) or as auto\n(--threads=auto), where auto tries to infer a useful default number of threads to use\n(see Command-line Options for more details).\n\nSee threadpools for how to control how many :default and :interactive threads are in\neach threadpool.\n\ncompat: Julia 1.5\nThe -t/--threads command line argument requires at least Julia 1.5.\nIn older versions you must use the environment variable instead.\n\ncompat: Julia 1.7\nUsing auto as value of the environment variable JULIA_NUM_THREADS requires at least Julia 1.7.\nIn older versions, this value is ignored.\n\ncompat: Julia 1.12\nStarting by default with 1 interactive thread, as well as the 1 worker thread, was made as such in Julia 1.12\nIf the number of threads is set to 1 by either doing -t1 or JULIA_NUM_THREADS=1 an interactive thread will not be spawned.\n\nLets start Julia with 4 threads:\n\n$ julia --threads 4\n\nLet's verify there are 4 threads at our disposal.\n\njulia> Threads.nthreads()\n4\n\nBut we are currently on the master thread. To check, we use the function Threads.threadid\n\njulia> Threads.threadid()\n1\n\nnote: Note\nIf you prefer to use the environment variable you can set it as follows in\nBash (Linux/macOS):export JULIA_NUM_THREADS=4C shell on Linux/macOS, CMD on Windows:set JULIA_NUM_THREADS=4Powershell on Windows:$env:JULIA_NUM_THREADS=4Note that this must be done before starting Julia.\n\nnote: Note\nThe number of threads specified with -t/--threads is propagated to worker processes\nthat are spawned using the -p/--procs or --machine-file command line options.\nFor example, julia -p2 -t2 spawns 1 main process with 2 worker processes, and all\nthree processes have 2 threads enabled. For more fine grained control over worker\nthreads use addprocs and pass -t/--threads as exeflags."},{"title":"Multiple GC Threads","page":"Multi-Threading","location":"manual/multi-threading.html#Multiple-GC-Threads","category":"section","text":"The Garbage Collector (GC) can use multiple threads. The amount used by default matches the compute\nworker threads or can configured by either the --gcthreads command line argument or by using the\nJULIA_NUM_GC_THREADS environment variable.\n\ncompat: Julia 1.10\nThe --gcthreads command line argument requires at least Julia 1.10.\n\nFor more details about garbage collection configuration and performance tuning, see Memory Management and Garbage Collection."},{"title":"Threadpools","page":"Multi-Threading","location":"manual/multi-threading.html#man-threadpools","category":"section","text":"When a program's threads are busy with many tasks to run, tasks may experience\ndelays which may negatively affect the responsiveness and interactivity of the\nprogram. To address this, you can specify that a task is interactive when you\nThreads.@spawn it:\n\nusing Base.Threads\n@spawn :interactive f()\n\nInteractive tasks should avoid performing high latency operations, and if they\nare long duration tasks, should yield frequently.\n\nBy default Julia starts with one interactive thread reserved to run interactive tasks, but that number can\nbe controlled with:\n\n$ julia --threads 3,1\njulia> Threads.nthreads(:interactive)\n1\n\n$ julia --threads 3,0\njulia> Threads.nthreads(:interactive)\n0\n\nThe environment variable JULIA_NUM_THREADS can also be used similarly:\n\nexport JULIA_NUM_THREADS=3,1\n\nThis starts Julia with 3 threads in the :default threadpool and 1 thread in\nthe :interactive threadpool:\n\njulia> using Base.Threads\n\njulia> nthreadpools()\n2\n\njulia> threadpool() # the main thread is in the interactive thread pool\n:interactive\n\njulia> nthreads(:default)\n3\n\njulia> nthreads(:interactive)\n1\n\njulia> nthreads()\n3\n\nnote: Note\nExplicitly asking for 1 thread by doing -t1 or JULIA_NUM_THREADS=1 does not add an interactive thread.\n\nnote: Note\nThe zero-argument version of nthreads returns the number of threads\nin the default pool.\n\nnote: Note\nDepending on whether Julia has been started with interactive threads,\nthe main thread is either in the default or interactive thread pool.\n\nEither or both numbers can be replaced with the word auto, which causes\nJulia to choose a reasonable default."},{"title":"The @threads Macro","page":"Multi-Threading","location":"manual/multi-threading.html#The-@threads-Macro","category":"section","text":"Let's work a simple example using our native threads. Let us create an array of zeros:\n\njulia> a = zeros(10)\n10-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\nLet us operate on this array simultaneously using 4 threads. We'll have each thread write its\nthread ID into each location.\n\nJulia supports parallel loops using the Threads.@threads macro. This macro is affixed\nin front of a for loop to indicate to Julia that the loop is a multi-threaded region:\n\njulia> Threads.@threads for i = 1:10\n           a[i] = Threads.threadid()\n       end\n\nThe iteration space is split among the threads, after which each thread writes its thread ID\nto its assigned locations:\n\njulia> a\n10-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 2.0\n 2.0\n 2.0\n 3.0\n 3.0\n 4.0\n 4.0\n\nNote that Threads.@threads does not have an optional reduction parameter like @distributed."},{"title":"Using @threads without data-races","page":"Multi-Threading","location":"manual/multi-threading.html#Using-@threads-without-data-races","category":"section","text":"The concept of a data-race is elaborated on in \"Communication and data races between threads\". For now, just know that a data race can result in incorrect results and dangerous errors.\n\nLets say we want to make the function sum_single below multithreaded.\n\njulia> function sum_single(a)\n           s = 0\n           for i in a\n               s += i\n           end\n           s\n       end\nsum_single (generic function with 1 method)\n\njulia> sum_single(1:1_000_000)\n500000500000\n\nSimply adding @threads exposes a data race with multiple threads reading and writing s at the same time.\n\njulia> function sum_multi_bad(a)\n           s = 0\n           Threads.@threads for i in a\n               s += i\n           end\n           s\n       end\nsum_multi_bad (generic function with 1 method)\n\njulia> sum_multi_bad(1:1_000_000)\n70140554652\n\nNote that the result is not 500000500000 as it should be, and will most likely change each evaluation.\n\nTo fix this, buffers that are specific to the task may be used to segment the sum into chunks that are race-free.\nHere sum_single is reused, with its own internal buffer s. The input vector a is split into at most nthreads()\nchunks for parallel work. We then use Threads.@spawn to create tasks that individually sum each chunk. Finally, we sum the results from each task using sum_single again:\n\njulia> function sum_multi_good(a)\n           chunks = Iterators.partition(a, cld(length(a), Threads.nthreads()))\n           tasks = map(chunks) do chunk\n               Threads.@spawn sum_single(chunk)\n           end\n           chunk_sums = fetch.(tasks)\n           return sum_single(chunk_sums)\n       end\nsum_multi_good (generic function with 1 method)\n\njulia> sum_multi_good(1:1_000_000)\n500000500000\n\nnote: Note\nBuffers should not be managed based on threadid() i.e. buffers = zeros(Threads.nthreads()) because concurrent tasks\ncan yield, meaning multiple concurrent tasks may use the same buffer on a given thread, introducing risk of data races.\nFurther, when more than one thread is available tasks may change thread at yield points, which is known as\ntask migration.\n\nAnother option is the use of atomic operations on variables shared across tasks/threads, which may be more performant\ndepending on the characteristics of the operations."},{"title":"Communication and data-races between threads","page":"Multi-Threading","location":"manual/multi-threading.html#man-communication-and-data-races","category":"section","text":"Although Julia's threads can communicate through shared memory, it is notoriously difficult to write correct and data-race free multi-threaded code. Julia's\nChannels are thread-safe and may be used to communicate safely. There are also sections below that explain how to use locks and atomics to avoid data-races.\n\nIn certain cases, Julia is able to detect safety violations, in particular in regards to deadlocks or other known-unsafe operations such as yielding\nto the currently running task. In these cases, a ConcurrencyViolationError is thrown."},{"title":"Data-race freedom","page":"Multi-Threading","location":"manual/multi-threading.html#Data-race-freedom","category":"section","text":"You are entirely responsible for ensuring that your program is data-race free,\nand nothing promised here can be assumed if you do not observe that\nrequirement. The observed results may be highly unintuitive.\n\nIf data-races are introduced, Julia is not memory safe. Be very\ncareful about reading any data if another thread might write to it, as it could result in segmentation faults or worse. Below are a couple of unsafe ways to access global variables from different threads:\n\nThread 1:\nglobal b = false\nglobal a = rand()\nglobal b = true\n\nThread 2:\nwhile !b; end\nbad_read1(a) # it is NOT safe to access `a` here!\n\nThread 3:\nwhile !@isdefined(a); end\nbad_read2(a) # it is NOT safe to access `a` here"},{"title":"Using locks to avoid data-races","page":"Multi-Threading","location":"manual/multi-threading.html#man-using-locks","category":"section","text":"An important tool for avoiding data races, and writing thread-safe code in general, is the concept of a \"lock\". A lock can be locked and unlocked. If a thread has locked a lock, and not unlocked it, it is said to \"hold\" the lock. If there is only one lock, and we write code that requires holding the lock to access some data, we can ensure that multiple threads will never access the same data simultaneously.\n\nNote that the link between a lock and a variable is made by the programmer, and not the program. A helper-type Base.Lockable exists that helps you associate a lock and a value. This is often more safe than keeping track yourself, and is detailed under Using Base.Lockable to associate a lock and a value.\n\nFor example, we can create a lock my_lock, and lock it while we mutate a variable my_variable. This is done most simply with the @lock macro:\n\njulia> my_lock = ReentrantLock();\n\njulia> my_variable = [1, 2, 3];\n\njulia> @lock my_lock my_variable[1] = 100\n100\n\nBy using a similar pattern with the same lock and variable, but on another thread, the operations are free from data-races.\n\nWe could have performed the operation above with the functional version of lock, in the following two ways:\n\njulia> lock(my_lock) do\n           my_variable[1] = 100\n       end\n100\n\njulia> begin\n           lock(my_lock)\n           try\n               my_variable[1] = 100\n           finally\n               unlock(my_lock)\n           end\n       end\n100\n\nAll three options are equivalent. Note how the final version requires an explicit try-block to ensure that the lock is always unlocked, whereas the first two version do this internally. One should always use the lock pattern above when changing data (such as assigning\nto a global or closure variable) accessed by other threads. Failing to do this could have unforeseen and serious consequences."},{"title":"Using Base.Lockable to associate a lock and a value","page":"Multi-Threading","location":"manual/multi-threading.html#man-lockable","category":"section","text":"As mentioned in the previous section, the helper-type Base.Lockable can be used to programmatically ensure the association between a lock and a value. This is generally recommended, as it is both less prone to error and more readable for others compared to having the association only by convention.\n\nAny object can be wrapped in Base.Lockable:\n\njulia> my_array = [];\n\njulia> my_locked_array = Base.Lockable(my_array);\n\nIf the lock is held, the underlying object can be accessed with the empty indexing notation:\n\njulia> begin\n           lock(my_locked_array)\n           try\n               push!(my_locked_array[], 1)\n           finally\n               unlock(my_locked_array)\n           end\n       end\n1-element Vector{Any}:\n 1\n\nIt is usually easier and safer to pass a function as the first argument to lock. The function is applied to the unlocked object, and the locking/unlocking is handled automatically:\n\njulia> lock(x -> push!(x, 2), my_locked_array);\n\njulia> lock(display, my_locked_array)\n2-element Vector{Any}:\n 1\n 2\n\njulia> lock(my_locked_array) do x\n           x[1] = π\n           display(x)\n       end\n2-element Vector{Any}:\n π = 3.1415926535897...\n 2"},{"title":"Atomic Operations","page":"Multi-Threading","location":"manual/multi-threading.html#man-atomic-operations","category":"section","text":"Julia supports accessing and modifying values atomically, that is, in a thread-safe way to avoid\nrace conditions. A value (which must be of a primitive\ntype) can be wrapped as Threads.Atomic to indicate it must be accessed in this way.\nHere we can see an example:\n\njulia> i = Threads.Atomic{Int}(0);\n\njulia> ids = zeros(4);\n\njulia> old_is = zeros(4);\n\njulia> Threads.@threads for id in 1:4\n           old_is[id] = Threads.atomic_add!(i, id)\n           ids[id] = id\n       end\n\njulia> old_is\n4-element Vector{Float64}:\n 0.0\n 1.0\n 7.0\n 3.0\n\njulia> i[]\n 10\n\njulia> ids\n4-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n\nHad we tried to do the addition without the atomic tag, we might have gotten the\nwrong answer due to a race condition. An example of what would happen if we didn't\navoid the race:\n\njulia> using Base.Threads\n\njulia> Threads.nthreads()\n4\n\njulia> acc = Ref(0)\nBase.RefValue{Int64}(0)\n\njulia> @threads for i in 1:1000\n          acc[] += 1\n       end\n\njulia> acc[]\n926\n\njulia> acc = Atomic{Int64}(0)\nAtomic{Int64}(0)\n\njulia> @threads for i in 1:1000\n          atomic_add!(acc, 1)\n       end\n\njulia> acc[]\n1000"},{"title":"Per-field atomics","page":"Multi-Threading","location":"manual/multi-threading.html#man-atomics","category":"section","text":"We can also use atomics on a more granular level using the [@atomic](@ref\nBase.@atomic), @atomicswap,\n@atomicreplace macros, and\n@atomiconce macros.\n\nSpecific details of the memory model and other details of the design are written\nin the [Julia Atomics\nManifesto](https://gist.github.com/vtjnash/11b0031f2e2a66c9c24d33e810b34ec0),\nwhich will later be published formally.\n\nAny field in a struct declaration can be decorated with @atomic, and then any\nwrite must be marked with @atomic also, and must use one of the defined atomic\norderings (:monotonic, :acquire, :release, :acquire_release, or\n:sequentially_consistent). Any read of an atomic field can also be annotated\nwith an atomic ordering constraint, or will be done with monotonic (relaxed)\nordering if unspecified.\n\ncompat: Julia 1.7\nPer-field atomics requires at least Julia 1.7."},{"title":"Side effects and mutable function arguments","page":"Multi-Threading","location":"manual/multi-threading.html#Side-effects-and-mutable-function-arguments","category":"section","text":"When using multi-threading we have to be careful when using functions that are not\npure as we might get a wrong answer.\nFor instance functions that have a\nname ending with !\nby convention modify their arguments and thus are not pure."},{"title":"@threadcall","page":"Multi-Threading","location":"manual/multi-threading.html#@threadcall","category":"section","text":"External libraries, such as those called via ccall, pose a problem for\nJulia's task-based I/O mechanism.\nIf a C library performs a blocking operation, that prevents the Julia scheduler\nfrom executing any other tasks until the call returns.\n(Exceptions are calls into custom C code that call back into Julia, which may then\nyield, or C code that calls jl_yield(), the C equivalent of yield.)\n\nThe @threadcall macro provides a way to avoid stalling execution in such\na scenario.\nIt schedules a C function for execution in a separate thread. A threadpool with a\ndefault size of 4 is used for this. The size of the threadpool is controlled via environment variable\nUV_THREADPOOL_SIZE. While waiting for a free thread, and during function execution once a thread\nis available, the requesting task (on the main Julia event loop) yields to other tasks. Note that\n@threadcall does not return until the execution is complete. From a user point of view, it is\ntherefore a blocking call like other Julia APIs.\n\nIt is very important that the called function does not call back into Julia, as it will segfault.\n\n@threadcall may be removed/changed in future versions of Julia."},{"title":"Caveats","page":"Multi-Threading","location":"manual/multi-threading.html#Caveats","category":"section","text":"At this time, most operations in the Julia runtime and standard libraries\ncan be used in a thread-safe manner, if the user code is data-race free.\nHowever, in some areas work on stabilizing thread support is ongoing.\nMulti-threaded programming has many inherent difficulties, and if a program\nusing threads exhibits unusual or undesirable behavior (e.g. crashes or\nmysterious results), thread interactions should typically be suspected first.\n\nThere are a few specific limitations and warnings to be aware of when using\nthreads in Julia:\n\nBase collection types require manual locking if used simultaneously by\nmultiple threads where at least one thread modifies the collection\n(common examples include push! on arrays, or inserting\nitems into a Dict).\nThe schedule used by @spawn is nondeterministic and should not be relied on.\nCompute-bound, non-memory-allocating tasks can prevent garbage collection from\nrunning in other threads that are allocating memory. In these cases it may\nbe necessary to insert a manual call to GC.safepoint() to allow GC to run.\nThis limitation will be removed in the future.\nAvoid running top-level operations, e.g. include, or eval of type,\nmethod, and module definitions in parallel.\nBe aware that finalizers registered by a library may break if threads are enabled.\nThis may require some transitional work across the ecosystem before threading\ncan be widely adopted with confidence. See the section on\nthe safe use of finalizers for further details."},{"title":"Task Migration","page":"Multi-Threading","location":"manual/multi-threading.html#man-task-migration","category":"section","text":"After a task starts running on a certain thread it may move to a different thread if the task yields.\n\nSuch tasks may have been started with @spawn or @threads,\nalthough the :static schedule option for @threads does freeze the threadid.\n\nThis means that in most cases threadid() should not be treated as constant within a task,\nand therefore should not be used to index into a vector of buffers or stateful objects.\n\ncompat: Julia 1.7\nTask migration was introduced in Julia 1.7. Before this tasks always remained on the same thread that they were\nstarted on."},{"title":"Safe use of Finalizers","page":"Multi-Threading","location":"manual/multi-threading.html#man-finalizers","category":"section","text":"Because finalizers can interrupt any code, they must be very careful in how\nthey interact with any global state. Unfortunately, the main reason that\nfinalizers are used is to update global state (a pure function is generally\nrather pointless as a finalizer). This leads us to a bit of a conundrum.\nThere are a few approaches to dealing with this problem:\n\nWhen single-threaded, code could call the internal jl_gc_enable_finalizers\nC function to prevent finalizers from being scheduled\ninside a critical region. Internally, this is used inside some functions (such\nas our C locks) to prevent recursion when doing certain operations (incremental\npackage loading, codegen, etc.). The combination of a lock and this flag\ncan be used to make finalizers safe.\nA second strategy, employed by Base in a couple places, is to explicitly\ndelay a finalizer until it may be able to acquire its lock non-recursively.\nThe following example demonstrates how this strategy could be applied to\nDistributed.finalize_ref:\nfunction finalize_ref(r::AbstractRemoteRef)\n    if r.where > 0 # Check if the finalizer is already run\n        if islocked(client_refs) || !trylock(client_refs)\n            # delay finalizer for later if we aren't free to acquire the lock\n            finalizer(finalize_ref, r)\n            return nothing\n        end\n        try # `lock` should always be followed by `try`\n            if r.where > 0 # Must check again here\n                # Do actual cleanup here\n                r.where = 0\n            end\n        finally\n            unlock(client_refs)\n        end\n    end\n    nothing\nend\nA related third strategy is to use a yield-free queue. We don't currently\nhave a lock-free queue implemented in Base, but\nBase.IntrusiveLinkedListSynchronized{T} is suitable. This can frequently be a\ngood strategy to use for code with event loops. For example, this strategy is\nemployed by Gtk.jl to manage lifetime ref-counting. In this approach, we\ndon't do any explicit work inside the finalizer, and instead add it to a queue\nto run at a safer time. In fact, Julia's task scheduler already uses this, so\ndefining the finalizer as x -> @spawn do_cleanup(x) is one example of this\napproach. Note however that this doesn't control which thread do_cleanup\nruns on, so do_cleanup would still need to acquire a lock. That\ndoesn't need to be true if you implement your own queue, as you can explicitly\nonly drain that queue from your thread."},{"title":"I/O and Network","page":"I/O and Network","location":"base/io-network.html#I/O-and-Network","category":"section","text":""},{"title":"General I/O","page":"I/O and Network","location":"base/io-network.html#General-I/O","category":"section","text":""},{"title":"Text I/O","page":"I/O and Network","location":"base/io-network.html#Text-I/O","category":"section","text":""},{"title":"Multimedia I/O","page":"I/O and Network","location":"base/io-network.html#Multimedia-I/O","category":"section","text":"Just as text output is performed by print and user-defined types can indicate their textual\nrepresentation by overloading show, Julia provides a standardized mechanism for rich multimedia\noutput (such as images, formatted text, or even audio and video), consisting of three parts:\n\nA function display(x) to request the richest available multimedia display of a Julia object\nx (with a plain-text fallback).\nOverloading show allows one to indicate arbitrary multimedia representations (keyed by standard\nMIME types) of user-defined types.\nMultimedia-capable display backends may be registered by subclassing a generic AbstractDisplay type\nand pushing them onto a stack of display backends via pushdisplay.\n\nThe base Julia runtime provides only plain-text display, but richer displays may be enabled by\nloading external modules or by using graphical Julia environments (such as the IPython-based IJulia\nnotebook).\n\nAs mentioned above, one can also define new display backends. For example, a module that can display\nPNG images in a window can register this capability with Julia, so that calling display(x) on\ntypes with PNG representations will automatically display the image using the module's window.\n\nIn order to define a new display backend, one should first create a subtype D of the abstract\nclass AbstractDisplay. Then, for each MIME type (mime string) that can be displayed on D, one should\ndefine a function display(d::D, ::MIME\"mime\", x) = ... that displays x as that MIME type,\nusually by calling show(io, mime, x) or repr(io, mime, x).\nA MethodError should be thrown if x cannot be displayed\nas that MIME type; this is automatic if one calls show or repr. Finally, one should define a function\ndisplay(d::D, x) that queries showable(mime, x) for the mime types supported by D\nand displays the \"best\" one; a MethodError should be thrown if no supported MIME types are found\nfor x. Similarly, some subtypes may wish to override redisplay(d::D, ...). (Again, one should\nimport Base.display to add new methods to display.) The return values of these functions are\nup to the implementation (since in some cases it may be useful to return a display \"handle\" of\nsome type). The display functions for D can then be called directly, but they can also be invoked\nautomatically from display(x) simply by pushing a new display onto the display-backend stack\nwith:"},{"title":"Network I/O","page":"I/O and Network","location":"base/io-network.html#Network-I/O","category":"section","text":""},{"title":"Core.IO","page":"I/O and Network","location":"base/io-network.html#Core.IO","category":"type","text":"IO\n\nAbstract supertype for input/output types.\n\n\n\n\n\n"},{"title":"Base.stdout","page":"I/O and Network","location":"base/io-network.html#Base.stdout","category":"constant","text":"stdout::IO\n\nGlobal variable referring to the standard out stream.\n\n\n\n\n\n"},{"title":"Base.stderr","page":"I/O and Network","location":"base/io-network.html#Base.stderr","category":"constant","text":"stderr::IO\n\nGlobal variable referring to the standard error stream.\n\n\n\n\n\n"},{"title":"Base.stdin","page":"I/O and Network","location":"base/io-network.html#Base.stdin","category":"constant","text":"stdin::IO\n\nGlobal variable referring to the standard input stream.\n\n\n\n\n\n"},{"title":"Base.read","page":"I/O and Network","location":"base/io-network.html#Base.read-Tuple{AbstractString}","category":"method","text":"read(filename::AbstractString)\n\nRead the entire contents of a file as a Vector{UInt8}.\n\nread(filename::AbstractString, String)\n\nRead the entire contents of a file as a string.\n\nread(filename::AbstractString, args...)\n\nOpen a file and read its contents. args is passed to read: this is equivalent to\nopen(io->read(io, args...), filename).\n\n\n\n\n\n"},{"title":"Base.write","page":"I/O and Network","location":"base/io-network.html#Base.write-Tuple{AbstractString, Any}","category":"method","text":"write(filename::AbstractString, content)\n\nWrite the canonical binary representation of content to a file, which will be created if it does not exist yet or overwritten if it does exist.\n\nReturn the number of bytes written into the file.\n\n\n\n\n\n"},{"title":"Base.open","page":"I/O and Network","location":"base/io-network.html#Base.open","category":"function","text":"open(f::Function, command, args...; kwargs...)\n\nSimilar to open(command, args...; kwargs...), but calls f(stream) on the\nresulting process stream, then closes the input stream and waits for the process\nto complete. Return the value returned by f on success. Throw an error if the\nprocess failed, or if the process attempts to print anything to stdout.\n\n\n\n\n\nopen(command, stdio=devnull; write::Bool = false, read::Bool = !write)\n\nStart running command asynchronously, and return a process::IO object.  If read is\ntrue, then reads from the process come from the process's standard output and stdio optionally\nspecifies the process's standard input stream.  If write is true, then writes go to\nthe process's standard input and stdio optionally specifies the process's standard output\nstream.\nThe process's standard error stream is connected to the current global stderr.\n\n\n\n\n\nopen(command, mode::AbstractString, stdio=devnull)\n\nRun command asynchronously. Like open(command, stdio; read, write) except specifying\nthe read and write flags via a mode string instead of keyword arguments.\nPossible mode strings are:\n\nMode Description Keywords\nr read none\nw write write = true\nr+ read, write read = true, write = true\nw+ read, write read = true, write = true\n\n\n\n\n\nopen(fd::OS_HANDLE)::IO\n\nTake a raw file descriptor and wrap it in a Julia-aware IO type,\nand take ownership of the fd handle.\nCall open(Libc.dup(fd)) to avoid the ownership capture\nof the original handle.\n\nwarning: Warning\nDo not call this on a handle that's already owned by some\nother part of the system.\n\n\n\n\n\nopen(filename::AbstractString, [mode::AbstractString]; lock = true)::IOStream\n\nAlternate syntax for open, where a string-based mode specifier is used instead of the five\nbooleans. The values of mode correspond to those from fopen(3) or Perl open, and are\nequivalent to setting the following boolean groups:\n\nMode Description Keywords\nr read none\nw write, create, truncate write = true\na write, create, append append = true\nr+ read, write read = true, write = true\nw+ read, write, create, truncate truncate = true, read = true\na+ read, write, create, append append = true, read = true\n\nThe lock keyword argument controls whether operations will be locked for\nsafe multi-threaded access.\n\nExamples\n\njulia> io = open(\"myfile.txt\", \"w\");\n\njulia> write(io, \"Hello world!\");\n\njulia> close(io);\n\njulia> io = open(\"myfile.txt\", \"r\");\n\njulia> read(io, String)\n\"Hello world!\"\n\njulia> write(io, \"This file is read only\")\nERROR: ArgumentError: write failed, IOStream is not writeable\n[...]\n\njulia> close(io)\n\njulia> io = open(\"myfile.txt\", \"a\");\n\njulia> write(io, \"This stream is not read only\")\n28\n\njulia> close(io)\n\njulia> rm(\"myfile.txt\")\n\ncompat: Julia 1.5\nThe lock argument is available as of Julia 1.5.\n\n\n\n\n\nopen(filename::AbstractString; lock = true, keywords...)::IOStream\n\nOpen a file in a mode specified by five boolean keyword arguments:\n\nKeyword Description Default\nread open for reading !write\nwrite open for writing truncate | append\ncreate create if non-existent !read & write | truncate | append\ntruncate truncate to zero size !read & write\nappend seek to end false\n\nThe default when no keywords are passed is to open files for reading only.\nReturns a stream for accessing the opened file.\n\nThe lock keyword argument controls whether operations will be locked for\nsafe multi-threaded access.\n\ncompat: Julia 1.5\nThe lock argument is available as of Julia 1.5.\n\n\n\n\n\nopen(f::Function, args...; kwargs...)\n\nApply the function f to the result of open(args...; kwargs...) and close the resulting file\ndescriptor upon completion.\n\nExamples\n\njulia> write(\"myfile.txt\", \"Hello world!\");\n\njulia> open(io->read(io, String), \"myfile.txt\")\n\"Hello world!\"\n\njulia> rm(\"myfile.txt\")\n\n\n\n\n\n"},{"title":"Base.IOStream","page":"I/O and Network","location":"base/io-network.html#Base.IOStream","category":"type","text":"IOStream\n\nA buffered IO stream wrapping an OS file descriptor.\nMostly used to represent files returned by open.\n\n\n\n\n\n"},{"title":"Base.IOBuffer","page":"I/O and Network","location":"base/io-network.html#Base.IOBuffer","category":"type","text":"IOBuffer(string::String)\n\nCreate a read-only IOBuffer on the data underlying the given string.\n\nExamples\n\njulia> io = IOBuffer(\"Haho\");\n\njulia> takestring!(io)\n\"Haho\"\n\njulia> takestring!(io)\n\"Haho\"\n\n\n\n\n\nIOBuffer([data::AbstractVector{UInt8}]; keywords...)::IOBuffer\n\nCreate an in-memory I/O stream, which may optionally operate on a pre-existing array.\n\nIt may take optional keyword arguments:\n\nread, write, append: restricts operations to the buffer; see open for details.\ntruncate: truncates the buffer size to zero length.\nmaxsize: specifies a size beyond which the buffer may not be grown.\nsizehint: suggests a capacity of the buffer (data must implement sizehint!(data, size)).\n\nWhen data is not given, the buffer will be both readable and writable by default.\n\nwarning: Passing `data` as scratch space to `IOBuffer` with `write=true` may give unexpected behavior\nOnce write is called on an IOBuffer, it is best to consider any\nprevious references to data invalidated; in effect IOBuffer \"owns\"\nthis data until a call to take!. Any indirect mutations to data\ncould lead to undefined behavior by breaking the abstractions expected\nby IOBuffer. If write=true the IOBuffer may store data at any\noffset leaving behind arbitrary values at other offsets. If maxsize > length(data),\nthe IOBuffer might re-allocate the data entirely, which\nmay or may not be visible in any outstanding bindings to array.\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\", \" It has many members.\")\n56\n\njulia> takestring!(io)\n\"JuliaLang is a GitHub organization. It has many members.\"\n\njulia> io = IOBuffer(b\"JuliaLang is a GitHub organization.\")\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=35, maxsize=Inf, ptr=1, mark=-1)\n\njulia> read(io, String)\n\"JuliaLang is a GitHub organization.\"\n\njulia> write(io, \"This isn't writable.\")\nERROR: ArgumentError: ensureroom failed, IOBuffer is not writeable\n\njulia> io = IOBuffer(UInt8[], read=true, write=true, maxsize=34)\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=34, ptr=1, mark=-1)\n\njulia> write(io, \"JuliaLang is a GitHub organization.\")\n34\n\njulia> takestring!(io)\n\"JuliaLang is a GitHub organization\"\n\njulia> length(read(IOBuffer(b\"data\", read=true, truncate=false)))\n4\n\njulia> length(read(IOBuffer(b\"data\", read=true, truncate=true)))\n0\n\n\n\n\n\n"},{"title":"Base.take!","page":"I/O and Network","location":"base/io-network.html#Base.take!-Tuple{Base.GenericIOBuffer}","category":"method","text":"take!(b::IOBuffer)\n\nObtain the contents of an IOBuffer as an array. Afterwards, the IOBuffer is reset to its initial state.\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\", \" It has many members.\")\n56\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization. It has many members.\"\n\n\n\n\n\n"},{"title":"Base.takestring!","page":"I/O and Network","location":"base/io-network.html#Base.takestring!","category":"function","text":"takestring!(io::IOBuffer) -> String\n\nReturn the content of io as a String, resetting the buffer to its initial\nstate.\nThis is preferred over calling String(take!(io)) to create a string from\nan IOBuffer.\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> write(io, [0x61, 0x62, 0x63]);\n\njulia> s = takestring!(io)\n\"abc\"\n\njulia> isempty(take!(io)) # io is now empty\ntrue\n\ncompat: Julia 1.13\nThis function requires at least Julia 1.13.\n\n\n\n\n\ntakestring!(x) -> String\n\nCreate a string from the content of x, emptying x.\n\nExamples\n\njulia> v = [0x61, 0x62, 0x63];\n\njulia> s = takestring!(v)\n\"abc\"\n\njulia> isempty(v)\ntrue\n\n\n\n\n\n"},{"title":"Base.Pipe","page":"I/O and Network","location":"base/io-network.html#Base.Pipe","category":"type","text":"Pipe()\n\nConstruct an uninitialized Pipe object, especially for IO communication between multiple processes.\n\nThe appropriate end of the pipe will be automatically initialized if the object is used in\nprocess spawning. This can be useful to easily obtain references in process pipelines, e.g.:\n\njulia> err = Pipe()\n\n# After this `err` will be initialized and you may read `foo`'s\n# stderr from the `err` pipe, or pass `err` to other pipelines.\njulia> run(pipeline(pipeline(`foo`, stderr=err), `cat`), wait=false)\n\n# Now destroy the write half of the pipe, so that the read half will get EOF\njulia> closewrite(err)\n\njulia> read(err, String)\n\"stderr messages\"\n\nSee also Base.link_pipe!.\n\n\n\n\n\n"},{"title":"Base.link_pipe!","page":"I/O and Network","location":"base/io-network.html#Base.link_pipe!","category":"function","text":"link_pipe!(pipe; reader_supports_async=false, writer_supports_async=false)\n\nInitialize pipe and link the in endpoint to the out endpoint. The keyword\narguments reader_supports_async/writer_supports_async correspond to\nOVERLAPPED on Windows and O_NONBLOCK on POSIX systems. They should be true\nunless they'll be used by an external program (e.g. the output of a command\nexecuted with run).\n\n\n\n\n\n"},{"title":"Base.fdio","page":"I/O and Network","location":"base/io-network.html#Base.fdio","category":"function","text":"fdio([name::AbstractString, ]fd::Integer[, own::Bool=false])::IOStream\n\nCreate an IOStream object from an integer file descriptor. If own is true, closing\nthis object will close the underlying descriptor. By default, an IOStream is closed when\nit is garbage collected. name allows you to associate the descriptor with a named file.\n\n\n\n\n\n"},{"title":"Base.flush","page":"I/O and Network","location":"base/io-network.html#Base.flush","category":"function","text":"flush(io::IO)\n\nCommit all currently buffered writes to the given io.\nThis has a default implementation flush(::IO) = nothing, so may be called\nin generic IO code.\n\n\n\n\n\n"},{"title":"Base.close","page":"I/O and Network","location":"base/io-network.html#Base.close","category":"function","text":"close(io::IO)\n\nClose io. Performs a flush first.\n\nClosing an IO signals that its underlying resources (OS handle, network\nconnections, etc) should be destroyed.\nA closed IO is in an undefined state and should not be written to or read from.\nWhen attempting to do so, the IO may throw an exception, continue to behave\nnormally, or read/write zero bytes, depending on the implementation.\nHowever, implementations should make sure that reading to or writing from a\nclosed IO does not cause undefined behaviour.\n\nSee also: isopen\n\n\n\n\n\n"},{"title":"Base.closewrite","page":"I/O and Network","location":"base/io-network.html#Base.closewrite","category":"function","text":"closewrite(stream)\n\nShutdown the write half of a full-duplex I/O stream. Performs a flush\nfirst. Notify the other end that no more data will be written to the underlying\nfile. This is not supported by all IO types.\n\nIf implemented, closewrite causes subsequent read or eof calls that would\nblock to instead throw EOF or return true, respectively. If the stream is\nalready closed, this is idempotent.\n\nExamples\n\njulia> io = Base.BufferStream(); # this never blocks, so we can read and write on the same Task\n\njulia> write(io, \"request\");\n\njulia> # calling `read(io)` here would block forever\n\njulia> closewrite(io);\n\njulia> read(io, String)\n\"request\"\n\n\n\n\n\n"},{"title":"Base.write","page":"I/O and Network","location":"base/io-network.html#Base.write","category":"function","text":"write(io::IO, x)\n\nWrite the canonical binary representation of a value to the given I/O stream or file.\nReturn the number of bytes written into the stream. See also print to\nwrite a text representation (with an encoding that may depend upon io).\n\nThe endianness of the written value depends on the endianness of the host system.\nConvert to/from a fixed endianness when writing/reading (e.g. using  htol and\nltoh) to get results that are consistent across platforms.\n\nYou can write multiple values with the same write call, i.e. the following are equivalent:\n\nwrite(io, x, y...)\nwrite(io, x) + write(io, y...)\n\nExamples\n\nConsistent serialization:\n\njulia> fname = tempname(); # random temporary filename\n\njulia> open(fname,\"w\") do f\n           # Make sure we write 64bit integer in little-endian byte order\n           write(f,htol(Int64(42)))\n       end\n8\n\njulia> open(fname,\"r\") do f\n           # Convert back to host byte order and host integer type\n           Int(ltoh(read(f,Int64)))\n       end\n42\n\nMerging write calls:\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\", \" It has many members.\")\n56\n\njulia> takestring!(io)\n\"JuliaLang is a GitHub organization. It has many members.\"\n\njulia> write(io, \"Sometimes those members\") + write(io, \" write documentation.\")\n44\n\njulia> takestring!(io)\n\"Sometimes those members write documentation.\"\n\nUser-defined plain-data types without write methods can be written when wrapped in a Ref:\n\njulia> struct MyStruct; x::Float64; end\n\njulia> io = IOBuffer()\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=Inf, ptr=1, mark=-1)\n\njulia> write(io, Ref(MyStruct(42.0)))\n8\n\njulia> seekstart(io); read!(io, Ref(MyStruct(NaN)))\nBase.RefValue{MyStruct}(MyStruct(42.0))\n\n\n\n\n\n"},{"title":"Base.read","page":"I/O and Network","location":"base/io-network.html#Base.read","category":"function","text":"read(command::Cmd, String)\n\nRun command and return the resulting output as a String.\n\n\n\n\n\nread(command::Cmd)\n\nRun command and return the resulting output as an array of bytes.\n\n\n\n\n\nread(s::IOStream, nb::Integer; all=true)\n\nRead at most nb bytes from s, returning a Vector{UInt8} of the bytes read.\n\nIf all is true (the default), this function will block repeatedly trying to read all\nrequested bytes, until an error or end-of-file occurs. If all is false, at most one\nread call is performed, and the amount of data returned is device-dependent. Note that not\nall stream types support the all option.\n\n\n\n\n\nread(s::IO, nb=typemax(Int))\n\nRead at most nb bytes from s, returning a Vector{UInt8} of the bytes read.\n\n\n\n\n\nread(filename::AbstractString)\n\nRead the entire contents of a file as a Vector{UInt8}.\n\nread(filename::AbstractString, String)\n\nRead the entire contents of a file as a string.\n\nread(filename::AbstractString, args...)\n\nOpen a file and read its contents. args is passed to read: this is equivalent to\nopen(io->read(io, args...), filename).\n\n\n\n\n\nread(io::IO, T)\n\nRead a single value of type T from io, in canonical binary representation.\n\nNote that Julia does not convert the endianness for you. Use ntoh or\nltoh for this purpose.\n\nread(io::IO, String)\n\nRead the entirety of io, as a String (see also readchomp).\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> read(io, Char)\n'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> read(io, String)\n\"JuliaLang is a GitHub organization\"\n\n\n\n\n\n"},{"title":"Base.read!","page":"I/O and Network","location":"base/io-network.html#Base.read!","category":"function","text":"read!(stream::IO, array::AbstractArray)\nread!(filename::AbstractString, array::AbstractArray)\n\nRead binary data from an I/O stream or file, filling in array.\n\n\n\n\n\n"},{"title":"Base.readbytes!","page":"I/O and Network","location":"base/io-network.html#Base.readbytes!","category":"function","text":"readbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)\n\nRead at most nb bytes from stream into b, returning the number of bytes read.\nThe size of b will be increased if needed (i.e. if nb is greater than length(b)\nand enough bytes could be read), but it will never be decreased.\n\nIf all is true (the default), this function will block repeatedly trying to read all\nrequested bytes, until an error or end-of-file occurs. If all is false, at most one\nread call is performed, and the amount of data returned is device-dependent. Note that not\nall stream types support the all option.\n\n\n\n\n\nreadbytes!(stream::IO, b::AbstractVector{UInt8}, nb=length(b))\n\nRead at most nb bytes from stream into b, returning the number of bytes read.\nThe size of b will be increased if needed (i.e. if nb is greater than length(b)\nand enough bytes could be read), but it will never be decreased.\n\n\n\n\n\n"},{"title":"Base.unsafe_read","page":"I/O and Network","location":"base/io-network.html#Base.unsafe_read","category":"function","text":"unsafe_read(io::IO, ref, nbytes::UInt)\n\nCopy nbytes from the IO stream object into ref (converted to a pointer).\n\nIt is recommended that subtypes T<:IO override the following method signature\nto provide more efficient implementations:\nunsafe_read(s::T, p::Ptr{UInt8}, n::UInt)\n\n\n\n\n\n"},{"title":"Base.unsafe_write","page":"I/O and Network","location":"base/io-network.html#Base.unsafe_write","category":"function","text":"unsafe_write(io::IO, ref, nbytes::UInt)\n\nCopy nbytes from ref (converted to a pointer) into the IO object.\n\nIt is recommended that subtypes T<:IO override the following method signature\nto provide more efficient implementations:\nunsafe_write(s::T, p::Ptr{UInt8}, n::UInt)\n\n\n\n\n\n"},{"title":"Base.readeach","page":"I/O and Network","location":"base/io-network.html#Base.readeach","category":"function","text":"readeach(io::IO, T)\n\nReturn an iterable object yielding read(io, T).\n\nSee also skipchars, eachline, readuntil.\n\ncompat: Julia 1.6\nreadeach requires Julia 1.6 or later.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\\n It has many members.\\n\");\n\njulia> for c in readeach(io, Char)\n           c == '\\n' && break\n           print(c)\n       end\nJuliaLang is a GitHub organization.\n\n\n\n\n\n"},{"title":"Base.peek","page":"I/O and Network","location":"base/io-network.html#Base.peek","category":"function","text":"peek(stream[, T=UInt8])\n\nRead and return a value of type T from a stream without advancing the current position\nin the stream.   See also startswith(stream, char_or_string).\n\nExamples\n\njulia> b = IOBuffer(\"julia\");\n\njulia> peek(b)\n0x6a\n\njulia> position(b)\n0\n\njulia> peek(b, Char)\n'j': ASCII/Unicode U+006A (category Ll: Letter, lowercase)\n\ncompat: Julia 1.5\nThe method which accepts a type requires Julia 1.5 or later.\n\n\n\n\n\n"},{"title":"Base.position","page":"I/O and Network","location":"base/io-network.html#Base.position","category":"function","text":"position(l::Lexer)\n\nReturns the current position.\n\n\n\n\n\nposition(s)\n\nGet the current position of a stream.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> position(io)\n5\n\njulia> skip(io, 10);\n\njulia> position(io)\n15\n\njulia> seekend(io);\n\njulia> position(io)\n35\n\n\n\n\n\n"},{"title":"Base.seek","page":"I/O and Network","location":"base/io-network.html#Base.seek","category":"function","text":"seek(s, pos)\n\nSeek a stream to the given position.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> read(io, Char)\n'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)\n\n\n\n\n\n"},{"title":"Base.seekstart","page":"I/O and Network","location":"base/io-network.html#Base.seekstart","category":"function","text":"seekstart(s)\n\nSeek a stream to its beginning.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> read(io, Char)\n'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)\n\njulia> seekstart(io);\n\njulia> read(io, Char)\n'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)\n\n\n\n\n\n"},{"title":"Base.seekend","page":"I/O and Network","location":"base/io-network.html#Base.seekend","category":"function","text":"seekend(s)\n\nSeek a stream to its end.\n\n\n\n\n\n"},{"title":"Base.skip","page":"I/O and Network","location":"base/io-network.html#Base.skip","category":"function","text":"skip(s, offset)\n\nSeek a stream relative to the current position.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> skip(io, 10);\n\njulia> read(io, Char)\n'G': ASCII/Unicode U+0047 (category Lu: Letter, uppercase)\n\n\n\n\n\n"},{"title":"Base.mark","page":"I/O and Network","location":"base/io-network.html#Base.mark","category":"function","text":"mark(s::IO)\n\nAdd a mark at the current position of stream s. Return the marked position.\n\nSee also unmark, reset, ismarked.\n\n\n\n\n\n"},{"title":"Base.unmark","page":"I/O and Network","location":"base/io-network.html#Base.unmark","category":"function","text":"unmark(s::IO)\n\nRemove a mark from stream s. Return true if the stream was marked, false otherwise.\n\nSee also mark, reset, ismarked.\n\n\n\n\n\n"},{"title":"Base.reset","page":"I/O and Network","location":"base/io-network.html#Base.reset-Tuple{IO}","category":"method","text":"reset(s::IO)\n\nReset a stream s to a previously marked position, and remove the mark. Return the\npreviously marked position. Throw an error if the stream is not marked.\n\nSee also mark, unmark, ismarked.\n\n\n\n\n\n"},{"title":"Base.ismarked","page":"I/O and Network","location":"base/io-network.html#Base.ismarked","category":"function","text":"ismarked(s::IO)\n\nReturn true if stream s is marked.\n\nSee also mark, unmark, reset.\n\n\n\n\n\n"},{"title":"Base.eof","page":"I/O and Network","location":"base/io-network.html#Base.eof","category":"function","text":"eof(stream)::Bool\n\nTest whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this\nfunction will block to wait for more data if necessary, and then return false. Therefore\nit is always safe to read one byte after seeing eof return false. eof will return\nfalse as long as buffered data is still available, even if the remote end of a connection\nis closed.\n\nExamples\n\njulia> b = IOBuffer(\"my buffer\");\n\njulia> eof(b)\nfalse\n\njulia> seekend(b);\n\njulia> eof(b)\ntrue\n\n\n\n\n\n"},{"title":"Base.isreadonly","page":"I/O and Network","location":"base/io-network.html#Base.isreadonly","category":"function","text":"isreadonly(io)::Bool\n\nDetermine whether a stream is read-only.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> isreadonly(io)\ntrue\n\njulia> io = IOBuffer();\n\njulia> isreadonly(io)\nfalse\n\n\n\n\n\n"},{"title":"Base.iswritable","page":"I/O and Network","location":"base/io-network.html#Base.iswritable","category":"function","text":"iswritable(io)::Bool\n\nReturn false if the specified IO object is not writable.\n\nExamples\n\njulia> open(\"myfile.txt\", \"w\") do io\n           print(io, \"Hello world!\");\n           iswritable(io)\n       end\ntrue\n\njulia> open(\"myfile.txt\", \"r\") do io\n           iswritable(io)\n       end\nfalse\n\njulia> rm(\"myfile.txt\")\n\n\n\n\n\niswritable(path::String)\n\nReturn true if the access permissions for the given path permitted writing by the current user.\n\nnote: Note\nThis permission may change before the user calls open,\nso it is recommended to just call open alone and handle the error if that fails,\nrather than calling iswritable first.\n\nnote: Note\nCurrently this function does not correctly interrogate filesystem\nACLs on Windows, therefore it can return wrong results.\n\ncompat: Julia 1.11\nThis function requires at least Julia 1.11.\n\nSee also ispath, isexecutable, isreadable.\n\n\n\n\n\n"},{"title":"Base.isreadable","page":"I/O and Network","location":"base/io-network.html#Base.isreadable","category":"function","text":"isreadable(io)::Bool\n\nReturn false if the specified IO object is not readable.\n\nExamples\n\njulia> open(\"myfile.txt\", \"w\") do io\n           print(io, \"Hello world!\");\n           isreadable(io)\n       end\nfalse\n\njulia> open(\"myfile.txt\", \"r\") do io\n           isreadable(io)\n       end\ntrue\n\njulia> rm(\"myfile.txt\")\n\n\n\n\n\nisreadable(path::String)\n\nReturn true if the access permissions for the given path permitted reading by the current user.\n\nnote: Note\nThis permission may change before the user calls open,\nso it is recommended to just call open alone and handle the error if that fails,\nrather than calling isreadable first.\n\nnote: Note\nCurrently this function does not correctly interrogate filesystem\nACLs on Windows, therefore it can return wrong results.\n\ncompat: Julia 1.11\nThis function requires at least Julia 1.11.\n\nSee also ispath, isexecutable, iswritable.\n\n\n\n\n\n"},{"title":"Base.isexecutable","page":"I/O and Network","location":"base/io-network.html#Base.isexecutable","category":"function","text":"isexecutable(path::String)\n\nReturn true if the given path has executable permissions.\n\nnote: Note\nThis permission may change before the user executes path,\nso it is recommended to execute the file and handle the error if that fails,\nrather than calling isexecutable first.\n\nnote: Note\nPrior to Julia 1.6, this did not correctly interrogate filesystem\nACLs on Windows, therefore it would return true for any\nfile.  From Julia 1.6 on, it correctly determines whether the\nfile is marked as executable or not.\n\nSee also ispath, isreadable, iswritable.\n\n\n\n\n\n"},{"title":"Base.isopen","page":"I/O and Network","location":"base/io-network.html#Base.isopen","category":"function","text":"isopen(object)::Bool\n\nDetermine whether an object, such as an IO or timer, is still open and hence active.\n\nSee also: close\n\nExamples\n\njulia> io = open(\"my_file.txt\", \"w+\");\n\njulia> isopen(io)\ntrue\n\njulia> close(io)\n\njulia> isopen(io)\nfalse\n\n\n\n\n\n"},{"title":"Base.fd","page":"I/O and Network","location":"base/io-network.html#Base.fd","category":"function","text":"fd(x)::RawFD\n\nReturn the file descriptor backing the stream, file, or socket.\n\nRawFD objects can be passed directly to other languages via the ccall interface.\n\ncompat: Julia 1.12\nPrior to 1.12, this function returned an Int instead of a RawFD. You may use\nRawFD(fd(x)) to produce a RawFD in all Julia versions.\n\ncompat: Julia 1.12\nGetting the file descriptor of sockets are supported as of Julia 1.12.\n\nwarning: Warning\nDuplicate the returned file descriptor with Libc.dup() before\npassing it to another system that will take ownership of it (e.g. a C\nlibrary). Otherwise both the Julia object x and the other system may try\nto close the file descriptor, which will cause errors.\n\nwarning: Warning\nThe file descriptors for sockets are asynchronous (i.e. O_NONBLOCK on\nPOSIX and OVERLAPPED on Windows), they may behave differently than regular\nfile descriptors.\n\n\n\n\n\n"},{"title":"Base.redirect_stdio","page":"I/O and Network","location":"base/io-network.html#Base.redirect_stdio","category":"function","text":"redirect_stdio(f; stdin=nothing, stderr=nothing, stdout=nothing)\n\nRedirect a subset of the streams stdin, stderr, stdout,\ncall f() and restore each stream.\n\nPossible values for each stream are:\n\nnothing indicating the stream should not be redirected.\npath::AbstractString redirecting the stream to the file at path.\nio an IOStream, TTY, Pipe, socket, or devnull.\n\nExamples\n\njulia> redirect_stdio(stdout=\"stdout.txt\", stderr=\"stderr.txt\") do\n           print(\"hello stdout\")\n           print(stderr, \"hello stderr\")\n       end\n\njulia> read(\"stdout.txt\", String)\n\"hello stdout\"\n\njulia> read(\"stderr.txt\", String)\n\"hello stderr\"\n\nEdge cases\n\nIt is possible to pass the same argument to stdout and stderr:\n\njulia> redirect_stdio(stdout=\"log.txt\", stderr=\"log.txt\", stdin=devnull) do\n    ...\nend\n\nHowever it is not supported to pass two distinct descriptors of the same file.\n\njulia> io1 = open(\"same/path\", \"w\")\n\njulia> io2 = open(\"same/path\", \"w\")\n\njulia> redirect_stdio(f, stdout=io1, stderr=io2) # not supported\n\nAlso the stdin argument may not be the same descriptor as stdout or stderr.\n\njulia> io = open(...)\n\njulia> redirect_stdio(f, stdout=io, stdin=io) # not supported\n\ncompat: Julia 1.7\nredirect_stdio requires Julia 1.7 or later.\n\n\n\n\n\nredirect_stdio(;stdin=stdin, stderr=stderr, stdout=stdout)\n\nRedirect a subset of the streams stdin, stderr, stdout.\nEach argument must be an IOStream, TTY, Pipe, socket, or\ndevnull.\n\ncompat: Julia 1.7\nredirect_stdio requires Julia 1.7 or later.\n\n\n\n\n\n"},{"title":"Base.redirect_stdout","page":"I/O and Network","location":"base/io-network.html#Base.redirect_stdout","category":"function","text":"redirect_stdout([stream]) -> stream\n\nCreate a pipe to which all C and Julia level stdout output\nwill be redirected. Return a stream representing the pipe ends.\nData written to stdout may now be read from the rd end of\nthe pipe.\n\nnote: Note\nstream must be a compatible objects, such as an IOStream, TTY,\nPipe, socket, or devnull.\n\nSee also redirect_stdio.\n\n\n\n\n\n"},{"title":"Base.redirect_stdout","page":"I/O and Network","location":"base/io-network.html#Base.redirect_stdout-Tuple{Function, Any}","category":"method","text":"redirect_stdout(f::Function, stream)\n\nRun the function f while redirecting stdout to stream.\nUpon completion, stdout is restored to its prior setting.\n\n\n\n\n\n"},{"title":"Base.redirect_stderr","page":"I/O and Network","location":"base/io-network.html#Base.redirect_stderr","category":"function","text":"redirect_stderr([stream]) -> stream\n\nLike redirect_stdout, but for stderr.\n\nnote: Note\nstream must be a compatible objects, such as an IOStream, TTY,\nPipe, socket, or devnull.\n\nSee also redirect_stdio.\n\n\n\n\n\n"},{"title":"Base.redirect_stderr","page":"I/O and Network","location":"base/io-network.html#Base.redirect_stderr-Tuple{Function, Any}","category":"method","text":"redirect_stderr(f::Function, stream)\n\nRun the function f while redirecting stderr to stream.\nUpon completion, stderr is restored to its prior setting.\n\n\n\n\n\n"},{"title":"Base.redirect_stdin","page":"I/O and Network","location":"base/io-network.html#Base.redirect_stdin","category":"function","text":"redirect_stdin([stream]) -> stream\n\nLike redirect_stdout, but for stdin.\nNote that the direction of the stream is reversed.\n\nnote: Note\nstream must be a compatible objects, such as an IOStream, TTY,\nPipe, socket, or devnull.\n\nSee also redirect_stdio.\n\n\n\n\n\n"},{"title":"Base.redirect_stdin","page":"I/O and Network","location":"base/io-network.html#Base.redirect_stdin-Tuple{Function, Any}","category":"method","text":"redirect_stdin(f::Function, stream)\n\nRun the function f while redirecting stdin to stream.\nUpon completion, stdin is restored to its prior setting.\n\n\n\n\n\n"},{"title":"Base.readchomp","page":"I/O and Network","location":"base/io-network.html#Base.readchomp","category":"function","text":"readchomp(x)\n\nRead the entirety of x as a string and remove a single trailing newline\nif there is one. Equivalent to chomp(read(x, String)).\n\nExamples\n\njulia> write(\"my_file.txt\", \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n\njulia> readchomp(\"my_file.txt\")\n\"JuliaLang is a GitHub organization.\\nIt has many members.\"\n\njulia> rm(\"my_file.txt\");\n\n\n\n\n\n"},{"title":"Base.truncate","page":"I/O and Network","location":"base/io-network.html#Base.truncate","category":"function","text":"truncate(file, n)\n\nResize the file or buffer given by the first argument to exactly n bytes, filling\npreviously unallocated space with '\\0' if the file or buffer is grown.\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\")\n35\n\njulia> truncate(io, 15)\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=15, maxsize=Inf, ptr=16, mark=-1)\n\njulia> takestring!(io)\n\"JuliaLang is a \"\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\");\n\njulia> truncate(io, 40);\n\njulia> takestring!(io)\n\"JuliaLang is a GitHub organization.\\0\\0\\0\\0\\0\"\n\n\n\n\n\n"},{"title":"Base.skipchars","page":"I/O and Network","location":"base/io-network.html#Base.skipchars","category":"function","text":"skipchars(predicate, io::IO; linecomment=nothing)\n\nAdvance the stream io such that the next-read character will be the first remaining for\nwhich predicate returns false. If the keyword argument linecomment is specified, all\ncharacters from that character until the start of the next line are ignored.\n\nExamples\n\njulia> buf = IOBuffer(\"    text\")\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=1, mark=-1)\n\njulia> skipchars(isspace, buf)\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=5, mark=-1)\n\njulia> String(readavailable(buf))\n\"text\"\n\n\n\n\n\n"},{"title":"Base.countlines","page":"I/O and Network","location":"base/io-network.html#Base.countlines","category":"function","text":"countlines(io::IO; eol::AbstractChar = '\\n')\ncountlines(filename::AbstractString; eol::AbstractChar = '\\n')\n\nRead io until the end of the stream/file and count the number of lines. To specify a file\npass the filename as the first argument. EOL markers other than '\\n' are supported by\npassing them as the second argument.  The last non-empty line of io is counted even if it does not\nend with the EOL, matching the length returned by eachline and readlines.\n\nTo count lines of a String, countlines(IOBuffer(str)) can be used.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\\n\");\n\njulia> countlines(io)\n1\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> countlines(io)\n1\n\njulia> eof(io) # counting lines moves the file pointer\ntrue\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> countlines(io, eol = '.')\n1\n\njulia> write(\"my_file.txt\", \"JuliaLang is a GitHub organization.\\n\")\n36\n\njulia> countlines(\"my_file.txt\")\n1\n\njulia> countlines(\"my_file.txt\", eol = 'n')\n4\n\njulia> rm(\"my_file.txt\")\n\n\n\n\n\n\n"},{"title":"Base.PipeBuffer","page":"I/O and Network","location":"base/io-network.html#Base.PipeBuffer","category":"function","text":"PipeBuffer(data::AbstractVector{UInt8}=UInt8[]; maxsize::Integer = typemax(Int))\n\nAn IOBuffer that allows reading and performs writes by appending.\nSeeking and truncating are not supported.\nSee IOBuffer for the available constructors.\nIf data is given, creates a PipeBuffer to operate on a data vector,\noptionally specifying a size beyond which the underlying Array may not be grown.\n\n\n\n\n\n"},{"title":"Base.readavailable","page":"I/O and Network","location":"base/io-network.html#Base.readavailable","category":"function","text":"readavailable(stream)\n\nRead available buffered data from a stream. Actual I/O is performed only if no\ndata has already been buffered. The result is a Vector{UInt8}.\n\nwarning: Warning\nThe amount of data returned is implementation-dependent; for example it can\ndepend on the internal choice of buffer size. Other functions such as read\nshould generally be used instead.\n\n\n\n\n\n"},{"title":"Base.IOContext","page":"I/O and Network","location":"base/io-network.html#Base.IOContext","category":"type","text":"IOContext\n\nIOContext provides a mechanism for passing output configuration settings among show methods.\n\nIn short, it is an immutable dictionary that is a subclass of IO. It supports standard\ndictionary operations such as getindex, and can also be used as an I/O stream.\n\n\n\n\n\n"},{"title":"Base.IOContext","page":"I/O and Network","location":"base/io-network.html#Base.IOContext-Tuple{IO, Pair}","category":"method","text":"IOContext(io::IO, KV::Pair...)\n\nCreate an IOContext that wraps a given stream, adding the specified key=>value pairs to\nthe properties of that stream (note that io can itself be an IOContext).\n\nuse (key => value) in io to see if this particular combination is in the properties set\nuse get(io, key, default) to retrieve the most recent value for a particular key\n\nThe following properties are in common use:\n\n:compact: Boolean specifying that values should be printed more compactly, e.g.\nthat numbers should be printed with fewer digits. This is set when printing array\nelements. :compact output should not contain line breaks.\n:limit: Boolean specifying that containers should be truncated, e.g. showing … in\nplace of most elements.\n:displaysize: A Tuple{Int,Int} giving the size in rows and columns to use for text\noutput. This can be used to override the display size for called functions, but to\nget the size of the screen use the displaysize function.\n:typeinfo: a Type characterizing the information already printed\nconcerning the type of the object about to be displayed. This is mainly useful when\ndisplaying a collection of objects of the same type, so that redundant type information\ncan be avoided (e.g. [Float16(0)] can be shown as \"Float16[0.0]\" instead\nof \"Float16[Float16(0.0)]\" : while displaying the elements of the array, the :typeinfo\nproperty will be set to Float16).\n:color: Boolean specifying whether ANSI color/escape codes are supported/expected.\nBy default, this is determined by whether io is a compatible terminal and by any\n--color command-line flag when julia was launched.\n:hexunsigned: Boolean specifying whether to print unsigned integers in\nhexadecimal. Defaults to true, otherwise they will be printed in decimal.\n\ncompat: Julia 1.14\nThe :hexunsigned option requires Julia 1.14 or later.\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> printstyled(IOContext(io, :color => true), \"string\", color=:red)\n\njulia> takestring!(io)\n\"\\e[31mstring\\e[39m\"\n\njulia> printstyled(io, \"string\", color=:red)\n\njulia> takestring!(io)\n\"string\"\n\njulia> print(IOContext(stdout, :compact => false), 1.12341234)\n1.12341234\njulia> print(IOContext(stdout, :compact => true), 1.12341234)\n1.12341\n\njulia> function f(io::IO)\n           if get(io, :short, false)\n               print(io, \"short\")\n           else\n               print(io, \"loooooong\")\n           end\n       end\nf (generic function with 1 method)\n\njulia> f(stdout)\nloooooong\njulia> f(IOContext(stdout, :short => true))\nshort\n\n\n\n\n\n"},{"title":"Base.IOContext","page":"I/O and Network","location":"base/io-network.html#Base.IOContext-Tuple{IO, IOContext}","category":"method","text":"IOContext(io::IO, context::IOContext)\n\nCreate an IOContext that wraps an alternate IO but inherits the properties of context.\n\nnote: Note\nUnless explicitly set in the wrapped io the displaysize of io will not be inherited.\nThis is because by default displaysize is not a property of IO objects themselves, but lazily inferred,\nas the size of the terminal window can change during the lifetime of the IO object.\n\n\n\n\n\n"},{"title":"Base.show","page":"I/O and Network","location":"base/io-network.html#Base.show-Tuple{IO, Any}","category":"method","text":"show([io::IO = stdout], x)\n\nWrite a text representation of a value x to the output stream io. New types T\nshould overload show(io::IO, x::T). The representation used by show generally\nincludes Julia-specific formatting and type information, and should be parseable\nJulia code when possible.\n\nrepr returns the output of show as a string.\n\nFor a more verbose human-readable text output for objects of type T, define\nshow(io::IO, ::MIME\"text/plain\", ::T) in addition. Checking the :compact\nIOContext key (often checked as get(io, :compact, false)::Bool)\nof io in such methods is recommended,\nsince some containers show their elements by calling this method with\n:compact => true.\n\nSee also print, which writes un-decorated representations.\n\nExamples\n\njulia> show(\"Hello World!\")\n\"Hello World!\"\njulia> print(\"Hello World!\")\nHello World!\n\n\n\n\n\n"},{"title":"Base.summary","page":"I/O and Network","location":"base/io-network.html#Base.summary","category":"function","text":"summary(io::IO, x)\nstr = summary(x)\n\nPrint to a stream io, or return a string str, giving a brief description of\na value. By default returns string(typeof(x)), e.g. Int64.\n\nFor arrays, returns a string of size and type info,\ne.g. 10-element Vector{Int64} or 9×4×5 Array{Float64, 3}.\n\nExamples\n\njulia> summary(1)\n\"Int64\"\n\njulia> summary(zeros(2))\n\"2-element Vector{Float64}\"\n\n\n\n\n\n"},{"title":"Base.print","page":"I/O and Network","location":"base/io-network.html#Base.print","category":"function","text":"print([io::IO], xs...)\n\nWrite to io (or to the default output stream stdout\nif io is not given) a canonical (un-decorated) text representation.\nThe representation used by print includes minimal formatting and tries to\navoid Julia-specific details.\n\nprint falls back to calling the 2-argument show(io, x) for each argument x in xs,\nso most types should just define show. Define print if your type has a separate\n\"plain\" representation.  For example, show displays strings with quotes, and print\ndisplays strings without quotes.\n\nSee also println, string, printstyled.\n\nExamples\n\njulia> print(\"Hello World!\")\nHello World!\njulia> io = IOBuffer();\n\njulia> print(io, \"Hello\", ' ', :World!)\n\njulia> takestring!(io)\n\"Hello World!\"\n\n\n\n\n\n"},{"title":"Base.println","page":"I/O and Network","location":"base/io-network.html#Base.println","category":"function","text":"println([io::IO], xs...)\n\nPrint (using print) xs to io followed by a newline.\nIf io is not supplied, prints to the default output stream stdout.\n\nSee also printstyled to add colors etc.\n\nExamples\n\njulia> println(\"Hello, world\")\nHello, world\n\njulia> io = IOBuffer();\n\njulia> println(io, \"Hello\", ',', \" world.\")\n\njulia> takestring!(io)\n\"Hello, world.\\n\"\n\n\n\n\n\n"},{"title":"Base.printstyled","page":"I/O and Network","location":"base/io-network.html#Base.printstyled","category":"function","text":"printstyled([io], xs...; bold::Bool=false, italic::Bool=false, underline::Bool=false, blink::Bool=false, reverse::Bool=false, hidden::Bool=false, color::Union{Symbol,Int}=:normal)\n\nPrint xs in a color specified as a symbol or integer, optionally in bold.\n\nKeyword color may take any of the values :normal,\n:italic,\n:default,\n:bold,\n:black,\n:blink,\n:blue,\n:cyan,\n:green,\n:hidden,\n:light_black,\n:light_blue,\n:light_cyan,\n:light_green,\n:light_magenta,\n:light_red,\n:light_white,\n:light_yellow,\n:magenta,\n:nothing,\n:red,\n:reverse,\n:underline,\n:white, or \n:yellow\nor an integer between 0 and 255 inclusive. Note that not all terminals support 256 colors.\n\nKeywords bold=true, italic=true, underline=true, blink=true are self-explanatory.\nKeyword reverse=true prints with foreground and background colors exchanged,\nand hidden=true should be invisible in the terminal but can still be copied.\nThese properties can be used in any combination.\n\nSee also print, println, show.\n\nnote: Note\nNot all terminals support italic output. Some terminals interpret italic as reverse or\nblink.\n\ncompat: Julia 1.7\nKeywords except color and bold were added in Julia 1.7.\n\ncompat: Julia 1.10\nSupport for italic output was added in Julia 1.10.\n\n\n\n\n\n"},{"title":"Base.sprint","page":"I/O and Network","location":"base/io-network.html#Base.sprint","category":"function","text":"sprint(f::Function, args...; context=nothing, sizehint=0)\n\nCall the given function with an I/O stream and the supplied extra arguments.\nEverything written to this I/O stream is returned as a string.\n\nThe optional keyword argument context can be set to a :key=>value pair, a\ntuple of :key=>value pairs, or an IO or IOContext object whose\nattributes are used for the I/O stream passed to f.  The optional sizehint\nis a suggested size (in bytes) to allocate for the buffer used to write the\nstring.\n\ncompat: Julia 1.7\nPassing a tuple to keyword context requires Julia 1.7 or later.\n\nExamples\n\njulia> sprint(show, 66.66666; context=:compact => true)\n\"66.6667\"\n\njulia> sprint(showerror, BoundsError([1], 100))\n\"BoundsError: attempt to access 1-element Vector{Int64} at index [100]\"\n\n\n\n\n\n"},{"title":"Base.showerror","page":"I/O and Network","location":"base/io-network.html#Base.showerror","category":"function","text":"showerror(io, e)\n\nShow a descriptive representation of an exception object e.\nThis method is used to display the exception after a call to throw.\n\nExamples\n\njulia> struct MyException <: Exception\n           msg::String\n       end\n\njulia> function Base.showerror(io::IO, err::MyException)\n           print(io, \"MyException: \")\n           print(io, err.msg)\n       end\n\njulia> err = MyException(\"test exception\")\nMyException(\"test exception\")\n\njulia> sprint(showerror, err)\n\"MyException: test exception\"\n\njulia> throw(MyException(\"test exception\"))\nERROR: MyException: test exception\n\n\n\n\n\n"},{"title":"Base.dump","page":"I/O and Network","location":"base/io-network.html#Base.dump","category":"function","text":"dump(x; maxdepth=8)\n\nShow every part of the representation of a value.\nThe depth of the output is truncated at maxdepth.\n\nExamples\n\njulia> struct MyStruct\n           x\n           y\n       end\n\njulia> x = MyStruct(1, (2,3));\n\njulia> dump(x)\nMyStruct\n  x: Int64 1\n  y: Tuple{Int64, Int64}\n    1: Int64 2\n    2: Int64 3\n\njulia> dump(x; maxdepth = 1)\nMyStruct\n  x: Int64 1\n  y: Tuple{Int64, Int64}\n\n\n\n\n\n"},{"title":"Base.Meta.@dump","page":"I/O and Network","location":"base/io-network.html#Base.Meta.@dump","category":"macro","text":"@dump expr\n\nShow every part of the representation of the given expression. Equivalent to\ndump(:(expr)).\n\n\n\n\n\n"},{"title":"Base.readline","page":"I/O and Network","location":"base/io-network.html#Base.readline","category":"function","text":"readline(io::IO=stdin; keep::Bool=false)\nreadline(filename::AbstractString; keep::Bool=false)\n\nRead a single line of text from the given I/O stream or file (defaults to stdin).\nWhen reading from a file, the text is assumed to be encoded in UTF-8. Lines in the\ninput end with '\\n' or \"\\r\\n\" or the end of an input stream. When keep is\nfalse (as it is by default), these trailing newline characters are removed from the\nline before it is returned. When keep is true, they are returned as part of the\nline.\n\nReturn a String.   See also copyline to instead write in-place\nto another stream (which can be a preallocated IOBuffer).\n\nSee also readuntil for reading until more general delimiters.\n\nExamples\n\njulia> write(\"my_file.txt\", \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n\njulia> readline(\"my_file.txt\")\n\"JuliaLang is a GitHub organization.\"\n\njulia> readline(\"my_file.txt\", keep=true)\n\"JuliaLang is a GitHub organization.\\n\"\n\njulia> rm(\"my_file.txt\")\n\njulia> print(\"Enter your name: \")\nEnter your name:\n\njulia> your_name = readline()\nLogan\n\"Logan\"\n\n\n\n\n\n"},{"title":"Base.readuntil","page":"I/O and Network","location":"base/io-network.html#Base.readuntil","category":"function","text":"readuntil(stream::IO, delim; keep::Bool = false)\nreaduntil(filename::AbstractString, delim; keep::Bool = false)\n\nRead a string from an I/O stream or a file, up to the given delimiter.\nThe delimiter can be a UInt8, AbstractChar, string, or vector.\nKeyword argument keep controls whether the delimiter is included in the result.\nThe text is assumed to be encoded in UTF-8.\n\nReturn a String if delim is an AbstractChar or a string\nor otherwise return a Vector{typeof(delim)}.   See also copyuntil\nto instead write in-place to another stream (which can be a preallocated IOBuffer).\n\nExamples\n\njulia> write(\"my_file.txt\", \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n\njulia> readuntil(\"my_file.txt\", 'L')\n\"Julia\"\n\njulia> readuntil(\"my_file.txt\", '.', keep = true)\n\"JuliaLang is a GitHub organization.\"\n\njulia> rm(\"my_file.txt\")\n\n\n\n\n\n"},{"title":"Base.readlines","page":"I/O and Network","location":"base/io-network.html#Base.readlines","category":"function","text":"readlines(io::IO=stdin; keep::Bool=false)\nreadlines(filename::AbstractString; keep::Bool=false)\n\nRead all lines of an I/O stream or a file as a vector of strings. Behavior is\nequivalent to saving the result of reading readline repeatedly with the same\narguments and saving the resulting lines as a vector of strings.  See also\neachline to iterate over the lines without reading them all at once.\n\nExamples\n\njulia> write(\"my_file.txt\", \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n\njulia> readlines(\"my_file.txt\")\n2-element Vector{String}:\n \"JuliaLang is a GitHub organization.\"\n \"It has many members.\"\n\njulia> readlines(\"my_file.txt\", keep=true)\n2-element Vector{String}:\n \"JuliaLang is a GitHub organization.\\n\"\n \"It has many members.\\n\"\n\njulia> rm(\"my_file.txt\")\n\n\n\n\n\n"},{"title":"Base.eachline","page":"I/O and Network","location":"base/io-network.html#Base.eachline","category":"function","text":"eachline(io::IO=stdin; keep::Bool=false)\neachline(filename::AbstractString; keep::Bool=false)\n\nCreate an iterable EachLine object that will yield each line from an I/O stream\nor a file. Iteration calls readline on the stream argument repeatedly with\nkeep passed through, determining whether trailing end-of-line characters are\nretained. When called with a file name, the file is opened once at the beginning of\niteration and closed at the end. If iteration is interrupted, the file will be\nclosed when the EachLine object is garbage collected.\n\nTo iterate over each line of a String, eachline(IOBuffer(str)) can be used.\n\nIterators.reverse can be used on an EachLine object to read the lines\nin reverse order (for files, buffers, and other I/O streams supporting seek),\nand first or last can be used to extract the initial or final\nlines, respectively.\n\nExamples\n\njulia> write(\"my_file.txt\", \"JuliaLang is a GitHub organization.\\n It has many members.\\n\");\n\njulia> for line in eachline(\"my_file.txt\")\n           print(line)\n       end\nJuliaLang is a GitHub organization. It has many members.\n\njulia> rm(\"my_file.txt\");\n\ncompat: Julia 1.8\nJulia 1.8 is required to use Iterators.reverse or last with eachline iterators.\n\n\n\n\n\n"},{"title":"Base.copyline","page":"I/O and Network","location":"base/io-network.html#Base.copyline","category":"function","text":"copyline(out::IO, io::IO=stdin; keep::Bool=false)\ncopyline(out::IO, filename::AbstractString; keep::Bool=false)\n\nCopy a single line of text from an I/O stream or a file to the out stream,\nreturning out.\n\nWhen reading from a file, the text is assumed to be encoded in UTF-8. Lines in the\ninput end with '\\n' or \"\\r\\n\" or the end of an input stream. When keep is\nfalse (as it is by default), these trailing newline characters are removed from the\nline before it is returned. When keep is true, they are returned as part of the\nline.\n\nSimilar to readline, which returns a String; in contrast,\ncopyline writes directly to out, without allocating a string.\n(This can be used, for example, to read data into a pre-allocated IOBuffer.)\n\nSee also copyuntil for reading until more general delimiters.\n\nExamples\n\njulia> write(\"my_file.txt\", \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n\njulia> takestring!(copyline(IOBuffer(), \"my_file.txt\"))\n\"JuliaLang is a GitHub organization.\"\n\njulia> takestring!(copyline(IOBuffer(), \"my_file.txt\", keep=true))\n\"JuliaLang is a GitHub organization.\\n\"\n\njulia> rm(\"my_file.txt\")\n\n\n\n\n\n"},{"title":"Base.copyuntil","page":"I/O and Network","location":"base/io-network.html#Base.copyuntil","category":"function","text":"copyuntil(out::IO, stream::IO, delim; keep::Bool = false)\ncopyuntil(out::IO, filename::AbstractString, delim; keep::Bool = false)\n\nCopy a string from an I/O stream or a file, up to the given delimiter, to\nthe out stream, returning out.\nThe delimiter can be a UInt8, AbstractChar, string, or vector.\nKeyword argument keep controls whether the delimiter is included in the result.\nThe text is assumed to be encoded in UTF-8.\n\nSimilar to readuntil, which returns a String; in contrast,\ncopyuntil writes directly to out, without allocating a string.\n(This can be used, for example, to read data into a pre-allocated IOBuffer.)\n\nExamples\n\njulia> write(\"my_file.txt\", \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n\njulia> takestring!(copyuntil(IOBuffer(), \"my_file.txt\", 'L'))\n\"Julia\"\n\njulia> takestring!(copyuntil(IOBuffer(), \"my_file.txt\", '.', keep = true))\n\"JuliaLang is a GitHub organization.\"\n\njulia> rm(\"my_file.txt\")\n\n\n\n\n\n"},{"title":"Base.displaysize","page":"I/O and Network","location":"base/io-network.html#Base.displaysize","category":"function","text":"displaysize([io::IO]) -> (lines, columns)\n\nReturn the nominal size of the screen that may be used for rendering output to\nthis IO object.\nIf no input is provided, the environment variables LINES and COLUMNS are read.\nIf those are not set, a default size of (24, 80) is returned.\n\nExamples\n\njulia> withenv(\"LINES\" => 30, \"COLUMNS\" => 100) do\n           displaysize()\n       end\n(30, 100)\n\nTo get your TTY size,\n\njulia> displaysize(stdout)\n(34, 147)\n\n\n\n\n\n"},{"title":"Base.Multimedia.AbstractDisplay","page":"I/O and Network","location":"base/io-network.html#Base.Multimedia.AbstractDisplay","category":"type","text":"AbstractDisplay\n\nAbstract supertype for rich display output devices. TextDisplay is a subtype\nof this.\n\n\n\n\n\n"},{"title":"Base.Multimedia.display","page":"I/O and Network","location":"base/io-network.html#Base.Multimedia.display","category":"function","text":"display(x)\ndisplay(d::AbstractDisplay, x)\ndisplay(mime, x)\ndisplay(d::AbstractDisplay, mime, x)\n\nDisplay x using the topmost applicable display in the display stack, typically using the\nrichest supported multimedia output for x, with plain-text stdout output as a fallback.\nThe display(d, x) variant attempts to display x on the given display d only, throwing\na MethodError if d cannot display objects of this type.\n\nIn general, you cannot assume that display output goes to stdout (unlike print(x) or\nshow(x)).  For example, display(x) may open up a separate window with an image.\ndisplay(x) means \"show x in the best way you can for the current output device(s).\"\nIf you want REPL-like text output that is guaranteed to go to stdout, use\nshow(stdout, \"text/plain\", x) instead.\n\nThere are also two variants with a mime argument (a MIME type string, such as\n\"image/png\"), which attempt to display x using the requested MIME type only, throwing\na MethodError if this type is not supported by either the display(s) or by x. With these\nvariants, one can also supply the \"raw\" data in the requested MIME type by passing\nx::AbstractString (for MIME types with text-based storage, such as text/html or\napplication/postscript) or x::Vector{UInt8} (for binary MIME types).\n\nTo customize how instances of a type are displayed, overload show rather than display,\nas explained in the manual section on custom pretty-printing.\n\n\n\n\n\n"},{"title":"Base.Multimedia.redisplay","page":"I/O and Network","location":"base/io-network.html#Base.Multimedia.redisplay","category":"function","text":"redisplay(x)\nredisplay(d::AbstractDisplay, x)\nredisplay(mime, x)\nredisplay(d::AbstractDisplay, mime, x)\n\nBy default, the redisplay functions simply call display.\nHowever, some display backends may override redisplay to modify an existing\ndisplay of x (if any).\nUsing redisplay is also a hint to the backend that x may be redisplayed\nseveral times, and the backend may choose to defer the display until\n(for example) the next interactive prompt.\n\n\n\n\n\n"},{"title":"Base.Multimedia.displayable","page":"I/O and Network","location":"base/io-network.html#Base.Multimedia.displayable","category":"function","text":"displayable(mime)::Bool\ndisplayable(d::AbstractDisplay, mime)::Bool\n\nReturn a boolean value indicating whether the given mime type (string) is displayable by\nany of the displays in the current display stack, or specifically by the display d in the\nsecond variant.\n\n\n\n\n\n"},{"title":"Base.show","page":"I/O and Network","location":"base/io-network.html#Base.show-Tuple{IO, Any, Any}","category":"method","text":"show(io::IO, mime, x)\n\nThe display functions ultimately call show in order to write an object x as a\ngiven mime type to a given I/O stream io (usually a memory buffer), if possible. In order\nto provide a rich multimedia representation of a user-defined type T, it is only necessary\nto define a new show method for T, via: show(io, ::MIME\"mime\", x::T) = ...,\nwhere mime is a MIME-type string and the function body calls write (or similar) to write\nthat representation of x to io. (Note that the MIME\"\" notation only supports\nliteral strings; to construct MIME types in a more flexible manner use\nMIME{Symbol(\"\")}.)\n\nFor example, if you define a MyImage type and know how to write it to a PNG file, you\ncould define a function show(io, ::MIME\"image/png\", x::MyImage) = ... to allow\nyour images to be displayed on any PNG-capable AbstractDisplay (such as IJulia). As usual, be sure\nto import Base.show in order to add new methods to the built-in Julia function\nshow.\n\nTechnically, the MIME\"mime\" macro defines a singleton type for the given mime string,\nwhich allows us to exploit Julia's dispatch mechanisms in determining how to display objects\nof any given type.\n\nThe default MIME type is MIME\"text/plain\". There is a fallback definition for text/plain\noutput that calls show with 2 arguments, so it is not always necessary to add a method\nfor that case. If a type benefits from custom human-readable output though,\nshow(::IO, ::MIME\"text/plain\", ::T) should be defined. For example, the Day type uses\n1 day as the output for the text/plain MIME type, and Day(1) as the output of 2-argument show.\n\nExamples\n\njulia> struct Day\n           n::Int\n       end\n\njulia> Base.show(io::IO, ::MIME\"text/plain\", d::Day) = print(io, d.n, \" day\")\n\njulia> Day(1)\n1 day\n\nContainer types generally implement 3-argument show by calling show(io, MIME\"text/plain\"(), x)\nfor elements x, with :compact => true set in an IOContext passed as the first argument.\n\n\n\n\n\n"},{"title":"Base.Multimedia.showable","page":"I/O and Network","location":"base/io-network.html#Base.Multimedia.showable","category":"function","text":"showable(mime, x)\n\nReturn a boolean value indicating whether or not the object x can be written\nas the given mime type.\n\n(By default, this is determined automatically by the existence of the\ncorresponding show method for typeof(x).  Some types provide custom showable\nmethods; for example, if the available MIME formats depend on the value of x.)\n\nExamples\n\njulia> showable(MIME(\"text/plain\"), rand(5))\ntrue\n\njulia> showable(\"image/png\", rand(5))\nfalse\n\n\n\n\n\n"},{"title":"Base.repr","page":"I/O and Network","location":"base/io-network.html#Base.repr-Tuple{MIME, Any}","category":"method","text":"repr(mime, x; context=nothing)\n\nReturn an AbstractString or Vector{UInt8} containing the representation of\nx in the requested mime type, as written by show(io, mime, x) (throwing a\nMethodError if no appropriate show is available). An AbstractString is\nreturned for MIME types with textual representations (such as \"text/html\" or\n\"application/postscript\"), whereas binary data is returned as\nVector{UInt8}. (The function istextmime(mime) returns whether or not Julia\ntreats a given mime type as text.)\n\nThe optional keyword argument context can be set to :key=>value pair\nor an IO or IOContext object whose attributes are used for the I/O\nstream passed to show.\n\nAs a special case, if x is an AbstractString (for textual MIME types) or a\nVector{UInt8} (for binary MIME types), the repr function assumes that\nx is already in the requested mime format and simply returns x. This\nspecial case does not apply to the \"text/plain\" MIME type. This is useful so\nthat raw data can be passed to display(m::MIME, x).\n\nIn particular, repr(\"text/plain\", x) is typically a \"pretty-printed\" version\nof x designed for human consumption.  See also repr(x) to instead\nreturn a string corresponding to show(x) that may be closer to how\nthe value of x would be entered in Julia.\n\nExamples\n\njulia> A = [1 2; 3 4];\n\njulia> repr(\"text/plain\", A)\n\"2×2 Matrix{Int64}:\\n 1  2\\n 3  4\"\n\n\n\n\n\n"},{"title":"Base.Multimedia.MIME","page":"I/O and Network","location":"base/io-network.html#Base.Multimedia.MIME","category":"type","text":"MIME\n\nA type representing a standard internet data format. \"MIME\" stands for\n\"Multipurpose Internet Mail Extensions\", since the standard was originally\nused to describe multimedia attachments to email messages.\n\nA MIME object can be passed as the second argument to show to\nrequest output in that format.\n\nExamples\n\njulia> show(stdout, MIME(\"text/plain\"), \"hi\")\n\"hi\"\n\n\n\n\n\n"},{"title":"Base.Multimedia.@MIME_str","page":"I/O and Network","location":"base/io-network.html#Base.Multimedia.@MIME_str","category":"macro","text":"@MIME_str\n\nA convenience macro for writing MIME types, typically used when\nadding methods to show.\nFor example the syntax show(io::IO, ::MIME\"text/html\", x::MyType) = ...\ncould be used to define how to write an HTML representation of MyType.\n\n\n\n\n\n"},{"title":"Base.Multimedia.pushdisplay","page":"I/O and Network","location":"base/io-network.html#Base.Multimedia.pushdisplay","category":"function","text":"pushdisplay(d::AbstractDisplay)\n\nPushes a new display d on top of the global display-backend stack. Calling display(x) or\ndisplay(mime, x) will display x on the topmost compatible backend in the stack (i.e.,\nthe topmost backend that does not throw a MethodError).\n\n\n\n\n\n"},{"title":"Base.Multimedia.popdisplay","page":"I/O and Network","location":"base/io-network.html#Base.Multimedia.popdisplay","category":"function","text":"popdisplay()\npopdisplay(d::AbstractDisplay)\n\nPop the topmost backend off of the display-backend stack, or the topmost copy of d in the\nsecond variant.\n\n\n\n\n\n"},{"title":"Base.Multimedia.TextDisplay","page":"I/O and Network","location":"base/io-network.html#Base.Multimedia.TextDisplay","category":"type","text":"TextDisplay(io::IO)\n\nReturn a TextDisplay <: AbstractDisplay, which displays any object as the text/plain MIME type\n(by default), writing the text representation to the given I/O stream. (This is how\nobjects are printed in the Julia REPL.)\n\n\n\n\n\n"},{"title":"Base.Multimedia.istextmime","page":"I/O and Network","location":"base/io-network.html#Base.Multimedia.istextmime","category":"function","text":"istextmime(m::MIME)\n\nDetermine whether a MIME type is text data. MIME types are assumed to be binary\ndata except for a set of types known to be text data (possibly Unicode).\n\nExamples\n\njulia> istextmime(MIME(\"text/plain\"))\ntrue\n\njulia> istextmime(MIME(\"image/png\"))\nfalse\n\n\n\n\n\n"},{"title":"Base.bytesavailable","page":"I/O and Network","location":"base/io-network.html#Base.bytesavailable","category":"function","text":"bytesavailable(io)\n\nReturn the number of bytes available for reading before a read from this stream or buffer will block.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> bytesavailable(io)\n34\n\n\n\n\n\n"},{"title":"Base.ntoh","page":"I/O and Network","location":"base/io-network.html#Base.ntoh","category":"function","text":"ntoh(x)\n\nConvert the endianness of a value from Network byte order (big-endian) to that used by the Host.\n\n\n\n\n\n"},{"title":"Base.hton","page":"I/O and Network","location":"base/io-network.html#Base.hton","category":"function","text":"hton(x)\n\nConvert the endianness of a value from that used by the Host to Network byte order (big-endian).\n\n\n\n\n\n"},{"title":"Base.ltoh","page":"I/O and Network","location":"base/io-network.html#Base.ltoh","category":"function","text":"ltoh(x)\n\nConvert the endianness of a value from Little-endian to that used by the Host.\n\n\n\n\n\n"},{"title":"Base.htol","page":"I/O and Network","location":"base/io-network.html#Base.htol","category":"function","text":"htol(x)\n\nConvert the endianness of a value from that used by the Host to Little-endian.\n\n\n\n\n\n"},{"title":"Base.ENDIAN_BOM","page":"I/O and Network","location":"base/io-network.html#Base.ENDIAN_BOM","category":"constant","text":"ENDIAN_BOM\n\nThe 32-bit byte-order-mark indicates the native byte order of the host machine.\nLittle-endian machines will contain the value 0x04030201. Big-endian machines will contain\nthe value 0x01020304.\n\n\n\n\n\n"},{"title":"Unit Testing","page":"Unit Testing","location":"stdlib/Test.html#Unit-Testing","category":"section","text":""},{"title":"Testing Base Julia","page":"Unit Testing","location":"stdlib/Test.html#Testing-Base-Julia","category":"section","text":"Julia is under rapid development and has an extensive test suite to verify functionality across\nmultiple platforms. If you build Julia from source, you can run this test suite with make test.\nIn a binary install, you can run the test suite using Base.runtests()."},{"title":"Basic Unit Tests","page":"Unit Testing","location":"stdlib/Test.html#Basic-Unit-Tests","category":"section","text":"The Test module provides simple unit testing functionality. Unit testing is a way to\nsee if your code is correct by checking that the results are what you expect. It can be helpful\nto ensure your code still works after you make changes, and can be used when developing as a way\nof specifying the behaviors your code should have when complete. You may also want to look at the\ndocumentation for adding tests to your Julia Package.\n\nSimple unit testing can be performed with the @test and @test_throws macros:\n\nFor example, suppose we want to check our new function foo(x) works as expected:\n\njulia> using Test\n\njulia> foo(x) = length(x)^2\nfoo (generic function with 1 method)\n\nIf the condition is true, a Pass is returned:\n\njulia> @test foo(\"bar\") == 9\nTest Passed\n\njulia> @test foo(\"fizz\") >= 10\nTest Passed\n\nIf the condition is false, then a Fail is returned and an exception is thrown:\n\njulia> @test foo(\"f\") == 20\nTest Failed at none:1\n  Expression: foo(\"f\") == 20\n   Evaluated: 1 == 20\nERROR: There was an error during testing\n\nIf the condition could not be evaluated because an exception was thrown, which occurs in this\ncase because length is not defined for symbols, an Error object is returned and an exception\nis thrown:\n\njulia> @test foo(:cat) == 1\nError During Test\n  Test threw an exception of type MethodError\n  Expression: foo(:cat) == 1\n  MethodError: no method matching length(::Symbol)\n  The function `length` exists, but no method is defined for this combination of argument types.\n\n  Closest candidates are:\n    length(::SimpleVector) at essentials.jl:256\n    length(::Base.MethodList) at reflection.jl:521\n    length(::MethodTable) at reflection.jl:597\n    ...\n  Stacktrace:\n  [...]\nERROR: There was an error during testing\n\nIf we expect that evaluating an expression should throw an exception, then we can use @test_throws\nto check that this occurs:\n\njulia> @test_throws MethodError foo(:cat)\nTest Passed\n      Thrown: MethodError"},{"title":"Working with Test Sets","page":"Unit Testing","location":"stdlib/Test.html#Working-with-Test-Sets","category":"section","text":"Typically a large number of tests are used to make sure functions work correctly over a range\nof inputs. In the event a test fails, the default behavior is to throw an exception immediately.\nHowever, it is normally preferable to run the rest of the tests first to get a better picture\nof how many errors there are in the code being tested.\n\nnote: Note\nThe @testset will create a local scope of its own when running the tests in it.\n\nThe @testset macro can be used to group tests into sets. All the tests in a test set will\nbe run, and at the end of the test set a summary will be printed. If any of the tests failed,\nor could not be evaluated due to an error, the test set will then throw a TestSetException.\n\nWe can put our tests for the foo(x) function in a test set:\n\njulia> @testset \"Foo Tests\" begin\n           @test foo(\"a\")   == 1\n           @test foo(\"ab\")  == 4\n           @test foo(\"abc\") == 9\n       end;\nTest Summary: | Pass  Total  Time\nFoo Tests     |    3      3  0.0s\n\nTest sets can also be nested:\n\njulia> @testset \"Foo Tests\" begin\n           @testset \"Animals\" begin\n               @test foo(\"cat\") == 9\n               @test foo(\"dog\") == foo(\"cat\")\n           end\n           @testset \"Arrays $i\" for i in 1:3\n               @test foo(zeros(i)) == i^2\n               @test foo(fill(1.0, i)) == i^2\n           end\n       end;\nTest Summary: | Pass  Total  Time\nFoo Tests     |    8      8  0.0s\n\nAs well as call functions:\n\njulia> f(x) = @test isone(x)\nf (generic function with 1 method)\n\njulia> @testset f(1);\nTest Summary: | Pass  Total  Time\nf             |    1      1  0.0s\n\nThis can be used to allow for factorization of test sets, making it easier to run individual\ntest sets by running the associated functions instead.\nNote that in the case of functions, the test set will be given the name of the called function.\nIn the event that a nested test set has no failures, as happened here, it will be hidden in the\nsummary, unless the verbose=true option is passed:\n\njulia> @testset verbose = true \"Foo Tests\" begin\n           @testset \"Animals\" begin\n               @test foo(\"cat\") == 9\n               @test foo(\"dog\") == foo(\"cat\")\n           end\n           @testset \"Arrays $i\" for i in 1:3\n               @test foo(zeros(i)) == i^2\n               @test foo(fill(1.0, i)) == i^2\n           end\n       end;\nTest Summary: | Pass  Total  Time\nFoo Tests     |    8      8  0.0s\n  Animals     |    2      2  0.0s\n  Arrays 1    |    2      2  0.0s\n  Arrays 2    |    2      2  0.0s\n  Arrays 3    |    2      2  0.0s"},{"title":"Environment Variable Support","page":"Unit Testing","location":"stdlib/Test.html#Environment-Variable-Support","category":"section","text":"The Test module supports the JULIA_TEST_VERBOSE environment variable for controlling\nverbose behavior globally:\n\nWhen JULIA_TEST_VERBOSE=true, testsets will automatically use verbose=true by default,\nand additionally print \"Starting testset\" and \"Finished testset\" messages with timing\ninformation as testsets are entered and exited.\nWhen JULIA_TEST_VERBOSE=false or unset, testsets use verbose=false by default and\nno entry/exit messages are printed.\n\nThis environment variable provides a convenient way to enable comprehensive verbose output\nfor debugging test suites without modifying the test code itself.\n\n$ JULIA_TEST_VERBOSE=true julia -e '\nusing Test\n@testset \"Example\" begin\n    @test 1 + 1 == 2\n    @testset \"Nested\" begin\n        @test 2 * 2 == 4\n    end\nend'\n\nStarting testset: Example\n  Starting testset: Nested\n  Finished testset: Nested (0.0s)\nFinished testset: Example (0.0s)\nTest Summary: | Pass  Total  Time\nExample       |    2      2  0.0s\n  Nested      |    1      1  0.0s\n\nIf we do have a test failure, only the details for the failed test sets will be shown:\n\njulia> @testset \"Foo Tests\" begin\n           @testset \"Animals\" begin\n               @testset \"Felines\" begin\n                   @test foo(\"cat\") == 9\n               end\n               @testset \"Canines\" begin\n                   @test foo(\"dog\") == 9\n               end\n           end\n           @testset \"Arrays\" begin\n               @test foo(zeros(2)) == 4\n               @test foo(fill(1.0, 4)) == 15\n           end\n       end\n\nArrays: Test Failed\n  Expression: foo(fill(1.0, 4)) == 15\n   Evaluated: 16 == 15\n[...]\nTest Summary: | Pass  Fail  Total  Time\nFoo Tests     |    3     1      4  0.0s\n  Animals     |    2            2  0.0s\n  Arrays      |    1     1      2  0.0s\nERROR: Some tests did not pass: 3 passed, 1 failed, 0 errored, 0 broken."},{"title":"Testing Log Statements","page":"Unit Testing","location":"stdlib/Test.html#Testing-Log-Statements","category":"section","text":"One can use the @test_logs macro to test log statements, or use a TestLogger."},{"title":"Other Test Macros","page":"Unit Testing","location":"stdlib/Test.html#Other-Test-Macros","category":"section","text":"As calculations on floating-point values can be imprecise, you can perform approximate equality\nchecks using either @test a ≈ b (where ≈, typed via tab completion of \\approx, is the\nisapprox function) or use isapprox directly.\n\njulia> @test 1 ≈ 0.999999999\nTest Passed\n\njulia> @test 1 ≈ 0.999999\nTest Failed at none:1\n  Expression: 1 ≈ 0.999999\nERROR: There was an error during testing\n\nYou can specify relative and absolute tolerances by setting the rtol and atol keyword arguments of isapprox, respectively,\nafter the ≈ comparison:\n\njulia> @test 1 ≈ 0.999999  rtol=1e-5\nTest Passed\n\nNote that this is not a specific feature of the ≈ but rather a general feature of the @test macro: @test a <op> b key=val is transformed by the macro into @test op(a, b, key=val). It is, however, particularly useful for ≈ tests."},{"title":"Broken Tests","page":"Unit Testing","location":"stdlib/Test.html#Broken-Tests","category":"section","text":"If a test fails consistently it can be changed to use the @test_broken macro. This will denote\nthe test as Broken if the test continues to fail and alerts the user via an Error if the test\nsucceeds.\n\n@test_skip is also available to skip a test without evaluation, but counting the skipped test\nin the test set reporting. The test will not run but gives a Broken Result."},{"title":"Test result types","page":"Unit Testing","location":"stdlib/Test.html#Test-result-types","category":"section","text":""},{"title":"Creating Custom AbstractTestSet Types","page":"Unit Testing","location":"stdlib/Test.html#Creating-Custom-AbstractTestSet-Types","category":"section","text":"Packages can create their own AbstractTestSet subtypes by implementing the record and finish\nmethods. The subtype should have a one-argument constructor taking a description string, with\nany options passed in as keyword arguments.\n\nTest takes responsibility for maintaining a stack of nested testsets as they are executed,\nbut any result accumulation is the responsibility of the AbstractTestSet subtype. You can access\nthis stack with the get_testset and get_testset_depth methods. Note that these functions are\nnot exported.\n\nTest also makes sure that nested @testset invocations use the same AbstractTestSet\nsubtype as their parent unless it is set explicitly. It does not propagate any properties of the\ntestset. Option inheritance behavior can be implemented by packages using the stack infrastructure\nthat Test provides.\n\nDefining a basic AbstractTestSet subtype might look like:\n\nimport Test: Test, record, finish\nusing Test: AbstractTestSet, Result, Pass, Fail, Error\nusing Test: get_testset_depth, get_testset\nstruct CustomTestSet <: Test.AbstractTestSet\n    description::AbstractString\n    foo::Int\n    results::Vector\n    # constructor takes a description string and options keyword arguments\n    CustomTestSet(desc; foo=1) = new(desc, foo, [])\nend\n\nrecord(ts::CustomTestSet, child::AbstractTestSet) = push!(ts.results, child)\nrecord(ts::CustomTestSet, res::Result) = push!(ts.results, res)\nfunction finish(ts::CustomTestSet)\n    # just record if we're not the top-level parent\n    if get_testset_depth() > 0\n        record(get_testset(), ts)\n        return ts\n    end\n\n    # so the results are printed if we are at the top level\n    Test.print_test_results(ts)\n    return ts\nend\n\nAnd using that testset looks like:\n\n@testset CustomTestSet foo=4 \"custom testset inner 2\" begin\n    # this testset should inherit the type, but not the argument.\n    @testset \"custom testset inner\" begin\n        @test true\n    end\nend\n\nIn order to use a custom testset and have the recorded results printed as part of any outer default testset,\nalso define Test.get_test_counts. This might look like so:\n\nusing Test: AbstractTestSet, Pass, Fail, Error, Broken, get_test_counts, TestCounts, format_duration\n\nfunction Test.get_test_counts(ts::CustomTestSet)\n    passes, fails, errors, broken = 0, 0, 0, 0\n    # cumulative results\n    c_passes, c_fails, c_errors, c_broken = 0, 0, 0, 0\n\n    for t in ts.results\n        # count up results\n        isa(t, Pass)   && (passes += 1)\n        isa(t, Fail)   && (fails  += 1)\n        isa(t, Error)  && (errors += 1)\n        isa(t, Broken) && (broken += 1)\n        # handle children\n        if isa(t, AbstractTestSet)\n            tc = get_test_counts(t)::TestCounts\n            c_passes += tc.passes + tc.cumulative_passes\n            c_fails  += tc.fails + tc.cumulative_fails\n            c_errors += tc.errors + tc.cumulative_errors\n            c_broken += tc.broken + tc.cumulative_broken\n        end\n    end\n    # get a duration, if we have one\n    duration = format_duration(ts)\n    return TestCounts(true, passes, fails, errors, broken, c_passes, c_fails, c_errors, c_broken, duration)\nend"},{"title":"Test utilities","page":"Unit Testing","location":"stdlib/Test.html#Test-utilities","category":"section","text":""},{"title":"Workflow for Testing Packages","page":"Unit Testing","location":"stdlib/Test.html#Workflow-for-Testing-Packages","category":"section","text":"Using the tools available to us in the previous sections, here is a potential workflow of creating a package and adding tests to it."},{"title":"Generating an Example Package","page":"Unit Testing","location":"stdlib/Test.html#Generating-an-Example-Package","category":"section","text":"For this workflow, we will create a package called Example:\n\npkg> generate Example\nshell> cd Example\nshell> mkdir test\npkg> activate ."},{"title":"Creating Sample Functions","page":"Unit Testing","location":"stdlib/Test.html#Creating-Sample-Functions","category":"section","text":"The number one requirement for testing a package is to have functionality to test.\nFor that, we will add some simple functions to Example that we can test.\nAdd the following to src/Example.jl:\n\nmodule Example\n\nexport greet, simple_add, type_multiply\n\nfunction greet()\n    \"Hello world!\"\nend\n\nfunction simple_add(a, b)\n    a + b\nend\n\nfunction type_multiply(a::Float64, b::Float64)\n    a * b\nend\n\nend"},{"title":"Creating a Test Environment","page":"Unit Testing","location":"stdlib/Test.html#Creating-a-Test-Environment","category":"section","text":"From within the root of the Example package, navigate to the test directory, activate a new environment there, and add the Test package to the environment:\n\nshell> cd test\npkg> activate .\n(test) pkg> add Test"},{"title":"Testing Our Package","page":"Unit Testing","location":"stdlib/Test.html#Testing-Our-Package","category":"section","text":"Now, we are ready to add tests to Example.\nIt is standard practice to create a file within the test directory called runtests.jl which contains the test sets we want to run.\nGo ahead and create that file within the test directory and add the following code to it:\n\nusing Example\nusing Test\n\n@testset \"Example tests\" begin\n\n    @testset \"Math tests\" begin\n        include(\"math_tests.jl\")\n    end\n\n    @testset \"Greeting tests\" begin\n        include(\"greeting_tests.jl\")\n    end\nend\n\nWe will need to create those two included files, math_tests.jl and greeting_tests.jl, and add some tests to them.\n\nNote: Notice how we did not have to specify add Example into the test environment's Project.toml.\nThis is a benefit of Julia's testing system that you could read about more here."},{"title":"Writing Tests for math_tests.jl","page":"Unit Testing","location":"stdlib/Test.html#Writing-Tests-for-math_tests.jl","category":"section","text":"Using our knowledge of Test.jl, here are some example tests we could add to math_tests.jl:\n\n@testset \"Testset 1\" begin\n    @test 2 == simple_add(1, 1)\n    @test 3.5 == simple_add(1, 2.5)\n    @test_throws MethodError simple_add(1, \"A\")\n    @test_throws MethodError simple_add(1, 2, 3)\nend\n\n@testset \"Testset 2\" begin\n    @test 1.0 == type_multiply(1.0, 1.0)\n    @test isa(type_multiply(2.0, 2.0), Float64)\n    @test_throws MethodError type_multiply(1, 2.5)\nend"},{"title":"Writing Tests for greeting_tests.jl","page":"Unit Testing","location":"stdlib/Test.html#Writing-Tests-for-greeting_tests.jl","category":"section","text":"Using our knowledge of Test.jl, here are some example tests we could add to greeting_tests.jl:\n\n@testset \"Testset 3\" begin\n    @test \"Hello world!\" == greet()\n    @test_throws MethodError greet(\"Antonia\")\nend"},{"title":"Testing Our Package","page":"Unit Testing","location":"stdlib/Test.html#Testing-Our-Package-2","category":"section","text":"Now that we have added our tests and our runtests.jl script in test, we can test our Example package by going back to the root of the Example package environment and reactivating the Example environment:\n\nshell> cd ..\npkg> activate .\n\nFrom there, we can finally run our test suite as follows:\n\n(Example) pkg> test\n     Testing Example\n      Status `/tmp/jl_Yngpvy/Project.toml`\n  [fa318bd2] Example v0.1.0 `/home/src/Projects/tmp/errata/Example`\n  [8dfed614] Test `@stdlib/Test`\n      Status `/tmp/jl_Yngpvy/Manifest.toml`\n  [fa318bd2] Example v0.1.0 `/home/src/Projects/tmp/errata/Example`\n  [2a0f44e3] Base64 `@stdlib/Base64`\n  [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`\n  [56ddb016] Logging `@stdlib/Logging`\n  [d6f4376e] Markdown `@stdlib/Markdown`\n  [9a3f8284] Random `@stdlib/Random`\n  [ea8e919c] SHA `@stdlib/SHA`\n  [9e88b42a] Serialization `@stdlib/Serialization`\n  [8dfed614] Test `@stdlib/Test`\n     Testing Running tests...\nTest Summary: | Pass  Total\nExample tests |    9      9\n     Testing Example tests passed\n\nAnd if all went correctly, you should see a similar output as above.\nUsing Test.jl, more complicated tests can be added for packages but this should ideally point developers in the direction of how to get started with testing their own created packages."},{"title":"Code Coverage","page":"Unit Testing","location":"stdlib/Test.html#Code-Coverage","category":"section","text":"Code coverage tracking during tests can be enabled using the pkg> test --coverage flag (or at a lower level using the\n--code-coverage julia arg). This is on by default in the\njulia-runtest GitHub action.\n\nTo evaluate coverage either manually inspect the .cov files that are generated beside the source files locally,\nor in CI use the julia-processcoverage GitHub action.\n\ncompat: Julia 1.11\nSince Julia 1.11, coverage is not collected during the package precompilation phase."},{"title":"Base.runtests","page":"Unit Testing","location":"stdlib/Test.html#Base.runtests","category":"function","text":"Base.runtests(tests=[\"all\"]; ncores=ceil(Int, Sys.EFFECTIVE_CPU_THREADS / 2),\n              exit_on_error=false, revise=false, propagate_project=true, [seed], [julia_args::Cmd])\n\nRun the Julia unit tests listed in tests, which can be either a string or an array of\nstrings, using ncores processors. If exit_on_error is false, when one test\nfails, all remaining tests in other files will still be run; they are otherwise discarded,\nwhen exit_on_error == true.\nIf revise is true, the Revise package is used to load any modifications to Base or\nto the standard libraries before running the tests.\nIf propagate_project is true the current project is propagated to the test environment.\nIf a seed is provided via the keyword argument, it is used to seed the\nglobal RNG in the context where the tests are run; otherwise the seed is chosen randomly.\nThe argument julia_args can be used to pass custom julia command line flags to the test process.\n\n\n\n\n\n"},{"title":"Test.@test","page":"Unit Testing","location":"stdlib/Test.html#Test.@test","category":"macro","text":"@test ex\n@test f(args...) key=val ...\n@test ex broken=true\n@test ex skip=true\n@test ex context=ctx\n\nTest that the expression ex evaluates to true.\nIf executed inside a @testset, return a Pass Result if it does, a Fail Result if it is\nfalse, and an Error Result if it could not be evaluated.\nIf executed outside a @testset, throw an exception instead of returning Fail or Error.\n\nExamples\n\njulia> @test true\nTest Passed\n\njulia> @test [1, 2] + [2, 1] == [3, 3]\nTest Passed\n\nThe @test f(args...) key=val... form is equivalent to writing\n@test f(args..., key=val...) which can be useful when the expression\nis a call using infix syntax such as approximate comparisons:\n\njulia> @test π ≈ 3.14 atol=0.01\nTest Passed\n\nThis is equivalent to the uglier test @test ≈(π, 3.14, atol=0.01).\nIt is an error to supply more than one expression unless the first\nis a call expression and the rest are assignments (k=v).\n\nYou can use any key for the key=val arguments, except for broken, skip,\nand context, which have special meanings in the context of @test:\n\nbroken=cond indicates a test that should pass but currently consistently\nfails when cond==true.  Tests that the expression ex evaluates to false\nor causes an exception.  Returns a Broken Result if it does, or an Error\nResult if the expression evaluates to true.  Regular @test ex is\nevaluated when cond==false.\nskip=cond marks a test that should not be executed but should be included in\ntest summary reporting as Broken, when cond==true.  This can be useful for\ntests that intermittently fail, or tests of not-yet-implemented functionality.\nRegular @test ex is evaluated when cond==false.\ncontext=ctx provides additional context that will be displayed if the test\nfails. The context expression is evaluated and its result is shown in the\ntest failure output. This is useful for providing debugging information.\n\nExamples\n\njulia> @test 2 + 2 ≈ 6 atol=1 broken=true\nTest Broken\n  Expression: ≈(2 + 2, 6, atol = 1)\n\njulia> @test 2 + 2 ≈ 5 atol=1 broken=false\nTest Passed\n\njulia> @test 2 + 2 == 5 skip=true\nTest Broken\n  Skipped: 2 + 2 == 5\n\njulia> @test 2 + 2 == 4 skip=false\nTest Passed\n\ncompat: Julia 1.7\nThe broken and skip keyword arguments require at least Julia 1.7.\n\ncompat: Julia 1.14\nThe context keyword argument requires at least Julia 1.14.\n\n\n\n\n\n"},{"title":"Test.@test_throws","page":"Unit Testing","location":"stdlib/Test.html#Test.@test_throws","category":"macro","text":"@test_throws exception expr\n@test_throws extype pattern expr\n@test_throws exception expr broken=cond\n@test_throws exception expr skip=cond\n@test_throws exception expr context=ctx\n\nTests that the expression expr throws exception.\nThe exception may specify either a type,\na string, regular expression, or list of strings occurring in the displayed error message,\na matching function,\nor a value (which will be tested for equality by comparing fields).\n\nIn the two-argument form, @test_throws exception expr, the exception can be a type or a pattern.\n\nIn the three-argument form, @test_throws extype pattern expr, both the exception type and\na message pattern are tested. The extype must be a type, and pattern may be\na string, regular expression, or list of strings occurring in the displayed error message,\na matching function, or a value.\n\nKeyword Arguments\n\nbroken=cond: if cond==true, indicates a test that should pass but currently\nconsistently fails. The test will be recorded as Broken if it fails (no exception\nor wrong exception), or as Error if it unexpectedly passes.\nskip=cond: if cond==true, marks a test that should not be executed but should\nbe included in test summary reporting as Broken. This can be useful for tests\nthat intermittently fail, or tests of not-yet-implemented functionality.\ncontext=ctx: provides additional context that will be displayed if the test fails\n(wrong exception type, wrong message, or no exception thrown).\n\ncompat: Julia 1.8\nThe ability to specify anything other than a type or a value as exception requires Julia v1.8 or later.\n\ncompat: Julia 1.13\nThe three-argument form @test_throws extype pattern expr requires Julia v1.12 or later.\n\ncompat: Julia 1.14\nThe context keyword argument requires at least Julia 1.14.\n\ncompat: Julia 1.14\nThe broken and skip keyword arguments require at least Julia 1.14.\n\nExamples\n\njulia> @test_throws BoundsError [1, 2, 3][4]\nTest Passed\n      Thrown: BoundsError\n\njulia> @test_throws DimensionMismatch [1, 2, 3] + [1, 2]\nTest Passed\n      Thrown: DimensionMismatch\n\njulia> @test_throws \"Try sqrt(Complex\" sqrt(-1)\nTest Passed\n     Message: \"DomainError with -1.0:\\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\"\n\njulia> @test_throws ErrorException \"error foo\" error(\"error foo 1\")\nTest Passed\n      Thrown: ErrorException\n\nIn the third example, instead of matching a single string it could alternatively have been performed with:\n\n[\"Try\", \"Complex\"] (a list of strings)\nr\"Try sqrt\\([Cc]omplex\" (a regular expression)\nstr -> occursin(\"complex\", str) (a matching function)\n\nIn the final example, both the exception type (ErrorException) and message pattern (\"error foo\") are tested.\n\n\n\n\n\n"},{"title":"Test.@testset","page":"Unit Testing","location":"stdlib/Test.html#Test.@testset","category":"macro","text":"@testset [CustomTestSet] [options...] [\"description\"] begin test_ex end\n@testset [CustomTestSet] [options...] [\"description $v\"] for v in itr test_ex end\n@testset [CustomTestSet] [options...] [\"description $v, $w\"] for v in itrv, w in itrw test_ex end\n@testset [CustomTestSet] [options...] [\"description\"] test_func()\n@testset let v = v, w = w; test_ex; end\n\nWith begin/end or function call\n\nWhen @testset is used, with begin/end or a single function call, the macro\nstarts a new test set in which to evaluate the given expression.\n\nIf no custom testset type is given it defaults to creating a DefaultTestSet.\nDefaultTestSet records all the results and, if there are any Fails or\nErrors, throws an exception at the end of the top-level (non-nested) test set,\nalong with a summary of the test results.\n\nAny custom testset type (subtype of AbstractTestSet) can be given and it will\nalso be used for any nested @testset invocations. The given options are only\napplied to the test set where they are given. The default test set type\naccepts the following options:\n\nverbose::Bool: if true, the result summary of the nested testsets is shown even\nwhen they all pass (the default is false).\nshowtiming::Bool: if true, the duration of each displayed testset is shown\n(the default is true).\nfailfast::Bool: if true, any test failure or error will cause the testset and any\nchild testsets to return immediately (the default is false).\nThis can also be set globally via the env var JULIA_TEST_FAILFAST.\nrng::Random.AbstractRNG: use the given random number generator (RNG) as the global one\nfor the testset.  rng must be copy!-able.  This option can be useful to locally\nreproduce stochastic test failures which only depend on the state of the global RNG.\n\ncompat: Julia 1.8\n@testset test_func() requires at least Julia 1.8.\n\ncompat: Julia 1.9\nfailfast requires at least Julia 1.9.\n\ncompat: Julia 1.12\nThe rng option requires at least Julia 1.12.\n\nThe description string accepts interpolation from the loop indices.\nIf no description is provided, one is constructed based on the variables.\nIf a function call is provided, its name will be used.\nExplicit description strings override this behavior.\n\nBy default the @testset macro will return the testset object itself, though\nthis behavior can be customized in other testset types. If a for loop is used\nthen the macro collects and returns a list of the return values of the finish\nmethod, which by default will return a list of the testset objects used in\neach iteration.\n\nBefore the execution of the body of a @testset, there is an implicit\ncall to copy!(Random.default_rng(), rng) where rng is the RNG of the current task, or\nthe value of the RNG passed via the rng option.\nMoreover, after the execution of the body, the state of the global RNG is\nrestored to what it was before the @testset. This is meant to ease\nreproducibility in case of failure, and to allow seamless\nre-arrangements of @testsets regardless of their side-effect on the\nglobal RNG state.\n\nnote: RNG of nested testsets\nUnless changed with the rng option, the same RNG is set at the beginning of all\nnested testsets.  The RNG printed to screen when a testset has failures is the global RNG of\nthe outermost testset even if inner testsets have different RNGs manually set by the user.\n\nExamples\n\njulia> @testset \"trigonometric identities\" begin\n           θ = 2/3*π\n           @test sin(-θ) ≈ -sin(θ)\n           @test cos(-θ) ≈ cos(θ)\n           @test sin(2θ) ≈ 2*sin(θ)*cos(θ)\n           @test cos(2θ) ≈ cos(θ)^2 - sin(θ)^2\n       end;\nTest Summary:            | Pass  Total  Time\ntrigonometric identities |    4      4  0.2s\n\n@testset for\n\nWhen @testset for is used, the macro starts a new test set for each iteration of\nthe provided loop. The semantics of each test set are otherwise identical to that\nof the begin/end case (as if used for each loop iteration).\n\n@testset let\n\nWhen @testset let is used, the macro starts a transparent test set with\nthe given object added as a context object to any failing or erroring test contained\ntherein. This is useful when performing a set of related tests on one larger\nobject and it is desirable to print this larger object when any of the\nindividual tests fail. Transparent test sets do not introduce additional levels\nof nesting in the test set hierarchy and are passed through directly to the\nparent test set (with the context object appended to any failing tests.)\n\ncompat: Julia 1.9\n@testset let requires at least Julia 1.9.\n\ncompat: Julia 1.10\nMultiple let assignments are supported since Julia 1.10.\n\ncompat: Julia 1.13\nContext is shown when a test errors since Julia 1.13.\n\nSpecial implicit world age increment for @testset begin\n\nWorld age inside @testset begin increments implicitly after every statement.\nThis matches the behavior of ordinary toplevel code, but not that of ordinary\nbegin/end blocks, i.e. with respect to world age, @testset begin behaves\nas if the body of the begin/end block was written at toplevel.\n\nExamples\n\njulia> @testset let logi = log(im)\n           @test imag(logi) == π/2\n           @test !iszero(real(logi))\n       end\nTest Failed at none:3\n  Expression: !(iszero(real(logi)))\n   Evaluated: !(iszero(0.0))\n     Context: logi = 0.0 + 1.5707963267948966im\nERROR: There was an error during testing\n\njulia> @testset let logi = log(im), op = !iszero\n           @test imag(logi) == π/2\n           @test op(real(logi))\n       end\nTest Failed at none:3\n  Expression: op(real(logi))\n   Evaluated: op(0.0)\n     Context: logi = 0.0 + 1.5707963267948966im\n              op = !iszero\nERROR: There was an error during testing\n\n\n\n\n\n"},{"title":"Test.TestSetException","page":"Unit Testing","location":"stdlib/Test.html#Test.TestSetException","category":"type","text":"TestSetException\n\nThrown when a test set finishes and not all tests passed.\n\n\n\n\n\n"},{"title":"Test.@test_logs","page":"Unit Testing","location":"stdlib/Test.html#Test.@test_logs","category":"macro","text":"@test_logs [log_patterns...] [keywords] expression\n\nCollect a list of log records generated by expression using\ncollect_test_logs, check that they match the sequence log_patterns, and\nreturn the value of expression.  The keywords provide some simple filtering\nof log records: the min_level keyword controls the minimum log level which\nwill be collected for the test, the match_mode keyword defines how matching\nwill be performed (the default :all checks that all logs and patterns match\npairwise; use :any to check that the pattern matches at least once somewhere\nin the sequence.)\n\nThe most useful log pattern is a simple tuple of the form (level,message).\nA different number of tuple elements may be used to match other log metadata,\ncorresponding to the arguments to passed to AbstractLogger via the\nhandle_message function: (level,message,module,group,id,file,line).\nElements which are present will be matched pairwise with the log record fields\nusing == by default, with the special cases that Symbols may be used for\nthe standard log levels, and Regexs in the pattern will match string or\nSymbol fields using occursin.\n\nExamples\n\nConsider a function which logs a warning, and several debug messages:\n\nfunction foo(n)\n    @info \"Doing foo with n=$n\"\n    for i=1:n\n        @debug \"Iteration $i\"\n    end\n    42\nend\n\nWe can test the info message using\n\n@test_logs (:info,\"Doing foo with n=2\") foo(2)\n\nIf we also wanted to test the debug messages, these need to be enabled with the\nmin_level keyword:\n\nusing Logging\n@test_logs (:info,\"Doing foo with n=2\") (:debug,\"Iteration 1\") (:debug,\"Iteration 2\") min_level=Logging.Debug foo(2)\n\nIf you want to test that some particular messages are generated while ignoring the rest,\nyou can set the keyword match_mode=:any:\n\nusing Logging\n@test_logs (:info,) (:debug,\"Iteration 42\") min_level=Logging.Debug match_mode=:any foo(100)\n\nThe macro may be chained with @test to also test the returned value:\n\n@test (@test_logs (:info,\"Doing foo with n=2\") foo(2)) == 42\n\nIf you want to test for the absence of warnings, you can omit specifying log\npatterns and set the min_level accordingly:\n\n# test that the expression logs no messages when the logger level is warn:\n@test_logs min_level=Logging.Warn @info(\"Some information\") # passes\n@test_logs min_level=Logging.Warn @warn(\"Some information\") # fails\n\nIf you want to test the absence of warnings (or error messages) in\nstderr which are not generated by @warn, see @test_nowarn.\n\nKeyword Arguments\n\nbroken=cond: if cond==true, indicates a test that should pass but currently\nconsistently fails.\nskip=cond: if cond==true, marks a test that should not be executed but should\nbe included in test summary reporting as Broken.\n\ncompat: Julia 1.14\nThe broken and skip keyword arguments require at least Julia 1.14.\n\n\n\n\n\n"},{"title":"Test.TestLogger","page":"Unit Testing","location":"stdlib/Test.html#Test.TestLogger","category":"type","text":"TestLogger(; min_level=Info, catch_exceptions=false)\n\nCreate a TestLogger which captures logged messages in its logs::Vector{LogRecord} field.\n\nSet min_level to control the LogLevel, catch_exceptions for whether or not exceptions\nthrown as part of log event generation should be caught, and respect_maxlog for whether\nor not to follow the convention of logging messages with maxlog=n for some integer n at\nmost n times.\n\nSee also: LogRecord.\n\nExamples\n\njulia> using Test, Logging\n\njulia> f() = @info \"Hi\" number=5;\n\njulia> test_logger = TestLogger();\n\njulia> with_logger(test_logger) do\n           f()\n           @info \"Bye!\"\n       end\n\njulia> @test test_logger.logs[1].message == \"Hi\"\nTest Passed\n\njulia> @test test_logger.logs[1].kwargs[:number] == 5\nTest Passed\n\njulia> @test test_logger.logs[2].message == \"Bye!\"\nTest Passed\n\n\n\n\n\n"},{"title":"Test.LogRecord","page":"Unit Testing","location":"stdlib/Test.html#Test.LogRecord","category":"type","text":"LogRecord\n\nStores the results of a single log event. Fields:\n\nlevel: the LogLevel of the log message\nmessage: the textual content of the log message\n_module: the module of the log event\ngroup: the logging group (by default, the name of the file containing the log event)\nid: the ID of the log event\nfile: the file containing the log event\nline: the line within the file of the log event\nkwargs: any keyword arguments passed to the log event\n\n\n\n\n\n"},{"title":"Test.@inferred","page":"Unit Testing","location":"stdlib/Test.html#Test.@inferred","category":"macro","text":"@inferred [AllowedType] f(x)\n\nTests that the call expression f(x) returns a value of the same type inferred by the\ncompiler. It is useful to check for type stability.\n\nf(x) can be any call expression. Returns the result of f(x) if the types match, and an\nError Result if it finds different types.\n\nOptionally, AllowedType relaxes the test, by making it pass when either the type of f(x)\nmatches the inferred type modulo AllowedType, or when the return type is a subtype of\nAllowedType. This is useful when testing type stability of functions returning a small\nunion such as Union{Nothing, T} or Union{Missing, T}.\n\njulia> f(a) = a > 1 ? 1 : 1.0\nf (generic function with 1 method)\n\njulia> typeof(f(2))\nInt64\n\njulia> @code_warntype f(2)\nMethodInstance for f(::Int64)\n  from f(a) @ Main none:1\nArguments\n  #self#::Core.Const(f)\n  a::Int64\nBody::UNION{FLOAT64, INT64}\n1 ─ %1 = :>::Core.Const(>)\n│   %2 = (%1)(a, 1)::Bool\n└──      goto #3 if not %2\n2 ─      return 1\n3 ─      return 1.0\n\njulia> @inferred f(2)\nERROR: return type Int64 does not match inferred return type Union{Float64, Int64}\n[...]\n\njulia> @inferred max(1, 2)\n2\n\njulia> g(a) = a < 10 ? missing : 1.0\ng (generic function with 1 method)\n\njulia> @inferred g(20)\nERROR: return type Float64 does not match inferred return type Union{Missing, Float64}\n[...]\n\njulia> @inferred Missing g(20)\n1.0\n\njulia> h(a) = a < 10 ? missing : f(a)\nh (generic function with 1 method)\n\njulia> @inferred Missing h(20)\nERROR: return type Int64 does not match inferred return type Union{Missing, Float64, Int64}\n[...]\n\n\n\n\n\n"},{"title":"Test.@test_deprecated","page":"Unit Testing","location":"stdlib/Test.html#Test.@test_deprecated","category":"macro","text":"@test_deprecated [pattern] expression\n@test_deprecated [pattern] expression broken=cond\n@test_deprecated [pattern] expression skip=cond\n\nWhen --depwarn=yes, test that expression emits a deprecation warning and\nreturn the value of expression.  The log message string will be matched\nagainst pattern which defaults to r\"deprecated\"i.\n\nWhen --depwarn=no, simply return the result of executing expression.  When\n--depwarn=error, check that an ErrorException is thrown.\n\nKeyword Arguments\n\nbroken=cond: if cond==true, indicates a test that should pass but currently\nconsistently fails.\nskip=cond: if cond==true, marks a test that should not be executed but should\nbe included in test summary reporting as Broken.\n\ncompat: Julia 1.14\nThe broken and skip keyword arguments require at least Julia 1.14.\n\nExamples\n\n# Deprecated in julia 0.7\n@test_deprecated num2hex(1)\n\n# The returned value can be tested by chaining with @test:\n@test (@test_deprecated num2hex(1)) == \"0000000000000001\"\n\n\n\n\n\n"},{"title":"Test.@test_warn","page":"Unit Testing","location":"stdlib/Test.html#Test.@test_warn","category":"macro","text":"@test_warn msg expr\n@test_warn msg expr broken=cond\n@test_warn msg expr skip=cond\n\nTest whether evaluating expr results in stderr output that contains\nthe msg string or matches the msg regular expression.  If msg is\na boolean function, tests whether msg(output) returns true.  If msg is a\ntuple or array, checks that the error output contains/matches each item in msg.\nReturns the result of evaluating expr.\n\nSee also @test_nowarn to check for the absence of error output.\n\nNote: Warnings generated by @warn cannot be tested with this macro. Use\n@test_logs instead.\n\nKeyword Arguments\n\nbroken=cond: if cond==true, indicates a test that should pass but currently\nconsistently fails.\nskip=cond: if cond==true, marks a test that should not be executed but should\nbe included in test summary reporting as Broken.\n\ncompat: Julia 1.14\nThe broken and skip keyword arguments require at least Julia 1.14.\n\n\n\n\n\n"},{"title":"Test.@test_nowarn","page":"Unit Testing","location":"stdlib/Test.html#Test.@test_nowarn","category":"macro","text":"@test_nowarn expr\n@test_nowarn expr broken=cond\n@test_nowarn expr skip=cond\n\nTest whether evaluating expr results in empty stderr output\n(no warnings or other messages).  Returns the result of evaluating expr.\n\nNote: The absence of warnings generated by @warn cannot be tested\nwith this macro. Use @test_logs instead.\n\nKeyword Arguments\n\nbroken=cond: if cond==true, indicates a test that should pass but currently\nconsistently fails.\nskip=cond: if cond==true, marks a test that should not be executed but should\nbe included in test summary reporting as Broken.\n\ncompat: Julia 1.14\nThe broken and skip keyword arguments require at least Julia 1.14.\n\n\n\n\n\n"},{"title":"Test.@test_broken","page":"Unit Testing","location":"stdlib/Test.html#Test.@test_broken","category":"macro","text":"@test_broken ex\n@test_broken f(args...) key=val ...\n@test_broken ex context=ctx\n\nIndicates a test that should pass but currently consistently fails.\nTests that the expression ex evaluates to false or causes an\nexception. Returns a Broken Result if it does, or an Error Result\nif the expression evaluates to true.  This is equivalent to\n@test ex broken=true.\n\nThe @test_broken f(args...) key=val... form works as for the @test macro.\n\nThe context=ctx keyword provides additional context that will be displayed\nif the test unexpectedly passes (becomes an Error).\n\nExamples\n\njulia> @test_broken 1 == 2\nTest Broken\n  Expression: 1 == 2\n\njulia> @test_broken 1 == 2 atol=0.1\nTest Broken\n  Expression: ==(1, 2, atol = 0.1)\n\ncompat: Julia 1.14\nThe context keyword argument requires at least Julia 1.14.\n\n\n\n\n\n"},{"title":"Test.@test_skip","page":"Unit Testing","location":"stdlib/Test.html#Test.@test_skip","category":"macro","text":"@test_skip ex\n@test_skip f(args...) key=val ...\n\nMarks a test that should not be executed but should be included in test\nsummary reporting as Broken. This can be useful for tests that intermittently\nfail, or tests of not-yet-implemented functionality.  This is equivalent to\n@test ex skip=true.\n\nThe @test_skip f(args...) key=val... form works as for the @test macro.\n\nExamples\n\njulia> @test_skip 1 == 2\nTest Broken\n  Skipped: 1 == 2\n\njulia> @test_skip 1 == 2 atol=0.1\nTest Broken\n  Skipped: ==(1, 2, atol = 0.1)\n\n\n\n\n\n"},{"title":"Test.Result","page":"Unit Testing","location":"stdlib/Test.html#Test.Result","category":"type","text":"Test.Result\n\nAll tests produce a result object. This object may or may not be\nstored, depending on whether the test is part of a test set.\n\n\n\n\n\n"},{"title":"Test.Pass","page":"Unit Testing","location":"stdlib/Test.html#Test.Pass","category":"type","text":"Test.Pass <: Test.Result\n\nThe test condition was true, i.e. the expression evaluated to true or\nthe correct exception was thrown.\n\n\n\n\n\n"},{"title":"Test.Fail","page":"Unit Testing","location":"stdlib/Test.html#Test.Fail","category":"type","text":"Test.Fail <: Test.Result\n\nThe test condition was false, i.e. the expression evaluated to false or\nthe correct exception was not thrown.\n\n\n\n\n\n"},{"title":"Test.Error","page":"Unit Testing","location":"stdlib/Test.html#Test.Error","category":"type","text":"Test.Error <: Test.Result\n\nThe test condition couldn't be evaluated due to an exception, or\nit evaluated to something other than a Bool.\nIn the case of @test_broken it is used to indicate that an\nunexpected Pass Result occurred.\n\n\n\n\n\n"},{"title":"Test.Broken","page":"Unit Testing","location":"stdlib/Test.html#Test.Broken","category":"type","text":"Test.Broken <: Test.Result\n\nThe test condition is the expected (failed) result of a broken test,\nor was explicitly skipped with @test_skip.\n\n\n\n\n\n"},{"title":"Test.record","page":"Unit Testing","location":"stdlib/Test.html#Test.record","category":"function","text":"record(ts::AbstractTestSet, res::Result)\n\nRecord a result to a testset. This function is called by the @testset\ninfrastructure each time a contained @test macro completes, and is given the\ntest result (which could be an Error). This will also be called with an Error\nif an exception is thrown inside the test block but outside of a @test context.\n\n\n\n\n\n"},{"title":"Test.finish","page":"Unit Testing","location":"stdlib/Test.html#Test.finish","category":"function","text":"finish(ts::AbstractTestSet)\n\nDo any final processing necessary for the given testset. This is called by the\n@testset infrastructure after a test block executes.\n\nCustom AbstractTestSet subtypes should call record on their parent (if there\nis one) to add themselves to the tree of test results. This might be implemented\nas:\n\nif get_testset_depth() != 0\n    # Attach this test set to the parent test set\n    parent_ts = get_testset()\n    record(parent_ts, self)\n    return self\nend\n\n\n\n\n\n"},{"title":"Test.get_testset","page":"Unit Testing","location":"stdlib/Test.html#Test.get_testset","category":"function","text":"get_testset()\n\nRetrieve the active test set from the task's local storage. If no\ntest set is active, use the fallback default test set.\n\n\n\n\n\n"},{"title":"Test.get_testset_depth","page":"Unit Testing","location":"stdlib/Test.html#Test.get_testset_depth","category":"function","text":"get_testset_depth()\n\nReturn the number of active test sets, not including the default test set\n\n\n\n\n\n"},{"title":"Test.TestCounts","page":"Unit Testing","location":"stdlib/Test.html#Test.TestCounts","category":"type","text":"TestCounts\n\nHolds the state for recursively gathering the results of a test set for display purposes.\n\nFields:\n\ncustomized: Whether the function get_test_counts was customized for the AbstractTestSet\n              this counts object is for. If a custom method was defined, always pass true\n              to the constructor.\npasses: The number of passing @test invocations.\nfails: The number of failing @test invocations.\nerrors: The number of erroring @test invocations.\nbroken: The number of broken @test invocations.\npasses: The cumulative number of passing @test invocations.\nfails: The cumulative number of failing @test invocations.\nerrors: The cumulative number of erroring @test invocations.\nbroken: The cumulative number of broken @test invocations.\nduration: The total duration the AbstractTestSet in question ran for, as a formatted String.\n\n\n\n\n\n"},{"title":"Test.get_test_counts","page":"Unit Testing","location":"stdlib/Test.html#Test.get_test_counts","category":"function","text":"\"\n    gettestcounts(::AbstractTestSet)::TestCounts\n\nRecursive function that counts the number of test results of each\ntype directly in the testset, and totals across the child testsets.\n\nCustom AbstractTestSet should implement this function to get their totals\ncounted & displayed with DefaultTestSet as well.\n\nIf this is not implemented for a custom TestSet, the printing falls back to\nreporting x for failures and ?s for the duration.\n\n\n\n\n\n"},{"title":"Test.format_duration","page":"Unit Testing","location":"stdlib/Test.html#Test.format_duration","category":"function","text":"format_duration(::AbstractTestSet)\n\nReturn a formatted string for printing the duration the testset ran for.\n\nIf not defined, falls back to \"?s\".\n\n\n\n\n\n"},{"title":"Test.print_test_results","page":"Unit Testing","location":"stdlib/Test.html#Test.print_test_results","category":"function","text":"print_test_results([io::IO], ts::AbstractTestSet, depth_pad=0)\n\nPrint the results of an AbstractTestSet as a formatted table.\n\ndepth_pad refers to how much padding should be added in front of all output.\nIf io is not provided, defaults to stdout.\n\nCalled inside of Test.finish, if the finished testset is the topmost\ntestset.\n\n\n\n\n\n"},{"title":"Test.GenericArray","page":"Unit Testing","location":"stdlib/Test.html#Test.GenericArray","category":"type","text":"The GenericArray can be used to test generic array APIs that program to\nthe AbstractArray interface, in order to ensure that functions can work\nwith array types besides the standard Array type.\n\n\n\n\n\n"},{"title":"Test.GenericDict","page":"Unit Testing","location":"stdlib/Test.html#Test.GenericDict","category":"type","text":"The GenericDict can be used to test generic dict APIs that program to\nthe AbstractDict interface, in order to ensure that functions can work\nwith associative types besides the standard Dict type.\n\n\n\n\n\n"},{"title":"Test.GenericOrder","page":"Unit Testing","location":"stdlib/Test.html#Test.GenericOrder","category":"type","text":"The GenericOrder can be used to test APIs for their support\nof generic ordered types.\n\n\n\n\n\n"},{"title":"Test.GenericSet","page":"Unit Testing","location":"stdlib/Test.html#Test.GenericSet","category":"type","text":"The GenericSet can be used to test generic set APIs that program to\nthe AbstractSet interface, in order to ensure that functions can work\nwith set types besides the standard Set and BitSet types.\n\n\n\n\n\n"},{"title":"Test.GenericString","page":"Unit Testing","location":"stdlib/Test.html#Test.GenericString","category":"type","text":"The GenericString can be used to test generic string APIs that program to\nthe AbstractString interface, in order to ensure that functions can work\nwith string types besides the standard String type.\n\n\n\n\n\n"},{"title":"Test.detect_ambiguities","page":"Unit Testing","location":"stdlib/Test.html#Test.detect_ambiguities","category":"function","text":"detect_ambiguities(mod1, mod2...; recursive=false,\n                                  ambiguous_bottom=false,\n                                  allowed_undefineds=nothing)\n\nReturn a vector of (Method,Method) pairs of ambiguous methods\ndefined in the specified modules.\nUse recursive=true to test in all submodules.\n\nambiguous_bottom controls whether ambiguities triggered only by\nUnion{} type parameters are included; in most cases you probably\nwant to set this to false. See Base.isambiguous.\n\nSee Test.detect_unbound_args for an explanation of\nallowed_undefineds.\n\ncompat: Julia 1.8\nallowed_undefineds requires at least Julia 1.8.\n\n\n\n\n\n"},{"title":"Test.detect_unbound_args","page":"Unit Testing","location":"stdlib/Test.html#Test.detect_unbound_args","category":"function","text":"detect_unbound_args(mod1, mod2...; recursive=false, allowed_undefineds=nothing)\n\nReturn a vector of Methods which may have unbound type parameters.\nUse recursive=true to test in all submodules.\n\nBy default, any undefined symbols trigger a warning. This warning can\nbe suppressed by supplying a collection of GlobalRefs for which\nthe warning can be skipped. For example, setting\n\nallowed_undefineds = Set([GlobalRef(Base, :active_repl),\n                          GlobalRef(Base, :active_repl_backend)])\n\nwould suppress warnings about Base.active_repl and\nBase.active_repl_backend.\n\ncompat: Julia 1.8\nallowed_undefineds requires at least Julia 1.8.\n\n\n\n\n\n"},{"title":"UUIDs","page":"UUIDs","location":"stdlib/UUIDs.html#UUIDs","category":"section","text":""},{"title":"UUIDs.uuid1","page":"UUIDs","location":"stdlib/UUIDs.html#UUIDs.uuid1","category":"function","text":"uuid1([rng::AbstractRNG])::UUID\n\nGenerates a version 1 (time-based) universally unique identifier (UUID), as specified\nby RFC 4122. Note that the Node ID is randomly generated (does not identify the host)\naccording to section 4.5 of the RFC.\n\nThe default rng used by uuid1 is not Random.default_rng() and every invocation of uuid1() without\nan argument should be expected to return a unique identifier. Importantly, the outputs of\nuuid1 do not repeat even when Random.seed!(seed) is called. Currently (as of Julia 1.6),\nuuid1 uses Random.RandomDevice as the default rng. However, this is an implementation\ndetail that may change in the future.\n\ncompat: Julia 1.6\nThe output of uuid1 does not depend on Random.default_rng() as of Julia 1.6.\n\nExamples\n\njulia> using Random\n\njulia> rng = MersenneTwister(1234);\n\njulia> uuid1(rng)\nUUID(\"cfc395e8-590f-11e8-1f13-43a2532b2fa8\")\n\n\n\n\n\n"},{"title":"UUIDs.uuid4","page":"UUIDs","location":"stdlib/UUIDs.html#UUIDs.uuid4","category":"function","text":"uuid4([rng::AbstractRNG])::UUID\n\nGenerates a version 4 (random or pseudo-random) universally unique identifier (UUID),\nas specified by RFC 4122.\n\nThe default rng used by uuid4 is not Random.default_rng() and every invocation of uuid4() without\nan argument should be expected to return a unique identifier. Importantly, the outputs of\nuuid4 do not repeat even when Random.seed!(seed) is called. Currently (as of Julia 1.6),\nuuid4 uses Random.RandomDevice as the default rng. However, this is an implementation\ndetail that may change in the future.\n\ncompat: Julia 1.6\nThe output of uuid4 does not depend on Random.default_rng() as of Julia 1.6.\n\nExamples\n\njulia> using Random\n\njulia> rng = Xoshiro(123);\n\njulia> uuid4(rng)\nUUID(\"856e446e-0c6a-472a-9638-f7b8557cd282\")\n\n\n\n\n\n"},{"title":"UUIDs.uuid5","page":"UUIDs","location":"stdlib/UUIDs.html#UUIDs.uuid5","category":"function","text":"uuid5(ns::UUID, name::String)::UUID\n\nGenerates a version 5 (namespace and domain-based) universally unique identifier (UUID),\nas specified by RFC 4122.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\nExamples\n\njulia> using Random\n\njulia> rng = Xoshiro(123);\n\njulia> u4 = uuid4(rng)\nUUID(\"856e446e-0c6a-472a-9638-f7b8557cd282\")\n\njulia> u5 = uuid5(u4, \"julia\")\nUUID(\"2df91e3f-da06-5362-a6fe-03772f2e14c9\")\n\n\n\n\n\n"},{"title":"UUIDs.uuid_version","page":"UUIDs","location":"stdlib/UUIDs.html#UUIDs.uuid_version","category":"function","text":"uuid_version(u::UUID)::Int\n\nInspects the given UUID and returns its version\n(see RFC 4122).\n\nExamples\n\njulia> uuid_version(uuid4())\n4\n\n\n\n\n\n"},{"title":"System Image Building","page":"System Image Building","location":"devdocs/sysimg.html#System-Image-Building","category":"section","text":""},{"title":"Building the Julia system image","page":"System Image Building","location":"devdocs/sysimg.html#Building-the-Julia-system-image","category":"section","text":"Julia ships with a preparsed system image containing the contents of the Base module, named\nsys.ji. This file is also precompiled into a shared library called sys.{so,dll,dylib} on\nas many platforms as possible, so as to give vastly improved startup times. On systems that do\nnot ship with a precompiled system image file, one can be generated from the source files shipped\nin Julia's DATAROOTDIR/julia/base folder.\n\nJulia will by default generate its system image on half of the available system threads. This\nmay be controlled by the JULIA_IMAGE_THREADS environment variable.\n\nThis operation is useful for multiple reasons. A user may:\n\nBuild a precompiled shared library system image on a platform that did not ship with one, thereby\nimproving startup times.\nModify Base, rebuild the system image and use the new Base next time Julia is started.\nInclude a userimg.jl file that includes packages into the system image, thereby creating a system\nimage that has packages embedded into the startup environment.\n\nThe PackageCompiler.jl package contains convenient\nwrapper functions to automate this process."},{"title":"System image optimized for multiple microarchitectures","page":"System Image Building","location":"devdocs/sysimg.html#sysimg-multi-versioning","category":"section","text":"The system image can be compiled simultaneously for multiple CPU microarchitectures\nunder the same instruction set architecture (ISA). Multiple versions of the same function\nmay be created with minimum dispatch point inserted into shared functions\nin order to take advantage of different ISA extensions or other microarchitecture features.\nThe version that offers the best performance will be selected automatically at runtime\nbased on available CPU features."},{"title":"Specifying multiple system image targets","page":"System Image Building","location":"devdocs/sysimg.html#Specifying-multiple-system-image-targets","category":"section","text":"A multi-microarchitecture system image can be enabled by passing multiple targets\nduring system image compilation. This can be done either with the JULIA_CPU_TARGET make option\nor with the -C command line option when running the compilation command manually.\nMultiple targets are separated by ; in the option string.\nThe syntax for each target is a CPU name followed by multiple features separated by ,.\nAll features supported by LLVM are supported and a feature can be disabled with a - prefix.\n(+ prefix is also allowed and ignored to be consistent with LLVM syntax).\nAdditionally, a few special features are supported to control the function cloning behavior.\n\nnote: Note\nIt is good practice to specify either clone_all or base(<n>) for every target apart from the first one. This makes it explicit which targets have all functions cloned, and which targets are based on other targets. If this is not done, the default behavior is to not clone every function, and to use the first target's function definition as the fallback when not cloning a function.\n\nclone_all\nBy default, only functions that are the most likely to benefit from\n the microarchitecture features will be cloned.\n When clone_all is specified for a target, however,\n all functions in the system image will be cloned for the target.\n The negative form -clone_all can be used to prevent the built-in\n heuristic from cloning all functions.\nbase(<n>)\nWhere <n> is a placeholder for a non-negative number (e.g. base(0), base(1)).\n By default, a partially cloned (i.e. not clone_all) target will use functions\n from the default target (first one specified) if a function is not cloned.\n This behavior can be changed by specifying a different base with the base(<n>) option.\n The nth target (0-based) will be used as the base target instead of the default (0th) one.\n The base target has to be either 0 or another clone_all target.\n Specifying a non-clone_all target as the base target will cause an error.\nopt_size\nThis causes the function for the target to be optimized for size when there isn't a significant\n runtime performance impact. This corresponds to -Os GCC and Clang option.\nmin_size\nThis causes the function for the target to be optimized for size that might have\n a significant runtime performance impact. This corresponds to -Oz Clang option.\n\nAs an example, at the time of this writing, the following string is used in the creation of\nthe official x86_64 Julia binaries downloadable from julialang.org:\n\ngeneric;sandybridge,-xsaveopt,clone_all;haswell,-rdrnd,base(1)\n\nThis creates a system image with three separate targets; one for a generic x86_64\nprocessor, one with a sandybridge ISA (explicitly excluding xsaveopt) that explicitly\nclones all functions, and one targeting the haswell ISA, based off of the sandybridge\nsysimg version, and also excluding rdrnd. When a Julia implementation loads the\ngenerated sysimg, it will check the host processor for matching CPU capability flags,\nenabling the highest ISA level possible. Note that the base level (generic) requires\nthe cx16 instruction, which is disabled in some virtualization software and must be\nenabled for the generic target to be loaded. Alternatively, a sysimg could be generated\nwith the target generic,-cx16 for greater compatibility, however note that this may cause\nperformance and stability problems in some code."},{"title":"Implementation overview","page":"System Image Building","location":"devdocs/sysimg.html#Implementation-overview","category":"section","text":"This is a brief overview of different part involved in the implementation.\nSee code comments for each components for more implementation details.\n\nSystem image compilation\nThe parsing and cloning decision are done in src/processor*.\n We currently support cloning of function based on the present of loops, simd instructions,\n or other math operations (e.g. fastmath, fma, muladd).\n This information is passed on to src/llvm-multiversioning.cpp which does the actual cloning.\n In addition to doing the cloning and insert dispatch slots\n (see comments in MultiVersioning::runOnModule for how this is done),\n the pass also generates metadata so that the runtime can load and initialize the\n system image correctly.\n A detailed description of the metadata is available in src/processor.h.\nSystem image loading\nThe loading and initialization of the system image is done in src/processor* by\n parsing the metadata saved during system image generation.\n Host feature detection and selection decision are done in src/processor_*.cpp\n depending on the ISA. The target selection will prefer exact CPU name match,\n larger vector register size, and larger number of features.\n An overview of this process is in src/processor.cpp."},{"title":"Trimming","page":"System Image Building","location":"devdocs/sysimg.html#Trimming","category":"section","text":"System images are typically quite large, since Base includes a lot of functionality, and by\ndefault system images also include several packages such as LinearAlgebra for convenience\nand backwards compatibility. Most programs will use only a fraction of the functions in\nthese packages. Therefore it makes sense to build binaries that exclude unused functions\nto save space, referred to as \"trimming\".\n\nWhile the basic idea of trimming is sound, Julia has dynamic and reflective features that make it\ndifficult (or impossible) to know in general which functions are unused. As an extreme example,\nconsider code like\n\ngetglobal(Base, Symbol(readchomp(stdin)))(1)\n\nThis code reads a function name from stdin and calls the named function from Base on the value\n1. In this case it is impossible to predict which function will be called, so no functions\ncan reliably be considered \"unused\". With some noteworthy exceptions (Julia's own REPL being\none of them), most real-world programs do not do things like this.\n\nLess extreme cases occur, for example, when there are type instabilities that make it impossible\nfor the compiler to predict which method will be called. However, if code is well-typed and does\nnot use reflection, a complete and (hopefully) relatively small set of needed methods can be\ndetermined, and the rest can be removed. The --trim command-line option requests this kind of\ncompilation.\n\nWhen --trim is specified in a command used to build a system image, the compiler begins\ntracing calls starting at methods marked using Base.Experimental.entrypoint. If a call is too\ndynamic to reasonably narrow down the possible call targets, an error is given at compile\ntime showing the location of the call. For testing purposes, it is possible to skip these\nerrors by specifying --trim=unsafe or --trim=unsafe-warn. Then you will get a system\nimage built, but it may crash at run time if needed code is not present.\n\nIt typically makes sense to specify --strip-ir along with --trim, since trimmed binaries\nare fully compiled and therefore don't need Julia IR. At some point we may make --trim imply\n--strip-ir, but for now we have kept them orthogonal.\n\nTo get the smallest possible binary, it will also help to specify --strip-metadata and\nrun the Unix strip utility. However, those steps remove Julia-specific and native (DWARF format)\ndebug info, respectively, and so will make debugging more difficult."},{"title":"Common problems","page":"System Image Building","location":"devdocs/sysimg.html#Common-problems","category":"section","text":"The Base global variables stdin, stdout, and stderr are non-constant and so their\ntypes are not known. All printing should use a specific IO object with a known type.\nThe easiest substitution is to use print(Core.stdout, x) instead of print(x) or\nprint(stdout, x).\nUse tools like JET.jl,\nCthulhu.jl, and/or\nSnoopCompile\nto identify failures of type-inference, and follow our Performance Tips to fix them."},{"title":"Compatibility concerns","page":"System Image Building","location":"devdocs/sysimg.html#Compatibility-concerns","category":"section","text":"We have identified many small changes to Base that significantly increase the set of programs\nthat can be reliably trimmed. Unfortunately some of those changes would be considered breaking,\nand so are only applied when trimming is requested (this is done by an external build script,\ncurrently maintained inside the test suite as contrib/juliac/juliac-buildscript.jl).\nTherefore in many cases trimming will require you to opt in to new variants of Base and some\nstandard libraries.\n\nIf you want to use trimming, it is important to set up continuous integration testing that\nperforms a trimmed build and fully tests the resulting program.\nFortunately, if your program successfully compiles with --trim then it is very likely to work\nthe same as it did before. However, CI is needed to ensure that your program continues to build\nwith trimming as you develop it.\n\nPackage authors may wish to test that their package is \"trimming safe\", however this is impossible\nin general. Trimming is only expected to work given concrete entry points such as main() and\nlibrary entry points meant to be called from outside Julia. For generic packages, existing tests\nfor type stability like @inferred and JET.@report_call are about as close as you can get to checking\ntrim compatibility.\n\nTrimming also introduces new compatibility issues between minor versions of Julia. At this time,\nwe are not able to guarantee that a program that can be trimmed in one version of Julia\ncan also be trimmed in all future versions of Julia. However, breakage of that kind is expected\nto be rare. We also plan to try to increase the set of programs that can be trimmed over time."},{"title":"Networking and Streams","page":"Networking and Streams","location":"manual/networking-and-streams.html#Networking-and-Streams","category":"section","text":"Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and\nTCP sockets.\nThese objects allow data to be sent and received in a stream-like fashion, which means that data is processed sequentially as it becomes available.\nThis interface, though asynchronous at the system level, is presented in a synchronous manner to the programmer.\nThis is achieved by making heavy use of Julia cooperative threading (coroutine)\nfunctionality."},{"title":"Basic Stream I/O","page":"Networking and Streams","location":"manual/networking-and-streams.html#Basic-Stream-I/O","category":"section","text":"All Julia streams expose at least a read and a write method, taking the\nstream as their first argument, e.g.:\n\njulia> write(stdout, \"Hello World\");  # suppress return value 11 with ;\nHello World\njulia> read(stdin, Char)\n\n'\\n': ASCII/Unicode U+000a (category Cc: Other, control)\n\nNote that write returns 11, the number of bytes (in \"Hello World\") written to stdout,\nbut this return value is suppressed with the ;.\n\nHere Enter was pressed again so that Julia would read the newline. Now, as you can see from this\nexample, write takes the data to write as its second argument, while read\ntakes the type of the data to be read as the second argument.\n\nFor example, to read a simple byte array, we could do:\n\njulia> x = zeros(UInt8, 4)\n4-element Vector{UInt8}:\n 0x00\n 0x00\n 0x00\n 0x00\n\njulia> read!(stdin, x)\nabcd\n4-element Vector{UInt8}:\n 0x61\n 0x62\n 0x63\n 0x64\n\nHowever, since this is slightly cumbersome, there are several convenience methods provided. For\nexample, we could have written the above as:\n\njulia> read(stdin, 4)\nabcd\n4-element Vector{UInt8}:\n 0x61\n 0x62\n 0x63\n 0x64\n\nor if we had wanted to read the entire line instead:\n\njulia> readline(stdin)\nabcd\n\"abcd\"\n\nNote that depending on your terminal settings, your TTY (\"teletype terminal\") may be line buffered and might thus require an additional enter before stdin data is sent to Julia.\nWhen running Julia from the command line in a TTY, output is sent to the console by default, and standard input is read from the keyboard.\n\nTo read every line from stdin you can use eachline:\n\nfor line in eachline(stdin)\n    print(\"Found $line\")\nend\n\nor read if you wanted to read by character instead:\n\nwhile !eof(stdin)\n    x = read(stdin, Char)\n    println(\"Found: $x\")\nend"},{"title":"Text I/O","page":"Networking and Streams","location":"manual/networking-and-streams.html#Text-I/O","category":"section","text":"Note that the write method mentioned above operates on binary streams. In particular,\nvalues do not get converted to any canonical text representation but are written out as is:\n\njulia> write(stdout, 0x61);  # suppress return value 1 with ;\na\n\nNote that a is written to stdout by the write function and that the returned\nvalue is 1 (since 0x61 is one byte).\n\nFor text I/O, use the print or show methods, depending on your needs (see\nthe documentation for these two methods for a detailed discussion of the difference between them):\n\njulia> print(stdout, 0x61)\n97\n\nSee Custom pretty-printing for more information on how to\nimplement display methods for custom types."},{"title":"IO Output Contextual Properties","page":"Networking and Streams","location":"manual/networking-and-streams.html#IO-Output-Contextual-Properties","category":"section","text":"Sometimes IO output can benefit from the ability to pass contextual information into show methods.\nThe IOContext object provides this framework for associating arbitrary metadata with an IO object.\nFor example, :compact => true adds a hinting parameter to the IO object that the invoked show method\nshould print a shorter output (if applicable). See the IOContext documentation for a list\nof common properties."},{"title":"Working with Files","page":"Networking and Streams","location":"manual/networking-and-streams.html#Working-with-Files","category":"section","text":"You can write content to a file with the write(filename::String, content) method:\n\njulia> write(\"hello.txt\", \"Hello, World!\")\n13\n\n(13 is the number of bytes written.)\n\nYou can read the contents of a file with the read(filename::String) method, or read(filename::String, String)\nto the contents as a string:\n\njulia> read(\"hello.txt\", String)\n\"Hello, World!\""},{"title":"Advanced: streaming files","page":"Networking and Streams","location":"manual/networking-and-streams.html#Advanced:-streaming-files","category":"section","text":"The read and write methods above allow you to read and write file contents. Like many other\nenvironments, Julia also has an open function, which takes a filename and\nreturns an IOStream object that you can use to read and write things from the file. For example,\nif we have a file, hello.txt, whose contents are Hello, World!:\n\njulia> f = open(\"hello.txt\")\nIOStream(<file hello.txt>)\n\njulia> readlines(f)\n1-element Vector{String}:\n \"Hello, World!\"\n\nIf you want to write to a file, you can open it with the write (\"w\") flag:\n\njulia> f = open(\"hello.txt\",\"w\")\nIOStream(<file hello.txt>)\n\njulia> write(f,\"Hello again.\")\n12\n\nIf you examine the contents of hello.txt at this point, you will notice that it is empty; nothing\nhas actually been written to disk yet. This is because the IOStream must be closed before the\nwrite is actually flushed to disk:\n\njulia> close(f)\n\nExamining hello.txt again will show its contents have been changed.\n\nOpening a file, doing something to its contents, and closing it again is a very common pattern.\nTo make this easier, there exists another invocation of open which takes a function\nas its first argument and filename as its second, opens the file, calls the function with the\nfile as an argument, and then closes it again. For example, given a function:\n\nfunction read_and_capitalize(f::IOStream)\n    return uppercase(read(f, String))\nend\n\nYou can call:\n\njulia> open(read_and_capitalize, \"hello.txt\")\n\"HELLO AGAIN.\"\n\nto open hello.txt, call read_and_capitalize on it, close hello.txt and return the capitalized\ncontents.\n\nTo avoid even having to define a named function, you can use the do syntax, which creates an\nanonymous function on the fly:\n\njulia> open(\"hello.txt\") do f\n           uppercase(read(f, String))\n       end\n\"HELLO AGAIN.\"\n\nIf you want to redirect stdout to a file\n\nout_file = open(\"output.txt\", \"w\")\n\n# Redirect stdout to file\nredirect_stdout(out_file) do\n    # Your code here\n    println(\"This output goes to `out_file` via the `stdout` variable.\")\nend\n\n# Close file\nclose(out_file)\n\n\nRedirecting stdout to a file can help you save and analyze program output, automate processes, and meet compliance requirements."},{"title":"A simple TCP example","page":"Networking and Streams","location":"manual/networking-and-streams.html#A-simple-TCP-example","category":"section","text":"Let's jump right in with a simple example involving TCP sockets.\nThis functionality is in a standard library package called Sockets.\nLet's first create a simple server:\n\njulia> using Sockets\n\njulia> errormonitor(Threads.@spawn begin\n           server = listen(2000)\n           while true\n               sock = accept(server)\n               println(\"Hello World\\n\")\n           end\n       end)\nTask (runnable) @0x00007fd31dc11ae0\n\nTo those familiar with the Unix socket API, the method names will feel familiar, though their\nusage is somewhat simpler than the raw Unix socket API. The first call to listen will\ncreate a server waiting for incoming connections on the specified port (2000) in this case. The\nsame function may also be used to create various other kinds of servers:\n\njulia> listen(2000) # Listens on localhost:2000 (IPv4)\nSockets.TCPServer(active)\n\njulia> listen(ip\"127.0.0.1\",2000) # Equivalent to the first\nSockets.TCPServer(active)\n\njulia> listen(ip\"::1\",2000) # Listens on localhost:2000 (IPv6)\nSockets.TCPServer(active)\n\njulia> listen(IPv4(0),2001) # Listens on port 2001 on all IPv4 interfaces\nSockets.TCPServer(active)\n\njulia> listen(IPv6(0),2001) # Listens on port 2001 on all IPv6 interfaces\nSockets.TCPServer(active)\n\njulia> listen(\"testsocket\") # Listens on a UNIX domain socket\nSockets.PipeServer(active)\n\njulia> listen(\"\\\\\\\\.\\\\pipe\\\\testsocket\") # Listens on a Windows named pipe\nSockets.PipeServer(active)\n\nNote that the return type of the last invocation is different. This is because this server does not\nlisten on TCP, but rather on a named pipe (Windows) or UNIX domain socket. Also note that Windows\nnamed pipe format has to be a specific pattern such that the name prefix (\\\\.\\pipe\\) uniquely\nidentifies the file type.\nThe difference between TCP and named pipes or\nUNIX domain sockets is subtle and has to do with the accept and connect\nmethods. The accept method retrieves a connection to the client that is connecting on\nthe server we just created, while the connect function connects to a server using the\nspecified method. The connect function takes the same arguments as listen,\nso, assuming the environment (i.e. host, cwd, etc.) is the same you should be able to pass the same\narguments to connect as you did to listen to establish the connection. So let's try that\nout (after having created the server above):\n\njulia> connect(2000)\nTCPSocket(open, 0 bytes waiting)\n\njulia> Hello World\n\nAs expected we saw \"Hello World\" printed. So, let's actually analyze what happened behind the\nscenes. When we called connect, we connect to the server we had just created. Meanwhile,\nthe accept function returns a server-side connection to the newly created socket and prints \"Hello\nWorld\" to indicate that the connection was successful.\n\nA great strength of Julia is that since the API is exposed synchronously even though the I/O is\nactually happening asynchronously, we didn't have to worry about callbacks or even making sure that\nthe server gets to run. When we called connect the current task waited for the connection\nto be established and only continued executing after that was done. In this pause, the server\ntask resumed execution (because a connection request was now available), accepted the connection,\nprinted the message and waited for the next client. Reading and writing works in the same way.\nTo see this, consider the following simple echo server:\n\njulia> errormonitor(Threads.@spawn begin\n           server = listen(2001)\n           while true\n               sock = accept(server)\n               Threads.@spawn while isopen(sock)\n                   write(sock, readline(sock, keep=true))\n               end\n           end\n       end)\nTask (runnable) @0x00007fd31dc12e60\n\njulia> clientside = connect(2001)\nTCPSocket(RawFD(28) open, 0 bytes waiting)\n\njulia> errormonitor(Threads.@spawn while isopen(clientside)\n           write(stdout, readline(clientside, keep=true))\n       end)\nTask (runnable) @0x00007fd31dc11870\n\njulia> println(clientside,\"Hello World from the Echo Server\")\nHello World from the Echo Server\n\nAs with other streams, use close to disconnect the socket:\n\njulia> close(clientside)"},{"title":"Resolving IP Addresses","page":"Networking and Streams","location":"manual/networking-and-streams.html#Resolving-IP-Addresses","category":"section","text":"One of the connect methods that does not follow the listen methods is\nconnect(host::String,port), which will attempt to connect to the host given by the host parameter\non the port given by the port parameter. It allows you to do things like:\n\njulia> connect(\"google.com\", 80)\nTCPSocket(RawFD(30) open, 0 bytes waiting)\n\nAt the base of this functionality is getaddrinfo, which will do the appropriate address\nresolution:\n\njulia> getaddrinfo(\"google.com\")\nip\"74.125.226.225\""},{"title":"Asynchronous I/O","page":"Networking and Streams","location":"manual/networking-and-streams.html#Asynchronous-I/O","category":"section","text":"All I/O operations exposed by Base.read and Base.write can be performed\nasynchronously through the use of coroutines. You can create a new coroutine to\nread from or write to a stream using the Threads.@spawn macro:\n\njulia> task = Threads.@spawn open(\"foo.txt\", \"w\") do io\n           write(io, \"Hello, World!\")\n       end;\n\njulia> wait(task)\n\njulia> readlines(\"foo.txt\")\n1-element Vector{String}:\n \"Hello, World!\"\n\nIt's common to run into situations where you want to perform multiple asynchronous operations\nconcurrently and wait until they've all completed. You can use the @sync macro to cause\nyour program to block until all of the coroutines it wraps around have exited:\n\njulia> using Sockets\n\njulia> @sync for hostname in (\"google.com\", \"github.com\", \"julialang.org\")\n           Threads.@spawn begin\n               conn = connect(hostname, 80)\n               write(conn, \"GET / HTTP/1.1\\r\\nHost:$(hostname)\\r\\n\\r\\n\")\n               readline(conn, keep=true)\n               println(\"Finished connection to $(hostname)\")\n           end\n       end\nFinished connection to google.com\nFinished connection to julialang.org\nFinished connection to github.com"},{"title":"Multicast","page":"Networking and Streams","location":"manual/networking-and-streams.html#Multicast","category":"section","text":"Julia supports multicast over IPv4 and IPv6 using the User Datagram Protocol (UDP) as transport.\n\nUnlike the Transmission Control Protocol (TCP), UDP makes almost no assumptions about the needs of the application.\nTCP provides flow control (it accelerates and decelerates to maximize throughput), reliability (lost or corrupt packets are automatically retransmitted), sequencing (packets are ordered by the operating system before they are given to the application), segment size, and session setup and teardown.\nUDP provides no such features.\n\nA common use for UDP is in multicast applications.\nTCP is a stateful protocol for communication between exactly two devices.\nUDP can use special multicast addresses to allow simultaneous communication between many devices."},{"title":"Receiving IP Multicast Packets","page":"Networking and Streams","location":"manual/networking-and-streams.html#Receiving-IP-Multicast-Packets","category":"section","text":"To transmit data over UDP multicast, simply recv on the socket, and the first packet received will be returned. Note that it may not be the first packet that you sent however!\n\nusing Sockets\ngroup = ip\"228.5.6.7\"\nsocket = Sockets.UDPSocket()\nbind(socket, ip\"0.0.0.0\", 6789)\njoin_multicast_group(socket, group)\nprintln(String(recv(socket)))\nleave_multicast_group(socket, group)\nclose(socket)"},{"title":"Sending IP Multicast Packets","page":"Networking and Streams","location":"manual/networking-and-streams.html#Sending-IP-Multicast-Packets","category":"section","text":"To transmit data over UDP multicast, simply send to the socket.\nNotice that it is not necessary for a sender to join the multicast group.\n\nusing Sockets\ngroup = ip\"228.5.6.7\"\nsocket = Sockets.UDPSocket()\nsend(socket, group, 6789, \"Hello over IPv4\")\nclose(socket)"},{"title":"IPv6 Example","page":"Networking and Streams","location":"manual/networking-and-streams.html#IPv6-Example","category":"section","text":"This example gives the same functionality as the previous program, but uses IPv6 as the network-layer protocol.\n\nListener:\n\nusing Sockets\ngroup = Sockets.IPv6(\"ff05::5:6:7\")\nsocket = Sockets.UDPSocket()\nbind(socket, Sockets.IPv6(\"::\"), 6789)\njoin_multicast_group(socket, group)\nprintln(String(recv(socket)))\nleave_multicast_group(socket, group)\nclose(socket)\n\nSender:\n\nusing Sockets\ngroup = Sockets.IPv6(\"ff05::5:6:7\")\nsocket = Sockets.UDPSocket()\nsend(socket, group, 6789, \"Hello over IPv6\")\nclose(socket)"},{"title":"ARM (Linux)","page":"ARM (Linux)","location":"devdocs/build/arm.html#ARM-(Linux)","category":"section","text":"Julia fully supports ARMv8 (AArch64) processors, and supports ARMv7 and ARMv6\n(AArch32) with some caveats. This file provides general guidelines for compilation,\nin addition to instructions for specific devices.\n\nA list of known issues for ARM is\navailable. If you encounter difficulties, please create an issue including the output\nfrom cat /proc/cpuinfo."},{"title":"32-bit (ARMv6, ARMv7)","page":"ARM (Linux)","location":"devdocs/build/arm.html#32-bit-(ARMv6,-ARMv7)","category":"section","text":"Julia has been successfully compiled on several variants of the following ARMv6 & ARMv7 devices:\n\nARMv7 / Cortex A15 Samsung Chromebooks running Ubuntu Linux under Crouton;\nRaspberry Pi.\nOdroid.\n\nJulia requires at least the armv6 and vfpv2 instruction sets. It's recommended to use  armv7-a.\narmv5 or soft float are not supported."},{"title":"Raspberry Pi 1 / Raspberry Pi Zero","page":"ARM (Linux)","location":"devdocs/build/arm.html#Raspberry-Pi-1-/-Raspberry-Pi-Zero","category":"section","text":"If the type of ARM CPU used in the Raspberry Pi is not detected by LLVM, then explicitly set the\nCPU target by adding the following to Make.user:\n\nJULIA_CPU_TARGET=arm1176jzf-s\n\nTo complete the build, you may need to increase the swap file size. To do so, edit\n/etc/dphys-swapfile, changing the line:\n\nCONF_SWAPSIZE=100\n\nto:\n\nCONF_SWAPSIZE=512\n\nbefore restarting the swapfile service:\n\nsudo /etc/init.d/dphys-swapfile stop\nsudo /etc/init.d/dphys-swapfile start"},{"title":"Raspberry Pi 2","page":"ARM (Linux)","location":"devdocs/build/arm.html#Raspberry-Pi-2","category":"section","text":"The type of ARM CPU used in the Raspberry Pi 2 is not detected by LLVM. Explicitly set the\nCPU target by adding the following to Make.user:\n\nJULIA_CPU_TARGET=cortex-a7\n\nDepending on the exact compiler and distribution, there might be a build failure\ndue to unsupported inline assembly. In that case, add MCPU=armv7-a to\nMake.user."},{"title":"AArch64 (ARMv8)","page":"ARM (Linux)","location":"devdocs/build/arm.html#AArch64-(ARMv8)","category":"section","text":"Julia is expected to work and build on ARMv8 cpus. One should follow the general build instructions. Julia expects to have around 8GB of ram or swap enabled to build itself."},{"title":"Known issues","page":"ARM (Linux)","location":"devdocs/build/arm.html#Known-issues","category":"section","text":"Starting from Julia v1.10, JITLink is automatically enabled on this architecture for all operating systems when linking to LLVM 15 or later versions.\nDue to a bug in LLVM memory manager, non-trivial workloads may generate too many memory mappings that on Linux can exceed the limit of memory mappings (mmap) set in the file /proc/sys/vm/max_map_count, resulting in an error like\n\nJIT session error: Cannot allocate memory\n\nShould this happen, ask your system administrator to increase the limit of memory mappings for example with the command\n\nsysctl -w vm.max_map_count=262144"},{"title":"Documentation","page":"Documentation","location":"manual/documentation.html#man-documentation","category":"section","text":""},{"title":"Accessing Documentation","page":"Documentation","location":"manual/documentation.html#Accessing-Documentation","category":"section","text":"Documentation can be accessed at the REPL or in IJulia\nby typing ? followed by the name of a function or macro, and pressing Enter. For example,\n\n?cos\n?@time\n?r\"\"\n\nwill show documentation for the relevant function, macro or string macro respectively. Most Julia\nenvironments provide a way to access documentation directly:\n\nVS Code shows documentation when you hover over a function name.\nYou can also use the Julia panel in the sidebar to search for documentation.\nIn Pluto, open the \"Live Docs\" panel on the bottom right.\nIn Juno using Ctrl-J, Ctrl-D will show the documentation for the object\nunder the cursor.\n\nDocs.hasdoc(module, name)::Bool tells whether a name has a docstring. Docs.undocumented_names(module; all)\nreturns the undocumented names in a module."},{"title":"Writing Documentation","page":"Documentation","location":"manual/documentation.html#man-writing-documentation","category":"section","text":"Julia enables package developers and users to document functions, types and other objects easily\nvia a built-in documentation system.\n\nThe basic syntax is simple: any string appearing just before an object\n(function, macro, type or instance) will be interpreted as documenting it (these are called\ndocstrings). Note that no blank lines or comments may intervene between a docstring and\nthe documented object. Here is a basic example:\n\n\"Tell whether there are too many foo items in the array.\"\nfoo(xs::Array) = ...\n\nnote: Reminder\nAny empty lines between the docstring and the object being documented detach the former from the latter, making the docstring ineffective.\n\nDocumentation is interpreted as Markdown, so you can\nuse indentation and code fences to delimit code examples from text. Technically, any object can\nbe associated with any other as metadata; Markdown happens to be the default, but one can construct\nother string macros and pass them to the @doc macro just as well.\n\nnote: Note\nMarkdown support is implemented in the Markdown standard library\nand for a full list of supported syntax see the\ndocumentation.\n\nHere is a more complex example, still using Markdown:\n\n\"\"\"\n    bar(x[, y])\n\nCompute the Bar index between `x` and `y`.\n\nIf `y` is unspecified, compute the Bar index between all pairs of columns of `x`.\n\n# Examples\n```julia-repl\njulia> bar([1, 2], [1, 2])\n1\n```\n\"\"\"\nfunction bar(x, y) ...\n\nAs in the example above, we recommend following some simple conventions when writing documentation:\n\nAlways show the signature of a function at the top of the documentation, with a four-space indent\nso that it is printed as Julia code.\nThis can be identical to the signature present in the Julia code (like mean(x::AbstractArray)),\nor a simplified form. Optional arguments should be represented with their default values (i.e.\nf(x, y=1)) when possible, following the actual Julia syntax. Optional arguments which do not\nhave a default value should be put in brackets (i.e. f(x[, y]) and f(x[, y[, z]])). An alternative\nsolution is to use several lines: one without optional arguments, the other(s) with them. This\nsolution can also be used to document several related methods of a given function. When a function\naccepts many keyword arguments, only include a <keyword arguments> placeholder in the signature\n(i.e. f(x; <keyword arguments>)), and give the complete list under an # Arguments section\n(see point 4 below).\nUse this style to document the return type or give the return value a name:\n# Naming the return value or its type is not necessary (this is the most common case)\n\"\"\"\n   sum(itr; [init])\n\n...\n\"\"\"\n\n# The return type is easily documented and critical to the semantics of this function\n\"\"\"\n   vec(x::AbstractArray)::AbstractVector\n\n...\n\"\"\"\n\n# Naming and/or destructuring the return value clarifies the semantics of this function\n\"\"\"\n   splitdir(path::AbstractString) -> (dir::AbstractString, file::AbstractString)\n...\n\"\"\"\nWhen included, a return type should be written after the signature, separated by ::,\nwhile a named return value should be separated by ->, with a space on both sides.\nReturn types and return values should be valid Julia expressions when possible.\nMacro docstring signatures that annotate return types or return values should use\nparentheses to clarify where the macro arguments end and return type or return value begins.\nInclude a single one-line sentence describing what the function does or what the object represents\nafter the simplified signature block. If needed, provide more details in a second paragraph, after\na blank line.\nThe one-line sentence should use the imperative form (\"Do this\", \"Return that\") instead of the\nthird person (do not write \"Returns the length...\") when documenting functions. It should end\nwith a period. If the meaning of a function cannot be summarized easily, splitting it into separate\ncomposable parts could be beneficial (this should not be taken as an absolute requirement for\nevery single case though).\nDo not repeat yourself.\nSince the function name is given by the signature, there is no need to start the documentation\nwith \"The function bar...\": go straight to the point. Similarly, if the signature specifies\nthe types of the arguments, mentioning them in the description is redundant.\nOnly provide an argument list when really necessary.\nFor simple functions, it is often clearer to mention the role of the arguments directly in the\ndescription of the function's purpose. An argument list would only repeat information already\nprovided elsewhere. However, providing an argument list can be a good idea for complex functions\nwith many arguments (in particular keyword arguments). In that case, insert it after the general\ndescription of the function, under an # Arguments header, with one - bullet for each argument.\nThe list should mention the types and default values (if any) of the arguments:\n\"\"\"\n...\n# Arguments\n- `n::Integer`: the number of elements to compute.\n- `dim::Integer=1`: the dimensions along which to perform the computation.\n...\n\"\"\"\nProvide hints to related functions.\nSometimes there are functions of related functionality. To increase discoverability please provide\na short list of these in a See also paragraph.\nSee also [`bar!`](@ref), [`baz`](@ref), [`baaz`](@ref).\nInclude any code examples in an # Examples section.\nExamples should, whenever possible, be written as doctests. A doctest is a fenced code block\n(see Code blocks) starting with ```jldoctest and contains any number of julia>\nprompts together with inputs and expected outputs that mimic the Julia REPL.\nnote: Note\nDoctests are enabled by Documenter.jl.\nFor more detailed documentation see Documenter's\nmanual.\nFor example in the following docstring a variable a is defined and the expected result, as printed\nin a Julia REPL, appears afterwards:\n\"\"\"\nSome nice documentation here.\n\n# Examples\n```jldoctest\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n```\n\"\"\"\nwarning: Warning\nCalling rand and other RNG-related functions should be avoided in doctests since they will not\nproduce consistent outputs during different Julia sessions. If you would like to show some random\nnumber generation related functionality, one option is to explicitly construct and seed your own\nRNG object (see Random) and pass it to the functions you are doctesting.Operating system word size (Int32 or Int64) as well as path separator differences\n(/ or \\) will also affect the reproducibility of some doctests.Note that whitespace in your doctest is significant! The doctest will fail if you misalign the\noutput of pretty-printing an array, for example.\nYou can then run make -C doc doctest=true to run all the doctests in the Julia Manual and API\ndocumentation, which will ensure that your example works.\nTo indicate that the output result is truncated, you may write\n[...] at the line where checking should stop. This is useful to\nhide a stacktrace (which contains non-permanent references to lines\nof julia code) when the doctest shows that an exception is thrown,\nfor example:\n```jldoctest\njulia> div(1, 0)\nERROR: DivideError: integer division error\n[...]\n```\nExamples that are untestable should be written within fenced code blocks starting with ```julia\nso that they are highlighted correctly in the generated documentation.\ntip: Tip\nWherever possible examples should be self-contained and runnable so that readers are able\nto try them out without having to include any dependencies.\nUse backticks to identify code and equations.\nJulia identifiers and code excerpts should always appear between backticks ` to enable\nhighlighting. Equations in the LaTeX syntax can be inserted between double backticks ``.\nUse Unicode characters rather than their LaTeX escape sequence, i.e. ``α = 1`` rather\nthan ``\\\\alpha = 1``.\nPlace the starting and ending \"\"\" characters on lines by themselves.\nThat is, write:\n\"\"\"\n...\n\n...\n\"\"\"\nf(x, y) = ...\nrather than:\n\"\"\"...\n\n...\"\"\"\nf(x, y) = ...\nThis makes it clearer where docstrings start and end.\nRespect the line length limit used in the surrounding code.\nDocstrings are edited using the same tools as code. Therefore, the same conventions should apply.\nIt is recommended that lines are at most 92 characters wide.\nProvide information allowing custom types to implement the function in an\n# Implementation section. These implementation details are intended for developers\nrather than users, explaining e.g. which functions should be overridden and which\nfunctions automatically use appropriate fallbacks. Such details are best kept separate\nfrom the main description of the function's behavior.\nFor long docstrings, consider splitting the documentation with an\n# Extended help header. The typical help-mode will show only the\nmaterial above the header; you can access the full help by adding a '?'\nat the beginning of the expression (i.e., \"??foo\" rather than \"?foo\")."},{"title":"Functions & Methods","page":"Documentation","location":"manual/documentation.html#Functions-and-Methods","category":"section","text":"Functions in Julia may have multiple implementations, known as methods. While it's good practice\nfor generic functions to have a single purpose, Julia allows methods to be documented individually\nif necessary. In general, only the most generic method should be documented, or even the function\nitself (i.e. the object created without any methods by function bar end). Specific methods should\nonly be documented if their behaviour differs from the more generic ones. In any case, they should\nnot repeat the information provided elsewhere. For example:\n\n\"\"\"\n    *(x, y, z...)\n\nMultiplication operator. `x * y * z *...` calls this function with multiple\narguments, i.e. `*(x, y, z...)`.\n\"\"\"\nfunction *(x, y, z...)\n    # ... [implementation sold separately] ...\nend\n\n\"\"\"\n    *(x::AbstractString, y::AbstractString, z::AbstractString...)\n\nWhen applied to strings, concatenates them.\n\"\"\"\nfunction *(x::AbstractString, y::AbstractString, z::AbstractString...)\n    # ... [insert secret sauce here] ...\nend\n\nhelp?> *\nsearch: * .*\n\n  *(x, y, z...)\n\n  Multiplication operator. x * y * z *... calls this function with multiple\n  arguments, i.e. *(x,y,z...).\n\n  *(x::AbstractString, y::AbstractString, z::AbstractString...)\n\n  When applied to strings, concatenates them.\n\nWhen retrieving documentation for a generic function, the metadata for each method is concatenated\nwith the catdoc function, which can of course be overridden for custom types."},{"title":"Advanced Usage","page":"Documentation","location":"manual/documentation.html#Advanced-Usage","category":"section","text":"The @doc macro associates its first argument with its second in a per-module dictionary called\nMETA.\n\nTo make it easier to write documentation, the parser treats the macro name @doc specially:\nif a call to @doc has one argument, but another expression appears after a single line\nbreak, then that additional expression is added as an argument to the macro.\nTherefore the following syntax is parsed as a 2-argument call to @doc:\n\n@doc raw\"\"\"\n...\n\"\"\"\nf(x) = x\n\nThis makes it possible to use expressions other than normal string literals (such as the raw\"\" string macro) as a docstring.\n\nWhen used for retrieving documentation, the @doc macro (or equally, the doc function) will\nsearch all META dictionaries for metadata relevant to the given object and return it. The returned\nobject (some Markdown content, for example) will by default display itself intelligently. This\ndesign also makes it easy to use the doc system in a programmatic way; for example, to re-use\ndocumentation between different versions of a function:\n\n@doc \"...\" foo!\n@doc (@doc foo!) foo\n\ncompat: Julia 1.11\nIn Julia 1.11 and newer, retrieving documentation with the @doc macro requires that\nthe REPL stdlib is loaded.\n\nOr for use with Julia's metaprogramming functionality:\n\nfor (f, op) in ((:add, :+), (:subtract, :-), (:multiply, :*), (:divide, :/))\n    @eval begin\n        $f(a, b) = $op(a, b)\n    end\nend\n@doc \"`add(a, b)` adds `a` and `b` together\" add\n@doc \"`subtract(a, b)` subtracts `b` from `a`\" subtract\n\nDocumentation in non-toplevel blocks, such as begin, if, for, let, and\ninner constructors, should be added to the documentation system via @doc as\nwell. For example:\n\nif condition()\n    @doc \"...\"\n    f(x) = x\nend\n\nwill add documentation to f(x) when condition() is true. Note that even if f(x) goes\nout of scope at the end of a block, its documentation will remain.\n\nIt is possible to make use of metaprogramming to assist in the creation of documentation.\nWhen using string-interpolation within the docstring you will need to use an extra $ as\nshown with $($name):\n\nfor func in (:day, :dayofmonth)\n    name = string(func)\n    @eval begin\n        @doc \"\"\"\n            $($name)(dt::TimeType) -> Int64\n\n        The day of month of a `Date` or `DateTime` as an `Int64`.\n        \"\"\" $func(dt::Dates.TimeType)\n    end\nend"},{"title":"Dynamic documentation","page":"Documentation","location":"manual/documentation.html#Dynamic-documentation","category":"section","text":"Sometimes the appropriate documentation for an instance of a type depends on the field values of that\ninstance, rather than just on the type itself. In these cases, you can add a method to Docs.getdoc\nfor your custom type that returns the documentation on a per-instance basis. For instance,\n\nstruct MyType\n    value::Int\nend\n\nDocs.getdoc(t::MyType) = \"Documentation for MyType with value $(t.value)\"\n\nx = MyType(1)\ny = MyType(2)\n\n?x will display \"Documentation for MyType with value 1\" while ?y will display\n\"Documentation for MyType with value 2\"."},{"title":"Syntax Guide","page":"Documentation","location":"manual/documentation.html#Syntax-Guide","category":"section","text":"This guide provides a comprehensive overview of how to attach documentation to all Julia syntax\nconstructs for which providing documentation is possible.\n\nIn the following examples \"...\" is used to illustrate an arbitrary docstring."},{"title":"$ and \\ characters","page":"Documentation","location":"manual/documentation.html#and-\\-characters","category":"section","text":"The $ and \\ characters are still parsed as string interpolation or start of an escape sequence\nin docstrings too. The raw\"\" string macro together with the @doc macro can be used to avoid\nhaving to escape them. This is handy when the docstrings include LaTeX or Julia source code examples\ncontaining interpolation:\n\n@doc raw\"\"\"\n```math\n\\LaTeX\n```\n\"\"\"\nfunction f end"},{"title":"Functions and Methods","page":"Documentation","location":"manual/documentation.html#Functions-and-Methods-2","category":"section","text":"\"...\"\nfunction f end\n\n\"...\"\nf\n\nAdds docstring \"...\" to the function f. The first version is the preferred syntax, however both\nare equivalent.\n\n\"...\"\nf(x) = x\n\n\"...\"\nfunction f(x)\n    return x\nend\n\n\"...\"\nf(x)\n\nAdds docstring \"...\" to the method f(::Any).\n\n\"...\"\nf(x, y = 1) = x + y\n\nAdds docstring \"...\" to two Methods, namely f(::Any) and f(::Any, ::Any)."},{"title":"Macros","page":"Documentation","location":"manual/documentation.html#Macros","category":"section","text":"\"...\"\nmacro m(x) end\n\nAdds docstring \"...\" to the @m(::Any) macro definition.\n\n\"...\"\n:(@m1)\n\n\"...\"\nmacro m2 end\n\nAdds docstring \"...\" to the macros named @m1 and @m2."},{"title":"Types","page":"Documentation","location":"manual/documentation.html#Types","category":"section","text":"\"...\"\nabstract type T1 end\n\n\"...\"\nmutable struct T2\n    ...\nend\n\n\"...\"\nstruct T3\n    ...\nend\n\nAdds the docstring \"...\" to types T1, T2, and T3.\n\n\"...\"\nT1\n\n\"...\"\nT2\n\n\"...\"\nT3\n\nAdds the docstring \"...\" to types T1, T2, and T3.\nThe previous version is the preferred syntax, however both are equivalent.\n\n\"...\"\nstruct T\n    \"x\"\n    x\n    \"y\"\n    y\n\n    @doc \"Inner constructor\"\n    function T()\n        new(...)\n    end\nend\n\nAdds docstring \"...\" to type T, \"x\" to field T.x, \"y\" to field T.y,\nand \"Inner constructor\" to the inner constructor T(). Also applicable to\nmutable struct types."},{"title":"Modules","page":"Documentation","location":"manual/documentation.html#Modules","category":"section","text":"\"...\"\nmodule M end\n\nmodule M\n\n\"...\"\nM\n\nend\n\nAdds docstring \"...\" to the Module M. Adding the docstring above the Module is the preferred\nsyntax, however both are equivalent.\n\nThe module docstring is evaluated inside the scope of the module, allowing\naccess to all the symbols defined in and imported into the module:\n\n\"The magic number is $(MAGIC).\"\nmodule DocStringEval\nconst MAGIC = 42\nend\n\nDocumenting a baremodule by placing a docstring above the expression automatically imports\n@doc into the module. These imports must be done manually when the module expression is not\ndocumented:\n\n\"...\"\nbaremodule M\n# ...\nend\n\nbaremodule M\n\nimport Base: @doc\n\n\"...\"\nf(x) = x\n\nend"},{"title":"Global Variables","page":"Documentation","location":"manual/documentation.html#Global-Variables","category":"section","text":"\"...\"\nconst a = 1\n\n\"...\"\nb = 2\n\n\"...\"\nglobal c = 3\n\nAdds docstring \"...\" to the Bindings a, b, and c.\n\nBindings are used to store a reference to a particular Symbol in a Module without storing\nthe referenced value itself.\n\nnote: Note\nWhen a const definition is only used to define an alias of another definition, such as is the\ncase with the function div and its alias ÷ in Base, do not document the alias and instead\ndocument the actual function.If the alias is documented and not the real definition then the docsystem (? mode) will not\nreturn the docstring attached to the alias when the real definition is searched for.For example you should write\"...\"\nf(x) = x + 1\nconst alias = frather thanf(x) = x + 1\n\"...\"\nconst alias = f\n\n\"...\"\nsym\n\nAdds docstring \"...\" to the value associated with sym. However, it is preferred that\nsym is documented where it is defined."},{"title":"Multiple Objects","page":"Documentation","location":"manual/documentation.html#Multiple-Objects","category":"section","text":"\"...\"\na, b\n\nAdds docstring \"...\" to a and b each of which should be a documentable expression. This\nsyntax is equivalent to\n\n\"...\"\na\n\n\"...\"\nb\n\nAny number of expressions many be documented together in this way. This syntax can be useful when\ntwo functions are related, such as non-mutating and mutating versions f and f!."},{"title":"Macro-generated code","page":"Documentation","location":"manual/documentation.html#Macro-generated-code","category":"section","text":"\"...\"\n@m expression\n\nAdds docstring \"...\" to the expression generated by expanding @m expression. This allows\nfor expressions decorated with @inline, @noinline, @generated, or any other macro to\nbe documented in the same way as undecorated expressions.\n\nMacro authors should take note that only macros that generate a single expression will automatically\nsupport docstrings. If a macro returns a block containing multiple subexpressions then the subexpression\nthat should be documented must be marked using the @__doc__ macro.\n\nThe @enum macro makes use of @__doc__ to allow for documenting Enums.\nExamining its definition\nshould serve as an example of how to use @__doc__ correctly."},{"title":"Core.@__doc__","page":"Documentation","location":"manual/documentation.html#Core.@__doc__","category":"macro","text":"@__doc__(ex)\n\nLow-level macro used to mark expressions returned by a macro that should be documented. If\nmore than one expression is marked then the same docstring is applied to each expression.\n\nmacro example(f)\n    quote\n        $(f)() = 0\n        @__doc__ $(f)(x) = 1\n        $(f)(x, y) = 2\n    end |> esc\nend\n\n@__doc__ has no effect when a macro that uses it is not documented.\n\ncompat: Julia 1.12\nThis section documents a very subtle corner case that is only relevant to\nmacros which themselves both define other macros and then attempt to use them\nwithin the same expansion. Such macros were impossible to write prior to\nJulia 1.12 and are still quite rare. If you are not writing such a macro,\nyou may ignore this note.In versions prior to Julia 1.12, macroexpansion would recursively expand through\nExpr(:toplevel) blocks. This behavior was changed in Julia 1.12 to allow\nmacros to recursively define other macros and use them in the same returned\nexpression. However, to preserve backwards compatibility with existing uses of\n@__doc__, the doc system will still expand through Expr(:toplevel) blocks\nwhen looking for @__doc__ markers. As a result, macro-defining-macros will\nhave an observable behavior difference when annotated with a docstring:julia> macro macroception()\n    Expr(:toplevel, :(macro foo() 1 end), :(@foo))\nend\n\njulia> @macroception\n1\n\njulia> \"Docstring\" @macroception\nERROR: LoadError: UndefVarError: `@foo` not defined in `Main`The supported workaround is to manually expand the @__doc__ macro in the\ndefining macro, which the docsystem will recognize and suppress the recursive\nexpansion:julia> macro macroception()\n    Expr(:toplevel,\n        macroexpand(__module__, :(@__doc__ macro foo() 1 end); recursive=false),\n        :(@foo))\nend\n\njulia> @macroception\n1\n\njulia> \"Docstring\" @macroception\n1\n\n\n\n\n\n"},{"title":"Sanitizer support","page":"Sanitizer support","location":"devdocs/sanitizers.html#Sanitizer-support","category":"section","text":"Sanitizers can be used in custom Julia builds to make it\neasier to detect certain kinds of errors in Julia's internal C/C++ code."},{"title":"Address Sanitizer: easy build","page":"Sanitizer support","location":"devdocs/sanitizers.html#Address-Sanitizer:-easy-build","category":"section","text":"From a source-checkout of Julia, you should be able to build a version\nsupporting address sanitization in Julia and LLVM as follows:\n\n$ mkdir /tmp/julia\n$ contrib/asan/build.sh /tmp/julia/\n\nHere we've chosen /tmp/julia as a build directory, but you can\nchoose whatever you wish. Once built, run the workload you wish to\ntest with /tmp/julia/julia. Memory bugs will result in errors.\n\nIf you require customization or further detail, see the documentation below."},{"title":"General considerations","page":"Sanitizer support","location":"devdocs/sanitizers.html#General-considerations","category":"section","text":"Using Clang's sanitizers obviously requires you to use Clang, but there's another\ncatch: most sanitizers require a run-time library, provided by the host compiler, while the instrumented\ncode generated by Julia's JIT relies on functionality from that library. This implies that the\nLLVM version of your host compiler must match that of the LLVM library used within Julia.\n\nAn easy solution is to have a dedicated build folder for providing a matching toolchain, by building\nwith BUILD_LLVM_CLANG=1. You can then refer to this toolchain from another build\nfolder by overriding the CC and CXX variables.\n\nThe sanitizers error out when they detect a shared library being opened using RTLD_DEEPBIND\n(ref: google/sanitizers#611).\nSince libblastrampoline by default\nuses RTLD_DEEPBIND, we need to set the environment variable LBT_USE_RTLD_DEEPBIND=0\nwhen using a sanitizer.\n\nTo use one of the sanitizers set SANITIZE=1 and then the appropriate flag for the sanitizer you\nwant to use.\n\nOn macOS, this might need some extra flags also to work. Altogether, it might\nlook like this, plus one or more of the SANITIZE_* flags listed below:\n\nmake -C deps USE_BINARYBUILDER_LLVM=0 LLVM_VER=svn stage-llvm\n\nmake -C src SANITIZE=1 \\\n    CC=~+/deps/scratch/llvm-svn/build_Release/bin/clang \\\n    CXX=~+/deps/scratch/llvm-svn/build_Release/bin/clang++ \\\n    CPPFLAGS=\"-isysroot $(xcode-select -p)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk\" \\\n    CXXFLAGS=\"-isystem $(xcode-select -p)/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1\"\n\n(or put these into your Make.user, so you don't need to remember them every time)."},{"title":"Address Sanitizer (ASAN)","page":"Sanitizer support","location":"devdocs/sanitizers.html#Address-Sanitizer-(ASAN)","category":"section","text":"For detecting or debugging memory bugs, you can use Clang's address sanitizer (ASAN).\nBy compiling with SANITIZE_ADDRESS=1 you enable ASAN for the Julia compiler and its generated code.\nIn addition, you can specify LLVM_SANITIZE=1 to sanitize the LLVM library as well. Note that\nthese options incur a high performance and memory cost. For example, using ASAN for Julia and\nLLVM makes testall1 take 8-10 times as long while using 20 times as much memory (this can be\nreduced to respectively a factor of 3 and 4 by using the options described below).\n\nBy default, Julia sets the allow_user_segv_handler=1 ASAN flag, which is required for signal\ndelivery to work properly. You can define other options using the ASAN_OPTIONS environment flag,\nin which case you'll need to repeat the default option mentioned before. For example, memory usage\ncan be reduced by specifying fast_unwind_on_malloc=0 and malloc_context_size=2, at the cost\nof backtrace accuracy. For now, Julia also sets detect_leaks=0, but this should be removed in\nthe future."},{"title":"Example setup","page":"Sanitizer support","location":"devdocs/sanitizers.html#Example-setup","category":"section","text":""},{"title":"Step 1: Install toolchain","page":"Sanitizer support","location":"devdocs/sanitizers.html#Step-1:-Install-toolchain","category":"section","text":"Checkout a Git worktree (or create out-of-tree build directory) at\n$TOOLCHAIN_WORKTREE and create a config file $TOOLCHAIN_WORKTREE/Make.user\nwith\n\nUSE_BINARYBUILDER_LLVM=1\nBUILD_LLVM_CLANG=1\n\nRun:\n\ncd $TOOLCHAIN_WORKTREE\nmake -C deps install-llvm install-clang install-llvm-tools\n\nto install toolchain binaries in $TOOLCHAIN_WORKTREE/usr/tools"},{"title":"Step 2: Build Julia with ASAN","page":"Sanitizer support","location":"devdocs/sanitizers.html#Step-2:-Build-Julia-with-ASAN","category":"section","text":"Checkout a Git worktree (or create out-of-tree build directory) at\n$BUILD_WORKTREE and create a config file $BUILD_WORKTREE/Make.user with\n\nTOOLCHAIN=$(TOOLCHAIN_WORKTREE)/usr/tools\n\n# use our new toolchain\noverride CC=$(TOOLCHAIN)/clang\noverride CXX=$(TOOLCHAIN)/clang++\nexport ASAN_SYMBOLIZER_PATH=$(TOOLCHAIN)/llvm-symbolizer\n\nUSE_BINARYBUILDER_LLVM=1\n\noverride SANITIZE=1\noverride SANITIZE_ADDRESS=1\n\n# make the GC use regular malloc/frees, which are hooked by ASAN\noverride WITH_GC_DEBUG_ENV=1\n\n# default to a debug build for better line number reporting\noverride JULIA_BUILD_MODE=debug\n\n# make ASAN consume less memory\nexport ASAN_OPTIONS=detect_leaks=0:fast_unwind_on_malloc=0:allow_user_segv_handler=1:malloc_context_size=2\n\nJULIA_PRECOMPILE=1\n\n# tell libblastrampoline to not use RTLD_DEEPBIND\nexport LBT_USE_RTLD_DEEPBIND=0\n\nRun:\n\ncd $BUILD_WORKTREE\nmake debug\n\nto build julia-debug with ASAN."},{"title":"Memory Sanitizer (MSAN)","page":"Sanitizer support","location":"devdocs/sanitizers.html#Memory-Sanitizer-(MSAN)","category":"section","text":"For detecting use of uninitialized memory, you can use Clang's memory sanitizer (MSAN)\nby compiling with SANITIZE_MEMORY=1."},{"title":"Thread Sanitizer (TSAN)","page":"Sanitizer support","location":"devdocs/sanitizers.html#Thread-Sanitizer-(TSAN)","category":"section","text":"For debugging data-races and other threading related issues you can use Clang's thread sanitizer (TSAN)\nby compiling with SANITIZE_THREAD=1."},{"title":"Improving documentation","page":"Improving documentation","location":"devdocs/contributing/documentation.html#Improving-documentation","category":"section","text":"By contributing documentation to Julia, you are agreeing to release it under the MIT License.\n\nJulia's documentation source files are stored in the doc/ directory and all docstrings are found in base/. Like everything else these can be modified using git. Documentation is built with Documenter.jl, which uses Markdown syntax. The HTML documentation can be built locally by running\n\nmake docs\n\nfrom Julia's root directory. This will rebuild the Julia system image, then install or update the package dependencies required to build the documentation, and finally build the HTML documentation and place the resulting files in doc/_build/html/.\n\nNoteWhen making changes to any of Julia's documentation it is recommended that you run make docs to check that your changes are valid and do not produce any errors before opening a pull request.\n\nBelow are outlined the three most common types of documentation changes and the steps required to perform them. Please note that the following instructions do not cover the full range of features provided by Documenter.jl. Refer to Documenter's documentation if you encounter anything that is not covered by the sections below."},{"title":"Modifying files in doc/src/","page":"Improving documentation","location":"devdocs/contributing/documentation.html#Modifying-files-in-doc/src/","category":"section","text":"Most of the source text for the Julia Manual is located in doc/src/. To update or add new text to any one of the existing files the following steps should be followed:\n\nupdate the text in whichever .md files are applicable;\nrun make docs from the root directory;\ncheck the output in doc/_build/html/ to make sure the changes are correct;\ncommit your changes and open a pull request.\n\nNoteThe contents of doc/_build/ does not need to be committed when you make changes.\n\nTo add a new file to doc/src/ rather than updating a file replace step 1 above with\n\nadd the file to the appropriate subdirectory in doc/src/ and also add the file path to the PAGES vector in doc/make.jl."},{"title":"Modifying an existing docstring in base/","page":"Improving documentation","location":"devdocs/contributing/documentation.html#Modifying-an-existing-docstring-in-base/","category":"section","text":"All docstrings are written inline above the methods or types they are associated with and can be found by clicking on the source link that appears below each docstring in the HTML file. The steps needed to make a change to an existing docstring are listed below:\n\nfind the docstring in base/;\nupdate the text in the docstring;\nrun make docs from the root directory;\ncheck the output in doc/_build/html/ to make sure the changes are correct;\ncommit your changes and open a pull request."},{"title":"Adding a new docstring to base/","page":"Improving documentation","location":"devdocs/contributing/documentation.html#Adding-a-new-docstring-to-base/","category":"section","text":"The steps required to add a new docstring are listed below:\n\nfind a suitable definition in base/ that the docstring will be most applicable to;\nadd a docstring above the definition;\nfind a suitable @docs code block in one of the doc/src/stdlib/ files where you would like the docstring to appear;\nadd the name of the definition to the @docs code block. For example, with a docstring added to a function bar\njulia  \"...\"  function bar(args...)      # ...  end\nyou would add the name bar to a @docs block in doc/src/stdlib/\n ```@docs\n foo\n bar # <-- Added this one.\n baz\n ```\nrun make docs from the root directory;\ncheck the output in doc/_build/html to make sure the changes are correct;\ncommit your changes and open a pull request."},{"title":"Doctests","page":"Improving documentation","location":"devdocs/contributing/documentation.html#Doctests","category":"section","text":"Examples written within docstrings can be used as testcases known as \"doctests\" by annotating code blocks with jldoctest.\n\n```jldoctest\njulia> uppercase(\"Docstring test\")\n\"DOCSTRING TEST\"\n```\n\nA doctest needs to match an interactive REPL including the julia> prompt. It is recommended to add the header # Examples above the doctests.\n\nSee the documentation of writing jldoctests for best\npractices on how to write doctests for common scenarios and the doc/README.md\nfile for how to run the doctests."},{"title":"Dates","page":"Dates","location":"stdlib/Dates.html#Dates","category":"section","text":"The Dates module provides two types for working with dates: Date and DateTime,\nrepresenting day and millisecond precision, respectively; both are subtypes of the abstract TimeType.\nThe motivation for distinct types is simple: some operations are much simpler, both in terms of\ncode and mental reasoning, when the complexities of greater precision don't have to be dealt with.\nFor example, since the Date type only resolves to the precision of a single date (i.e.\nno hours, minutes, or seconds), normal considerations for time zones, daylight savings/summer\ntime, and leap seconds are unnecessary and avoided.\n\nBoth Date and DateTime are basically immutable Int64 wrappers.\nThe single instant field of either type is actually a UTInstant{P} type, which\nrepresents a continuously increasing machine timeline based on the UT second [1]. The\nDateTime type is not aware of time zones (naive, in Python parlance),\nanalogous to a LocalDateTime in Java 8. Additional time zone functionality\ncan be added through the TimeZones.jl package, which\ncompiles the IANA time zone database. Both Date and\nDateTime are based on the ISO 8601 standard, which follows the proleptic Gregorian calendar.\nOne note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last\nday of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists.\nThe ISO standard, however, states that 1 BC/BCE is year zero, so 0000-12-31 is the day before\n0001-01-01, and year -0001 (yes, negative one for the year) is 2 BC/BCE, year -0002 is 3\nBC/BCE, etc.\n\n[1]: The notion of the UT second is actually quite fundamental. There are basically two different notions\nof time generally accepted, one based on the physical rotation of the earth (one full rotation\n= 1 day), the other based on the SI second (a fixed, constant value). These are radically different!\nThink about it, a \"UT second\", as defined relative to the rotation of the earth, may have a different\nabsolute length depending on the day! Anyway, the fact that Date and DateTime\nare based on UT seconds is a simplifying, yet honest assumption so that things like leap seconds\nand all their complexity can be avoided. This basis of time is formally called UT\nor UT1. Basing types on the UT second basically means that every minute has 60 seconds and every\nday has 24 hours and leads to more natural calculations when working with calendar dates."},{"title":"Constructors","page":"Dates","location":"stdlib/Dates.html#Constructors","category":"section","text":"Date and DateTime types can be constructed by integer or Period\ntypes, by parsing, or through adjusters (more on those later):\n\njulia> DateTime(2013)\n2013-01-01T00:00:00\n\njulia> DateTime(2013,7)\n2013-07-01T00:00:00\n\njulia> DateTime(2013,7,1)\n2013-07-01T00:00:00\n\njulia> DateTime(2013,7,1,12)\n2013-07-01T12:00:00\n\njulia> DateTime(2013,7,1,12,30)\n2013-07-01T12:30:00\n\njulia> DateTime(2013,7,1,12,30,59)\n2013-07-01T12:30:59\n\njulia> DateTime(2013,7,1,12,30,59,1)\n2013-07-01T12:30:59.001\n\njulia> Date(2013)\n2013-01-01\n\njulia> Date(2013,7)\n2013-07-01\n\njulia> Date(2013,7,1)\n2013-07-01\n\njulia> Date(Dates.Year(2013),Dates.Month(7),Dates.Day(1))\n2013-07-01\n\njulia> Date(Dates.Month(7),Dates.Year(2013))\n2013-07-01\n\nDate or DateTime parsing is accomplished by the use of format strings. Format\nstrings work by the notion of defining delimited or fixed-width \"slots\" that contain a period\nto parse and passing the text to parse and format string to a Date or DateTime\nconstructor, of the form Date(\"2015-01-01\",dateformat\"y-m-d\") or\nDateTime(\"20150101\",dateformat\"yyyymmdd\").\n\nDelimited slots are marked by specifying the delimiter the parser should expect between two subsequent\nperiods; so \"y-m-d\" lets the parser know that between the first and second slots in a date string\nlike \"2014-07-16\", it should find the - character. The y, m, and d characters let the\nparser know which periods to parse in each slot.\n\nAs in the case of constructors above such as Date(2013), delimited DateFormats allow for\nmissing parts of dates and times so long as the preceding parts are given. The other parts are given the usual\ndefault values. For example, Date(\"1981-03\", dateformat\"y-m-d\") returns 1981-03-01, whilst\nDate(\"31/12\", dateformat\"d/m/y\") gives 0001-12-31.  (Note that the default year is\n1 AD/CE.)\nAn empty string, however, always throws an ArgumentError.\n\nFixed-width slots are specified by repeating the period character the number of times corresponding\nto the width with no delimiter between characters. So dateformat\"yyyymmdd\" would correspond to a date\nstring like \"20140716\". The parser distinguishes a fixed-width slot by the absence of a delimiter,\nnoting the transition \"yyyymm\" from one period character to the next.\n\nSupport for text-form month parsing is also supported through the u and U characters, for\nabbreviated and full-length month names, respectively. By default, only English month names are\nsupported, so u corresponds to \"Jan\", \"Feb\", \"Mar\", etc. And U corresponds to \"January\", \"February\",\n\"March\", etc. Similar to other name=>value mapping functions dayname and monthname,\ncustom locales can be loaded by passing in the locale=>Dict{String,Int} mapping to the MONTHTOVALUEABBR\nand MONTHTOVALUE dicts for abbreviated and full-name month names, respectively.\n\nThe above examples used the dateformat\"\" string macro. This macro creates a DateFormat object once when\nthe macro is expanded and uses the same DateFormat object even if a code snippet is run multiple times.\n\njulia> for i = 1:10^5\n           Date(\"2015-01-01\", dateformat\"y-m-d\")\n       end\n\nOr you can create the DateFormat object explicitly:\n\njulia> df = DateFormat(\"y-m-d\");\n\njulia> dt = Date(\"2015-01-01\",df)\n2015-01-01\n\njulia> dt2 = Date(\"2015-01-02\",df)\n2015-01-02\n\nAlternatively, use broadcasting:\n\njulia> years = [\"2015\", \"2016\"];\n\njulia> Date.(years, DateFormat(\"yyyy\"))\n2-element Vector{Date}:\n 2015-01-01\n 2016-01-01\n\nFor convenience, you may pass the format string directly (e.g., Date(\"2015-01-01\",\"y-m-d\")),\nalthough this form incurs performance costs if you are parsing the same format repeatedly, as\nit internally creates a new DateFormat object each time.\n\nAs well as via the constructors, a Date or DateTime can be constructed from\nstrings using the parse and tryparse functions, but with\nan optional third argument of type DateFormat specifying the format; for example,\nparse(Date, \"06.23.2013\", dateformat\"m.d.y\"), or\ntryparse(DateTime, \"1999-12-31T23:59:59\") which uses the default format.\nThe notable difference between the functions is that with tryparse,\nan error is not thrown if the string is empty or in an invalid format;\ninstead nothing is returned.\n\ncompat: Julia 1.9\nBefore Julia 1.9, empty strings could be passed to constructors and parse\nwithout error, returning as appropriate DateTime(1), Date(1) or Time(0).\nLikewise, tryparse did not return nothing.\n\nA full suite of parsing and formatting tests and examples is available in stdlib/Dates/test/io.jl."},{"title":"Durations/Comparisons","page":"Dates","location":"stdlib/Dates.html#Durations/Comparisons","category":"section","text":"Finding the length of time between two Date or DateTime is straightforward\ngiven their underlying representation as UTInstant{Day} and UTInstant{Millisecond}, respectively.\nThe difference between Date is returned in the number of Day, and DateTime\nin the number of Millisecond. Similarly, comparing TimeType is a simple matter\nof comparing the underlying machine instants (which in turn compares the internal Int64 values).\n\njulia> dt = Date(2012,2,29)\n2012-02-29\n\njulia> dt2 = Date(2000,2,1)\n2000-02-01\n\njulia> dump(dt)\nDate\n  instant: Dates.UTInstant{Day}\n    periods: Day\n      value: Int64 734562\n\njulia> dump(dt2)\nDate\n  instant: Dates.UTInstant{Day}\n    periods: Day\n      value: Int64 730151\n\njulia> dt > dt2\ntrue\n\njulia> dt != dt2\ntrue\n\njulia> dt + dt2\nERROR: MethodError: no method matching +(::Date, ::Date)\n[...]\n\njulia> dt * dt2\nERROR: MethodError: no method matching *(::Date, ::Date)\n[...]\n\njulia> dt / dt2\nERROR: MethodError: no method matching /(::Date, ::Date)\n\njulia> dt - dt2\n4411 days\n\njulia> dt2 - dt\n-4411 days\n\njulia> dt = DateTime(2012,2,29)\n2012-02-29T00:00:00\n\njulia> dt2 = DateTime(2000,2,1)\n2000-02-01T00:00:00\n\njulia> dt - dt2\n381110400000 milliseconds"},{"title":"Accessor Functions","page":"Dates","location":"stdlib/Dates.html#Accessor-Functions","category":"section","text":"Because the Date and DateTime types are stored as single Int64 values, date\nparts or fields can be retrieved through accessor functions. The lowercase accessors return the\nfield as an integer:\n\njulia> t = Date(2014, 1, 31)\n2014-01-31\n\njulia> Dates.year(t)\n2014\n\njulia> Dates.month(t)\n1\n\njulia> Dates.week(t)\n5\n\njulia> Dates.day(t)\n31\n\nWhile propercase return the same value in the corresponding Period type:\n\njulia> Dates.Year(t)\n2014 years\n\njulia> Dates.Day(t)\n31 days\n\nCompound methods are provided because it is more efficient to access multiple fields at the same time than individually:\n\njulia> Dates.yearmonth(t)\n(2014, 1)\n\njulia> Dates.monthday(t)\n(1, 31)\n\njulia> Dates.yearmonthday(t)\n(2014, 1, 31)\n\nOne may also access the underlying UTInstant or integer value:\n\njulia> dump(t)\nDate\n  instant: Dates.UTInstant{Day}\n    periods: Day\n      value: Int64 735264\n\njulia> t.instant\nDates.UTInstant{Day}(Day(735264))\n\njulia> Dates.value(t)\n735264"},{"title":"Query Functions","page":"Dates","location":"stdlib/Dates.html#Query-Functions","category":"section","text":"Query functions provide calendrical information about a TimeType. They include information\nabout the day of the week:\n\njulia> t = Date(2014, 1, 31)\n2014-01-31\n\njulia> Dates.dayofweek(t)\n5\n\njulia> Dates.dayname(t)\n\"Friday\"\n\njulia> Dates.dayofweekofmonth(t) # 5th Friday of January\n5\n\nMonth of the year:\n\njulia> Dates.monthname(t)\n\"January\"\n\njulia> Dates.daysinmonth(t)\n31\n\nAs well as information about the TimeType's year and quarter:\n\njulia> Dates.isleapyear(t)\nfalse\n\njulia> Dates.dayofyear(t)\n31\n\njulia> Dates.quarterofyear(t)\n1\n\njulia> Dates.dayofquarter(t)\n31\n\nThe dayname and monthname methods can also take an optional locale keyword\nthat can be used to return the name of the day or month of the year for other languages/locales.\nThere are also versions of these functions returning the abbreviated names, namely\ndayabbr and monthabbr.\nFirst the mapping is loaded into the LOCALES variable:\n\njulia> french_months = [\"janvier\", \"février\", \"mars\", \"avril\", \"mai\", \"juin\",\n                        \"juillet\", \"août\", \"septembre\", \"octobre\", \"novembre\", \"décembre\"];\n\njulia> french_months_abbrev = [\"janv\",\"févr\",\"mars\",\"avril\",\"mai\",\"juin\",\n                              \"juil\",\"août\",\"sept\",\"oct\",\"nov\",\"déc\"];\n\njulia> french_days = [\"lundi\",\"mardi\",\"mercredi\",\"jeudi\",\"vendredi\",\"samedi\",\"dimanche\"];\n\njulia> Dates.LOCALES[\"french\"] = Dates.DateLocale(french_months, french_months_abbrev, french_days, [\"\"]);\n\nThe above mentioned functions can then be used to perform the queries:\n\njulia> Dates.dayname(t;locale=\"french\")\n\"vendredi\"\n\njulia> Dates.monthname(t;locale=\"french\")\n\"janvier\"\n\njulia> Dates.monthabbr(t;locale=\"french\")\n\"janv\"\n\nSince the abbreviated versions of the days are not loaded, trying to use the\nfunction dayabbr will throw an error.\n\njulia> Dates.dayabbr(t;locale=\"french\")\nERROR: BoundsError: attempt to access 1-element Vector{String} at index [5]\nStacktrace:\n[...]"},{"title":"TimeType-Period Arithmetic","page":"Dates","location":"stdlib/Dates.html#TimeType-Period-Arithmetic","category":"section","text":"It's good practice when using any language/date framework to be familiar with how date-period\narithmetic is handled as there are some tricky issues\nto deal with (though much less so for day-precision types).\n\nThe Dates module approach tries to follow the simple principle of trying to change as\nlittle as possible when doing Period arithmetic. This approach is also often known as\ncalendrical arithmetic or what you would probably guess if someone were to ask you the same\ncalculation in a conversation. Why all the fuss about this? Let's take a classic example: add\n1 month to January 31st, 2014. What's the answer? Javascript will say March 3\n(assumes 31 days). PHP says March 2\n(assumes 30 days). The fact is, there is no right answer. In the Dates module, it gives\nthe result of February 28th. How does it figure that out? Consider the classic 7-7-7\ngambling game in casinos.\n\nNow just imagine that instead of 7-7-7, the slots are Year-Month-Day, or in our example, 2014-01-31.\nWhen you ask to add 1 month to this date, the month slot is incremented, so now we have 2014-02-31.\nThen the day number is checked if it is greater than the last valid day of the new month; if it\nis (as in the case above), the day number is adjusted down to the last valid day (28). What are\nthe ramifications with this approach? Go ahead and add another month to our date, 2014-02-28 + Month(1) == 2014-03-28.\nWhat? Were you expecting the last day of March? Nope, sorry, remember the 7-7-7 slots. As few\nslots as possible are going to change, so we first increment the month slot by 1, 2014-03-28,\nand boom, we're done because that's a valid date. On the other hand, if we were to add 2 months\nto our original date, 2014-01-31, then we end up with 2014-03-31, as expected. The other ramification\nof this approach is a loss in associativity when a specific ordering is forced (i.e. adding things\nin different orders results in different outcomes). For example:\n\njulia> (Date(2014,1,29)+Dates.Day(1)) + Dates.Month(1)\n2014-02-28\n\njulia> (Date(2014,1,29)+Dates.Month(1)) + Dates.Day(1)\n2014-03-01\n\nWhat's going on there? In the first line, we're adding 1 day to January 29th, which results in\n2014-01-30; then we add 1 month, so we get 2014-02-30, which then adjusts down to 2014-02-28.\nIn the second example, we add 1 month first, where we get 2014-02-29, which adjusts down to\n2014-02-28, and then add 1 day, which results in 2014-03-01. One design principle that helps\nin this case is that, in the presence of multiple Periods, the operations will be ordered by the\nPeriods' types, not their value or positional order; this means Year will always be added\nfirst, then Month, then Week, etc. Hence the following does result in associativity and\nJust Works:\n\njulia> Date(2014,1,29) + Dates.Day(1) + Dates.Month(1)\n2014-03-01\n\njulia> Date(2014,1,29) + Dates.Month(1) + Dates.Day(1)\n2014-03-01\n\nTricky? Perhaps. What is an innocent Dates user to do? The bottom line is to be aware\nthat explicitly forcing a certain associativity, when dealing with months, may lead to some unexpected\nresults, but otherwise, everything should work as expected. Thankfully, that's pretty much the\nextent of the odd cases in date-period arithmetic when dealing with time in UT (avoiding the \"joys\"\nof dealing with daylight savings, leap seconds, etc.).\n\nAs a bonus, all period arithmetic objects work directly with ranges:\n\njulia> dr = Date(2014,1,29):Day(1):Date(2014,2,3)\nDate(\"2014-01-29\"):Day(1):Date(\"2014-02-03\")\n\njulia> collect(dr)\n6-element Vector{Date}:\n 2014-01-29\n 2014-01-30\n 2014-01-31\n 2014-02-01\n 2014-02-02\n 2014-02-03\n\njulia> dr = Date(2014,1,29):Dates.Month(1):Date(2014,07,29)\nDate(\"2014-01-29\"):Month(1):Date(\"2014-07-29\")\n\njulia> collect(dr)\n7-element Vector{Date}:\n 2014-01-29\n 2014-02-28\n 2014-03-29\n 2014-04-29\n 2014-05-29\n 2014-06-29\n 2014-07-29"},{"title":"Adjuster Functions","page":"Dates","location":"stdlib/Dates.html#Adjuster-Functions","category":"section","text":"As convenient as date-period arithmetic is, often the kinds of calculations needed on dates\ntake on a calendrical or temporal nature rather than a fixed number of periods. Holidays are\na perfect example; most follow rules such as \"Memorial Day = Last Monday of May\", or \"Thanksgiving\n= 4th Thursday of November\". These kinds of temporal expressions deal with rules relative to the\ncalendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.\n\nThe Dates module provides the adjuster API through several convenient methods that\naid in simply and succinctly expressing temporal rules. The first group of adjuster methods deal\nwith the first and last of weeks, months, quarters, and years. They each take a single TimeType\nas input and return or adjust to the first or last of the desired period relative to the input.\n\njulia> Dates.firstdayofweek(Date(2014,7,16)) # Adjusts the input to the Monday of the input's week\n2014-07-14\n\njulia> Dates.lastdayofmonth(Date(2014,7,16)) # Adjusts to the last day of the input's month\n2014-07-31\n\njulia> Dates.lastdayofquarter(Date(2014,7,16)) # Adjusts to the last day of the input's quarter\n2014-09-30\n\nThe next two higher-order methods, tonext, and toprev, generalize working\nwith temporal expressions by taking a DateFunction as first argument, along with a starting\nTimeType. A DateFunction is just a function, usually anonymous, that takes a single\nTimeType as input and returns a Bool, true indicating a satisfied\nadjustment criterion.\nFor example:\n\njulia> istuesday = x->Dates.dayofweek(x) == Dates.Tuesday; # Returns true if the day of the week of x is Tuesday\n\njulia> Dates.tonext(istuesday, Date(2014,7,13)) # 2014-07-13 is a Sunday\n2014-07-15\n\njulia> Dates.tonext(Date(2014,7,13), Dates.Tuesday) # Convenience method provided for day of the week adjustments\n2014-07-15\n\nThis is useful with the do-block syntax for more complex temporal expressions:\n\njulia> Dates.tonext(Date(2014,7,13)) do x\n           # Return true on the 4th Thursday of November (Thanksgiving)\n           Dates.dayofweek(x) == Dates.Thursday &&\n           Dates.dayofweekofmonth(x) == 4 &&\n           Dates.month(x) == Dates.November\n       end\n2014-11-27\n\nThe Base.filter method can be used to obtain all valid dates/moments in a specified\nrange:\n\n# Pittsburgh street cleaning; Every 2nd Tuesday from April to November\n# Date range from January 1st, 2014 to January 1st, 2015\njulia> dr = Dates.Date(2014):Day(1):Dates.Date(2015);\n\njulia> filter(dr) do x\n           Dates.dayofweek(x) == Dates.Tue &&\n           Dates.April <= Dates.month(x) <= Dates.Nov &&\n           Dates.dayofweekofmonth(x) == 2\n       end\n8-element Vector{Date}:\n 2014-04-08\n 2014-05-13\n 2014-06-10\n 2014-07-08\n 2014-08-12\n 2014-09-09\n 2014-10-14\n 2014-11-11\n\nAdditional examples and tests are available in stdlib/Dates/test/adjusters.jl."},{"title":"Period Types","page":"Dates","location":"stdlib/Dates.html#Period-Types","category":"section","text":"Periods are a human view of discrete, sometimes irregular durations of time. Consider 1 month;\nit could represent, in days, a value of 28, 29, 30, or 31 depending on the year and month context.\nOr a year could represent 365 or 366 days in the case of a leap year. Period types are\nsimple Int64 wrappers and are constructed by wrapping any Int64 convertible type, i.e. Year(1)\nor Month(3.0). Arithmetic between Period of the same type behave like integers, and\nlimited Period-Real arithmetic is available. You can extract the underlying integer with\nDates.value.\n\njulia> y1 = Dates.Year(1)\n1 year\n\njulia> y2 = Dates.Year(2)\n2 years\n\njulia> y3 = Dates.Year(10)\n10 years\n\njulia> y1 + y2\n3 years\n\njulia> div(y3,y2)\n5\n\njulia> y3 - y2\n8 years\n\njulia> y3 % y2\n0 years\n\njulia> div(y3,3) # mirrors integer division\n3 years\n\njulia> Dates.value(Dates.Millisecond(10))\n10\n\nRepresenting periods or durations that are not integer multiples of the basic types can be achieved\nwith the Dates.CompoundPeriod type. Compound periods may be constructed manually from simple\nPeriod types. Additionally, the canonicalize function can be used to break down a\nperiod into a Dates.CompoundPeriod. This is particularly useful to convert a duration, e.g.,\na difference of two DateTime, into a more convenient representation.\n\njulia> cp = Dates.CompoundPeriod(Day(1),Minute(1))\n1 day, 1 minute\n\njulia> t1 = DateTime(2018,8,8,16,58,00)\n2018-08-08T16:58:00\n\njulia> t2 = DateTime(2021,6,23,10,00,00)\n2021-06-23T10:00:00\n\njulia> canonicalize(t2-t1) # creates a CompoundPeriod\n149 weeks, 6 days, 17 hours, 2 minutes"},{"title":"Rounding","page":"Dates","location":"stdlib/Dates.html#Rounding","category":"section","text":"Date and DateTime values can be rounded to a specified resolution (e.g., 1\nmonth or 15 minutes) with floor, ceil, or round:\n\njulia> floor(Date(1985, 8, 16), Dates.Month)\n1985-08-01\n\njulia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))\n2013-02-13T00:45:00\n\njulia> round(DateTime(2016, 8, 6, 20, 15), Dates.Day)\n2016-08-07T00:00:00\n\nUnlike the numeric round method, which breaks ties toward the even number by default,\nthe TimeTyperound method uses the RoundNearestTiesUp rounding mode. (It's\ndifficult to guess what breaking ties to nearest \"even\" TimeType would entail.) Further\ndetails on the available RoundingMode s can be found in the API reference.\n\nRounding should generally behave as expected, but there are a few cases in which the expected\nbehaviour is not obvious."},{"title":"Rounding Epoch","page":"Dates","location":"stdlib/Dates.html#Rounding-Epoch","category":"section","text":"In many cases, the resolution specified for rounding (e.g., Dates.Second(30)) divides evenly\ninto the next largest period (in this case, Dates.Minute(1)). But rounding behaviour in cases\nin which this is not true may lead to confusion. What is the expected result of rounding a DateTime\nto the nearest 10 hours?\n\njulia> round(DateTime(2016, 7, 17, 11, 55), Dates.Hour(10))\n2016-07-17T12:00:00\n\nThat may seem confusing, given that the hour (12) is not divisible by 10. The reason that 2016-07-17T12:00:00\nwas chosen is that it is 17,676,660 hours after 0000-01-01T00:00:00, and 17,676,660 is divisible\nby 10.\n\nAs Julia Date and DateTime values are represented according to the ISO 8601\nstandard, 0000-01-01T00:00:00 was chosen as base (or \"rounding epoch\") from which to begin the\ncount of days (and milliseconds) used in rounding calculations. (Note that this differs slightly\nfrom Julia's internal representation of Date s using Rata Die notation;\nbut since the ISO 8601 standard is most visible to the end user, 0000-01-01T00:00:00 was chosen as the rounding\nepoch instead of the 0000-12-31T00:00:00 used internally to minimize confusion.)\n\nThe only exception to the use of 0000-01-01T00:00:00 as the rounding epoch is when rounding\nto weeks. Rounding to the nearest week will always return a Monday (the first day of the week\nas specified by ISO 8601). For this reason, we use 0000-01-03T00:00:00 (the first day of the\nfirst week of year 0000, as defined by ISO 8601) as the base when rounding to a number of weeks.\n\nHere is a related case in which the expected behaviour is not necessarily obvious: What happens\nwhen we round to the nearest P(2), where P is a Period type? In some cases (specifically,\nwhen P <: Dates.TimePeriod) the answer is clear:\n\njulia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Hour(2))\n2016-07-17T08:00:00\n\njulia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Minute(2))\n2016-07-17T08:56:00\n\nThis seems obvious, because two of each of these periods still divides evenly into the next larger\norder period. But in the case of two months (which still divides evenly into one year), the answer\nmay be surprising:\n\njulia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Month(2))\n2016-07-01T00:00:00\n\nWhy round to the first day in July, even though it is month 7 (an odd number)? The key is that\nmonths are 1-indexed (the first month is assigned 1), unlike hours, minutes, seconds, and milliseconds\n(the first of which are assigned 0).\n\nThis means that rounding a DateTime to an even multiple of seconds, minutes, hours,\nor years (because the ISO 8601 specification includes a year zero) will result in a DateTime\nwith an even value in that field, while rounding a DateTime to an even multiple of months\nwill result in the months field having an odd value. Because both months and years may contain\nan irregular number of days, whether rounding to an even number of days will result in an even\nvalue in the days field is uncertain.\n\nSee the API reference for additional information\non methods exported from the Dates module."},{"title":"API reference","page":"Dates","location":"stdlib/Dates.html#stdlib-dates-api","category":"section","text":""},{"title":"Dates and Time Types","page":"Dates","location":"stdlib/Dates.html#Dates-and-Time-Types","category":"section","text":""},{"title":"Dates Functions","page":"Dates","location":"stdlib/Dates.html#Dates-Functions","category":"section","text":""},{"title":"Accessor Functions","page":"Dates","location":"stdlib/Dates.html#Accessor-Functions-2","category":"section","text":""},{"title":"Query Functions","page":"Dates","location":"stdlib/Dates.html#Query-Functions-2","category":"section","text":""},{"title":"Adjuster Functions","page":"Dates","location":"stdlib/Dates.html#Adjuster-Functions-2","category":"section","text":""},{"title":"Periods","page":"Dates","location":"stdlib/Dates.html#Periods","category":"section","text":""},{"title":"Rounding Functions","page":"Dates","location":"stdlib/Dates.html#Rounding-Functions","category":"section","text":"Date and DateTime values can be rounded to a specified resolution (e.g., 1 month or 15 minutes)\nwith floor, ceil, or round.\n\nMost Period values can also be rounded to a specified resolution:\n\nThe following functions are not exported:"},{"title":"Conversion Functions","page":"Dates","location":"stdlib/Dates.html#Conversion-Functions","category":"section","text":""},{"title":"Constants","page":"Dates","location":"stdlib/Dates.html#Constants","category":"section","text":"Days of the Week:\n\nVariable Abbr. Value (Int)\nMonday Mon 1\nTuesday Tue 2\nWednesday Wed 3\nThursday Thu 4\nFriday Fri 5\nSaturday Sat 6\nSunday Sun 7\n\nMonths of the Year:\n\nVariable Abbr. Value (Int)\nJanuary Jan 1\nFebruary Feb 2\nMarch Mar 3\nApril Apr 4\nMay May 5\nJune Jun 6\nJuly Jul 7\nAugust Aug 8\nSeptember Sep 9\nOctober Oct 10\nNovember Nov 11\nDecember Dec 12"},{"title":"Common Date Formatters","page":"Dates","location":"stdlib/Dates.html#Common-Date-Formatters","category":"section","text":""},{"title":"Dates.Period","page":"Dates","location":"stdlib/Dates.html#Dates.Period","category":"type","text":"Period\nYear\nQuarter\nMonth\nWeek\nDay\nHour\nMinute\nSecond\nMillisecond\nMicrosecond\nNanosecond\n\nPeriod types represent discrete, human representations of time.\n\n\n\n\n\n"},{"title":"Dates.CompoundPeriod","page":"Dates","location":"stdlib/Dates.html#Dates.CompoundPeriod","category":"type","text":"CompoundPeriod\n\nA CompoundPeriod is useful for expressing time periods that are not a fixed multiple of\nsmaller periods. For example, \"a year and a day\" is not a fixed number of days, but can\nbe expressed using a CompoundPeriod. In fact, a CompoundPeriod is automatically\ngenerated by addition of different period types, e.g. Year(1) + Day(1) produces a\nCompoundPeriod result.\n\n\n\n\n\n"},{"title":"Dates.Instant","page":"Dates","location":"stdlib/Dates.html#Dates.Instant","category":"type","text":"Instant\n\nInstant types represent integer-based, machine representations of time as continuous\ntimelines starting from an epoch.\n\n\n\n\n\n"},{"title":"Dates.UTInstant","page":"Dates","location":"stdlib/Dates.html#Dates.UTInstant","category":"type","text":"UTInstant{T}\n\nThe UTInstant represents a machine timeline based on UT time (1 day = one revolution of\nthe earth). The T is a Period parameter that indicates the resolution or precision of\nthe instant.\n\n\n\n\n\n"},{"title":"Dates.TimeType","page":"Dates","location":"stdlib/Dates.html#Dates.TimeType","category":"type","text":"TimeType\n\nTimeType types wrap Instant machine instances to provide human representations of the\nmachine instant. Time, DateTime and Date are subtypes of TimeType.\n\n\n\n\n\n"},{"title":"Dates.DateTime","page":"Dates","location":"stdlib/Dates.html#Dates.DateTime","category":"type","text":"DateTime\n\nDateTime represents a point in time according to the proleptic Gregorian calendar.\nThe finest resolution of the time is millisecond (i.e., microseconds or\nnanoseconds cannot be represented by this type). The type supports fixed-point\narithmetic, and thus is prone to underflowing (and overflowing). A notable\nconsequence is rounding when adding a Microsecond or a Nanosecond:\n\njulia> dt = DateTime(2023, 8, 19, 17, 45, 32, 900)\n2023-08-19T17:45:32.900\n\njulia> dt + Millisecond(1)\n2023-08-19T17:45:32.901\n\njulia> dt + Microsecond(1000) # 1000us == 1ms\n2023-08-19T17:45:32.901\n\njulia> dt + Microsecond(999) # 999us rounded to 1000us\n2023-08-19T17:45:32.901\n\njulia> dt + Microsecond(1499) # 1499 rounded to 1000us\n2023-08-19T17:45:32.901\n\n\n\n\n\n"},{"title":"Dates.Date","page":"Dates","location":"stdlib/Dates.html#Dates.Date","category":"type","text":"Date\n\nDate wraps a UTInstant{Day} and interprets it according to the proleptic Gregorian calendar.\n\n\n\n\n\n"},{"title":"Dates.Time","page":"Dates","location":"stdlib/Dates.html#Dates.Time","category":"type","text":"Time\n\nTime wraps a Nanosecond and represents a specific moment in a 24-hour day.\n\n\n\n\n\n"},{"title":"Dates.TimeZone","page":"Dates","location":"stdlib/Dates.html#Dates.TimeZone","category":"type","text":"TimeZone\n\nGeographic zone generally based on longitude determining what the time is at a certain location.\nSome time zones observe daylight savings (eg EST -> EDT).\nFor implementations and more support, see the TimeZones.jl package\n\n\n\n\n\n"},{"title":"Dates.UTC","page":"Dates","location":"stdlib/Dates.html#Dates.UTC","category":"type","text":"UTC\n\nUTC, or Coordinated Universal Time, is the TimeZone from which all others are measured.\nIt is associated with the time at 0° longitude. It is not adjusted for daylight savings.\n\n\n\n\n\n"},{"title":"Dates.DateTime","page":"Dates","location":"stdlib/Dates.html#Dates.DateTime-NTuple{7, Int64}","category":"method","text":"DateTime(y, [m, d, h, mi, s, ms])::DateTime\n\nConstruct a DateTime type by parts. Arguments must be convertible to Int64.\n\n\n\n\n\n"},{"title":"Dates.DateTime","page":"Dates","location":"stdlib/Dates.html#Dates.DateTime-Tuple{Period}","category":"method","text":"DateTime(periods::Period...)::DateTime\n\nConstruct a DateTime type by Period type parts. Arguments may be in any order. DateTime\nparts not provided will default to the value of Dates.default(period).\n\n\n\n\n\n"},{"title":"Dates.DateTime","page":"Dates","location":"stdlib/Dates.html#Dates.DateTime-Tuple{Function, Vararg{Any}}","category":"method","text":"DateTime(f::Function, y[, m, d, h, mi, s]; step=Day(1), limit=10000)::DateTime\n\nCreate a DateTime through the adjuster API. The starting point will be constructed from\nthe provided y, m, d... arguments, and will be adjusted until f::Function returns\ntrue. The step size in adjusting can be provided manually through the step keyword.\nlimit provides a limit to the max number of iterations the adjustment API will\npursue before throwing an error (in the case that f::Function is never satisfied).\n\nExamples\n\njulia> DateTime(dt -> second(dt) == 40, 2010, 10, 20, 10; step = Second(1))\n2010-10-20T10:00:40\n\njulia> DateTime(dt -> hour(dt) == 20, 2010, 10, 20, 10; step = Hour(1), limit = 5)\nERROR: ArgumentError: Adjustment limit reached: 5 iterations\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"Dates.DateTime","page":"Dates","location":"stdlib/Dates.html#Dates.DateTime-Tuple{TimeType}","category":"method","text":"DateTime(dt::Date)\n\nConvert a Date to a DateTime. The hour, minute, second, and millisecond parts of\nthe new DateTime are assumed to be zero.\n\n\n\n\n\n"},{"title":"Dates.DateTime","page":"Dates","location":"stdlib/Dates.html#Dates.DateTime-Tuple{AbstractString, AbstractString}","category":"method","text":"DateTime(dt::AbstractString, format::AbstractString; locale=\"english\")\n\nConstruct a DateTime by parsing the dt date time string following the\npattern given in the format string (see DateFormat  for syntax).\n\nnote: Note\nThis method creates a DateFormat object each time it is called. It is recommended\nthat you create a DateFormat object instead and use that as the second\nargument to avoid performance loss when using the same format repeatedly.\n\nExamples\n\njulia> DateTime(\"2020-01-01\", \"yyyy-mm-dd\")\n2020-01-01T00:00:00\n\njulia> a = (\"2020-01-01\", \"2020-01-02\");\n\njulia> [DateTime(d, dateformat\"yyyy-mm-dd\") for d ∈ a] # preferred\n2-element Vector{DateTime}:\n 2020-01-01T00:00:00\n 2020-01-02T00:00:00\n\n\n\n\n\n"},{"title":"Dates.format","page":"Dates","location":"stdlib/Dates.html#Dates.format-Tuple{TimeType, AbstractString}","category":"method","text":"format(dt::TimeType, format::AbstractString; locale=\"english\")::AbstractString\n\nConstruct a string by using a TimeType object and applying the provided format. The\nfollowing character codes can be used to construct the format string:\n\nCode Examples Comment\ny 6 Numeric year with a fixed width\nY 1996 Numeric year with a minimum width\nm 1, 12 Numeric month with a minimum width\nu Jan Month name shortened to 3-chars according to the locale\nU January Full month name according to the locale keyword\nd 1, 31 Day of the month with a minimum width\nH 0, 23 Hour (24-hour clock) with a minimum width\nM 0, 59 Minute with a minimum width\nS 0, 59 Second with a minimum width\ns 000, 500 Millisecond with a minimum width of 3\ne Mon, Tue Abbreviated days of the week\nE Monday Full day of week name\n\nThe number of sequential code characters indicate the width of the code. A format of\nyyyy-mm specifies that the code y should have a width of four while m a width of two.\nCodes that yield numeric digits have an associated mode: fixed-width or minimum-width.\nThe fixed-width mode left-pads the value with zeros when it is shorter than the specified\nwidth and truncates the value when longer. Minimum-width mode works the same as fixed-width\nexcept that it does not truncate values longer than the width.\n\nWhen creating a format you can use any non-code characters as a separator. For example to\ngenerate the string \"1996-01-15T00:00:00\" you could use format: \"yyyy-mm-ddTHH:MM:SS\".\nNote that if you need to use a code character as a literal you can use the escape character\nbackslash. The string \"1996y01m\" can be produced with the format raw\"yyyy\\ymm\\m\".\n\n\n\n\n\n"},{"title":"Dates.DateFormat","page":"Dates","location":"stdlib/Dates.html#Dates.DateFormat","category":"type","text":"DateFormat(format::AbstractString, locale=\"english\")\n\nConstruct a date formatting object that can be used for parsing date strings or\nformatting a date object as a string. The following character codes can be used to construct the format\nstring:\n\nCode Matches Comment\nY 1996, 96 Returns year of 1996, 0096\ny 1996, 96 Same as Y on parse but discards excess digits on format\nm 1, 01 Matches 1 or 2-digit months\nu Jan Matches abbreviated months according to the locale keyword\nU January Matches full month names according to the locale keyword\nd 1, 01 Matches 1 or 2-digit days\nH 00 Matches hours (24-hour clock)\nI 00 For outputting hours with 12-hour clock\nM 00 Matches minutes\nS 00 Matches seconds\ns .500 Matches milliseconds\ne Mon, Tues Matches abbreviated days of the week\nE Monday Matches full name days of the week\np AM Matches AM/PM (case-insensitive)\nyyyymmdd 19960101 Matches fixed-width year, month, and day\n\nCharacters not listed above are normally treated as delimiters between date and time slots.\nFor example a dt string of \"1996-01-15T00:00:00.0\" would have a format string like\n\"y-m-dTH:M:S.s\". If you need to use a code character as a delimiter you can escape it using\nbackslash. The date \"1995y01m\" would have the format \"y\\ym\\m\".\n\nNote that 12:00AM corresponds 00:00 (midnight), and 12:00PM corresponds to 12:00 (noon).\nWhen parsing a time with a p specifier, any hour (either H or I) is interpreted as\nas a 12-hour clock, so the I code is mainly useful for output.\n\nCreating a DateFormat object is expensive. Whenever possible, create it once and use it many times\nor try the dateformat\"\" string macro. Using this macro creates the DateFormat\nobject once at macro expansion time and reuses it later. There are also several [pre-defined formatters](@ref\nCommon-Date-Formatters), listed later.\n\nSee DateTime and format for how to use a DateFormat object to parse and write Date strings\nrespectively.\n\n\n\n\n\n"},{"title":"Dates.@dateformat_str","page":"Dates","location":"stdlib/Dates.html#Dates.@dateformat_str","category":"macro","text":"dateformat\"Y-m-d H:M:S\"\n\nCreate a DateFormat object. Similar to DateFormat(\"Y-m-d H:M:S\")\nbut creates the DateFormat object once during macro expansion.\n\nSee DateFormat for details about format specifiers.\n\n\n\n\n\n"},{"title":"Dates.DateTime","page":"Dates","location":"stdlib/Dates.html#Dates.DateTime-Tuple{AbstractString, DateFormat}","category":"method","text":"DateTime(dt::AbstractString, df::DateFormat=ISODateTimeFormat)\n\nConstruct a DateTime by parsing the dt date time string following the\npattern given in the DateFormat object, or dateformat\"yyyy-mm-dd\\THH:MM:SS.s\" if omitted.\n\nSimilar to DateTime(::AbstractString, ::AbstractString) but more efficient when\nrepeatedly parsing similarly formatted date time strings with a pre-created\nDateFormat object.\n\n\n\n\n\n"},{"title":"Dates.Date","page":"Dates","location":"stdlib/Dates.html#Dates.Date-Tuple{Int64, Int64, Int64}","category":"method","text":"Date(y, [m, d])::Date\n\nConstruct a Date type by parts. Arguments must be convertible to Int64.\n\n\n\n\n\n"},{"title":"Dates.Date","page":"Dates","location":"stdlib/Dates.html#Dates.Date-Tuple{Period}","category":"method","text":"Date(period::Period...)::Date\n\nConstruct a Date type by Period type parts. Arguments may be in any order. Date parts\nnot provided will default to the value of Dates.default(period).\n\n\n\n\n\n"},{"title":"Dates.Date","page":"Dates","location":"stdlib/Dates.html#Dates.Date-Tuple{Function, Any, Any, Any}","category":"method","text":"Date(f::Function, y[, m, d]; step=Day(1), limit=10000)::Date\n\nCreate a Date through the adjuster API. The starting point will be constructed from the\nprovided y, m, d arguments, and will be adjusted until f::Function returns true.\nThe step size in adjusting can be provided manually through the step keyword.\nlimit provides a limit to the max number of iterations the adjustment API will\npursue before throwing an error (given that f::Function is never satisfied).\n\nExamples\n\njulia> Date(date -> week(date) == 20, 2010, 01, 01)\n2010-05-17\n\njulia> Date(date -> year(date) == 2010, 2000, 01, 01)\n2010-01-01\n\njulia> Date(date -> month(date) == 10, 2000, 01, 01; limit = 5)\nERROR: ArgumentError: Adjustment limit reached: 5 iterations\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"Dates.Date","page":"Dates","location":"stdlib/Dates.html#Dates.Date-Tuple{TimeType}","category":"method","text":"Date(dt::DateTime)\n\nConvert a DateTime to a Date. The hour, minute, second, and millisecond parts of\nthe DateTime are truncated, so only the year, month and day parts are used in\nconstruction.\n\n\n\n\n\n"},{"title":"Dates.Date","page":"Dates","location":"stdlib/Dates.html#Dates.Date-Tuple{AbstractString, AbstractString}","category":"method","text":"Date(d::AbstractString, format::AbstractString; locale=\"english\")\n\nConstruct a Date by parsing the d date string following the pattern given\nin the format string (see DateFormat for syntax).\n\nnote: Note\nThis method creates a DateFormat object each time it is called. It is recommended\nthat you create a DateFormat object instead and use that as the second\nargument to avoid performance loss when using the same format repeatedly.\n\nExamples\n\njulia> Date(\"2020-01-01\", \"yyyy-mm-dd\")\n2020-01-01\n\njulia> a = (\"2020-01-01\", \"2020-01-02\");\n\njulia> [Date(d, dateformat\"yyyy-mm-dd\") for d ∈ a] # preferred\n2-element Vector{Date}:\n 2020-01-01\n 2020-01-02\n\n\n\n\n\n"},{"title":"Dates.Date","page":"Dates","location":"stdlib/Dates.html#Dates.Date-Tuple{AbstractString, DateFormat}","category":"method","text":"Date(d::AbstractString, df::DateFormat=ISODateFormat)\n\nConstruct a Date by parsing the d date string following the\npattern given in the DateFormat object, or dateformat\"yyyy-mm-dd\" if omitted.\n\nSimilar to Date(::AbstractString, ::AbstractString) but more efficient when\nrepeatedly parsing similarly formatted date strings with a pre-created\nDateFormat object.\n\n\n\n\n\n"},{"title":"Dates.Time","page":"Dates","location":"stdlib/Dates.html#Dates.Time-NTuple{5, Int64}","category":"method","text":"Time(h, [mi, s, ms, us, ns])::Time\n\nConstruct a Time type by parts. Arguments must be convertible to Int64.\n\n\n\n\n\n"},{"title":"Dates.Time","page":"Dates","location":"stdlib/Dates.html#Dates.Time-Tuple{TimePeriod}","category":"method","text":"Time(period::TimePeriod...)::Time\n\nConstruct a Time type by Period type parts. Arguments may be in any order. Time parts\nnot provided will default to the value of Dates.default(period).\n\n\n\n\n\n"},{"title":"Dates.Time","page":"Dates","location":"stdlib/Dates.html#Dates.Time-Tuple{Function, Vararg{Any}}","category":"method","text":"Time(f::Function, h, mi=0; step::Period=Second(1), limit::Int=10000)\nTime(f::Function, h, mi, s; step::Period=Millisecond(1), limit::Int=10000)\nTime(f::Function, h, mi, s, ms; step::Period=Microsecond(1), limit::Int=10000)\nTime(f::Function, h, mi, s, ms, us; step::Period=Nanosecond(1), limit::Int=10000)\n\nCreate a Time through the adjuster API. The starting point will be constructed from the\nprovided h, mi, s, ms, us arguments, and will be adjusted until f::Function returns true.\nThe step size in adjusting can be provided manually through the step keyword. limit\nprovides a limit to the max number of iterations the adjustment API will pursue before\nthrowing an error (in the case that f::Function is never satisfied). Note that the default step\nwill adjust to allow for greater precision for the given arguments; i.e. if hour, minute, and second\narguments are provided, the default step will be Millisecond(1) instead of Second(1).\n\nExamples\n\njulia> Time(t -> minute(t) == 30, 20)\n20:30:00\n\njulia> Time(t -> minute(t) == 0, 20)\n20:00:00\n\njulia> Time(t -> hour(t) == 10, 3; limit = 5)\nERROR: ArgumentError: Adjustment limit reached: 5 iterations\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"Dates.Time","page":"Dates","location":"stdlib/Dates.html#Dates.Time-Tuple{DateTime}","category":"method","text":"Time(dt::DateTime)\n\nConvert a DateTime to a Time. The hour, minute, second, and millisecond parts of\nthe DateTime are used to create the new Time. Microsecond and nanoseconds are zero by default.\n\n\n\n\n\n"},{"title":"Dates.Time","page":"Dates","location":"stdlib/Dates.html#Dates.Time-Tuple{AbstractString, AbstractString}","category":"method","text":"Time(t::AbstractString, format::AbstractString; locale=\"english\")\n\nConstruct a Time by parsing the t time string following the pattern given\nin the format string (see DateFormat for syntax).\n\nnote: Note\nThis method creates a DateFormat object each time it is called. It is recommended\nthat you create a DateFormat object instead and use that as the second\nargument to avoid performance loss when using the same format repeatedly.\n\nExamples\n\njulia> Time(\"12:34pm\", \"HH:MMp\")\n12:34:00\n\njulia> a = (\"12:34pm\", \"2:34am\");\n\njulia> [Time(d, dateformat\"HH:MMp\") for d ∈ a] # preferred\n2-element Vector{Time}:\n 12:34:00\n 02:34:00\n\n\n\n\n\n"},{"title":"Dates.Time","page":"Dates","location":"stdlib/Dates.html#Dates.Time-Tuple{AbstractString, DateFormat}","category":"method","text":"Time(t::AbstractString, df::DateFormat=ISOTimeFormat)\n\nConstruct a Time by parsing the t date time string following the\npattern given in the DateFormat object, or dateformat\"HH:MM:SS.s\" if omitted.\n\nSimilar to Time(::AbstractString, ::AbstractString) but more efficient when\nrepeatedly parsing similarly formatted time strings with a pre-created\nDateFormat object.\n\n\n\n\n\n"},{"title":"Dates.now","page":"Dates","location":"stdlib/Dates.html#Dates.now-Tuple{}","category":"method","text":"now()::DateTime\n\nReturn a DateTime corresponding to the user's system time including the system timezone\nlocale.\n\n\n\n\n\n"},{"title":"Dates.now","page":"Dates","location":"stdlib/Dates.html#Dates.now-Tuple{Type{UTC}}","category":"method","text":"now(::Type{UTC})::DateTime\n\nReturn a DateTime corresponding to the user's system time as UTC/GMT.\nFor other time zones, see the TimeZones.jl package.\n\nExamples\n\njulia> now(UTC)\n2023-01-04T10:52:24.864\n\n\n\n\n\n"},{"title":"Base.eps","page":"Dates","location":"stdlib/Dates.html#Base.eps-Tuple{Union{Type{Date}, Type{DateTime}, Type{Time}, TimeType}}","category":"method","text":"eps(::Type{DateTime})::Millisecond\neps(::Type{Date})::Day\neps(::Type{Time})::Nanosecond\neps(::TimeType)::Period\n\nReturn the smallest unit value supported by the TimeType.\n\nExamples\n\njulia> eps(DateTime)\n1 millisecond\n\njulia> eps(Date)\n1 day\n\njulia> eps(Time)\n1 nanosecond\n\n\n\n\n\n"},{"title":"Dates.year","page":"Dates","location":"stdlib/Dates.html#Dates.year","category":"function","text":"year(dt::TimeType)::Int64\n\nThe year of a Date or DateTime as an Int64.\n\n\n\n\n\n"},{"title":"Dates.month","page":"Dates","location":"stdlib/Dates.html#Dates.month","category":"function","text":"month(dt::TimeType)::Int64\n\nThe month of a Date or DateTime as an Int64.\n\n\n\n\n\n"},{"title":"Dates.week","page":"Dates","location":"stdlib/Dates.html#Dates.week","category":"function","text":"week(dt::TimeType)::Int64\n\nReturn the ISO week date of a Date or\nDateTime as an Int64. Note that the first week of a year is the week that\ncontains the first Thursday of the year, which can result in dates prior to January 4th\nbeing in the last week of the previous year. For example, week(Date(2005, 1, 1)) is the 53rd\nweek of 2004.\n\nExamples\n\njulia> week(Date(1989, 6, 22))\n25\n\njulia> week(Date(2005, 1, 1))\n53\n\njulia> week(Date(2004, 12, 31))\n53\n\n\n\n\n\n"},{"title":"Dates.day","page":"Dates","location":"stdlib/Dates.html#Dates.day","category":"function","text":"day(dt::TimeType)::Int64\n\nThe day of month of a Date or DateTime as an Int64.\n\n\n\n\n\n"},{"title":"Dates.hour","page":"Dates","location":"stdlib/Dates.html#Dates.hour","category":"function","text":"hour(dt::DateTime)::Int64\n\nThe hour of day of a DateTime as an Int64.\n\n\n\n\n\nhour(t::Time)::Int64\n\nThe hour of a Time as an Int64.\n\n\n\n\n\n"},{"title":"Dates.minute","page":"Dates","location":"stdlib/Dates.html#Dates.minute","category":"function","text":"minute(dt::DateTime)::Int64\n\nThe minute of a DateTime as an Int64.\n\n\n\n\n\nminute(t::Time)::Int64\n\nThe minute of a Time as an Int64.\n\n\n\n\n\n"},{"title":"Dates.second","page":"Dates","location":"stdlib/Dates.html#Dates.second","category":"function","text":"second(dt::DateTime)::Int64\n\nThe second of a DateTime as an Int64.\n\n\n\n\n\nsecond(t::Time)::Int64\n\nThe second of a Time as an Int64.\n\n\n\n\n\n"},{"title":"Dates.millisecond","page":"Dates","location":"stdlib/Dates.html#Dates.millisecond","category":"function","text":"millisecond(dt::DateTime)::Int64\n\nThe millisecond of a DateTime as an Int64.\n\n\n\n\n\nmillisecond(t::Time)::Int64\n\nThe millisecond of a Time as an Int64.\n\n\n\n\n\n"},{"title":"Dates.microsecond","page":"Dates","location":"stdlib/Dates.html#Dates.microsecond","category":"function","text":"microsecond(t::Time)::Int64\n\nThe microsecond of a Time as an Int64.\n\n\n\n\n\n"},{"title":"Dates.nanosecond","page":"Dates","location":"stdlib/Dates.html#Dates.nanosecond","category":"function","text":"nanosecond(t::Time)::Int64\n\nThe nanosecond of a Time as an Int64.\n\n\n\n\n\n"},{"title":"Dates.Year","page":"Dates","location":"stdlib/Dates.html#Dates.Year-Tuple{TimeType}","category":"method","text":"Year(v)\n\nConstruct a Year object with the given v value. Input must be\nlosslessly convertible to an Int64.\n\n\n\n\n\n"},{"title":"Dates.Month","page":"Dates","location":"stdlib/Dates.html#Dates.Month-Tuple{TimeType}","category":"method","text":"Month(v)\n\nConstruct a Month object with the given v value. Input must be\nlosslessly convertible to an Int64.\n\n\n\n\n\n"},{"title":"Dates.Week","page":"Dates","location":"stdlib/Dates.html#Dates.Week-Tuple{TimeType}","category":"method","text":"Week(v)\n\nConstruct a Week object with the given v value. Input must be\nlosslessly convertible to an Int64.\n\n\n\n\n\n"},{"title":"Dates.Day","page":"Dates","location":"stdlib/Dates.html#Dates.Day-Tuple{TimeType}","category":"method","text":"Day(v)\n\nConstruct a Day object with the given v value. Input must be\nlosslessly convertible to an Int64.\n\n\n\n\n\n"},{"title":"Dates.Hour","page":"Dates","location":"stdlib/Dates.html#Dates.Hour-Tuple{DateTime}","category":"method","text":"Hour(dt::DateTime)\n\nThe hour part of a DateTime as a Hour.\n\n\n\n\n\n"},{"title":"Dates.Minute","page":"Dates","location":"stdlib/Dates.html#Dates.Minute-Tuple{DateTime}","category":"method","text":"Minute(dt::DateTime)\n\nThe minute part of a DateTime as a Minute.\n\n\n\n\n\n"},{"title":"Dates.Second","page":"Dates","location":"stdlib/Dates.html#Dates.Second-Tuple{DateTime}","category":"method","text":"Second(dt::DateTime)\n\nThe second part of a DateTime as a Second.\n\n\n\n\n\n"},{"title":"Dates.Millisecond","page":"Dates","location":"stdlib/Dates.html#Dates.Millisecond-Tuple{DateTime}","category":"method","text":"Millisecond(dt::DateTime)\n\nThe millisecond part of a DateTime as a Millisecond.\n\n\n\n\n\n"},{"title":"Dates.Microsecond","page":"Dates","location":"stdlib/Dates.html#Dates.Microsecond-Tuple{Time}","category":"method","text":"Microsecond(dt::Time)\n\nThe microsecond part of a Time as a Microsecond.\n\n\n\n\n\n"},{"title":"Dates.Nanosecond","page":"Dates","location":"stdlib/Dates.html#Dates.Nanosecond-Tuple{Time}","category":"method","text":"Nanosecond(dt::Time)\n\nThe nanosecond part of a Time as a Nanosecond.\n\n\n\n\n\n"},{"title":"Dates.yearmonth","page":"Dates","location":"stdlib/Dates.html#Dates.yearmonth","category":"function","text":"yearmonth(dt::TimeType) -> (Int64, Int64)\n\nSimultaneously return the year and month parts of a Date or\nDateTime.\n\n\n\n\n\n"},{"title":"Dates.monthday","page":"Dates","location":"stdlib/Dates.html#Dates.monthday","category":"function","text":"monthday(dt::TimeType) -> (Int64, Int64)\n\nSimultaneously return the month and day parts of a Date or\nDateTime.\n\n\n\n\n\n"},{"title":"Dates.yearmonthday","page":"Dates","location":"stdlib/Dates.html#Dates.yearmonthday","category":"function","text":"yearmonthday(dt::TimeType) -> (Int64, Int64, Int64)\n\nSimultaneously return the year, month and day parts of a Date or\nDateTime.\n\n\n\n\n\n"},{"title":"Dates.dayname","page":"Dates","location":"stdlib/Dates.html#Dates.dayname","category":"function","text":"dayname(dt::TimeType; locale=\"english\")::String\ndayname(day::Integer; locale=\"english\")::String\n\nReturn the full day name corresponding to the day of the week of the Date or DateTime in\nthe given locale. Also accepts Integer.\n\nExamples\n\njulia> dayname(Date(\"2000-01-01\"))\n\"Saturday\"\n\njulia> dayname(4)\n\"Thursday\"\n\n\n\n\n\n"},{"title":"Dates.dayabbr","page":"Dates","location":"stdlib/Dates.html#Dates.dayabbr","category":"function","text":"dayabbr(dt::TimeType; locale=\"english\")::String\ndayabbr(day::Integer; locale=\"english\")::String\n\nReturn the abbreviated name corresponding to the day of the week of the Date or DateTime\nin the given locale. Also accepts Integer.\n\nExamples\n\njulia> dayabbr(Date(\"2000-01-01\"))\n\"Sat\"\n\njulia> dayabbr(3)\n\"Wed\"\n\n\n\n\n\n"},{"title":"Dates.dayofweek","page":"Dates","location":"stdlib/Dates.html#Dates.dayofweek","category":"function","text":"dayofweek(dt::TimeType)::Int64\n\nReturn the day of the week as an Int64 with 1 = Monday, 2 = Tuesday, etc..\n\nExamples\n\njulia> dayofweek(Date(\"2000-01-01\"))\n6\n\n\n\n\n\n"},{"title":"Dates.dayofmonth","page":"Dates","location":"stdlib/Dates.html#Dates.dayofmonth","category":"function","text":"dayofmonth(dt::TimeType)::Int64\n\nThe day of month of a Date or DateTime as an Int64.\n\n\n\n\n\n"},{"title":"Dates.dayofweekofmonth","page":"Dates","location":"stdlib/Dates.html#Dates.dayofweekofmonth","category":"function","text":"dayofweekofmonth(dt::TimeType)::Int\n\nFor the day of week of dt, return which number it is in dt's month. So if the day of\nthe week of dt is Monday, then 1 = First Monday of the month, 2 = Second Monday of the month, etc. In the range 1:5.\n\nExamples\n\njulia> dayofweekofmonth(Date(\"2000-02-01\"))\n1\n\njulia> dayofweekofmonth(Date(\"2000-02-08\"))\n2\n\njulia> dayofweekofmonth(Date(\"2000-02-15\"))\n3\n\n\n\n\n\n"},{"title":"Dates.daysofweekinmonth","page":"Dates","location":"stdlib/Dates.html#Dates.daysofweekinmonth","category":"function","text":"daysofweekinmonth(dt::TimeType)::Int\n\nFor the day of week of dt, return the total number of that day of the week in dt's\nmonth. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week\nin a month by including dayofweekofmonth(dt) == daysofweekinmonth(dt) in the adjuster\nfunction.\n\nExamples\n\njulia> daysofweekinmonth(Date(\"2005-01-01\"))\n5\n\njulia> daysofweekinmonth(Date(\"2005-01-04\"))\n4\n\n\n\n\n\n"},{"title":"Dates.monthname","page":"Dates","location":"stdlib/Dates.html#Dates.monthname","category":"function","text":"monthname(dt::TimeType; locale=\"english\")::String\nmonthname(month::Integer, locale=\"english\")::String\n\nReturn the full name of the month of the Date or DateTime or Integer in the given locale.\n\nExamples\n\njulia> monthname(Date(\"2005-01-04\"))\n\"January\"\n\njulia> monthname(2)\n\"February\"\n\n\n\n\n\n"},{"title":"Dates.monthabbr","page":"Dates","location":"stdlib/Dates.html#Dates.monthabbr","category":"function","text":"monthabbr(dt::TimeType; locale=\"english\")::String\nmonthabbr(month::Integer, locale=\"english\")::String\n\nReturn the abbreviated month name of the Date or DateTime or Integer in the given locale.\n\nExamples\n\njulia> monthabbr(Date(\"2005-01-04\"))\n\"Jan\"\n\njulia> monthabbr(2)\n\"Feb\"\n\n\n\n\n\n"},{"title":"Dates.daysinmonth","page":"Dates","location":"stdlib/Dates.html#Dates.daysinmonth","category":"function","text":"daysinmonth(dt::TimeType)::Int\n\nReturn the number of days in the month of dt. Value will be 28, 29, 30, or 31.\n\nExamples\n\njulia> daysinmonth(Date(\"2000-01\"))\n31\n\njulia> daysinmonth(Date(\"2001-02\"))\n28\n\njulia> daysinmonth(Date(\"2000-02\"))\n29\n\n\n\n\n\n"},{"title":"Dates.isleapyear","page":"Dates","location":"stdlib/Dates.html#Dates.isleapyear","category":"function","text":"isleapyear(dt::TimeType)::Bool\n\nReturn true if the year of dt is a leap year.\n\nExamples\n\njulia> isleapyear(Date(\"2004\"))\ntrue\n\njulia> isleapyear(Date(\"2005\"))\nfalse\n\n\n\n\n\n"},{"title":"Dates.dayofyear","page":"Dates","location":"stdlib/Dates.html#Dates.dayofyear","category":"function","text":"dayofyear(dt::TimeType)::Int\n\nReturn the day of the year for dt with January 1st being day 1.\n\n\n\n\n\n"},{"title":"Dates.daysinyear","page":"Dates","location":"stdlib/Dates.html#Dates.daysinyear","category":"function","text":"daysinyear(dt::TimeType)::Int\n\nReturn 366 if the year of dt is a leap year, otherwise return 365.\n\nExamples\n\njulia> daysinyear(1999)\n365\n\njulia> daysinyear(2000)\n366\n\n\n\n\n\n"},{"title":"Dates.quarterofyear","page":"Dates","location":"stdlib/Dates.html#Dates.quarterofyear","category":"function","text":"quarterofyear(dt::TimeType)::Int\n\nReturn the quarter that dt resides in. Range of value is 1:4.\n\n\n\n\n\n"},{"title":"Dates.dayofquarter","page":"Dates","location":"stdlib/Dates.html#Dates.dayofquarter","category":"function","text":"dayofquarter(dt::TimeType)::Int\n\nReturn the day of the current quarter of dt. Range of value is 1:92.\n\n\n\n\n\n"},{"title":"Base.trunc","page":"Dates","location":"stdlib/Dates.html#Base.trunc-Tuple{TimeType, Type{Period}}","category":"method","text":"trunc(dt::TimeType, ::Type{Period})::TimeType\n\nTruncates the value of dt according to the provided Period type.\n\nExamples\n\njulia> trunc(DateTime(\"1996-01-01T12:30:00\"), Day)\n1996-01-01T00:00:00\n\n\n\n\n\n"},{"title":"Dates.firstdayofweek","page":"Dates","location":"stdlib/Dates.html#Dates.firstdayofweek","category":"function","text":"firstdayofweek(dt::TimeType)::TimeType\n\nAdjusts dt to the Monday of its week.\n\nExamples\n\njulia> firstdayofweek(DateTime(\"1996-01-05T12:30:00\"))\n1996-01-01T00:00:00\n\n\n\n\n\n"},{"title":"Dates.lastdayofweek","page":"Dates","location":"stdlib/Dates.html#Dates.lastdayofweek","category":"function","text":"lastdayofweek(dt::TimeType)::TimeType\n\nAdjusts dt to the Sunday of its week.\n\nExamples\n\njulia> lastdayofweek(DateTime(\"1996-01-05T12:30:00\"))\n1996-01-07T00:00:00\n\n\n\n\n\n"},{"title":"Dates.firstdayofmonth","page":"Dates","location":"stdlib/Dates.html#Dates.firstdayofmonth","category":"function","text":"firstdayofmonth(dt::TimeType)::TimeType\n\nAdjusts dt to the first day of its month.\n\nExamples\n\njulia> firstdayofmonth(DateTime(\"1996-05-20\"))\n1996-05-01T00:00:00\n\n\n\n\n\n"},{"title":"Dates.lastdayofmonth","page":"Dates","location":"stdlib/Dates.html#Dates.lastdayofmonth","category":"function","text":"lastdayofmonth(dt::TimeType)::TimeType\n\nAdjusts dt to the last day of its month.\n\nExamples\n\njulia> lastdayofmonth(DateTime(\"1996-05-20\"))\n1996-05-31T00:00:00\n\n\n\n\n\n"},{"title":"Dates.firstdayofyear","page":"Dates","location":"stdlib/Dates.html#Dates.firstdayofyear","category":"function","text":"firstdayofyear(dt::TimeType)::TimeType\n\nAdjusts dt to the first day of its year.\n\nExamples\n\njulia> firstdayofyear(DateTime(\"1996-05-20\"))\n1996-01-01T00:00:00\n\n\n\n\n\n"},{"title":"Dates.lastdayofyear","page":"Dates","location":"stdlib/Dates.html#Dates.lastdayofyear","category":"function","text":"lastdayofyear(dt::TimeType)::TimeType\n\nAdjusts dt to the last day of its year.\n\nExamples\n\njulia> lastdayofyear(DateTime(\"1996-05-20\"))\n1996-12-31T00:00:00\n\n\n\n\n\n"},{"title":"Dates.firstdayofquarter","page":"Dates","location":"stdlib/Dates.html#Dates.firstdayofquarter","category":"function","text":"firstdayofquarter(dt::TimeType)::TimeType\n\nAdjusts dt to the first day of its quarter.\n\nExamples\n\njulia> firstdayofquarter(DateTime(\"1996-05-20\"))\n1996-04-01T00:00:00\n\njulia> firstdayofquarter(DateTime(\"1996-08-20\"))\n1996-07-01T00:00:00\n\n\n\n\n\n"},{"title":"Dates.lastdayofquarter","page":"Dates","location":"stdlib/Dates.html#Dates.lastdayofquarter","category":"function","text":"lastdayofquarter(dt::TimeType)::TimeType\n\nAdjusts dt to the last day of its quarter.\n\nExamples\n\njulia> lastdayofquarter(DateTime(\"1996-05-20\"))\n1996-06-30T00:00:00\n\njulia> lastdayofquarter(DateTime(\"1996-08-20\"))\n1996-09-30T00:00:00\n\n\n\n\n\n"},{"title":"Dates.tonext","page":"Dates","location":"stdlib/Dates.html#Dates.tonext-Tuple{TimeType, Int64}","category":"method","text":"tonext(dt::TimeType, dow::Int; same::Bool=false)::TimeType\n\nAdjusts dt to the next day of week corresponding to dow with 1 = Monday, 2 = Tuesday, etc. Setting same=true allows the current dt to be considered as the next dow,\nallowing for no adjustment to occur.\n\n\n\n\n\n"},{"title":"Dates.toprev","page":"Dates","location":"stdlib/Dates.html#Dates.toprev-Tuple{TimeType, Int64}","category":"method","text":"toprev(dt::TimeType, dow::Int; same::Bool=false)::TimeType\n\nAdjusts dt to the previous day of week corresponding to dow with 1 = Monday, 2 = Tuesday, etc. Setting same=true allows the current dt to be considered as the previous\ndow, allowing for no adjustment to occur.\n\n\n\n\n\n"},{"title":"Dates.tofirst","page":"Dates","location":"stdlib/Dates.html#Dates.tofirst","category":"function","text":"tofirst(dt::TimeType, dow::Int; of=Month)::TimeType\n\nAdjusts dt to the first dow of its month. Alternatively, of=Year will adjust to the\nfirst dow of the year.\n\n\n\n\n\n"},{"title":"Dates.tolast","page":"Dates","location":"stdlib/Dates.html#Dates.tolast","category":"function","text":"tolast(dt::TimeType, dow::Int; of=Month)::TimeType\n\nAdjusts dt to the last dow of its month. Alternatively, of=Year will adjust to the\nlast dow of the year.\n\n\n\n\n\n"},{"title":"Dates.tonext","page":"Dates","location":"stdlib/Dates.html#Dates.tonext-Tuple{Function, TimeType}","category":"method","text":"tonext(func::Function, dt::TimeType; step=Day(1), limit=10000, same=false)::TimeType\n\nAdjusts dt by iterating at most limit iterations by step increments until func\nreturns true. func must take a single TimeType argument and return a Bool.\nsame allows dt to be considered in satisfying func.\n\n\n\n\n\n"},{"title":"Dates.toprev","page":"Dates","location":"stdlib/Dates.html#Dates.toprev-Tuple{Function, TimeType}","category":"method","text":"toprev(func::Function, dt::TimeType; step=Day(-1), limit=10000, same=false)::TimeType\n\nAdjusts dt by iterating at most limit iterations by step increments until func\nreturns true. func must take a single TimeType argument and return a Bool.\nsame allows dt to be considered in satisfying func.\n\n\n\n\n\n"},{"title":"Dates.Period","page":"Dates","location":"stdlib/Dates.html#Dates.Period-Tuple{Any}","category":"method","text":"Year(v)\nQuarter(v)\nMonth(v)\nWeek(v)\nDay(v)\nHour(v)\nMinute(v)\nSecond(v)\nMillisecond(v)\nMicrosecond(v)\nNanosecond(v)\n\nConstruct a Period type with the given v value. Input must be losslessly convertible\nto an Int64.\n\n\n\n\n\n"},{"title":"Dates.CompoundPeriod","page":"Dates","location":"stdlib/Dates.html#Dates.CompoundPeriod-Tuple{Vector{<:Period}}","category":"method","text":"CompoundPeriod(periods)\n\nConstruct a CompoundPeriod from a Vector of Periods. All Periods of the same type\nwill be added together.\n\nExamples\n\njulia> Dates.CompoundPeriod(Dates.Hour(12), Dates.Hour(13))\n25 hours\n\njulia> Dates.CompoundPeriod(Dates.Hour(-1), Dates.Minute(1))\n-1 hour, 1 minute\n\njulia> Dates.CompoundPeriod(Dates.Month(1), Dates.Week(-2))\n1 month, -2 weeks\n\njulia> Dates.CompoundPeriod(Dates.Minute(50000))\n50000 minutes\n\n\n\n\n\n"},{"title":"Dates.canonicalize","page":"Dates","location":"stdlib/Dates.html#Dates.canonicalize","category":"function","text":"canonicalize(::CompoundPeriod)::CompoundPeriod\n\nReduces the CompoundPeriod into its canonical form by applying the following rules:\n\nAny Period large enough be partially representable by a coarser Period will be broken\ninto multiple Periods (eg. Hour(30) becomes Day(1) + Hour(6))\nPeriods with opposite signs will be combined when possible\n(eg. Hour(1) - Day(1) becomes -Hour(23))\n\nExamples\n\njulia> canonicalize(Dates.CompoundPeriod(Dates.Hour(12), Dates.Hour(13)))\n1 day, 1 hour\n\njulia> canonicalize(Dates.CompoundPeriod(Dates.Hour(-1), Dates.Minute(1)))\n-59 minutes\n\njulia> canonicalize(Dates.CompoundPeriod(Dates.Month(1), Dates.Week(-2)))\n1 month, -2 weeks\n\njulia> canonicalize(Dates.CompoundPeriod(Dates.Minute(50000)))\n4 weeks, 6 days, 17 hours, 20 minutes\n\n\n\n\n\n"},{"title":"Dates.value","page":"Dates","location":"stdlib/Dates.html#Dates.value","category":"function","text":"Dates.value(x::Period)::Int64\n\nFor a given period, return the value associated with that period.  For example,\nvalue(Millisecond(10)) returns 10 as an integer.\n\n\n\n\n\n"},{"title":"Dates.default","page":"Dates","location":"stdlib/Dates.html#Dates.default","category":"function","text":"default(p::Period)::Period\n\nReturn a sensible \"default\" value for the input Period by returning T(1) for Year,\nMonth, and Day, and T(0) for Hour, Minute, Second, and Millisecond.\n\n\n\n\n\n"},{"title":"Dates.periods","page":"Dates","location":"stdlib/Dates.html#Dates.periods","category":"function","text":"Dates.periods(::CompoundPeriod)::Vector{Period}\n\nReturn the Vector of Periods that comprise the given CompoundPeriod.\n\ncompat: Julia 1.7\nThis function requires Julia 1.7 or later.\n\n\n\n\n\n"},{"title":"Base.floor","page":"Dates","location":"stdlib/Dates.html#Base.floor-Tuple{TimeType, Period}","category":"method","text":"floor(dt::TimeType, p::Period)::TimeType\n\nReturn the nearest Date or DateTime less than or equal to dt at resolution p.\n\nFor convenience, p may be a type instead of a value: floor(dt, Dates.Hour) is a shortcut\nfor floor(dt, Dates.Hour(1)).\n\njulia> floor(Date(1985, 8, 16), Month)\n1985-08-01\n\njulia> floor(DateTime(2013, 2, 13, 0, 31, 20), Minute(15))\n2013-02-13T00:30:00\n\njulia> floor(DateTime(2016, 8, 6, 12, 0, 0), Day)\n2016-08-06T00:00:00\n\n\n\n\n\n"},{"title":"Base.ceil","page":"Dates","location":"stdlib/Dates.html#Base.ceil-Tuple{TimeType, Period}","category":"method","text":"ceil(dt::TimeType, p::Period)::TimeType\n\nReturn the nearest Date or DateTime greater than or equal to dt at resolution p.\n\nFor convenience, p may be a type instead of a value: ceil(dt, Dates.Hour) is a shortcut\nfor ceil(dt, Dates.Hour(1)).\n\njulia> ceil(Date(1985, 8, 16), Month)\n1985-09-01\n\njulia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Minute(15))\n2013-02-13T00:45:00\n\njulia> ceil(DateTime(2016, 8, 6, 12, 0, 0), Day)\n2016-08-07T00:00:00\n\n\n\n\n\n"},{"title":"Base.round","page":"Dates","location":"stdlib/Dates.html#Base.round-Tuple{TimeType, Period, RoundingMode{:NearestTiesUp}}","category":"method","text":"round(dt::TimeType, p::Period, [r::RoundingMode]) -> TimeType\n\nReturn the Date or DateTime nearest to dt at resolution p. By default\n(RoundNearestTiesUp), ties (e.g., rounding 9:30 to the nearest hour) will be rounded up.\n\nFor convenience, p may be a type instead of a value: round(dt, Dates.Hour) is a shortcut\nfor round(dt, Dates.Hour(1)).\n\njulia> round(Date(1985, 8, 16), Month)\n1985-08-01\n\njulia> round(DateTime(2013, 2, 13, 0, 31, 20), Minute(15))\n2013-02-13T00:30:00\n\njulia> round(DateTime(2016, 8, 6, 12, 0, 0), Day)\n2016-08-07T00:00:00\n\nValid rounding modes for round(::TimeType, ::Period, ::RoundingMode) are\nRoundNearestTiesUp (default), RoundDown (floor), and RoundUp (ceil).\n\n\n\n\n\n"},{"title":"Base.floor","page":"Dates","location":"stdlib/Dates.html#Base.floor-Union{Tuple{T}, Tuple{Union{Day, Week, TimePeriod}, T}} where T<:Union{Day, Week, TimePeriod}","category":"method","text":"floor(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> T\n\nRound x down to the nearest multiple of precision. If x and precision are different\nsubtypes of Period, the return value will have the same type as precision.\n\nFor convenience, precision may be a type instead of a value: floor(x, Dates.Hour) is a\nshortcut for floor(x, Dates.Hour(1)).\n\njulia> floor(Day(16), Week)\n2 weeks\n\njulia> floor(Minute(44), Minute(15))\n30 minutes\n\njulia> floor(Hour(36), Day)\n1 day\n\nRounding to a precision of Months or Years is not supported, as these Periods are of\ninconsistent length.\n\n\n\n\n\n"},{"title":"Base.ceil","page":"Dates","location":"stdlib/Dates.html#Base.ceil-Tuple{Union{Day, Week, TimePeriod}, Union{Day, Week, TimePeriod}}","category":"method","text":"ceil(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> T\n\nRound x up to the nearest multiple of precision. If x and precision are different\nsubtypes of Period, the return value will have the same type as precision.\n\nFor convenience, precision may be a type instead of a value: ceil(x, Dates.Hour) is a\nshortcut for ceil(x, Dates.Hour(1)).\n\njulia> ceil(Day(16), Week)\n3 weeks\n\njulia> ceil(Minute(44), Minute(15))\n45 minutes\n\njulia> ceil(Hour(36), Day)\n2 days\n\nRounding to a precision of Months or Years is not supported, as these Periods are of\ninconsistent length.\n\n\n\n\n\n"},{"title":"Base.round","page":"Dates","location":"stdlib/Dates.html#Base.round-Tuple{Union{Day, Week, TimePeriod}, Union{Day, Week, TimePeriod}, RoundingMode{:NearestTiesUp}}","category":"method","text":"round(x::Period, precision::T, [r::RoundingMode]) where T <: Union{TimePeriod, Week, Day} -> T\n\nRound x to the nearest multiple of precision. If x and precision are different\nsubtypes of Period, the return value will have the same type as precision. By default\n(RoundNearestTiesUp), ties (e.g., rounding 90 minutes to the nearest hour) will be rounded\nup.\n\nFor convenience, precision may be a type instead of a value: round(x, Dates.Hour) is a\nshortcut for round(x, Dates.Hour(1)).\n\njulia> round(Day(16), Week)\n2 weeks\n\njulia> round(Minute(44), Minute(15))\n45 minutes\n\njulia> round(Hour(36), Day)\n2 days\n\nValid rounding modes for round(::Period, ::T, ::RoundingMode) are RoundNearestTiesUp\n(default), RoundDown (floor), and RoundUp (ceil).\n\nRounding to a precision of Months or Years is not supported, as these Periods are of\ninconsistent length.\n\n\n\n\n\n"},{"title":"Dates.floorceil","page":"Dates","location":"stdlib/Dates.html#Dates.floorceil","category":"function","text":"floorceil(dt::TimeType, p::Period) -> (TimeType, TimeType)\n\nSimultaneously return the floor and ceil of a Date or DateTime at resolution p.\nMore efficient than calling both floor and ceil individually.\n\n\n\n\n\nfloorceil(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> (T, T)\n\nSimultaneously return the floor and ceil of Period at resolution p.  More efficient\nthan calling both floor and ceil individually.\n\n\n\n\n\n"},{"title":"Dates.epochdays2date","page":"Dates","location":"stdlib/Dates.html#Dates.epochdays2date","category":"function","text":"epochdays2date(days)::Date\n\nTake the number of days since the rounding epoch (0000-01-01T00:00:00) and return the\ncorresponding Date.\n\n\n\n\n\n"},{"title":"Dates.epochms2datetime","page":"Dates","location":"stdlib/Dates.html#Dates.epochms2datetime","category":"function","text":"epochms2datetime(milliseconds)::DateTime\n\nTake the number of milliseconds since the rounding epoch (0000-01-01T00:00:00) and\nreturn the corresponding DateTime.\n\n\n\n\n\n"},{"title":"Dates.date2epochdays","page":"Dates","location":"stdlib/Dates.html#Dates.date2epochdays","category":"function","text":"date2epochdays(dt::Date)::Int64\n\nTake the given Date and return the number of days since the rounding epoch\n(0000-01-01T00:00:00) as an Int64.\n\n\n\n\n\n"},{"title":"Dates.datetime2epochms","page":"Dates","location":"stdlib/Dates.html#Dates.datetime2epochms","category":"function","text":"datetime2epochms(dt::DateTime)::Int64\n\nTake the given DateTime and return the number of milliseconds since the rounding epoch\n(0000-01-01T00:00:00) as an Int64.\n\n\n\n\n\n"},{"title":"Dates.today","page":"Dates","location":"stdlib/Dates.html#Dates.today","category":"function","text":"today()::Date\n\nReturn the date portion of now().\n\n\n\n\n\n"},{"title":"Dates.unix2datetime","page":"Dates","location":"stdlib/Dates.html#Dates.unix2datetime","category":"function","text":"unix2datetime(x)::DateTime\n\nTake the number of seconds since unix epoch 1970-01-01T00:00:00 and convert to the\ncorresponding DateTime.\n\n\n\n\n\n"},{"title":"Dates.datetime2unix","page":"Dates","location":"stdlib/Dates.html#Dates.datetime2unix","category":"function","text":"datetime2unix(dt::DateTime)::Float64\n\nTake the given DateTime and return the number of seconds\nsince the unix epoch 1970-01-01T00:00:00 as a Float64.\n\n\n\n\n\n"},{"title":"Dates.julian2datetime","page":"Dates","location":"stdlib/Dates.html#Dates.julian2datetime","category":"function","text":"julian2datetime(julian_days)::DateTime\n\nTake the number of Julian calendar days since epoch -4713-11-24T12:00:00 and return the\ncorresponding DateTime.\n\n\n\n\n\n"},{"title":"Dates.datetime2julian","page":"Dates","location":"stdlib/Dates.html#Dates.datetime2julian","category":"function","text":"datetime2julian(dt::DateTime)::Float64\n\nTake the given DateTime and return the number of Julian calendar days since the julian\nepoch -4713-11-24T12:00:00 as a Float64.\n\n\n\n\n\n"},{"title":"Dates.rata2datetime","page":"Dates","location":"stdlib/Dates.html#Dates.rata2datetime","category":"function","text":"rata2datetime(days)::DateTime\n\nTake the number of Rata Die days since epoch 0000-12-31T00:00:00 and return the\ncorresponding DateTime.\n\n\n\n\n\n"},{"title":"Dates.datetime2rata","page":"Dates","location":"stdlib/Dates.html#Dates.datetime2rata","category":"function","text":"datetime2rata(dt::TimeType)::Int64\n\nReturn the number of Rata Die days since epoch from the given Date or DateTime.\n\n\n\n\n\n"},{"title":"Dates.ISODateTimeFormat","page":"Dates","location":"stdlib/Dates.html#Dates.ISODateTimeFormat","category":"constant","text":"Dates.ISODateTimeFormat\n\nDescribes the ISO8601 formatting for a date and time. This is the default value for Dates.format\nof a DateTime.\n\nExamples\n\njulia> Dates.format(DateTime(2018, 8, 8, 12, 0, 43, 1), ISODateTimeFormat)\n\"2018-08-08T12:00:43.001\"\n\n\n\n\n\n"},{"title":"Dates.ISODateFormat","page":"Dates","location":"stdlib/Dates.html#Dates.ISODateFormat","category":"constant","text":"Dates.ISODateFormat\n\nDescribes the ISO8601 formatting for a date. This is the default value for Dates.format of a Date.\n\nExamples\n\njulia> Dates.format(Date(2018, 8, 8), ISODateFormat)\n\"2018-08-08\"\n\n\n\n\n\n"},{"title":"Dates.ISOTimeFormat","page":"Dates","location":"stdlib/Dates.html#Dates.ISOTimeFormat","category":"constant","text":"Dates.ISOTimeFormat\n\nDescribes the ISO8601 formatting for a time. This is the default value for Dates.format of a Time.\n\nExamples\n\njulia> Dates.format(Time(12, 0, 43, 1), ISOTimeFormat)\n\"12:00:43.001\"\n\n\n\n\n\n"},{"title":"Dates.RFC1123Format","page":"Dates","location":"stdlib/Dates.html#Dates.RFC1123Format","category":"constant","text":"Dates.RFC1123Format\n\nDescribes the RFC1123 formatting for a date and time.\n\nExamples\n\njulia> Dates.format(DateTime(2018, 8, 8, 12, 0, 43, 1), RFC1123Format)\n\"Wed, 08 Aug 2018 12:00:43\"\n\n\n\n\n\n"},{"title":"Calling C and Fortran Code","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Calling-C-and-Fortran-Code","category":"section","text":"Though most code can be written in Julia, there are many high-quality, mature libraries for numerical\ncomputing already written in C and Fortran. To allow easy use of this existing code, Julia makes\nit simple and efficient to call C and Fortran functions. Julia has a \"no boilerplate\" philosophy:\nfunctions can be called directly from Julia without any \"glue\" code, code generation, or compilation\n– even from the interactive prompt. This is accomplished just by making an appropriate call with the\n@ccall macro (or the less convenient ccall syntax, see the ccall syntax section).\n\nThe code to be called must be available as a shared library. Most C and Fortran libraries ship\ncompiled as shared libraries already, but if you are compiling the code yourself using GCC (or\nClang), you will need to use the -shared and -fPIC options. The machine instructions generated\nby Julia's JIT are the same as a native C call would be, so the resulting overhead is the same\nas calling a library function from C code. [1]\n\nBy default, Fortran compilers [generate mangled\nnames](https://en.wikipedia.org/wiki/Name_mangling#Fortran) (for example,\nconverting function names to lowercase or uppercase, often appending an\nunderscore), and so to call a Fortran function you must pass\nthe mangled identifier corresponding to the rule followed by your Fortran\ncompiler. Also, when calling a Fortran function, all inputs must be passed as\npointers to allocated values on the heap or stack. This applies not only to\narrays and other mutable objects which are normally heap-allocated, but also to\nscalar values such as integers and floats which are normally stack-allocated and\ncommonly passed in registers when using C or Julia calling conventions.\n\nThe syntax for @ccall to generate a call to the library function is:\n\n@ccall library.function_name(argvalue1::argtype1, ...)::returntype\n@ccall function_name(argvalue1::argtype1, ...)::returntype\n@ccall $function_pointer(argvalue1::argtype1, ...)::returntype\n\nwhere library is a string constant or global variable name (see [Non-constant\nFunction -Specifications](@ref) below). The library can be just a name, or it\ncan specify a full path to the library. The library may be omitted, in which\ncase the function name is resolved in the current executable, the current libc,\nor libjulia(-internal). This form can be used to call C library functions,\nfunctions in the Julia runtime, or functions in an application linked to Julia.\nOmitting the library cannot be used to call a function in any library (like\nspecifying RTLD_DEFAULT to dlsym) as such behavior is slow, complicated,\nand not implemented on all platforms.\nAlternatively, @ccall may also be used to call a function pointer\n$function_pointer, such as one returned by Libdl.dlsym. The argtypes\ncorresponds to the C-function signature and the argvalues are the actual\nargument values to be passed to the function.\n\nnote: Note\nSee below for how to map C types to Julia types.\n\nAs a complete but simple example, the following calls the clock function from the standard C\nlibrary on most Unix-derived systems:\n\njulia> t = @ccall clock()::Int32\n2292761\n\njulia> typeof(t)\nInt32\n\nclock takes no arguments and returns an Int32. To call the getenv function\nto get a pointer to the value of an environment variable, one makes a call like this:\n\njulia> path = @ccall getenv(\"SHELL\"::Cstring)::Cstring\nCstring(@0x00007fff5fbffc45)\n\njulia> unsafe_string(path)\n\"/bin/bash\"\n\nIn practice, especially when providing reusable functionality, one generally wraps @ccall\nuses in Julia functions that set up arguments and then check for errors in whatever manner the\nC or Fortran function specifies. If an error occurs it is thrown as a normal Julia exception. This is especially\nimportant since C and Fortran APIs are notoriously inconsistent about how they indicate error\nconditions. For example, the getenv C library function is wrapped in the following Julia function,\nwhich is a simplified version of the actual definition from env.jl:\n\nfunction getenv(var::AbstractString)\n    val = @ccall getenv(var::Cstring)::Cstring\n    if val == C_NULL\n        error(\"getenv: undefined variable: \", var)\n    end\n    return unsafe_string(val)\nend\n\nThe C getenv function indicates an error by returning C_NULL, but other standard C functions\nindicate errors in different ways, including by returning -1, 0, 1, and other special values.\nThis wrapper throws an exception indicating the problem if the caller tries to get a non-existent\nenvironment variable:\n\njulia> getenv(\"SHELL\")\n\"/bin/bash\"\n\njulia> getenv(\"FOOBAR\")\nERROR: getenv: undefined variable: FOOBAR\n\nHere is a slightly more complex example that discovers the local machine's hostname.\n\nfunction gethostname()\n    hostname = Vector{UInt8}(undef, 256) # MAXHOSTNAMELEN\n    err = @ccall gethostname(hostname::Ptr{UInt8}, sizeof(hostname)::Csize_t)::Int32\n    Base.systemerror(\"gethostname\", err != 0)\n    hostname[end] = 0 # ensure null-termination\n    return GC.@preserve hostname unsafe_string(pointer(hostname))\nend\n\nThis example first allocates an array of bytes. It then calls the C library function gethostname\nto populate the array with the hostname. Finally, it takes a pointer to the hostname buffer, and\nconverts the pointer to a Julia string, assuming that it is a null-terminated C string.\n\nIt is common for C libraries to use this pattern of requiring the caller to allocate memory to be\npassed to the callee and populated. Allocation of memory from Julia like this is generally\naccomplished by creating an uninitialized array and passing a pointer to its data to the C function.\nThis is why we don't use the Cstring type here: as the array is uninitialized, it could contain\nnull bytes. Converting to a Cstring as part of the @ccall checks for contained null bytes\nand could therefore throw a conversion error.\n\nDereferencing pointer(hostname) with unsafe_string is an unsafe operation as it requires access to\nthe memory allocated for hostname that may have been in the meanwhile garbage collected. The macro\nGC.@preserve prevents this from happening and therefore accessing an invalid memory location.\n\nFinally, here is an example of specifying a library via a path.\nWe create a shared library with the following content\n\n#include <stdio.h>\n\nvoid say_y(int y)\n{\n    printf(\"Hello from C: got y = %d.\\n\", y);\n}\n\nand compile it with gcc -fPIC -shared -o mylib.so mylib.c.\nIt can then be called by specifying the (absolute) path as the library name:\n\njulia> @ccall \"./mylib.so\".say_y(5::Cint)::Cvoid\nHello from C: got y = 5."},{"title":"Creating C-Compatible Julia Function Pointers","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Creating-C-Compatible-Julia-Function-Pointers","category":"section","text":"It is possible to pass Julia functions to native C functions that accept function pointer arguments.\nFor example, to match C prototypes of the form:\n\ntypedef returntype (*functiontype)(argumenttype, ...)\n\nThe macro @cfunction generates the C-compatible function pointer for a call to a\nJulia function. The arguments to @cfunction are:\n\nA Julia function\nThe function's return type\nA tuple of input types, corresponding to the function signature\n\nnote: Note\nAs with @ccall, the return type and the input types must be literal constants.\n\nnote: Note\nCurrently, only the platform-default C calling convention is supported. This means that\n@cfunction-generated pointers cannot be used in calls where WINAPI expects a stdcall\nfunction on 32-bit Windows, but can be used on WIN64 (where stdcall is unified with the\nC calling convention).\n\nnote: Note\nCallback functions exposed via @cfunction should not throw errors, as that will\nreturn control to the Julia runtime unexpectedly and may leave the program in an undefined state.\n\nA classic example is the standard C library qsort function, declared as:\n\nvoid qsort(void *base, size_t nitems, size_t size,\n           int (*compare)(const void*, const void*));\n\nThe base argument is a pointer to an array of length nitems, with elements of size bytes\neach. compare is a callback function which takes pointers to two elements a and b and returns\nan integer less/greater than zero if a should appear before/after b (or zero if any order\nis permitted).\n\nNow, suppose that we have a 1-d array A of values in Julia that we want to sort\nusing the qsort function (rather than Julia's built-in sort function). Before we consider\ncalling qsort and passing arguments, we need to write a comparison function:\n\njulia> function mycompare(a, b)::Cint\n           return (a < b) ? -1 : ((a > b) ? +1 : 0)\n       end;\n\nqsort expects a comparison function that return a C int, so we annotate the return type\nto be Cint.\n\nIn order to pass this function to C, we obtain its address using the macro @cfunction:\n\njulia> mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));\n\n@cfunction requires three arguments: the Julia function (mycompare), the return type\n(Cint), and a literal tuple of the input argument types, in this case to sort an array of Cdouble\n(Float64) elements.\n\nThe final call to qsort looks like this:\n\njulia> A = [1.3, -2.7, 4.4, 3.1];\n\njulia> @ccall qsort(A::Ptr{Cdouble}, length(A)::Csize_t, sizeof(eltype(A))::Csize_t, mycompare_c::Ptr{Cvoid})::Cvoid\n\njulia> A\n4-element Vector{Float64}:\n -2.7\n  1.3\n  3.1\n  4.4\n\nAs the example shows, the original Julia array A has now been sorted: [-2.7, 1.3, 3.1, 4.4]. Note that Julia\ntakes care of converting the array to a Ptr{Cdouble}, computing\nthe size of the element type in bytes, and so on.\n\nFor fun, try inserting a println(\"mycompare($a, $b)\") line into mycompare, which will allow\nyou to see the comparisons that qsort is performing (and to verify that it is really calling\nthe Julia function that you passed to it)."},{"title":"Mapping C Types to Julia","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#mapping-c-types-to-julia","category":"section","text":"It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies\ncan cause code that works correctly on one system to fail or produce indeterminate results on\na different system.\n\nNote that no C header files are used anywhere in the process of calling C functions: you are responsible\nfor making sure that your Julia types and call signatures accurately reflect those in the C header\nfile.[2]"},{"title":"Automatic Type Conversion","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#automatic-type-conversion","category":"section","text":"Julia automatically inserts calls to the Base.cconvert function to convert each argument\nto the specified type. For example, the following call:\n\n@ccall \"libfoo\".foo(x::Int32, y::Float64)::Cvoid\n\nwill behave as if it were written like this:\n\nc_x = Base.cconvert(Int32, x)\nc_y = Base.cconvert(Float64, y)\nGC.@preserve c_x c_y begin\n    @ccall \"libfoo\".foo(\n        Base.unsafe_convert(Int32, c_x)::Int32,\n        Base.unsafe_convert(Float64, c_y)::Float64\n    )::Cvoid\nend\n\nBase.cconvert normally just calls convert, but can be defined to return an\narbitrary new object more appropriate for passing to C.\nThis should be used to perform all allocations of memory that will be accessed by the C code.\nFor example, this is used to convert an Array of objects (e.g. strings) to an array of pointers.\n\nBase.unsafe_convert handles conversion to Ptr types. It is considered unsafe because\nconverting an object to a native pointer can hide the object from the garbage collector, causing\nit to be freed prematurely."},{"title":"Type Correspondences","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Type-Correspondences","category":"section","text":"First, let's review some relevant Julia type terminology:\n\nSyntax / Keyword Example Description\nmutable struct BitSet \"Concrete Type\" :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a concrete type must be fully defined (no TypeVars are allowed) in order for the instance to be constructed. Also see isconcretetype.\nabstract type Any, AbstractArray{T, N}, Complex{T} \"Super Type\" :: A super-type (not a concrete type) that cannot be instantiated, but can be used to describe a group of types. Also see isabstracttype.\nT{A} Vector{Int} \"Type Parameter\" :: A specialization of a type (typically used for dispatch or storage optimization).\n  \"TypeVar\" :: The T in the type parameter declaration is referred to as a TypeVar (short for type variable).\nprimitive type Int, Float64 \"Primitive Type\" :: A type with no fields, but a size. It is stored and defined by-value.\nstruct Pair{Int, Int} \"Struct\" :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag.\n ComplexF64 (isbits) \"Is-Bits\"   :: A primitive type, or a struct type where all fields are other isbits types. It is defined by-value, and is stored without a type-tag.\nstruct ...; end nothing \"Singleton\" :: a concrete Type or Struct with no fields.\n(...) or tuple(...) (1, 2, 3) \"Tuple\" :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct."},{"title":"Bits Types","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#man-bits-types","category":"section","text":"There are several special types to be aware of, as no other type can be defined to behave the\nsame:\n\nFloat32\nExactly corresponds to the float type in C (or REAL*4 in Fortran).\nFloat64\nExactly corresponds to the double type in C (or REAL*8 in Fortran).\nComplexF32\nExactly corresponds to the complex float type in C (or COMPLEX*8 in Fortran).\nComplexF64\nExactly corresponds to the complex double type in C (or COMPLEX*16 in Fortran).\nSigned\nExactly corresponds to the signed type annotation in C (or any INTEGER type in Fortran).\nAny Julia type that is not a subtype of Signed is assumed to be unsigned.\nRef{T}\nBehaves like a Ptr{T} that can manage its memory via the Julia GC.\nArray{T,N}\nWhen an array is passed to C as a Ptr{T} argument, it is not reinterpret-cast: Julia requires\nthat the element type of the array matches T, and the address of the first element is passed.\nTherefore, if an Array contains data in the wrong format, it will have to be explicitly converted\nusing a call such as trunc.(Int32, A).\nTo pass an array A as a pointer of a different type without converting the data beforehand\n(for example, to pass a Float64 array to a function that operates on uninterpreted bytes), you\ncan declare the argument as Ptr{Cvoid}.\nIf an array of eltype Ptr{T} is passed as a Ptr{Ptr{T}} argument, Base.cconvert\nwill attempt to first make a null-terminated copy of the array with each element replaced by its\nBase.cconvert version. This allows, for example, passing an argv pointer array of type\nVector{String} to an argument of type Ptr{Ptr{Cchar}}.\n\nOn all systems we currently support, basic C/C++ value types may be translated to Julia types\nas follows. Every C type also has a corresponding Julia type with the same name, prefixed by C.\nThis can help when writing portable code (and remembering that an int in C is not the same as\nan Int in Julia).\n\nSystem Independent Types\n\nC name Fortran name Standard Julia Alias Julia Base Type\nunsigned char CHARACTER Cuchar UInt8\nbool (_Bool in C99+)  Cuchar UInt8\nshort INTEGER*2, LOGICAL*2 Cshort Int16\nunsigned short  Cushort UInt16\nint, BOOL (C, typical) INTEGER*4, LOGICAL*4 Cint Int32\nunsigned int  Cuint UInt32\nlong long INTEGER*8, LOGICAL*8 Clonglong Int64\nunsigned long long  Culonglong UInt64\nintmax_t  Cintmax_t Int64\nuintmax_t  Cuintmax_t UInt64\nfloat REAL*4 Cfloat Float32\ndouble REAL*8 Cdouble Float64\ncomplex float COMPLEX*8 ComplexF32 Complex{Float32}\ncomplex double COMPLEX*16 ComplexF64 Complex{Float64}\nptrdiff_t  Cptrdiff_t Int\nssize_t  Cssize_t Int\nsize_t  Csize_t UInt\nvoid   Cvoid\nvoid and [[noreturn]] or _Noreturn   Union{}\nvoid*   Ptr{Cvoid} (or similarly Ref{Cvoid})\nT* (where T represents an appropriately defined type)   Ref{T} (T may be safely mutated only if T is an isbits type)\nchar* (or char[], e.g. a string) CHARACTER*N  Cstring if null-terminated, or Ptr{UInt8} if not\nchar** (or *char[])   Ptr{Ptr{UInt8}}\njl_value_t* (any Julia Type)   Any\njl_value_t* const* (a reference to a Julia value)   Ref{Any} (const, since mutation would require a write barrier, which is not possible to insert correctly)\nva_arg   Not supported\n... (variadic function specification)   T... (where T is one of the above types, when using the ccall function)\n... (variadic function specification)   ; va_arg1::T, va_arg2::S, etc. (only supported with @ccall macro)\n\nThe Cstring type is essentially a synonym for Ptr{UInt8}, except the conversion to Cstring\nthrows an error if the Julia string contains any embedded null characters (which would cause the\nstring to be silently truncated if the C routine treats null as the terminator). If you are passing\na char* to a C routine that does not assume null termination (e.g. because you pass an explicit\nstring length), or if you know for certain that your Julia string does not contain null and want\nto skip the check, you can use Ptr{UInt8} as the argument type. Cstring can also be used as\nthe ccall return type, but in that case it obviously does not introduce any extra\nchecks and is only meant to improve the readability of the call.\n\nSystem Dependent Types\n\nC name Standard Julia Alias Julia Base Type\nchar Cchar Int8 (x86, x86_64), UInt8 (powerpc, arm)\nlong Clong Int (UNIX), Int32 (Windows)\nunsigned long Culong UInt (UNIX), UInt32 (Windows)\nwchar_t Cwchar_t Int32 (UNIX), UInt16 (Windows)\n\nnote: Note\nWhen calling Fortran, all inputs must be passed by pointers to heap- or stack-allocated\nvalues, so all type correspondences above should contain an additional Ptr{..} or\nRef{..} wrapper around their type specification.\n\nwarning: Warning\nFor string arguments (char*) the Julia type should be Cstring (if null-terminated data is\nexpected), or either Ptr{Cchar} or Ptr{UInt8} otherwise (these two pointer types have the same\neffect), as described above, not String. Similarly, for array arguments (T[] or T*), the\nJulia type should again be Ptr{T}, not Vector{T}.\n\nwarning: Warning\nJulia's Char type is 32 bits, which is not the same as the wide-character type (wchar_t or\nwint_t) on all platforms.\n\nwarning: Warning\nA return type of Union{} means the function will not return, i.e., C++11 [[noreturn]] or C11\n_Noreturn (e.g. jl_throw or longjmp). Do not use this for functions that return no value\n(void) but do return, for those, use Cvoid instead.\n\nnote: Note\nFor wchar_t* arguments, the Julia type should be Cwstring (if the C routine expects a\nnull-terminated string), or Ptr{Cwchar_t} otherwise. Note also that UTF-8 string data in Julia is\ninternally null-terminated, so it can be passed to C functions expecting null-terminated data without\nmaking a copy (but using the Cwstring type will cause an error to be thrown if the string itself\ncontains null characters).\n\nnote: Note\nC functions that take an argument of type char** can be called by using a Ptr{Ptr{UInt8}}\ntype within Julia. For example, C functions of the form:int main(int argc, char **argv);can be called via the following Julia code:argv = [ \"a.out\", \"arg1\", \"arg2\" ]\n@ccall main(length(argv)::Int32, argv::Ptr{Ptr{UInt8}})::Int32\n\nnote: Note\nFor Fortran functions taking variable length strings of type character(len=*) the string lengths\nare provided as hidden arguments. Type and position of these arguments in the list are compiler\nspecific, where compiler vendors usually default to using Csize_t as type and append the hidden\narguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU),\nothers optionally permit placing hidden arguments directly after the character argument (Intel, PGI).\nFor example, Fortran subroutines of the formsubroutine test(str1, str2)\ncharacter(len=*) :: str1,str2can be called via the following Julia code, where the lengths are appendedstr1 = \"foo\"\nstr2 = \"bar\"\nccall(:test, Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),\n                    str1, str2, sizeof(str1), sizeof(str2))\n\nwarning: Warning\nFortran compilers may also add other hidden arguments for pointers, assumed-shape (:)\nand assumed-size (*) arrays. Such behaviour can be avoided by using ISO_C_BINDING and\nincluding bind(c) in the definition of the subroutine, which is strongly recommended for\ninteroperable code. In this case, there will be no hidden arguments, at the cost of some\nlanguage features (e.g. only character(len=1) will be permitted to pass strings).\n\nnote: Note\nA C function declared to return Cvoid will return the value nothing in Julia."},{"title":"Struct Type Correspondences","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Struct-Type-Correspondences","category":"section","text":"Composite types such as struct in C or TYPE in Fortran90 (or STRUCTURE / RECORD in some variants\nof F77), can be mirrored in Julia by creating a struct definition with the same\nfield layout.\n\nWhen used recursively, isbits types are stored inline. All other types are stored as a pointer\nto the data. When mirroring a struct used by-value inside another struct in C, it is imperative\nthat you do not attempt to manually copy the fields over, as this will not preserve the correct\nfield alignment. Instead, declare an isbits struct type and use that instead. Unnamed structs\nare not possible in the translation to Julia.\n\nPacked structs and union declarations are not supported by Julia.\n\nYou can get an approximation of a union if you know, a priori, the field that will have\nthe greatest size (potentially including padding). When translating your fields to Julia, declare\nthe Julia field to be only of that type.\n\nArrays of parameters can be expressed with NTuple. For example, the struct in C notation is written as\n\nstruct B {\n    int A[3];\n};\n\nb_a_2 = B.A[2];\n\ncan be written in Julia as\n\nstruct B\n    A::NTuple{3, Cint}\nend\n\nb_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)\n\nArrays of unknown size (C99-compliant variable length structs specified by [] or [0]) are not directly\nsupported. Often the best way to deal with these is to deal with the byte offsets directly.\nFor example, if a C library declared a proper string type and returned a pointer to it:\n\nstruct String {\n    int strlen;\n    char data[];\n};\n\nIn Julia, we can access the parts independently to make a copy of that string:\n\nstr = from_c::Ptr{Cvoid}\nlen = unsafe_load(Ptr{Cint}(str))\nunsafe_string(str + Core.sizeof(Cint), len)"},{"title":"Type Parameters","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Type-Parameters","category":"section","text":"The type arguments to @ccall and @cfunction are evaluated statically,\nwhen the method containing the usage is defined.\nThey therefore must take the form of a literal tuple, not a variable,\nand cannot reference local variables.\n\nThis may sound like a strange restriction,\nbut remember that since C is not a dynamic language like Julia,\nits functions can only accept argument types with a statically-known, fixed signature.\n\nHowever, while the type layout must be known statically to compute the intended C ABI,\nthe static parameters of the function are considered to be part of this static environment.\nThe static parameters of the function may be used as type parameters in the call signature,\nas long as they don't affect the layout of the type.\nFor example, f(x::T) where {T} = @ccall valid(x::Ptr{T})::Ptr{T}\nis valid, since Ptr is always a word-size primitive type.\nBut, g(x::T) where {T} = @ccall notvalid(x::T)::T\nis not valid, since the type layout of T is not known statically."},{"title":"SIMD Values","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#SIMD-Values","category":"section","text":"If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding\nJulia type is a homogeneous tuple of VecElement that naturally maps to the SIMD type. Specifically:\n\nThe tuple must be the same size and elements as the SIMD type. For example, a tuple\nrepresenting an __m128 on x86 must have a size of 16 bytes and Float32 elements.\nThe element type of the tuple must be an instance of VecElement{T} where T is a\nprimitive type with a power-of-two number of bytes (e.g. 1, 2, 4, 8, 16, etc) such as\nInt8 or Float64.\n\nFor instance, consider this C routine that uses AVX intrinsics:\n\n#include <immintrin.h>\n\n__m256 dist( __m256 a, __m256 b ) {\n    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),\n                                        _mm256_mul_ps(b, b)));\n}\n\nThe following Julia code calls dist using ccall:\n\nconst m256 = NTuple{8, VecElement{Float32}}\n\na = m256(ntuple(i -> VecElement(sin(Float32(i))), 8))\nb = m256(ntuple(i -> VecElement(cos(Float32(i))), 8))\n\nfunction call_dist(a::m256, b::m256)\n    @ccall \"libdist\".dist(a::m256, b::m256)::m256\nend\n\nprintln(call_dist(a,b))\n\nThe host machine must have the requisite SIMD registers. For example, the code above will not\nwork on hosts without AVX support."},{"title":"Memory Ownership","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Memory-Ownership","category":"section","text":"malloc/free\n\nMemory allocation and deallocation of such objects must be handled by calls to the appropriate\ncleanup routines in the libraries being used, just like in any C program. Do not try to free an\nobject received from a C library with Libc.free in Julia, as this may result in the free function\nbeing called via the wrong library and cause the process to abort. The reverse (passing an object\nallocated in Julia to be freed by an external library) is equally invalid."},{"title":"When to use T, Ptr{T} and Ref{T}","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#When-to-use-T,-Ptr{T}-and-Ref{T}","category":"section","text":"In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared\nto be of type T inside the @ccall, as they are passed by value. For C code accepting\npointers, Ref{T} should generally be used for the types of input arguments, allowing the use\nof pointers to memory managed by either Julia or C through the implicit call to Base.cconvert.\nIn contrast, pointers returned by the C function called should be declared to be of the output type\nPtr{T}, reflecting that the memory pointed to is managed by C only. Pointers contained in C\nstructs should be represented as fields of type Ptr{T} within the corresponding Julia struct\ntypes designed to mimic the internal structure of corresponding C structs.\n\nIn Julia code wrapping calls to external Fortran routines, all input arguments\nshould be declared as of type Ref{T}, as Fortran passes all variables by\npointers to memory locations. The return type should either be Cvoid for\nFortran subroutines, or a T for Fortran functions returning the type T."},{"title":"Mapping C Functions to Julia","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Mapping-C-Functions-to-Julia","category":"section","text":""},{"title":"@ccall / @cfunction argument translation guide","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#@ccall-/-@cfunction-argument-translation-guide","category":"section","text":"For translating a C argument list to Julia:\n\nT, where T is one of the primitive types: char, int, long, short, float, double,\ncomplex, enum or any of their typedef equivalents\nT, where T is an equivalent Julia Bits Type (per the table above)\nif T is an enum, the argument type should be equivalent to Cint or Cuint\nargument value will be copied (passed by value)\nstruct T (including typedef to a struct)\nT, where T is a concrete Julia type\nargument value will be copied (passed by value)\nvector T (or __attribute__ vector_size, or a typedef such as __m128)\nNTuple{N, VecElement{T}}, where T is a primitive Julia type of the correct size\nand N is the number of elements in the vector (equal to vector_size / sizeof T).\nvoid*\ndepends on how this parameter is used, first translate this to the intended pointer type, then\ndetermine the Julia equivalent using the remaining rules in this list\nthis argument may be declared as Ptr{Cvoid} if it really is just an unknown pointer\njl_value_t*\nAny\nargument value must be a valid Julia object\njl_value_t* const*\nRef{Any}\nargument list must be a valid Julia object (or C_NULL)\ncannot be used for an output parameter, unless the user is able to\nseparately arrange for the object to be GC-preserved\nT*\nRef{T}, where T is the Julia type corresponding to T\nargument value will be copied if it is an inlinealloc type (which\nincludes isbits otherwise, the value must be a valid Julia object\nT (*)(...) (e.g. a pointer to a function)\nPtr{Cvoid} (you may need to use @cfunction explicitly to\ncreate this pointer)\n... (e.g. a vararg)\n[for ccall]: T..., where T is the single Julia type of all\nremaining arguments\n[for @ccall]: ; va_arg1::T, va_arg2::S, etc, where T and S are\nthe Julia type (i.e. separate the regular arguments from varargs with\na ;)\ncurrently unsupported by @cfunction\nva_arg\nnot supported by ccall or @cfunction"},{"title":"@ccall / @cfunction return type translation guide","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#@ccall-/-@cfunction-return-type-translation-guide","category":"section","text":"For translating a C return type to Julia:\n\nvoid\nCvoid (this will return the singleton instance nothing::Cvoid)\nT, where T is one of the primitive types: char, int, long, short, float, double,\ncomplex, enum or any of their typedef equivalents\nsame as C argument list\nargument value will be copied (returned by-value)\nstruct T (including typedef to a struct)\nsame as C argument list\nargument value will be copied (returned by-value)\nvector T\nsame as C argument list\nvoid*\ndepends on how this parameter is used, first translate this to the intended pointer type, then\ndetermine the Julia equivalent using the remaining rules in this list\nthis argument may be declared as Ptr{Cvoid} if it really is just an unknown pointer\njl_value_t*\nAny\nargument value must be a valid Julia object\njl_value_t**\nPtr{Any} (Ref{Any} is invalid as a return type)\nT*\nIf the memory is already owned by Julia, or is an isbits type, and is known to be non-null:\nRef{T}, where T is the Julia type corresponding to T\na return type of Ref{Any} is invalid, it should either be Any (corresponding to\njl_value_t*) or Ptr{Any} (corresponding to jl_value_t**)\nC MUST NOT modify the memory returned via Ref{T} if T is an isbits type\nIf the memory is owned by C:\nPtr{T}, where T is the Julia type corresponding to T\nT (*)(...) (e.g. a pointer to a function)\nPtr{Cvoid} to call this directly from Julia you will need to pass this as the first argument to @ccall.\nSee Indirect Calls."},{"title":"Passing Pointers for Modifying Inputs","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Passing-Pointers-for-Modifying-Inputs","category":"section","text":"Because C doesn't support multiple return values, often C functions will take pointers to data\nthat the function will modify. To accomplish this within a @ccall, you need to first\nencapsulate the value inside a Ref{T} of the appropriate type. When you pass this Ref object\nas an argument, Julia will automatically pass a C pointer to the encapsulated data:\n\nwidth = Ref{Cint}(0)\nrange = Ref{Cfloat}(0)\n@ccall foo(width::Ref{Cint}, range::Ref{Cfloat})::Cvoid\n\nUpon return, the contents of width and range can be retrieved (if they were changed by foo)\nby width[] and range[]; that is, they act like zero-dimensional arrays."},{"title":"C Wrapper Examples","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#C-Wrapper-Examples","category":"section","text":"Let's start with a simple example of a C wrapper that returns a Ptr type:\n\nmutable struct gsl_permutation\nend\n\n# The corresponding C signature is\n#     gsl_permutation * gsl_permutation_alloc (size_t n);\nfunction permutation_alloc(n::Integer)\n    output_ptr = @ccall \"libgsl\".gsl_permutation_alloc(n::Csize_t)::Ptr{gsl_permutation}\n    if output_ptr == C_NULL # Could not allocate memory\n        throw(OutOfMemoryError())\n    end\n    return output_ptr\nend\n\nThe GNU Scientific Library (here assumed to be accessible\nthrough :libgsl) defines an opaque pointer, gsl_permutation *, as the return type of the C\nfunction gsl_permutation_alloc. As user code never has to look inside the gsl_permutation\nstruct, the corresponding Julia wrapper simply needs a new type declaration, gsl_permutation,\nthat has no internal fields and whose sole purpose is to be placed in the type parameter of a\nPtr type. The return type of the ccall is declared as Ptr{gsl_permutation}, since\nthe memory allocated and pointed to by output_ptr is controlled by C.\n\nThe input n is passed by value, and so the function's input signature is\nsimply declared as ::Csize_t without any Ref or Ptr necessary. (If the\nwrapper was calling a Fortran function instead, the corresponding function input\nsignature would instead be ::Ref{Csize_t}, since Fortran variables are\npassed by pointers.) Furthermore, n can be any type that is convertible to a\nCsize_t integer; the ccall implicitly calls [Base.cconvert(Csize_t, n)](@ref).\n\nHere is a second example wrapping the corresponding destructor:\n\n# The corresponding C signature is\n#     void gsl_permutation_free (gsl_permutation * p);\nfunction permutation_free(p::Ptr{gsl_permutation})\n    @ccall \"libgsl\".gsl_permutation_free(p::Ptr{gsl_permutation})::Cvoid\nend\n\nHere is a third example passing Julia arrays:\n\n# The corresponding C signature is\n#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,\n#                                double result_array[])\nfunction sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)\n    if nmax < nmin\n        throw(DomainError())\n    end\n    result_array = Vector{Cdouble}(undef, nmax - nmin + 1)\n    errorcode = @ccall \"libgsl\".gsl_sf_bessel_Jn_array(\n                    nmin::Cint, nmax::Cint, x::Cdouble, result_array::Ref{Cdouble})::Cint\n    if errorcode != 0\n        error(\"GSL error code $errorcode\")\n    end\n    return result_array\nend\n\nThe C function wrapped returns an integer error code; the results of the actual evaluation of\nthe Bessel J function populate the Julia array result_array. This variable is declared as a\nRef{Cdouble}, since its memory is allocated and managed by Julia. The implicit call to\nBase.cconvert(Ref{Cdouble}, result_array) unpacks\nthe Julia pointer to a Julia array data structure into a form understandable by C."},{"title":"Fortran Wrapper Example","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Fortran-Wrapper-Example","category":"section","text":"The following example utilizes ccall to call a function in a common Fortran library (libBLAS) to\ncompute a dot product. Notice that the argument mapping is a bit different here than above, as\nwe need to map from Julia to Fortran. On every argument type, we specify Ref or Ptr. This\nmangling convention may be specific to your Fortran compiler and operating system and is likely\nundocumented. However, wrapping each in a Ref (or Ptr, where equivalent) is a frequent\nrequirement of Fortran compiler implementations:\n\nfunction compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\n    @assert length(DX) == length(DY)\n    n = length(DX)\n    incx = incy = 1\n    product = @ccall \"libLAPACK\".ddot(\n        n::Ref{Int32}, DX::Ptr{Float64}, incx::Ref{Int32}, DY::Ptr{Float64}, incy::Ref{Int32})::Float64\n    return product\nend"},{"title":"Garbage Collection Safety","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Garbage-Collection-Safety","category":"section","text":"When passing data to a @ccall, it is best to avoid using the pointer function.\nInstead define a Base.cconvert method and pass the variables directly to the @ccall. @ccall\nautomatically arranges that all of its arguments will be preserved from garbage collection until\nthe call returns. If a C API will store a reference to memory allocated by Julia, after the @ccall\nreturns, you must ensure that the object remains visible to the garbage collector. The suggested\nway to do this is to make a global variable of type Vector{Ref} to hold these values until\nthe C library notifies you that it is finished with them.\n\nWhenever you have created a pointer to Julia data, you must ensure the original data exists until\nyou have finished using the pointer. Many methods in Julia such as unsafe_load and\nString make copies of data instead of taking ownership of the buffer, so that it is\nsafe to free (or alter) the original data without affecting Julia. A notable exception is\nunsafe_wrap which, for performance reasons, shares (or can be told to take ownership of) the\nunderlying buffer.\n\nThe garbage collector does not guarantee any order of finalization. That is, if a contained\na reference to b and both a and b are due for garbage collection, there is no guarantee\nthat b would be finalized after a. If proper finalization of a depends on b being valid,\nit must be handled in other ways."},{"title":"Non-constant Function Specifications","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Non-constant-Function-Specifications","category":"section","text":"In some cases, the exact name or path of the needed library is not known in\nadvance and must be computed at run time. To handle such cases, the library\ncomponent specification can be a value such as Libdl.LazyLibrary. The runtime\nwill call Libdl.dlopen on that object when first used by a ccall."},{"title":"Using LazyLibrary for Lazy Loading","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#man-lazylibrary","category":"section","text":"Libdl.LazyLibrary provides a thread-safe mechanism for deferring library loading\nuntil first use. This is the recommended approach for library initialization in modern Julia code.\n\nA LazyLibrary represents a library that opens itself (and its dependencies) automatically\non first use in a ccall(), @ccall, dlopen(), dlsym(), dlpath(), or cglobal().\nThe library is loaded exactly once in a thread-safe manner, and subsequent calls reuse the\nloaded library handle."},{"title":"Basic Usage","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Basic-Usage","category":"section","text":"using Libdl\n\n# Define a LazyLibrary as a const for optimal performance\nconst libz = LazyLibrary(\"libz\")\n\n# Use directly in @ccall - library loads automatically on first call\n@ccall libz.deflate(strm::Ptr{Cvoid}, flush::Cint)::Cint\n\n# Also works with ccall\nccall((:inflate, libz), Cint, (Ptr{Cvoid}, Cint), strm, flush)"},{"title":"Platform-Specific Libraries","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Platform-Specific-Libraries","category":"section","text":"For code that needs to work across different platforms:\n\nconst mylib = LazyLibrary(\n    if Sys.iswindows()\n        \"mylib.dll\"\n    elseif Sys.isapple()\n        \"libmylib.dylib\"\n    else\n        \"libmylib.so\"\n    end\n)"},{"title":"Libraries with Dependencies","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Libraries-with-Dependencies","category":"section","text":"When a library depends on other libraries, specify the dependencies to ensure\nthey load in the correct order:\n\nconst libfoo = LazyLibrary(\"libfoo\")\nconst libbar = LazyLibrary(\"libbar\"; dependencies=[libfoo])\n\n# When libbar is first used, libfoo is loaded first automatically\n@ccall libbar.bar_function(x::Cint)::Cint"},{"title":"Lazy Path Construction","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Lazy-Path-Construction","category":"section","text":"For libraries whose paths are determined at runtime, use LazyLibraryPath:\n\n# Path is constructed when library is first accessed\nconst mylib = LazyLibrary(LazyLibraryPath(artifact_dir, \"lib\", \"libmylib.so\"))"},{"title":"Initialization Callbacks","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Initialization-Callbacks","category":"section","text":"If a library requires initialization after loading:\n\nconst mylib = LazyLibrary(\"libmylib\";\n    on_load_callback = () -> @ccall mylib.initialize()::Cvoid\n)\n\nwarning: Warning\nThe on_load_callback should be minimal and must not call wait() on any tasks.\nIt is called exactly once by the thread that loads the library."},{"title":"Conversion from __init__() Pattern","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Conversion-from-__init__()-Pattern","category":"section","text":"Before LazyLibrary, library paths were often computed in __init__() functions.\nThis pattern can be replaced with LazyLibrary for better performance and thread safety.\n\nOld pattern using __init__():\n\n# Old: Library path computed in __init__()\nlibmylib_path = \"\"\n\nfunction __init__(\n    # Loads library on startup, whether it is used or not\n    global libmylib_path = find_library([\"libmylib\"])\nend\n\nfunction myfunc(x)\n    ccall((:cfunc, libmylib_path), Cint, (Cint,), x)\nend\n\nNew pattern using LazyLibrary:\n\n# New: Library as const, no __init__() needed\nconst libmylib = LazyLibrary(\"libmylib\")\n\nfunction myfunc(x)\n    # Library loads automatically just before calling `cfunc`\n    @ccall libmylib.cfunc(x::Cint)::Cint\nend\n\nFor more details, see the Libdl.LazyLibrary documentation."},{"title":"Overloading dlopen for Custom Types","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Overloading-dlopen-for-Custom-Types","category":"section","text":"The runtime will call dlsym(:function, dlopen(library)::Ptr{Cvoid}) when a @ccall is executed.\nThe Libdl.dlopen function can be overloaded for custom types to provide alternate behaviors.\nHowever, it is assumed that the library location and handle does not change\nonce it is determined, so the result of the call may be cached and reused.\nTherefore, the number of times the dlopen expression executes is unspecified,\nand returning different values for multiple calls will results in unspecified\n(but valid) behavior."},{"title":"Computed Function Names","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Computed-Function-Names","category":"section","text":"If even more flexibility is needed, it is possible to use computed values as\nfunction names by staging through eval as follows:\n\n@eval @ccall \"lib\".$(string(\"a\", \"b\"))()::Cint\n\nThis expression constructs a name using string, then substitutes this name into a new @ccall\nexpression, which is then evaluated. Keep in mind that eval only operates at the top level,\nso within this expression local variables will not be available (unless their values are substituted\nwith $). For this reason, eval is typically only used to form top-level definitions, for example\nwhen wrapping libraries that contain many similar functions."},{"title":"Indirect Calls","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Indirect-Calls","category":"section","text":"The first argument to @ccall can also be an expression to be evaluated at run\ntime, each time it is used. In this case, the expression must evaluate to a\nPtr, which will be used as the address of the native function to call. This\nbehavior occurs when the first @ccall argument is marked with $ and when\nthe first ccall argument is not a simple constant literal or expression in\n(). The argument can be any expression and can use local variables and\narguments and can return a different value every time.\n\nFor example, you might implement a macro similar to cglobal that looks up the\nfunction via dlsym, then caches the pointer in a shared reference (which is\nauto reset to C_NULL during precompile saving).\nFor example:\n\nmacro dlsym(lib, func)\n    z = Ref(C_NULL)\n    quote\n        local zlocal = $z[]\n        if zlocal == C_NULL\n            zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}\n            $z[] = zlocal\n        end\n        zlocal\n    end\nend\n\nconst mylibvar = LazyLibrary(\"mylib\")\n@ccall $(@dlsym(dlopen(mylibvar), \"myfunc\"))()::Cvoid"},{"title":"Closure cfunctions","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Closure-cfunctions","category":"section","text":"The first argument to @cfunction can be marked with a $, in which case\nthe return value will instead be a struct CFunction which closes over the argument.\nYou must ensure that this return object is kept alive until all uses of it are done.\nThe contents and code at the cfunction pointer will be erased via a finalizer\nwhen this reference is dropped and atexit. This is not usually needed, since this\nfunctionality is not present in C, but can be useful for dealing with ill-designed APIs\nwhich don't provide a separate closure environment parameter.\n\nfunction qsort(a::Vector{T}, cmp) where T\n    isbits(T) || throw(ArgumentError(\"this method can only qsort isbits arrays\"))\n    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})\n    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}\n    # (and protected against finalization) by the ccall\n    @ccall qsort(a::Ptr{T}, length(a)::Csize_t, Base.elsize(a)::Csize_t, callback::Ptr{Cvoid})\n    # We could instead use:\n    #    GC.@preserve callback begin\n    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))\n    #    end\n    # if we needed to use it outside of a `ccall`\n    return a\nend\n\nnote: Note\nClosure @cfunction relies on LLVM trampolines, which are not available on all\nplatforms (for example ARM and PowerPC)."},{"title":"Closing a Library","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Closing-a-Library","category":"section","text":"It is sometimes useful to close (unload) a library so that it can be reloaded.\nFor instance, when developing C code for use with Julia, one may need to compile,\ncall the C code from Julia, then close the library, make an edit, recompile,\nand load in the new changes. One can either restart Julia or use the\nLibdl functions to manage the library explicitly, such as:\n\nlib = Libdl.dlopen(\"./my_lib.so\") # Open the library explicitly.\nsym = Libdl.dlsym(lib, :my_fcn)   # Get a symbol for the function to call.\n@ccall $sym(...) # Use the pointer `sym` instead of the library.symbol tuple.\nLibdl.dlclose(lib) # Close the library explicitly.\n\nNote that when using @ccall with the input\n(e.g., @ccall \"./my_lib.so\".my_fcn(...)::Cvoid), the library is opened implicitly\nand it may not be explicitly closed."},{"title":"Variadic function calls","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Variadic-function-calls","category":"section","text":"To call variadic C functions a semicolon can be used in the argument list to\nseparate required arguments from variadic arguments. An example with the\nprintf function is given below:\n\njulia> @ccall printf(\"%s = %d\\n\"::Cstring ; \"foo\"::Cstring, foo::Cint)::Cint\nfoo = 3\n8"},{"title":"ccall interface","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#ccall-interface","category":"section","text":"There is another alternative interface to @ccall.\nThis interface is slightly less convenient but it does allow one to specify a calling convention.\n\nThe arguments to ccall are:\n\nA (:function, \"library\") pair (most common),\nOR\na :function name symbol or \"function\" name string (for symbols in the current process or libc),\nOR\na function pointer (for example, from dlsym).\nThe function's return type\nA tuple of input types, corresponding to the function signature. One common mistake is forgetting that a 1-tuple of\nargument types must be written with a trailing comma.\nThe actual argument values to be passed to the function, if any; each is a separate parameter.\n\nnote: Note\nThe (:function, \"library\") pair and the input type list must be syntactic tuples\n(i.e., they can't be variables or values with a type of Tuple.The rettype and argument type values are evaluated at when the containing method is\ndefined, not runtime.\n\nnote: Function Name vs Pointer Syntax\nThe syntax of the first argument to ccall determines whether you're calling by name or by pointer:Name-based calls (tuple literal syntax):Both the function and library names can be a quoted Symbol, a String, a\nvariable name (a GlobalRef), or a dotted expression ending with a variable\nname.\nSingle name: (:function_name,) or \"function_name\" - uses default library lookup.\nName with library: (:function_name, \"library\") - specifies both function and library.\nSymbol, string, and tuple literal constants (not expressions that evaluate to those constants,\nbut actual literals) are automatically normalized to tuple form.Pointer-based calls (non-tuple syntax):Anything that is not a literal tuple expression specified above is assumed to be an\nexpression that evaluates to a function pointers at runtime.\nFunction pointer variables: fptr where fptr is a runtime pointer value.\nFunction pointer computations: dlsym(:something) where the result is computed at\nruntime every time (usually along with some caching logic).Library name expressions:When given as a variable, the library name can resolve to a Symbol, a String, or\nany other value. The runtime will call Libdl.dlopen(name) on the value an\nunspecified number of times, caching the result. The result is not invalidated if the\nvalue of the binding changes or if it becomes undefined, as long as there exists any\nvalue for that binding in any past or future worlds, that value may be used.\nDot expressions, such as A.B().c, will be executed at method definition\ntime up to the final c. The first part must resolve to a Module, and the\nsecond part to a quoted symbol. The value of that global will be resolved at\nruntime when the ccall is first executed.\n\nA table of translations between the macro and function interfaces is given below.\n\n@ccall ccall\n@ccall clock()::Int32 ccall(:clock, Int32, ())\n@ccall f(a::Cint)::Cint ccall(:f, Cint, (Cint,), a)\n@ccall \"mylib\".f(a::Cint, b::Cdouble)::Cvoid ccall((:f, \"mylib\"), Cvoid, (Cint, Cdouble), a, b)\n@ccall $fptr.f()::Cvoid ccall(fptr, f, Cvoid, ())\n@ccall printf(\"%s = %d\\n\"::Cstring ; \"foo\"::Cstring, foo::Cint)::Cint <unavailable>\n@ccall printf(\"%s = %s\\n\"::Cstring ; \"2 + 2\"::Cstring, \"5\"::Cstring)::Cint ccall(:printf, Cint, (Cstring, Cstring...), \"%s = %s\\n\", \"2 + 2\", \"5\")\n<unavailable> ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))"},{"title":"Calling Convention","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#calling-convention","category":"section","text":"The second argument to ccall (immediately preceding return type) can optionally\nbe a calling convention specifier (the @ccall macro currently does not support\ngiving a calling convention). Without any specifier, the platform-default C\ncalling convention is used. Other supported conventions are: stdcall, cdecl,\nfastcall, and thiscall (no-op on 64-bit Windows). For example (from\nbase/libc.jl) we see the same gethostname ccall as above, but with the\ncorrect signature for Windows:\n\nhn = Vector{UInt8}(undef, 256)\nerr = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))\n\nFor more information, please see the LLVM Language Reference.\n\nThere is one additional special calling convention llvmcall,\nwhich allows inserting calls to LLVM intrinsics directly.\nThis can be especially useful when targeting unusual platforms such as GPGPUs.\nFor example, for CUDA, we need to be able to read the thread index:\n\nccall(\"llvm.nvvm.read.ptx.sreg.tid.x\", llvmcall, Int32, ())\n\nAs with any ccall, it is essential to get the argument signature exactly correct.\nAlso, note that there is no compatibility layer that ensures the intrinsic makes\nsense and works on the current target,\nunlike the equivalent Julia functions exposed by Core.Intrinsics."},{"title":"Accessing Global Variables","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Accessing-Global-Variables","category":"section","text":"Global variables exported by native libraries can be accessed by name using the cglobal\nfunction. The arguments to cglobal are a symbol specification identical to that used\nby ccall, and a type describing the value stored in the variable:\n\njulia> cglobal((:errno, :libc), Int32)\nPtr{Int32} @0x00007f418d0816b8\n\nThe result is a pointer giving the address of the value. The value can be manipulated through\nthis pointer using unsafe_load and unsafe_store!.\n\nnote: Note\nThis errno symbol may not be found in a library named \"libc\", as this is an implementation detail of\nyour system compiler. Typically standard library symbols should be accessed just by name,\nallowing the compiler to fill in the correct one.\nAlso, however, the errno symbol shown in this example is special in most compilers, and so the value\nseen here is probably not what you expect or want. Compiling the equivalent code in C on any\nmulti-threaded-capable system would typically actually call a different function (via macro preprocessor\noverloading), and may give a different result than the legacy value printed here."},{"title":"Accessing Data through a Pointer","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Accessing-Data-through-a-Pointer","category":"section","text":"The following methods are described as \"unsafe\" because a bad pointer or type declaration can\ncause Julia to terminate abruptly.\n\nGiven a Ptr{T}, the contents of type T can generally be copied from the referenced memory\ninto a Julia object using unsafe_load(ptr, [index]). The index argument is optional (default\nis 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar\nto the behavior of getindex and setindex! (e.g. [] access syntax).\n\nThe return value will be a new object initialized to contain a copy of the contents of the referenced\nmemory. The referenced memory can safely be freed or released.\n\nIf T is Any, then the memory is assumed to contain a reference to a Julia object (a jl_value_t*),\nthe result will be a reference to this object, and the object will not be copied. You must be\ncareful in this case to ensure that the object was always visible to the garbage collector (pointers\ndo not count, but the new reference does) to ensure the memory is not prematurely freed. Note\nthat if the object was not originally allocated by Julia, the new object will never be finalized\nby Julia's garbage collector. If the Ptr itself is actually a jl_value_t*, it can be converted\nback to a Julia object reference by unsafe_pointer_to_objref(ptr). (Julia values v\ncan be converted to jl_value_t* pointers, as Ptr{Cvoid}, by calling pointer_from_objref(v).)\n\nThe reverse operation (writing data to a Ptr{T}), can be performed using unsafe_store!(ptr, value, [index]).\nCurrently, this is only supported for primitive types or other pointer-free (isbits) immutable struct\ntypes.\n\nAny operation that throws an error is probably currently unimplemented and should be posted as\na bug so that it can be resolved.\n\nIf the pointer of interest is a plain-data array (primitive type or immutable struct), the function\nunsafe_wrap(Array, ptr,dims, own = false)\nmay be more useful. The final parameter should be true if Julia should \"take ownership\" of the\nunderlying buffer and call free(ptr) when the returned Array object is finalized. If the\nown parameter is omitted or false, the caller must ensure the buffer remains in existence until\nall access is complete.\n\nArithmetic on the Ptr type in Julia (e.g. using +) does not behave the same as C's pointer\narithmetic. Adding an integer to a Ptr in Julia always moves the pointer by some number of\nbytes, not elements. This way, the address values obtained from pointer arithmetic do not depend\non the element types of pointers."},{"title":"Thread-safety","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#Thread-safety","category":"section","text":"Some C libraries execute their callbacks from a different thread, and since Julia isn't thread-safe\nyou'll need to take some extra precautions. In particular, you'll need to set up a two-layered\nsystem: the C callback should only schedule (via Julia's event loop) the execution of your \"real\"\ncallback. To do this, create an AsyncCondition object and wait on it:\n\ncond = Base.AsyncCondition()\nwait(cond)\n\nThe callback you pass to C should only execute a ccall to :uv_async_send, passing\ncond.handle as the argument, taking care to avoid any allocations or other interactions with the\nJulia runtime.\n\nNote that events may be coalesced, so multiple calls to uv_async_send may result in a single wakeup\nnotification to the condition."},{"title":"More About Callbacks","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#More-About-Callbacks","category":"section","text":"For more details on how to pass callbacks to C libraries, see this blog post."},{"title":"C++","page":"Calling C and Fortran Code","location":"manual/calling-c-and-fortran-code.html#C","category":"section","text":"For tools to create C++ bindings, see the CxxWrap package.\n\n[1]: Non-library function calls in both C and Julia can be inlined and thus may have\neven less overhead than calls to shared library functions.\nThe point above is that the cost of actually doing foreign function call is about the same as doing a call in either native language.\n\n[2]: The Clang package can be used to auto-generate Julia code\nfrom a C header file."},{"title":"CRC32c","page":"CRC32c","location":"stdlib/CRC32c.html#CRC32c","category":"section","text":"Standard library module for computing the CRC-32c checksum."},{"title":"CRC32c.crc32c","page":"CRC32c","location":"stdlib/CRC32c.html#CRC32c.crc32c","category":"function","text":"crc32c(data, crc::UInt32=0x00000000)\n\nCompute the CRC-32c checksum of the given data, which can be\nan Array{UInt8}, a contiguous subarray thereof, an AbstractVector{UInt8}, or a String.\nOptionally, you can pass a starting crc integer to be mixed in with the checksum.\nThe crc parameter can be used to compute a checksum on data divided into chunks: performing\ncrc32c(data2, crc32c(data1)) is equivalent to the checksum of [data1; data2].\n(Technically, a little-endian checksum is computed.)\n\nThere is also a method crc32c(io, nb, crc) to checksum nb bytes from\na stream io, or crc32c(io, crc) to checksum all the remaining bytes.\nHence you can do open(crc32c, filename) to checksum an entire file,\nor crc32c(seekstart(buf)) to checksum an IOBuffer without\ncalling take!.\n\nFor a String, note that the result is specific to the UTF-8 encoding\n(a different checksum would be obtained from a different Unicode encoding).\nTo checksum an a::AbstractArray of some other bitstype without padding,\nyou can do crc32c(vec(reinterpret(UInt8,a))),\nbut note that the result may be endian-dependent.\n\n\n\n\n\n"},{"title":"CRC32c.crc32c","page":"CRC32c","location":"stdlib/CRC32c.html#CRC32c.crc32c-Tuple{IO, Integer, UInt32}","category":"method","text":"crc32c(io::IO, [nb::Integer,] crc::UInt32=0x00000000)\n\nRead up to nb bytes from io and return the CRC-32c checksum, optionally\nmixed with a starting crc integer.  If nb is not supplied, then\nio will be read until the end of the stream.\n\n\n\n\n\n"},{"title":"Sockets","page":"Sockets","location":"stdlib/Sockets.html#Sockets","category":"section","text":""},{"title":"Sockets.Sockets","page":"Sockets","location":"stdlib/Sockets.html#Sockets.Sockets","category":"module","text":"Support for sockets. Provides IPAddr and subtypes, TCPSocket, and UDPSocket.\n\n\n\n\n\n"},{"title":"Sockets.connect","page":"Sockets","location":"stdlib/Sockets.html#Sockets.connect-Tuple{TCPSocket, Integer}","category":"method","text":"connect([host], port::Integer) -> TCPSocket\n\nConnect to the host host on port port.\n\n\n\n\n\n"},{"title":"Sockets.connect","page":"Sockets","location":"stdlib/Sockets.html#Sockets.connect-Tuple{AbstractString}","category":"method","text":"connect(path::AbstractString) -> PipeEndpoint\n\nConnect to the named pipe / UNIX domain socket at path.\n\nnote: Note\nPath length on Unix is limited to somewhere between 92 and 108 bytes (cf. man unix).\n\n\n\n\n\n"},{"title":"Sockets.listen","page":"Sockets","location":"stdlib/Sockets.html#Sockets.listen-Tuple{Any}","category":"method","text":"listen([addr, ]port::Integer; backlog::Integer=BACKLOG_DEFAULT) -> TCPServer\n\nListen on port on the address specified by addr.\nBy default this listens on localhost only.\nTo listen on all interfaces pass IPv4(0) or IPv6(0) as appropriate.\nbacklog determines how many connections can be pending (not having\ncalled accept) before the server will begin to\nreject them. The default value of backlog is 511.\n\n\n\n\n\n"},{"title":"Sockets.listen","page":"Sockets","location":"stdlib/Sockets.html#Sockets.listen-Tuple{AbstractString}","category":"method","text":"listen(path::AbstractString) -> PipeServer\n\nCreate and listen on a named pipe / UNIX domain socket.\n\nnote: Note\nPath length on Unix is limited to somewhere between 92 and 108 bytes (cf. man unix).\n\n\n\n\n\n"},{"title":"Sockets.getaddrinfo","page":"Sockets","location":"stdlib/Sockets.html#Sockets.getaddrinfo","category":"function","text":"getaddrinfo(host::AbstractString, IPAddr) -> IPAddr\n\nGets the first IP address of the host of the specified IPAddr type.\nUses the operating system's underlying getaddrinfo implementation, which may do\na DNS lookup.\n\nExamples\n\njulia> getaddrinfo(\"localhost\", IPv6)\nip\"::1\"\n\njulia> getaddrinfo(\"localhost\", IPv4)\nip\"127.0.0.1\"\n\n\n\n\n\ngetaddrinfo(host::AbstractString) -> IPAddr\n\nGets the first available IP address of host, which may be either an IPv4 or\nIPv6 address. Uses the operating system's underlying getaddrinfo\nimplementation, which may do a DNS lookup.\n\n\n\n\n\n"},{"title":"Sockets.getipaddr","page":"Sockets","location":"stdlib/Sockets.html#Sockets.getipaddr","category":"function","text":"getipaddr() -> IPAddr\n\nGet an IP address of the local machine, preferring IPv4 over IPv6. Throws if no\naddresses are available.\n\ngetipaddr(addr_type::Type{T}) where T<:IPAddr -> T\n\nGet an IP address of the local machine of the specified type. Throws if no\naddresses of the specified type are available.\n\nThis function is a backwards-compatibility wrapper around getipaddrs.\nNew applications should use getipaddrs instead.\n\nExamples\n\njulia> getipaddr()\nip\"192.168.1.28\"\n\njulia> getipaddr(IPv6)\nip\"fe80::9731:35af:e1c5:6e49\"\n\nSee also getipaddrs.\n\n\n\n\n\n"},{"title":"Sockets.getipaddrs","page":"Sockets","location":"stdlib/Sockets.html#Sockets.getipaddrs","category":"function","text":"getipaddrs(addr_type::Type{T}=IPAddr; loopback::Bool=false) where T<:IPAddr -> Vector{T}\n\nGet the IP addresses of the local machine.\n\nSetting the optional addr_type parameter to IPv4 or IPv6 causes only addresses of that type to be returned.\n\nThe loopback keyword argument dictates whether loopback addresses (e.g. ip\"127.0.0.1\", ip\"::1\") are included.\n\ncompat: Julia 1.2\nThis function is available as of Julia 1.2.\n\nExamples\n\njulia> getipaddrs()\n5-element Vector{IPAddr}:\n ip\"198.51.100.17\"\n ip\"203.0.113.2\"\n ip\"2001:db8:8:4:445e:5fff:fe5d:5500\"\n ip\"2001:db8:8:4:c164:402e:7e3c:3668\"\n ip\"fe80::445e:5fff:fe5d:5500\"\n\njulia> getipaddrs(IPv6)\n3-element Vector{IPv6}:\n ip\"2001:db8:8:4:445e:5fff:fe5d:5500\"\n ip\"2001:db8:8:4:c164:402e:7e3c:3668\"\n ip\"fe80::445e:5fff:fe5d:5500\"\n\nSee also islinklocaladdr.\n\n\n\n\n\n"},{"title":"Sockets.islinklocaladdr","page":"Sockets","location":"stdlib/Sockets.html#Sockets.islinklocaladdr","category":"function","text":"islinklocaladdr(addr::IPAddr)\n\nTests if an IP address is a link-local address. Link-local addresses\nare not guaranteed to be unique beyond their network segment,\ntherefore routers do not forward them. Link-local addresses are from\nthe address blocks 169.254.0.0/16 or fe80::/10.\n\nExamples\n\nfilter(!islinklocaladdr, getipaddrs())\n\n\n\n\n\n"},{"title":"Sockets.getalladdrinfo","page":"Sockets","location":"stdlib/Sockets.html#Sockets.getalladdrinfo","category":"function","text":"getalladdrinfo(host::AbstractString) -> Vector{IPAddr}\n\nGets all of the IP addresses of the host.\nUses the operating system's underlying getaddrinfo implementation, which may do a DNS lookup.\n\nExamples\n\njulia> getalladdrinfo(\"google.com\")\n2-element Vector{IPAddr}:\n ip\"172.217.6.174\"\n ip\"2607:f8b0:4000:804::200e\"\n\n\n\n\n\n"},{"title":"Sockets.DNSError","page":"Sockets","location":"stdlib/Sockets.html#Sockets.DNSError","category":"type","text":"DNSError\n\nThe type of exception thrown when an error occurs in DNS lookup.\nThe host field indicates the host URL string.\nThe code field indicates the error code based on libuv.\n\n\n\n\n\n"},{"title":"Sockets.getnameinfo","page":"Sockets","location":"stdlib/Sockets.html#Sockets.getnameinfo","category":"function","text":"getnameinfo(host::IPAddr) -> String\n\nPerforms a reverse-lookup for IP address to return a hostname and service\nusing the operating system's underlying getnameinfo implementation.\n\nExamples\n\njulia> getnameinfo(IPv4(\"8.8.8.8\"))\n\"google-public-dns-a.google.com\"\n\n\n\n\n\n"},{"title":"Sockets.getsockname","page":"Sockets","location":"stdlib/Sockets.html#Sockets.getsockname","category":"function","text":"getsockname(sock::Union{TCPServer, TCPSocket}) -> (IPAddr, UInt16)\n\nGet the IP address and port that the given socket is bound to.\n\n\n\n\n\n"},{"title":"Sockets.getpeername","page":"Sockets","location":"stdlib/Sockets.html#Sockets.getpeername","category":"function","text":"getpeername(sock::TCPSocket) -> (IPAddr, UInt16)\n\nGet the IP address and port of the remote endpoint that the given\nsocket is connected to. Valid only for connected TCP sockets.\n\n\n\n\n\n"},{"title":"Sockets.IPAddr","page":"Sockets","location":"stdlib/Sockets.html#Sockets.IPAddr","category":"type","text":"IPAddr\n\nAbstract supertype for IP addresses. IPv4 and IPv6 are subtypes of this.\n\n\n\n\n\n"},{"title":"Sockets.IPv4","page":"Sockets","location":"stdlib/Sockets.html#Sockets.IPv4","category":"type","text":"IPv4(host::Integer) -> IPv4\n\nReturn an IPv4 object from IP address host formatted as an Integer.\n\nExamples\n\njulia> IPv4(3223256218)\nip\"192.30.252.154\"\n\n\n\n\n\nIPv4(str::AbstractString) -> IPv4\n\nParse an IPv4 address string into an IPv4 object.\n\nExamples\n\njulia> IPv4(\"127.0.0.1\")\nip\"127.0.0.1\"\n\n\n\n\n\n"},{"title":"Sockets.IPv6","page":"Sockets","location":"stdlib/Sockets.html#Sockets.IPv6","category":"type","text":"IPv6(host::Integer) -> IPv6\n\nReturn an IPv6 object from IP address host formatted as an Integer.\n\nExamples\n\njulia> IPv6(3223256218)\nip\"::c01e:fc9a\"\n\n\n\n\n\nIPv6(str::AbstractString) -> IPv6\n\nParse an IPv6 address string into an IPv6 object.\n\nExamples\n\njulia> IPv6(\"::1\")\nip\"::1\"\n\n\n\n\n\n"},{"title":"Sockets.@ip_str","page":"Sockets","location":"stdlib/Sockets.html#Sockets.@ip_str","category":"macro","text":"@ip_str str -> IPAddr\n\nParse str as an IP address.\n\nExamples\n\njulia> ip\"127.0.0.1\"\nip\"127.0.0.1\"\n\njulia> @ip_str \"2001:db8:0:0:0:0:2:1\"\nip\"2001:db8::2:1\"\n\n\n\n\n\n"},{"title":"Sockets.TCPSocket","page":"Sockets","location":"stdlib/Sockets.html#Sockets.TCPSocket","category":"type","text":"TCPSocket(; delay=true)\n\nOpen a TCP socket using libuv. If delay is true, libuv delays creation of the\nsocket's file descriptor till the first bind call. TCPSocket has various\nfields to denote the state of the socket as well as its send/receive buffers.\n\n\n\n\n\n"},{"title":"Sockets.UDPSocket","page":"Sockets","location":"stdlib/Sockets.html#Sockets.UDPSocket","category":"type","text":"UDPSocket()\n\nOpen a UDP socket using libuv. UDPSocket has various\nfields to denote the state of the socket.\n\n\n\n\n\n"},{"title":"Sockets.accept","page":"Sockets","location":"stdlib/Sockets.html#Sockets.accept","category":"function","text":"accept(server[, client])\n\nAccepts a connection on the given server and returns a connection to the client. An\nuninitialized client stream may be provided, in which case it will be used instead of\ncreating a new stream.\n\n\n\n\n\n"},{"title":"Sockets.listenany","page":"Sockets","location":"stdlib/Sockets.html#Sockets.listenany","category":"function","text":"listenany([host::IPAddr,] port_hint; backlog::Integer=BACKLOG_DEFAULT) -> (UInt16, TCPServer)\n\nCreate a TCPServer on any port, using hint as a starting point. Returns a tuple of the\nactual port that the server was created on and the server itself.\nThe backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow.\n\n\n\n\n\n"},{"title":"Base.bind","page":"Sockets","location":"stdlib/Sockets.html#Base.bind","category":"function","text":"bind(chnl::Channel, task::Task)\n\nAssociate the lifetime of chnl with a task.\nChannel chnl is automatically closed when the task terminates.\nAny uncaught exception in the task is propagated to all waiters on chnl.\n\nThe chnl object can be explicitly closed independent of task termination.\nTerminating tasks have no effect on already closed Channel objects.\n\nWhen a channel is bound to multiple tasks, the first task to terminate will\nclose the channel. When multiple channels are bound to the same task,\ntermination of the task will close all of the bound channels.\n\nExamples\n\njulia> c = Channel(0);\n\njulia> task = @async foreach(i->put!(c, i), 1:4);\n\njulia> bind(c,task);\n\njulia> for i in c\n           @show i\n       end;\ni = 1\ni = 2\ni = 3\ni = 4\n\njulia> isopen(c)\nfalse\n\njulia> c = Channel(0);\n\njulia> task = @async (put!(c, 1); error(\"foo\"));\n\njulia> bind(c, task);\n\njulia> take!(c)\n1\n\njulia> put!(c, 1);\nERROR: TaskFailedException\nStacktrace:\n[...]\n    nested task error: foo\n[...]\n\n\n\n\n\nbind(socket::Union{TCPServer, UDPSocket, TCPSocket}, host::IPAddr, port::Integer; ipv6only=false, reuseaddr=false, kws...)\n\nBind socket to the given host:port. Note that 0.0.0.0 will listen on all devices.\n\nThe ipv6only parameter disables dual stack mode. If ipv6only=true, only an IPv6 stack is created.\nIf reuseaddr=true, multiple threads or processes can bind to the same address without error\nif they all set reuseaddr=true, but only the last to bind will receive any traffic.\n\n\n\n\n\n"},{"title":"Sockets.send","page":"Sockets","location":"stdlib/Sockets.html#Sockets.send","category":"function","text":"send(socket::UDPSocket, host::IPAddr, port::Integer, msg)\n\nSend msg over socket to host:port.\n\n\n\n\n\n"},{"title":"Sockets.recv","page":"Sockets","location":"stdlib/Sockets.html#Sockets.recv","category":"function","text":"recv(socket::UDPSocket)\n\nRead a UDP packet from the specified socket, and return the bytes received. This call blocks.\n\n\n\n\n\n"},{"title":"Sockets.recvfrom","page":"Sockets","location":"stdlib/Sockets.html#Sockets.recvfrom","category":"function","text":"recvfrom(socket::UDPSocket) -> (host_port, data)\n\nRead a UDP packet from the specified socket, returning a tuple of (host_port, data), where\nhost_port will be an InetAddr{IPv4} or InetAddr{IPv6}, as appropriate.\n\ncompat: Julia 1.3\nPrior to Julia version 1.3, the first returned value was an address (IPAddr).\nIn version 1.3 it was changed to an InetAddr.\n\n\n\n\n\n"},{"title":"Sockets.setopt","page":"Sockets","location":"stdlib/Sockets.html#Sockets.setopt","category":"function","text":"setopt(sock::UDPSocket; multicast_loop=nothing, multicast_ttl=nothing, enable_broadcast=nothing, ttl=nothing)\n\nSet UDP socket options.\n\nmulticast_loop: loopback for multicast packets (default: true).\nmulticast_ttl: TTL for multicast packets (default: nothing).\nenable_broadcast: flag must be set to true if socket will be used for broadcast\nmessages, or else the UDP system will return an access error (default: false).\nttl: Time-to-live of packets sent on the socket (default: nothing).\n\n\n\n\n\n"},{"title":"Sockets.nagle","page":"Sockets","location":"stdlib/Sockets.html#Sockets.nagle","category":"function","text":"nagle(socket::Union{TCPServer, TCPSocket}, enable::Bool)\n\nNagle's algorithm batches multiple small TCP packets into larger\nones. This can improve throughput but worsen latency. Nagle's algorithm\nis enabled by default. This function sets whether Nagle's algorithm is\nactive on a given TCP server or socket. The opposite option is called\nTCP_NODELAY in other languages.\n\ncompat: Julia 1.3\nThis function requires Julia 1.3 or later.\n\n\n\n\n\n"},{"title":"Sockets.quickack","page":"Sockets","location":"stdlib/Sockets.html#Sockets.quickack","category":"function","text":"quickack(socket::Union{TCPServer, TCPSocket}, enable::Bool)\n\nOn Linux systems, the TCP_QUICKACK is disabled or enabled on socket.\n\n\n\n\n\n"},{"title":"Distributed Computing","page":"Distributed Computing","location":"stdlib/Distributed.html#man-distributed","category":"section","text":""},{"title":"Cluster Manager Interface","page":"Distributed Computing","location":"stdlib/Distributed.html#Cluster-Manager-Interface","category":"section","text":"This interface provides a mechanism to launch and manage Julia workers on different cluster environments.\nThere are two types of managers present in Base: LocalManager, for launching additional workers on the\nsame host, and SSHManager, for launching on remote hosts via ssh. TCP/IP sockets are used to connect\nand transport messages between processes. It is possible for Cluster Managers to provide a different transport."},{"title":"Distributed","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed","category":"module","text":"Tools for distributed parallel processing.\n\n\n\n\n\n"},{"title":"Distributed.addprocs","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.addprocs","category":"function","text":"addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers\n\nLaunches worker processes via the specified cluster manager.\n\nFor example, Beowulf clusters are supported via a custom cluster manager implemented in\nthe package ClusterManagers.jl.\n\nThe number of seconds a newly launched worker waits for connection establishment from the\nmaster can be specified via variable JULIA_WORKER_TIMEOUT in the worker process's\nenvironment. Relevant only when using TCP/IP as transport.\n\nTo launch workers without blocking the REPL, or the containing function\nif launching workers programmatically, execute addprocs in its own task.\n\nExamples\n\n# On busy clusters, call `addprocs` asynchronously\nt = @async addprocs(...)\n\n# Utilize workers as and when they come online\nif nprocs() > 1   # Ensure at least one new worker is available\n   ....   # perform distributed execution\nend\n\n# Retrieve newly launched worker IDs, or any error messages\nif istaskdone(t)   # Check if `addprocs` has completed to ensure `fetch` doesn't block\n    if nworkers() == N\n        new_pids = fetch(t)\n    else\n        fetch(t)\n    end\nend\n\n\n\n\n\naddprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers\n\nAdd worker processes on remote machines via SSH. Configuration is done with keyword\narguments (see below). In particular, the exename keyword can be used to specify\nthe path to the julia binary on the remote machine(s).\n\nmachines is a vector of \"machine specifications\" which are given as strings of\nthe form [user@]host[:port] [bind_addr[:port]]. user defaults to current user and port\nto the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect\nto this worker at the specified bind_addr and port.\n\nIt is possible to launch multiple processes on a remote host by using a tuple in the\nmachines vector or the form (machine_spec, count), where count is the number of\nworkers to be launched on the specified host. Passing :auto as the worker count will\nlaunch as many workers as the number of CPU threads on the remote host.\n\nExamples:\n\naddprocs([\n    \"remote1\",               # one worker on 'remote1' logging in with the current username\n    \"user@remote2\",          # one worker on 'remote2' logging in with the 'user' username\n    \"user@remote3:2222\",     # specifying SSH port to '2222' for 'remote3'\n    (\"user@remote4\", 4),     # launch 4 workers on 'remote4'\n    (\"user@remote5\", :auto), # launch as many workers as CPU threads on 'remote5'\n])\n\nKeyword arguments:\n\ntunnel: if true then SSH tunneling will be used to connect to the worker from the\nmaster process. Default is false.\nmultiplex: if true then SSH multiplexing is used for SSH tunneling. Default is false.\nssh: the name or path of the SSH client executable used to start the workers.\nDefault is \"ssh\".\nsshflags: specifies additional ssh options, e.g. sshflags=`-i /home/foo/bar.pem`\nmax_parallel: specifies the maximum number of workers connected to in parallel at a\nhost. Defaults to 10.\nshell: specifies the type of shell to which ssh connects on the workers.\nshell=:posix: a POSIX-compatible Unix/Linux shell\n(sh, ksh, bash, dash, zsh, etc.). The default.\nshell=:csh: a Unix C shell (csh, tcsh).\nshell=:wincmd: Microsoft Windows cmd.exe.\ndir: specifies the working directory on the workers. Defaults to the host's current\ndirectory (as found by pwd())\nenable_threaded_blas: if true then  BLAS will run on multiple threads in added\nprocesses. Default is false.\nexename: name of the julia executable. Defaults to \"$(Sys.BINDIR)/julia\" or\n\"$(Sys.BINDIR)/julia-debug\" as the case may be. It is recommended that a common Julia\nversion is used on all remote machines because serialization and code distribution might\nfail otherwise.\nexeflags: additional flags passed to the worker processes. It can either be a Cmd, a String\nholding one flag, or a collection of strings, with one element per flag.\nE.g. --threads=auto project=, \"--compile-trace=stderr\" or [\"--threads=auto\", \"--compile=all\"].\ntopology: Specifies how the workers connect to each other. Sending a message between\nunconnected workers results in an error.\ntopology=:all_to_all: All processes are connected to each other. The default.\ntopology=:master_worker: Only the driver process, i.e. pid 1 connects to the\nworkers. The workers do not connect to each other.\ntopology=:custom: The launch method of the cluster manager specifies the\nconnection topology via fields ident and connect_idents in WorkerConfig.\nA worker with a cluster manager identity ident will connect to all workers specified\nin connect_idents.\nlazy: Applicable only with topology=:all_to_all. If true, worker-worker connections\nare setup lazily, i.e. they are setup at the first instance of a remote call between\nworkers. Default is true.\nenv: provide an array of string pairs such as\nenv=[\"JULIA_DEPOT_PATH\"=>\"/depot\"] to request that environment variables\nare set on the remote machine. By default only the environment variable\nJULIA_WORKER_TIMEOUT is passed automatically from the local to the remote\nenvironment.\ncmdline_cookie: pass the authentication cookie via the --worker commandline\n option. The (more secure) default behaviour of passing the cookie via ssh stdio\n may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions,\n in which case cmdline_cookie=true offers a work-around.\n\ncompat: Julia 1.6\nThe keyword arguments ssh, shell, env and cmdline_cookie\nwere added in Julia 1.6.\n\nEnvironment variables:\n\nIf the master process fails to establish a connection with a newly launched worker within\n60.0 seconds, the worker treats it as a fatal situation and terminates.\nThis timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT.\nThe value of JULIA_WORKER_TIMEOUT on the master process specifies the number of seconds a\nnewly launched worker waits for connection establishment.\n\n\n\n\n\naddprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers\n\nLaunch np workers on the local host using the in-built LocalManager.\n\nLocal workers inherit the current package environment (i.e., active project,\nLOAD_PATH, and DEPOT_PATH) from the main process.\n\nwarning: Warning\nNote that workers do not run a ~/.julia/config/startup.jl startup script, nor do they synchronize\ntheir global state (such as command-line switches, global variables, new method definitions, and loaded modules) with any\nof the other running processes.\n\nKeyword arguments:\n\nrestrict::Bool: if true (default) binding is restricted to 127.0.0.1.\ndir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect\nas for SSHManager, see documentation for addprocs(machines::AbstractVector).\n\ncompat: Julia 1.9\nThe inheriting of the package environment and the env keyword argument were\nadded in Julia 1.9.\n\n\n\n\n\n"},{"title":"Distributed.nprocs","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.nprocs","category":"function","text":"nprocs()\n\nGet the number of available processes.\n\nExamples\n\njulia> nprocs()\n3\n\njulia> workers()\n2-element Array{Int64,1}:\n 2\n 3\n\n\n\n\n\n"},{"title":"Distributed.nworkers","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.nworkers","category":"function","text":"nworkers()\n\nGet the number of available worker processes. This is one less than nprocs(). Equal to\nnprocs() if nprocs() == 1.\n\nExamples\n\n$ julia -p 2\n\njulia> nprocs()\n3\n\njulia> nworkers()\n2\n\n\n\n\n\n"},{"title":"Distributed.procs","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.procs-Tuple{}","category":"method","text":"procs()\n\nReturn a list of all process identifiers, including pid 1 (which is not included by workers()).\n\nExamples\n\n$ julia -p 2\n\njulia> procs()\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\n\n\n\n\n"},{"title":"Distributed.procs","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.procs-Tuple{Integer}","category":"method","text":"procs(pid::Integer)\n\nReturn a list of all process identifiers on the same physical node.\nSpecifically all workers bound to the same ip-address as pid are returned.\n\n\n\n\n\n"},{"title":"Distributed.workers","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.workers","category":"function","text":"workers()\n\nReturn a list of all worker process identifiers.\n\nExamples\n\n$ julia -p 2\n\njulia> workers()\n2-element Array{Int64,1}:\n 2\n 3\n\n\n\n\n\n"},{"title":"Distributed.rmprocs","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.rmprocs","category":"function","text":"rmprocs(pids...; waitfor=typemax(Int))\n\nRemove the specified workers. Note that only process 1 can add or remove\nworkers.\n\nArgument waitfor specifies how long to wait for the workers to shut down:\n\nIf unspecified, rmprocs will wait until all requested pids are removed.\nAn ErrorException is raised if all workers cannot be terminated before\nthe requested waitfor seconds.\nWith a waitfor value of 0, the call returns immediately with the workers\nscheduled for removal in a different task. The scheduled Task object is\nreturned. The user should call wait on the task before invoking any other\nparallel calls.\n\nExamples\n\n$ julia -p 5\n\njulia> t = rmprocs(2, 3, waitfor=0)\nTask (runnable) @0x0000000107c718d0\n\njulia> wait(t)\n\njulia> workers()\n3-element Array{Int64,1}:\n 4\n 5\n 6\n\n\n\n\n\n"},{"title":"Distributed.interrupt","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.interrupt","category":"function","text":"interrupt(pids::Integer...)\n\nInterrupt the current executing task on the specified workers. This is equivalent to\npressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.\n\n\n\n\n\ninterrupt(pids::AbstractVector=workers())\n\nInterrupt the current executing task on the specified workers. This is equivalent to\npressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.\n\n\n\n\n\n"},{"title":"Distributed.myid","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.myid","category":"function","text":"myid()\n\nGet the id of the current process.\n\nExamples\n\njulia> myid()\n1\n\njulia> remotecall_fetch(() -> myid(), 4)\n4\n\n\n\n\n\n"},{"title":"Distributed.pmap","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.pmap","category":"function","text":"pmap(f, [::AbstractWorkerPool], c...; distributed=true, batch_size=1, on_error=nothing, retry_delays=[], retry_check=nothing) -> collection\n\nTransform collection c by applying f to each element using available\nworkers and tasks.\n\nFor multiple collection arguments, apply f elementwise.\n\nNote that f must be made available to all worker processes; see\nCode Availability and Loading Packages for details.\n\nIf a worker pool is not specified all available workers will be used via a CachingPool.\n\nBy default, pmap distributes the computation over all specified workers. To use only the\nlocal process and distribute over tasks, specify distributed=false.\nThis is equivalent to using asyncmap. For example,\npmap(f, c; distributed=false) is equivalent to asyncmap(f,c; ntasks=()->nworkers())\n\npmap can also use a mix of processes and tasks via the batch_size argument. For batch sizes\ngreater than 1, the collection is processed in multiple batches, each of length batch_size or less.\nA batch is sent as a single request to a free worker, where a local asyncmap processes\nelements from the batch using multiple concurrent tasks.\n\nAny error stops pmap from processing the remainder of the collection. To override this behavior\nyou can specify an error handling function via argument on_error which takes in a single argument, i.e.,\nthe exception. The function can stop the processing by rethrowing the error, or, to continue, return any value\nwhich is then returned inline with the results to the caller.\n\nConsider the following two examples. The first one returns the exception object inline,\nthe second a 0 in place of any exception:\n\njulia> pmap(x->iseven(x) ? error(\"foo\") : x, 1:4; on_error=identity)\n4-element Array{Any,1}:\n 1\n  ErrorException(\"foo\")\n 3\n  ErrorException(\"foo\")\n\njulia> pmap(x->iseven(x) ? error(\"foo\") : x, 1:4; on_error=ex->0)\n4-element Array{Int64,1}:\n 1\n 0\n 3\n 0\n\nErrors can also be handled by retrying failed computations. Keyword arguments retry_delays and\nretry_check are passed through to retry as keyword arguments delays and check\nrespectively. If batching is specified, and an entire batch fails, all items in\nthe batch are retried.\n\nNote that if both on_error and retry_delays are specified, the on_error hook is called\nbefore retrying. If on_error does not throw (or rethrow) an exception, the element will not\nbe retried.\n\nExample: On errors, retry f on an element a maximum of 3 times without any delay between retries.\n\npmap(f, c; retry_delays = zeros(3))\n\nExample: Retry f only if the exception is not of type InexactError, with exponentially increasing\ndelays up to 3 times. Return a NaN in place for all InexactError occurrences.\n\npmap(f, c; on_error = e->(isa(e, InexactError) ? NaN : rethrow()), retry_delays = ExponentialBackOff(n = 3))\n\n\n\n\n\n"},{"title":"Distributed.RemoteException","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.RemoteException","category":"type","text":"RemoteException(captured)\n\nExceptions on remote computations are captured and rethrown locally.  A RemoteException\nwraps the pid of the worker and a captured exception. A CapturedException captures the\nremote exception and a serializable form of the call stack when the exception was raised.\n\n\n\n\n\n"},{"title":"Distributed.ProcessExitedException","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.ProcessExitedException","category":"type","text":"ProcessExitedException(worker_id::Int)\n\nAfter a client Julia process has exited, further attempts to reference the dead child will\nthrow this exception.\n\n\n\n\n\n"},{"title":"Distributed.Future","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.Future","category":"type","text":"Future(w::Int, rrid::RRID, v::Union{Some, Nothing}=nothing)\n\nA Future is a placeholder for a single computation\nof unknown termination status and time.\nFor multiple potential computations, see RemoteChannel.\nSee remoteref_id for identifying an AbstractRemoteRef.\n\n\n\n\n\n"},{"title":"Distributed.RemoteChannel","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.RemoteChannel","category":"type","text":"RemoteChannel(pid::Integer=myid())\n\nMake a reference to a Channel{Any}(1) on process pid.\nThe default pid is the current process.\n\nRemoteChannel(f::Function, pid::Integer=myid())\n\nCreate references to remote channels of a specific size and type. f is a function that\nwhen executed on pid must return an implementation of an AbstractChannel.\n\nFor example, RemoteChannel(()->Channel{Int}(10), pid), will return a reference to a\nchannel of type Int and size 10 on pid.\n\nThe default pid is the current process.\n\n\n\n\n\n"},{"title":"Base.fetch","page":"Distributed Computing","location":"stdlib/Distributed.html#Base.fetch-Tuple{Distributed.Future}","category":"method","text":"fetch(x::Future)\n\nWait for and get the value of a Future. The fetched value is cached locally.\nFurther calls to fetch on the same reference return the cached value. If the remote value\nis an exception, throws a RemoteException which captures the remote exception and backtrace.\n\n\n\n\n\n"},{"title":"Base.fetch","page":"Distributed Computing","location":"stdlib/Distributed.html#Base.fetch-Tuple{RemoteChannel}","category":"method","text":"fetch(c::RemoteChannel)\n\nWait for and get a value from a RemoteChannel. Exceptions raised are the\nsame as for a Future. Does not remove the item fetched.\n\n\n\n\n\nfetch(x::Any)\n\nReturn x.\n\n\n\n\n\n"},{"title":"Distributed.remotecall","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.remotecall-Tuple{Any, Integer, Vararg{Any}}","category":"method","text":"remotecall(f, id::Integer, args...; kwargs...) -> Future\n\nCall a function f asynchronously on the given arguments on the specified process.\nReturn a Future.\nKeyword arguments, if any, are passed through to f.\n\n\n\n\n\n"},{"title":"Distributed.remotecall_wait","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.remotecall_wait-Tuple{Any, Integer, Vararg{Any}}","category":"method","text":"remotecall_wait(f, id::Integer, args...; kwargs...)\n\nPerform a faster wait(remotecall(...)) in one message on the Worker specified by worker id id.\nKeyword arguments, if any, are passed through to f.\n\nSee also wait and remotecall.\n\n\n\n\n\n"},{"title":"Distributed.remotecall_fetch","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.remotecall_fetch-Tuple{Any, Integer, Vararg{Any}}","category":"method","text":"remotecall_fetch(f, id::Integer, args...; kwargs...)\n\nPerform fetch(remotecall(...)) in one message.\nKeyword arguments, if any, are passed through to f.\nAny remote exceptions are captured in a\nRemoteException and thrown.\n\nSee also fetch and remotecall.\n\nExamples\n\n$ julia -p 2\n\njulia> remotecall_fetch(sqrt, 2, 4)\n2.0\n\njulia> remotecall_fetch(sqrt, 2, -4)\nERROR: On worker 2:\nDomainError with -4.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\n...\n\n\n\n\n\n"},{"title":"Distributed.remotecall_eval","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.remotecall_eval","category":"function","text":"remotecall_eval(m::Module, procs, expression)\n\nExecute an expression under module m on the processes\nspecified in procs.\nErrors on any of the processes are collected into a\nCompositeException and thrown.\n\nSee also @everywhere.\n\n\n\n\n\n"},{"title":"Distributed.remote_do","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.remote_do-Tuple{Any, Integer, Vararg{Any}}","category":"method","text":"remote_do(f, id::Integer, args...; kwargs...) -> nothing\n\nExecutes f on worker id asynchronously.\nUnlike remotecall, it does not store the\nresult of computation, nor is there a way to wait for its completion.\n\nA successful invocation indicates that the request has been accepted for execution on\nthe remote node.\n\nWhile consecutive remotecalls to the same worker are serialized in the order they are\ninvoked, the order of executions on the remote worker is undetermined. For example,\nremote_do(f1, 2); remotecall(f2, 2); remote_do(f3, 2) will serialize the call\nto f1, followed by f2 and f3 in that order. However, it is not guaranteed that f1\nis executed before f3 on worker 2.\n\nAny exceptions thrown by f are printed to stderr on the remote worker.\n\nKeyword arguments, if any, are passed through to f.\n\n\n\n\n\n"},{"title":"Base.put!","page":"Distributed Computing","location":"stdlib/Distributed.html#Base.put!-Tuple{RemoteChannel, Vararg{Any}}","category":"method","text":"put!(rr::RemoteChannel, args...)\n\nStore a set of values to the RemoteChannel.\nIf the channel is full, blocks until space is available.\nReturn the first argument.\n\n\n\n\n\n"},{"title":"Base.put!","page":"Distributed Computing","location":"stdlib/Distributed.html#Base.put!-Tuple{Distributed.Future, Any}","category":"method","text":"put!(rr::Future, v)\n\nStore a value to a Future rr.\nFutures are write-once remote references.\nA put! on an already set Future throws an Exception.\nAll asynchronous remote calls return Futures and set the\nvalue to the return value of the call upon completion.\n\n\n\n\n\n"},{"title":"Base.take!","page":"Distributed Computing","location":"stdlib/Distributed.html#Base.take!-Tuple{RemoteChannel, Vararg{Any}}","category":"method","text":"take!(rr::RemoteChannel, args...)\n\nFetch value(s) from a RemoteChannel rr,\nremoving the value(s) in the process.\n\n\n\n\n\n"},{"title":"Base.isready","page":"Distributed Computing","location":"stdlib/Distributed.html#Base.isready-Tuple{RemoteChannel, Vararg{Any}}","category":"method","text":"isready(rr::RemoteChannel, args...)\n\nDetermine whether a RemoteChannel has a value stored to it.\nNote that this function can cause race conditions, since by the\ntime you receive its result it may no longer be true. However,\nit can be safely used on a Future since they are assigned only once.\n\n\n\n\n\n"},{"title":"Base.isready","page":"Distributed Computing","location":"stdlib/Distributed.html#Base.isready-Tuple{Distributed.Future}","category":"method","text":"isready(rr::Future)\n\nDetermine whether a Future has a value stored to it.\n\nIf the argument Future is owned by a different node, this call will block to wait for the answer.\nIt is recommended to wait for rr in a separate task instead\nor to use a local Channel as a proxy:\n\np = 1\nf = Future(p)\nerrormonitor(@async put!(f, remotecall_fetch(long_computation, p)))\nisready(f)  # will not block\n\n\n\n\n\n"},{"title":"Distributed.AbstractWorkerPool","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.AbstractWorkerPool","category":"type","text":"AbstractWorkerPool\n\nSupertype for worker pools such as WorkerPool and CachingPool.\nAn AbstractWorkerPool should implement:\n\npush! - add a new worker to the overall pool (available + busy)\nput! - put back a worker to the available pool\ntake! - take a worker from the available pool (to be used for remote function execution)\nwait - block until a worker is available\nlength - number of workers available in the overall pool\nisready - return false if a take! on the pool would block, else true\n\nThe default implementations of the above (on a AbstractWorkerPool) require fields\n\nchannel::Channel{Int}\nworkers::Set{Int}\n\nwhere channel contains free worker pids and workers is the set of all workers associated with this pool.\n\n\n\n\n\n"},{"title":"Distributed.WorkerPool","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.WorkerPool","category":"type","text":"WorkerPool(workers::Union{Vector{Int},AbstractRange{Int}})\n\nCreate a WorkerPool from a vector or range of worker ids.\n\nExamples\n\n$ julia -p 3\n\njulia> WorkerPool([2, 3])\nWorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:2), Set([2, 3]), RemoteChannel{Channel{Any}}(1, 1, 6))\n\njulia> WorkerPool(2:4)\nWorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:2), Set([4, 2, 3]), RemoteChannel{Channel{Any}}(1, 1, 7))\n\n\n\n\n\n"},{"title":"Distributed.CachingPool","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.CachingPool","category":"type","text":"CachingPool(workers::Vector{Int})\n\nAn implementation of an AbstractWorkerPool.\nremote, remotecall_fetch,\npmap (and other remote calls which execute functions remotely)\nbenefit from caching the serialized/deserialized functions on the worker nodes,\nespecially closures (which may capture large amounts of data).\n\nThe remote cache is maintained for the lifetime of the returned CachingPool object.\nTo clear the cache earlier, use clear!(pool).\n\nFor global variables, only the bindings are captured in a closure, not the data.\nlet blocks can be used to capture global data.\n\nExamples\n\nconst foo = rand(10^8);\nwp = CachingPool(workers())\nlet foo = foo\n    pmap(i -> sum(foo) + i, wp, 1:100);\nend\n\nThe above would transfer foo only once to each worker.\n\n\n\n\n\n"},{"title":"Distributed.default_worker_pool","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.default_worker_pool","category":"function","text":"default_worker_pool()\n\nAbstractWorkerPool containing idle workers - used by remote(f) and pmap\n(by default). Unless one is explicitly set via default_worker_pool!(pool), the default worker pool is\ninitialized to a WorkerPool.\n\nExamples\n\n$ julia -p 3\n\njulia> default_worker_pool()\nWorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:3), Set([4, 2, 3]), RemoteChannel{Channel{Any}}(1, 1, 4))\n\n\n\n\n\n"},{"title":"Distributed.clear!","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.clear!","category":"function","text":"clear!(syms, pids=workers(); mod=Main)\n\nClears global bindings in modules by initializing them to nothing.\nsyms should be of type Symbol or a collection of Symbols . pids and mod\nidentify the processes and the module in which global variables are to be\nreinitialized. Only those names found to be defined under mod are cleared.\n\nAn exception is raised if a global constant is requested to be cleared.\n\n\n\n\n\nclear!(pool::CachingPool) -> pool\n\nRemoves all cached functions from all participating workers.\n\n\n\n\n\n"},{"title":"Distributed.remote","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.remote","category":"function","text":"remote([p::AbstractWorkerPool], f) -> Function\n\nReturn an anonymous function that executes function f on an available worker\n(drawn from WorkerPool p if provided) using remotecall_fetch.\n\n\n\n\n\n"},{"title":"Distributed.remotecall","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.remotecall-Tuple{Any, AbstractWorkerPool, Vararg{Any}}","category":"method","text":"remotecall(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future\n\nWorkerPool variant of remotecall(f, pid, ....). Wait for and take a free worker from pool and perform a remotecall on it.\n\nExamples\n\n$ julia -p 3\n\njulia> wp = WorkerPool([2, 3]);\n\njulia> A = rand(3000);\n\njulia> f = remotecall(maximum, wp, A)\nFuture(2, 1, 6, nothing)\n\nIn this example, the task ran on pid 2, called from pid 1.\n\n\n\n\n\n"},{"title":"Distributed.remotecall_wait","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.remotecall_wait-Tuple{Any, AbstractWorkerPool, Vararg{Any}}","category":"method","text":"remotecall_wait(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future\n\nWorkerPool variant of remotecall_wait(f, pid, ....). Wait for and take a free worker from pool and\nperform a remotecall_wait on it.\n\nExamples\n\n$ julia -p 3\n\njulia> wp = WorkerPool([2, 3]);\n\njulia> A = rand(3000);\n\njulia> f = remotecall_wait(maximum, wp, A)\nFuture(3, 1, 9, nothing)\n\njulia> fetch(f)\n0.9995177101692958\n\n\n\n\n\n"},{"title":"Distributed.remotecall_fetch","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.remotecall_fetch-Tuple{Any, AbstractWorkerPool, Vararg{Any}}","category":"method","text":"remotecall_fetch(f, pool::AbstractWorkerPool, args...; kwargs...) -> result\n\nWorkerPool variant of remotecall_fetch(f, pid, ....). Waits for and takes a free worker from pool and\nperforms a remotecall_fetch on it.\n\nExamples\n\n$ julia -p 3\n\njulia> wp = WorkerPool([2, 3]);\n\njulia> A = rand(3000);\n\njulia> remotecall_fetch(maximum, wp, A)\n0.9995177101692958\n\n\n\n\n\n"},{"title":"Distributed.remote_do","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.remote_do-Tuple{Any, AbstractWorkerPool, Vararg{Any}}","category":"method","text":"remote_do(f, pool::AbstractWorkerPool, args...; kwargs...) -> nothing\n\nWorkerPool variant of remote_do(f, pid, ....). Wait for and take a free worker from pool and\nperform a remote_do on it.\n\nNote that it's not possible to wait for the result of a remote_do() to finish\nso the worker will immediately be put back in the pool (i.e. potentially causing\noversubscription).\n\n\n\n\n\n"},{"title":"Distributed.@spawn","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.@spawn","category":"macro","text":"@spawn expr\n\nCreate a closure around an expression and run it on an automatically-chosen process,\nreturning a Future to the result.\nThis macro is deprecated; @spawnat :any expr should be used instead.\n\nExamples\n\njulia> addprocs(3);\n\njulia> f = @spawn myid()\nFuture(2, 1, 5, nothing)\n\njulia> fetch(f)\n2\n\njulia> f = @spawn myid()\nFuture(3, 1, 7, nothing)\n\njulia> fetch(f)\n3\n\ncompat: Julia 1.3\nAs of Julia 1.3 this macro is deprecated. Use @spawnat :any instead.\n\n\n\n\n\n"},{"title":"Distributed.@spawnat","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.@spawnat","category":"macro","text":"@spawnat p expr\n\nCreate a closure around an expression and run the closure\nasynchronously on process p. Return a Future to the result.\n\nIf p is the quoted literal symbol :any, then the system will pick a\nprocessor to use automatically. Using :any will not apply any form of\nload-balancing, consider using a WorkerPool and [remotecall(f, ::WorkerPool)](@ref) if you need load-balancing.\n\nExamples\n\njulia> addprocs(3);\n\njulia> f = @spawnat 2 myid()\nFuture(2, 1, 3, nothing)\n\njulia> fetch(f)\n2\n\njulia> f = @spawnat :any myid()\nFuture(3, 1, 7, nothing)\n\njulia> fetch(f)\n3\n\ncompat: Julia 1.3\nThe :any argument is available as of Julia 1.3.\n\n\n\n\n\n"},{"title":"Distributed.@fetch","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.@fetch","category":"macro","text":"@fetch expr\n\nEquivalent to fetch(@spawnat :any expr).\nSee fetch and @spawnat.\n\nExamples\n\njulia> addprocs(3);\n\njulia> @fetch myid()\n2\n\njulia> @fetch myid()\n3\n\njulia> @fetch myid()\n4\n\njulia> @fetch myid()\n2\n\n\n\n\n\n"},{"title":"Distributed.@fetchfrom","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.@fetchfrom","category":"macro","text":"@fetchfrom\n\nEquivalent to fetch(@spawnat p expr).\nSee fetch and @spawnat.\n\nExamples\n\njulia> addprocs(3);\n\njulia> @fetchfrom 2 myid()\n2\n\njulia> @fetchfrom 4 myid()\n4\n\n\n\n\n\n"},{"title":"Distributed.@distributed","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.@distributed","category":"macro","text":"@distributed\n\nA distributed memory, parallel for loop of the form :\n\n@distributed [reducer] for var = range\n    body\nend\n\nThe specified range is partitioned and locally executed across all workers. In case an\noptional reducer function is specified, @distributed performs local reductions on each worker\nwith a final reduction on the calling process.\n\nNote that without a reducer function, @distributed executes asynchronously, i.e. it spawns\nindependent tasks on all available workers and returns immediately without waiting for\ncompletion. To wait for completion, prefix the call with @sync, like :\n\n@sync @distributed for var = range\n    body\nend\n\n\n\n\n\n"},{"title":"Distributed.@everywhere","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.@everywhere","category":"macro","text":"@everywhere [procs()] expr\n\nExecute an expression under Main on all procs.\nErrors on any of the processes are collected into a\nCompositeException and thrown. For example:\n\n@everywhere bar = 1\n\nwill define Main.bar on all current processes. Any processes added later\n(say with addprocs()) will not have the expression defined.\n\nUnlike @spawnat, @everywhere does not capture any local variables.\nInstead, local variables can be broadcast using interpolation:\n\nfoo = 1\n@everywhere bar = $foo\n\nThe optional argument procs allows specifying a subset of all\nprocesses to have execute the expression.\n\nSimilar to calling remotecall_eval(Main, procs, expr), but with two extra features:\n\nusing and import statements run on the calling process first, to ensure\npackages are precompiled.\nThe current source file path used by include is propagated to other processes.\n\n\n\n\n\n"},{"title":"Distributed.remoteref_id","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.remoteref_id","category":"function","text":"remoteref_id(r::AbstractRemoteRef) -> RRID\n\nFutures and RemoteChannels are identified by fields:\n\nwhere - refers to the node where the underlying object/storage\nreferred to by the reference actually exists.\nwhence - refers to the node the remote reference was created from.\nNote that this is different from the node where the underlying object\nreferred to actually exists. For example calling RemoteChannel(2)\nfrom the master process would result in a where value of 2 and\na whence value of 1.\nid is unique across all references created from the worker specified by whence.\n\nTaken together,  whence and id uniquely identify a reference across all workers.\n\nremoteref_id is a low-level API which returns a RRID\nobject that wraps whence and id values of a remote reference.\n\n\n\n\n\n"},{"title":"Distributed.channel_from_id","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.channel_from_id","category":"function","text":"channel_from_id(id) -> c\n\nA low-level API which returns the backing AbstractChannel for an id returned by\nremoteref_id.\nThe call is valid only on the node where the backing channel exists.\n\n\n\n\n\n"},{"title":"Distributed.worker_id_from_socket","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.worker_id_from_socket","category":"function","text":"worker_id_from_socket(s) -> pid\n\nA low-level API which, given a IO connection or a Worker,\nreturns the pid of the worker it is connected to.\nThis is useful when writing custom serialize methods for a type,\nwhich optimizes the data written out depending on the receiving process id.\n\n\n\n\n\n"},{"title":"Distributed.cluster_cookie","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.cluster_cookie-Tuple{}","category":"method","text":"cluster_cookie() -> cookie\n\nReturn the cluster cookie.\n\n\n\n\n\n"},{"title":"Distributed.cluster_cookie","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.cluster_cookie-Tuple{Any}","category":"method","text":"cluster_cookie(cookie) -> cookie\n\nSet the passed cookie as the cluster cookie, then returns it.\n\n\n\n\n\n"},{"title":"Distributed.ClusterManager","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.ClusterManager","category":"type","text":"ClusterManager\n\nSupertype for cluster managers, which control workers processes as a cluster.\nCluster managers implement how workers can be added, removed and communicated with.\nSSHManager and LocalManager are subtypes of this.\n\n\n\n\n\n"},{"title":"Distributed.WorkerConfig","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.WorkerConfig","category":"type","text":"WorkerConfig\n\nType used by ClusterManagers to control workers added to their clusters. Some fields\nare used by all cluster managers to access a host:\n\nio – the connection used to access the worker (a subtype of IO or Nothing)\nhost – the host address (either a String or Nothing)\nport – the port on the host used to connect to the worker (either an Int or Nothing)\n\nSome are used by the cluster manager to add workers to an already-initialized host:\n\ncount – the number of workers to be launched on the host\nexename – the path to the Julia executable on the host, defaults to \"$(Sys.BINDIR)/julia\" or\n\"$(Sys.BINDIR)/julia-debug\"\nexeflags – flags to use when launching Julia remotely\n\nThe userdata field is used to store information for each worker by external managers.\n\nSome fields are used by SSHManager and similar managers:\n\ntunnel – true (use tunneling), false (do not use tunneling), or nothing (use default for the manager)\nmultiplex – true (use SSH multiplexing for tunneling) or false\nforward – the forwarding option used for -L option of ssh\nbind_addr – the address on the remote host to bind to\nsshflags – flags to use in establishing the SSH connection\nmax_parallel – the maximum number of workers to connect to in parallel on the host\n\nSome fields are used by both LocalManagers and SSHManagers:\n\nconnect_at – determines whether this is a worker-to-worker or driver-to-worker setup call\nprocess – the process which will be connected (usually the manager will assign this during addprocs)\nospid – the process ID according to the host OS, used to interrupt worker processes\nenviron – private dictionary used to store temporary information by Local/SSH managers\nident – worker as identified by the ClusterManager\nconnect_idents – list of worker ids the worker must connect to if using a custom topology\nenable_threaded_blas – true, false, or nothing, whether to use threaded BLAS or not on the workers\n\n\n\n\n\n"},{"title":"Distributed.launch","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.launch","category":"function","text":"launch(manager::ClusterManager, params::Dict, launched::Array, launch_ntfy::Condition)\n\nImplemented by cluster managers. For every Julia worker launched by this function, it should\nappend a WorkerConfig entry to launched and notify launch_ntfy. The function MUST exit\nonce all workers, requested by manager have been launched. params is a dictionary of all\nkeyword arguments addprocs was called with.\n\n\n\n\n\n"},{"title":"Distributed.manage","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.manage","category":"function","text":"manage(manager::ClusterManager, id::Integer, config::WorkerConfig. op::Symbol)\n\nImplemented by cluster managers. It is called on the master process, during a worker's\nlifetime, with appropriate op values:\n\nwith :register/:deregister when a worker is added / removed from the Julia worker pool.\nwith :interrupt when interrupt(workers) is called. The ClusterManager\nshould signal the appropriate worker with an interrupt signal.\nwith :finalize for cleanup purposes.\n\n\n\n\n\n"},{"title":"Base.kill","page":"Distributed Computing","location":"stdlib/Distributed.html#Base.kill-Tuple{ClusterManager, Int64, WorkerConfig}","category":"method","text":"kill(manager::ClusterManager, pid::Int, config::WorkerConfig)\n\nImplemented by cluster managers.\nIt is called on the master process, by rmprocs.\nIt should cause the remote worker specified by pid to exit.\nkill(manager::ClusterManager.....) executes a remote exit()\non pid.\n\n\n\n\n\n"},{"title":"Sockets.connect","page":"Distributed Computing","location":"stdlib/Distributed.html#Sockets.connect-Tuple{ClusterManager, Int64, WorkerConfig}","category":"method","text":"connect(manager::ClusterManager, pid::Int, config::WorkerConfig) -> (instrm::IO, outstrm::IO)\n\nImplemented by cluster managers using custom transports. It should establish a logical\nconnection to worker with id pid, specified by config and return a pair of IO\nobjects. Messages from pid to current process will be read off instrm, while messages to\nbe sent to pid will be written to outstrm. The custom transport implementation must\nensure that messages are delivered and received completely and in order.\nconnect(manager::ClusterManager.....) sets up TCP/IP socket connections in-between\nworkers.\n\n\n\n\n\n"},{"title":"Distributed.init_worker","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.init_worker","category":"function","text":"init_worker(cookie::AbstractString, manager::ClusterManager=DefaultClusterManager())\n\nCalled by cluster managers implementing custom transports. It initializes a newly launched\nprocess as a worker. Command line argument --worker[=<cookie>] has the effect of initializing a\nprocess as a worker using TCP/IP sockets for transport.\ncookie is a cluster_cookie.\n\n\n\n\n\n"},{"title":"Distributed.start_worker","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.start_worker","category":"function","text":"start_worker([out::IO=stdout], cookie::AbstractString=readline(stdin); close_stdin::Bool=true, stderr_to_stdout::Bool=true)\n\nstart_worker is an internal function which is the default entry point for\nworker processes connecting via TCP/IP. It sets up the process as a Julia cluster\nworker.\n\nhost:port information is written to stream out (defaults to stdout).\n\nThe function reads the cookie from stdin if required, and  listens on a free port\n(or if specified, the port in the --bind-to command line option) and schedules\ntasks to process incoming TCP connections and requests. It also (optionally)\ncloses stdin and redirects stderr to stdout.\n\nIt does not return.\n\n\n\n\n\n"},{"title":"Distributed.process_messages","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.process_messages","category":"function","text":"process_messages(r_stream::IO, w_stream::IO, incoming::Bool=true)\n\nCalled by cluster managers using custom transports. It should be called when the custom\ntransport implementation receives the first message from a remote worker. The custom\ntransport must manage a logical connection to the remote worker and provide two\nIO objects, one for incoming messages and the other for messages addressed to the\nremote worker.\nIf incoming is true, the remote peer initiated the connection.\nWhichever of the pair initiates the connection sends the cluster cookie and its\nJulia version number to perform the authentication handshake.\n\nSee also cluster_cookie.\n\n\n\n\n\n"},{"title":"Distributed.default_addprocs_params","page":"Distributed Computing","location":"stdlib/Distributed.html#Distributed.default_addprocs_params","category":"function","text":"default_addprocs_params(mgr::ClusterManager) -> Dict{Symbol, Any}\n\nImplemented by cluster managers. The default keyword parameters passed when calling\naddprocs(mgr). The minimal set of options is available by calling\ndefault_addprocs_params()\n\n\n\n\n\n"},{"title":"Constants","page":"Constants","location":"base/constants.html#lib-constants","category":"section","text":"See also:\n\nstdin\nstdout\nstderr\nENV\nENDIAN_BOM"},{"title":"Core.nothing","page":"Constants","location":"base/constants.html#Core.nothing","category":"constant","text":"nothing\n\nThe singleton instance of type Nothing, used by convention when there is no value to return\n(as in a C void function) or when a variable or field holds no value.\n\nA return value of nothing is not displayed by the REPL and similar interactive environments.\n\nSee also: isnothing, something, missing.\n\n\n\n\n\n"},{"title":"Base.PROGRAM_FILE","page":"Constants","location":"base/constants.html#Base.PROGRAM_FILE","category":"constant","text":"PROGRAM_FILE\n\nA string containing the script name passed to Julia from the command line. Note that the\nscript name remains unchanged from within included files. Alternatively see\n@__FILE__.\n\n\n\n\n\n"},{"title":"Base.ARGS","page":"Constants","location":"base/constants.html#Base.ARGS","category":"constant","text":"ARGS\n\nAn array of the command line arguments passed to Julia, as strings.\n\n\n\n\n\n"},{"title":"Base.C_NULL","page":"Constants","location":"base/constants.html#Base.C_NULL","category":"constant","text":"C_NULL\n\nThe C null pointer constant, sometimes used when calling external code.\n\n\n\n\n\n"},{"title":"Base.VERSION","page":"Constants","location":"base/constants.html#Base.VERSION","category":"constant","text":"VERSION\n\nA VersionNumber object describing which version of Julia is in use. See also\nVersion Number Literals.\n\n\n\n\n\n"},{"title":"Base.DEPOT_PATH","page":"Constants","location":"base/constants.html#Base.DEPOT_PATH","category":"constant","text":"DEPOT_PATH\n\nA stack of \"depot\" locations where the package manager, as well as Julia's code\nloading mechanisms, look for package registries, installed packages, named\nenvironments, repo clones, cached compiled package images, and configuration\nfiles. By default it includes:\n\n~/.julia where ~ is the user home as appropriate on the system;\nan architecture-specific shared system directory, e.g. /usr/local/share/julia;\nan architecture-independent shared system directory, e.g. /usr/share/julia.\n\nSo DEPOT_PATH might be:\n\n[joinpath(homedir(), \".julia\"), \"/usr/local/share/julia\", \"/usr/share/julia\"]\n\nThe first entry is the \"user depot\" and should be writable by and owned by the\ncurrent user. The user depot is where: registries are cloned, new package versions\nare installed, named environments are created and updated, package repos are cloned,\nnewly compiled package image files are saved, log files are written, development\npackages are checked out by default, and global configuration data is saved. Later\nentries in the depot path are treated as read-only and are appropriate for\nregistries, packages, etc. installed and managed by system administrators.\n\nDEPOT_PATH is populated based on the JULIA_DEPOT_PATH\nenvironment variable if set.\n\nDEPOT_PATH contents\n\nEach entry in DEPOT_PATH is a path to a directory which contains subdirectories used by Julia for various purposes.\nHere is an overview of some of the subdirectories that may exist in a depot:\n\nartifacts: Contains content that packages use for which Pkg manages the installation of.\nclones: Contains full clones of package repos. Maintained by Pkg.jl and used as a cache.\nconfig: Contains julia-level configuration such as a startup.jl.\ncompiled: Contains precompiled *.ji files for packages. Maintained by Julia.\ndev: Default directory for Pkg.develop. Maintained by Pkg.jl and the user.\nenvironments: Default package environments. For instance the global environment for a specific julia version. Maintained by Pkg.jl.\nlogs: Contains logs of Pkg and REPL operations. Maintained by Pkg.jl and Julia.\npackages: Contains packages, some of which were explicitly installed and some which are implicit dependencies. Maintained by Pkg.jl.\nregistries: Contains package registries. By default only General. Maintained by Pkg.jl.\nscratchspaces: Contains content that a package itself installs via the Scratch.jl package. Pkg.gc() will delete content that is known to be unused.\n\nnote: Note\nPackages that want to store content should use the scratchspaces subdirectory via\nScratch.jl instead of creating new\nsubdirectories in the depot root.\n\nSee also JULIA_DEPOT_PATH, and\nCode Loading.\n\n\n\n\n\n"},{"title":"Base.LOAD_PATH","page":"Constants","location":"base/constants.html#Base.LOAD_PATH","category":"constant","text":"LOAD_PATH\n\nAn array of paths for using and import statements to consider as project\nenvironments or package directories when loading code. It is populated based on\nthe JULIA_LOAD_PATH environment variable if set;\notherwise it defaults to [\"@\", \"@v#.#\", \"@stdlib\"]. Entries starting with @\nhave special meanings:\n\n@ refers to the \"current active environment\", the initial value of which is\ninitially determined by the JULIA_PROJECT environment\nvariable or the --project command-line option.\n@stdlib expands to the absolute path of the current Julia installation's\nstandard library directory.\n@name refers to a named environment, which are stored in depots (see\nJULIA_DEPOT_PATH) under the environments\nsubdirectory. The user's named environments are stored in\n~/.julia/environments so @name would refer to the environment in\n~/.julia/environments/name if it exists and contains a Project.toml file.\nIf name contains # characters, then they are replaced with the major, minor\nand patch components of the Julia version number. For example, if you are\nrunning Julia 1.2 then @v#.# expands to @v1.2 and will look for an\nenvironment by that name, typically at ~/.julia/environments/v1.2.\n\nThe fully expanded value of LOAD_PATH that is searched for projects and packages\ncan be seen by calling the Base.load_path() function.\n\nSee also\nJULIA_LOAD_PATH,\nJULIA_PROJECT,\nJULIA_DEPOT_PATH, and\nCode Loading.\n\n\n\n\n\n"},{"title":"Base.Sys.BINDIR","page":"Constants","location":"base/constants.html#Base.Sys.BINDIR","category":"constant","text":"Sys.BINDIR::String\n\nA string containing the full path to the directory containing the julia executable.\n\n\n\n\n\n"},{"title":"Base.Sys.CPU_THREADS","page":"Constants","location":"base/constants.html#Base.Sys.CPU_THREADS","category":"constant","text":"Sys.CPU_THREADS::Int\n\nThe number of logical CPU cores available in the system, i.e. the number of threads\nthat the CPU can run concurrently. Note that this is not necessarily the number of\nCPU cores, for example, in the presence of\nhyper-threading.\n\nSee Hwloc.jl or CpuId.jl for extended information, including number of physical cores.\n\nSee also: Sys.EFFECTIVE_CPU_THREADS for a container-aware CPU count that respects\ncgroup limits.\n\n\n\n\n\n"},{"title":"Base.Sys.EFFECTIVE_CPU_THREADS","page":"Constants","location":"base/constants.html#Base.Sys.EFFECTIVE_CPU_THREADS","category":"constant","text":"Sys.EFFECTIVE_CPU_THREADS::Int\n\nThe effective number of logical CPU cores available to the Julia process, taking into\naccount container limits (e.g., Docker --cpus, Kubernetes CPU limits, cgroup quotas).\nThis is the minimum of the hardware CPU thread count and any imposed CPU limits.\n\nIn non-containerized environments, this typically equals Sys.CPU_THREADS. In containerized\nenvironments, it respects cgroup CPU limits and provides a more accurate measure of\navailable parallelism.\n\nUse this constant when determining default thread pool sizes or parallelism levels to\nensure proper behavior in containerized deployments.\n\n\n\n\n\n"},{"title":"Base.Sys.WORD_SIZE","page":"Constants","location":"base/constants.html#Base.Sys.WORD_SIZE","category":"constant","text":"Sys.WORD_SIZE::Int\n\nStandard word size on the current machine, in bits.\n\n\n\n\n\n"},{"title":"Base.Sys.KERNEL","page":"Constants","location":"base/constants.html#Base.Sys.KERNEL","category":"constant","text":"Sys.KERNEL::Symbol\n\nA symbol representing the name of the operating system, as returned by uname of the build configuration.\n\n\n\n\n\n"},{"title":"Base.Sys.ARCH","page":"Constants","location":"base/constants.html#Base.Sys.ARCH","category":"constant","text":"Sys.ARCH::Symbol\n\nA symbol representing the architecture of the build configuration.\n\n\n\n\n\n"},{"title":"Base.Sys.MACHINE","page":"Constants","location":"base/constants.html#Base.Sys.MACHINE","category":"constant","text":"Sys.MACHINE::String\n\nA string containing the build triple.\n\n\n\n\n\n"},{"title":"Reflection and introspection","page":"Reflection and introspection","location":"base/reflection.html#Reflection-and-introspection","category":"section","text":"Julia provides a variety of runtime reflection capabilities."},{"title":"Module bindings","page":"Reflection and introspection","location":"base/reflection.html#Module-bindings","category":"section","text":"The public names for a Module are available using names(m::Module), which will return\nan array of Symbol elements representing the public bindings. names(m::Module, all = true)\nreturns symbols for all bindings in m, regardless of public status."},{"title":"DataType fields","page":"Reflection and introspection","location":"base/reflection.html#DataType-fields","category":"section","text":"The names of DataType fields may be interrogated using fieldnames. For example,\ngiven the following type, fieldnames(Point) returns a tuple of Symbols representing\nthe field names:\n\njulia> struct Point\n           x::Int\n           y\n       end\n\njulia> fieldnames(Point)\n(:x, :y)\n\nThe type of each field in a Point object is stored in the types field of the Point variable\nitself:\n\njulia> Point.types\nsvec(Int64, Any)\n\nWhile x is annotated as an Int, y was unannotated in the type definition, therefore y\ndefaults to the Any type.\n\nTypes are themselves represented as a structure called DataType:\n\njulia> typeof(Point)\nDataType\n\nNote that fieldnames(DataType) gives the names for each field of DataType itself, and one\nof these fields is the types field observed in the example above."},{"title":"Subtypes","page":"Reflection and introspection","location":"base/reflection.html#Subtypes","category":"section","text":"The direct subtypes of any DataType may be listed using subtypes. For example,\nthe abstract DataType AbstractFloat has four (concrete) subtypes:\n\njulia> InteractiveUtils.subtypes(AbstractFloat)\n5-element Vector{Any}:\n BigFloat\n Core.BFloat16\n Float16\n Float32\n Float64\n\nAny abstract subtype will also be included in this list, but further subtypes thereof will not;\nrecursive application of subtypes may be used to inspect the full type tree.\n\nNote that subtypes is located inside InteractiveUtils but\nis automatically exported when using the REPL."},{"title":"DataType layout","page":"Reflection and introspection","location":"base/reflection.html#DataType-layout","category":"section","text":"The internal representation of a DataType is critically important when interfacing with C code\nand several functions are available to inspect these details. isbitstype(T::DataType) returns\ntrue if T is stored with C-compatible alignment. fieldoffset(T::DataType, i::Integer)\nreturns the (byte) offset for field i relative to the start of the type."},{"title":"Function methods","page":"Reflection and introspection","location":"base/reflection.html#Function-methods","category":"section","text":"The methods of any generic function may be listed using methods. The method dispatch\ntable may be searched for methods accepting a given type using methodswith."},{"title":"Expansion and lowering","page":"Reflection and introspection","location":"base/reflection.html#Expansion-and-lowering","category":"section","text":"As discussed in the Metaprogramming section, the macroexpand function gives\nthe unquoted and interpolated expression (Expr) form for a given macro. To use macroexpand,\nquote the expression block itself (otherwise, the macro will be evaluated and the result will\nbe passed instead!). For example:\n\njulia> macroexpand(@__MODULE__, :(@invoke identity(1::Int)))\n:(Core.invoke(identity, Base.Tuple{Int}, 1))\n\nThe functions Base.Meta.show_sexpr and dump are used to display S-expr style views\nand depth-nested detail views for any expression.\n\nFinally, the Meta.lower function gives the lowered form of any expression and is of\nparticular interest for understanding how language constructs map to primitive operations such\nas assignments, branches, and calls:\n\njulia> Meta.lower(@__MODULE__, :( [1+2, sin(0.5)] ))\n:($(Expr(:thunk, CodeInfo(\n1 ─ %1 = :+\n│   %2 =   dynamic (%1)(1, 2)\n│   %3 = sin\n│   %4 =   dynamic (%3)(0.5)\n│   %5 =   dynamic Base.vect(%2, %4)\n└──      return %5\n))))"},{"title":"Intermediate and compiled representations","page":"Reflection and introspection","location":"base/reflection.html#Intermediate-and-compiled-representations","category":"section","text":"Inspecting the lowered form for functions requires selection of the specific method to display,\nbecause generic functions may have many methods with different type signatures. For this purpose,\nmethod-specific code-lowering is available using code_lowered,\nand the type-inferred form is available using code_typed.\ncode_warntype adds highlighting to the output of code_typed.\n\nCloser to the machine, the LLVM intermediate representation of a function may be printed using\nby code_llvm, and finally the compiled machine code is available\nusing code_native (this will trigger JIT compilation/code\ngeneration for any function which has not previously been called).\n\nFor convenience, there are macro versions of the above functions which take standard function\ncalls and expand argument types automatically:\n\njulia> @code_llvm +(1,1)\n;  @ int.jl:87 within `+`\n; Function Attrs: sspstrong uwtable\ndefine i64 @\"julia_+_476\"(i64 signext %0, i64 signext %1) #0 {\ntop:\n  %2 = add i64 %1, %0\n  ret i64 %2\n}\n\nFor more information see @code_lowered, @code_typed, @code_warntype,\n@code_llvm, and @code_native."},{"title":"Printing of debug information","page":"Reflection and introspection","location":"base/reflection.html#Printing-of-debug-information","category":"section","text":"The aforementioned functions and macros take the keyword argument debuginfo that controls the level\nof debug information printed.\n\njulia> InteractiveUtils.@code_typed debuginfo=:source +(1,1)\nCodeInfo(\n    @ int.jl:87 within `+`\n1 ─ %1 = intrinsic Base.add_int(x, y)::Int64\n└──      return %1\n) => Int64\n\nPossible values for debuginfo are: :none, :source, and :default.\nPer default debug information is not printed, but that can be changed\nby setting Base.IRShow.default_debuginfo[] = :source."},{"title":"Lazy Artifacts","page":"Lazy Artifacts","location":"stdlib/LazyArtifacts.html#Lazy-Artifacts","category":"section","text":"In order for a package to download artifacts lazily, LazyArtifacts must be\nexplicitly listed as a dependency of that package.\n\nFor further information on artifacts, see Artifacts."},{"title":"Noteworthy Differences from other Languages","page":"Noteworthy Differences from other Languages","location":"manual/noteworthy-differences.html#Noteworthy-Differences-from-other-Languages","category":"section","text":""},{"title":"Noteworthy differences from MATLAB","page":"Noteworthy Differences from other Languages","location":"manual/noteworthy-differences.html#Noteworthy-differences-from-MATLAB","category":"section","text":"Although MATLAB users may find Julia's syntax familiar, Julia is not a MATLAB clone. There are\nmajor syntactic and functional differences. The following are some noteworthy differences that\nmay trip up Julia users accustomed to MATLAB:\n\nJulia arrays are indexed with square brackets, A[i,j].\nJulia arrays are not copied when assigned to another variable. After A = B, changing elements of B\nwill modify A as well. To avoid this, use A = copy(B).\nJulia values are not copied when passed to a function. If a function modifies an array, the changes\nwill be visible in the caller.\nJulia does not automatically grow arrays in an assignment statement. Whereas in MATLAB a(4) = 3.2\ncan create the array a = [0 0 0 3.2] and a(5) = 7 can grow it into a = [0 0 0 3.2 7], the\ncorresponding Julia statement a[5] = 7 throws an error if the length of a is less than 5 or\nif this statement is the first use of the identifier a. Julia has push! and append!,\nwhich grow Vectors much more efficiently than MATLAB's a(end+1) = val.\nThe imaginary unit sqrt(-1) is represented in Julia as im, not i or j as in MATLAB.\nIn Julia, literal numbers without a decimal point (such as 42) create integers instead of floating\npoint numbers. As a result, some operations can throw a domain error if they expect a float; for example,\njulia> a = -1; 2^a throws a domain error, as the\nresult is not an integer (see the FAQ entry on domain errors for details).\nIn Julia, multiple values are returned and assigned as tuples, e.g. (a, b) = (1, 2) or a, b = 1, 2.\nMATLAB's nargout, which is often used in MATLAB to do optional work based on the number of returned\nvalues, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve\nsimilar capabilities.\nJulia has true one-dimensional arrays. Column vectors are of size N, not Nx1. For example,\nrand(N) makes a 1-dimensional array.\nIn Julia, [x,y,z] will always construct a 3-element array containing x, y and z.\nTo concatenate in the first (\"vertical\") dimension use either vcat(x,y,z) or separate\nwith semicolons ([x; y; z]).\nTo concatenate in the second (\"horizontal\") dimension use either hcat(x,y,z) or separate\nwith spaces ([x y z]).\nTo construct block matrices (concatenating in the first two dimensions), use either hvcat\nor combine spaces and semicolons ([a b; c d]).\nIn Julia, a:b and a:b:c construct AbstractRange objects. To construct a full vector like in MATLAB,\nuse collect(a:b). Generally, there is no need to call collect though. An AbstractRange\nobject will act like a normal array in most cases but is more efficient because it lazily computes\nits values. This pattern of creating specialized objects instead of full arrays is used frequently,\nand is also seen in functions such as range, or with iterators such as enumerate, and\nzip. The special objects can mostly be used as if they were normal arrays.\nFunctions in Julia return values from their last expression or the return keyword instead of\nlisting the names of variables to return in the function definition (see The return Keyword\nfor details).\nA Julia script may contain any number of functions, and all definitions will be externally visible\nwhen the file is loaded. Function definitions can be loaded from files outside the current working\ndirectory.\nIn Julia, reductions such as sum, prod, and maximum are performed\nover every element of an array when called with a single argument, as in sum(A), even if A\nhas more than one dimension.\nIn Julia, parentheses must be used to call a function with zero arguments, like in rand().\nJulia discourages the use of semicolons to end statements. The results of statements are not\nautomatically printed (except at the interactive prompt), and lines of code do not need to end\nwith semicolons. println or @printf can be used to print specific output.\nIn Julia, if A and B are arrays, logical comparison operations like A == B do not return\nan array of booleans. Instead, use A .== B, and similarly for the other boolean operators like\n<, >.\nIn Julia, when you want to apply a scalar-valued function elementwise to an array, use broadcasting\nsyntax: f.(A) instead of f(A). In some cases, both operations are defined but mean different things:\nin MATLAB exp(A) applies elementwise and expm(A) is the matrix exponential,\nbut in Julia exp.(A) applies elementwise and exp(A) is the matrix exponential.\nIn Julia, the operators &, |, and ⊻ (xor) perform the\nbitwise operations equivalent to and, or, and xor respectively in MATLAB, and have precedence\nsimilar to Python's bitwise operators (unlike C). To apply logical boolean operators over an array\n(like common uses of MATLAB's & and |), broadcast Julia's short-circuiting operators .&& and .||.\nFor example, to test if the elements in an array A are equal to 1 or 2, you can use A .== 1 .|| A .== 2.\nIn Julia, the elements of a collection can be passed as arguments to a function using the splat\noperator ..., as in xs=[1,2]; f(xs...).\nJulia's svd returns singular values as a vector instead of as a dense diagonal matrix.\nIn Julia, ... is not used to continue lines of code. Instead, incomplete expressions automatically\ncontinue onto the next line.\nIn both Julia and MATLAB, the variable ans is set to the value of the last expression issued\nin an interactive session. In Julia, unlike MATLAB, ans is not set when Julia code is run in\nnon-interactive mode.\nJulia's structs do not support dynamically adding fields at runtime, unlike MATLAB's classes.\nInstead, use a Dict. Dict in Julia isn't ordered.\nIn Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global\nscope.\nIn MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the\nexpression x(x>3) or in the statement x(x>3) = [] to modify x in-place. In contrast, Julia\nprovides the higher order functions filter and filter!, allowing users\nto write filter(z->z>3, x) and filter!(z->z>3, x) as alternatives to the corresponding transliterations\nx[x.>3] and x = x[x.>3]. Using filter! reduces the use of temporary arrays.\nFollowing on from the previous point, to replace values that meet specific criteria, for example a\nthresholding operation on all elements in a matrix, could be achieved in Matlab as follows A(A < threshold) = 0.\nThe Julia equivalent would be A[A .< threshold] .= 0.\nThe analogue of extracting (or \"dereferencing\") all elements of a cell array, e.g. in vertcat(A{:})\nin MATLAB, is written using the splat operator in Julia, e.g. as vcat(A...).\nIn Julia, the adjoint function performs conjugate transposition; in MATLAB, adjoint provides the\n\"adjugate\" or classical adjoint, which is the transpose of the matrix of cofactors.\nIn Julia, a^b^c is evaluated a^(b^c) while in MATLAB it's (a^b)^c."},{"title":"Noteworthy differences from R","page":"Noteworthy Differences from other Languages","location":"manual/noteworthy-differences.html#Noteworthy-differences-from-R","category":"section","text":"One of Julia's goals is to provide an effective language for data analysis and statistical programming.\nFor users coming to Julia from R, these are some noteworthy differences:\n\nJulia's single quotes enclose characters, not strings.\nJulia can create substrings by indexing into strings. In R, strings must be converted into character\nvectors before creating substrings.\nIn Julia, like Python but unlike R, strings can be created with triple quotes \"\"\" ... \"\"\". This\nsyntax is convenient for constructing strings that contain line breaks.\nIn Julia, varargs are specified using the splat operator ..., which always follows the name\nof a specific variable, unlike R, for which ... can occur in isolation.\nIn Julia, modulus is mod(a, b), not a %% b. % in Julia is the remainder operator.\nJulia constructs vectors using brackets. Julia's [1, 2, 3] is the equivalent of R's c(1, 2, 3).\nIn Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia\nis supported only with vectors of length equal to the object being indexed. For example:\nIn R, c(1, 2, 3, 4)[c(TRUE, FALSE)] is equivalent to c(1, 3).\nIn R, c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)] is equivalent to c(1, 3).\nIn Julia, [1, 2, 3, 4][[true, false]] throws a BoundsError.\nIn Julia, [1, 2, 3, 4][[true, false, true, false]] produces [1, 3].\nLike many languages, Julia does not always allow operations on vectors of different lengths, unlike\nR where the vectors only need to share a common index range. For example, c(1, 2, 3, 4) + c(1, 2)\nis valid R but the equivalent [1, 2, 3, 4] + [1, 2] will throw an error in Julia.\nJulia allows an optional trailing comma when that comma does not change the meaning of code.\nThis can cause confusion among R users when indexing into arrays. For example, x[1,] in R\nwould return the first row of a matrix; in Julia, however, the comma is ignored, so\nx[1,] == x[1], and will return the first element. To extract a row, be sure to use :, as in x[1,:].\nJulia's map takes the function first, then its arguments, unlike lapply(<structure>, function, ...)\nin R. Similarly Julia's equivalent of apply(X, MARGIN, FUN, ...) in R is mapslices\nwhere the function is the first argument.\nMultivariate apply in R, e.g. mapply(choose, 11:13, 1:3), can be written as broadcast(binomial, 11:13, 1:3)\nin Julia. Equivalently Julia offers a shorter dot syntax for vectorizing functions binomial.(11:13, 1:3).\nJulia uses end to denote the end of conditional blocks, like if, loop blocks, like while/\nfor, and functions. In lieu of the one-line if ( cond ) statement, Julia allows statements\nof the form if cond; statement; end, cond && statement and !cond || statement. Assignment\nstatements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. cond && (x = value).\nIn Julia, <-, <<- and -> are not assignment operators.\nJulia's -> creates an anonymous function.\nJulia's * operator can perform matrix multiplication, unlike in R. If A and B are\nmatrices, then A * B denotes a matrix multiplication in Julia, equivalent to R's A %*% B.\nIn R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise\nmultiplication operation, you need to write A .* B in Julia.\nJulia performs matrix transposition using the transpose function and conjugated transposition using\nthe ' operator or the adjoint function. Julia's transpose(A) is therefore equivalent to R's t(A).\nAdditionally a non-recursive transpose in Julia is provided by the permutedims function.\nJulia does not require parentheses when writing if statements or for/while loops: use for i in [1, 2, 3]\ninstead of for (i in c(1, 2, 3)) and if i == 1 instead of if (i == 1).\nJulia does not treat the numbers 0 and 1 as Booleans. You cannot write if (1) in Julia,\nbecause if statements accept only booleans. Instead, you can write if true, if Bool(1),\nor if 1==1.\nJulia does not provide nrow and ncol. Instead, use size(M, 1) for nrow(M) and size(M, 2)\nfor ncol(M).\nJulia is careful to distinguish scalars, vectors and matrices. In R, 1 and c(1) are the same.\nIn Julia, they cannot be used interchangeably.\nJulia's diag and diagm are not like R's.\nJulia cannot assign to the results of function calls on the left hand side of an assignment operation:\nyou cannot write diag(M) = fill(1, n).\nJulia discourages populating the main namespace with functions. Most statistical functionality\nfor Julia is found in packages under the JuliaStats organization.\nFor example:\nFunctions pertaining to probability distributions are provided by the Distributions package.\nThe DataFrames package provides data frames.\nGeneralized linear models are provided by the GLM package.\nJulia provides tuples and real hash tables, but not R-style lists. When returning multiple items,\nyou should typically use a tuple or a named tuple: instead of list(a = 1, b = 2), use (1, 2)\nor (a=1, b=2).\nJulia encourages users to write their own types, which are easier to use than S3 or S4 objects\nin R. Julia's multiple dispatch system means that table(x::TypeA) and table(x::TypeB) act\nlike R's table.TypeA(x) and table.TypeB(x).\nIn Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes\nwill be visible in the caller. This is very different from R and allows new functions to operate\non large data structures much more efficiently.\nIn Julia, vectors and matrices are concatenated using hcat, vcat and\nhvcat, not c, rbind and cbind like in R.\nIn Julia, a range like a:b is not shorthand for a vector like in R, but is a specialized AbstractRange\nobject that is used for iteration. To convert a range into a vector, use\ncollect(a:b).\nThe : operator has a different precedence in R and Julia. In particular, in Julia arithmetic operators\nhave higher precedence than the : operator, whereas the reverse is true in R. For example, 1:n-1 in\nJulia is equivalent to 1:(n-1) in R.\nJulia's max and min are the equivalent of pmax and pmin respectively\nin R, but both arguments need to have the same dimensions. While maximum and minimum\nreplace max and min in R, there are important differences.\nJulia's sum, prod, maximum, and minimum are different\nfrom their counterparts in R. They all accept an optional keyword argument dims, which indicates the\ndimensions, over which the operation is carried out. For instance, let A = [1 2; 3 4] in Julia\nand B <- rbind(c(1,2),c(3,4)) be the same matrix in R. Then sum(A) gives the same result as\nsum(B), but sum(A, dims=1) is a row vector containing the sum over each column and sum(A, dims=2)\nis a column vector containing the sum over each row. This contrasts to the behavior of R, where separate\ncolSums(B) and rowSums(B) functions provide these functionalities. If the dims keyword argument is a\nvector, then it specifies all the dimensions over which the sum is performed, while retaining the\ndimensions of the summed array, e.g. sum(A, dims=(1,2)) == hcat(10). It should be noted that there is no\nerror checking regarding the second argument.\nJulia has several functions that can mutate their arguments. For example, it has both sort\nand sort!.\nIn R, performance requires vectorization. In Julia, almost the opposite is true: the best performing\ncode is often achieved by using devectorized loops.\nJulia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this\nmeans that there are very few unquoted expressions or column names.\nJulia does not support the NULL type. The closest equivalent is nothing, but it\nbehaves like a scalar value rather than like a list. Use x === nothing instead of is.null(x).\nIn Julia, missing values are represented by the missing object rather than by NA.\nUse ismissing(x) (or ismissing.(x) for element-wise operation on vectors) instead of\nis.na(x). The skipmissing function is generally\nused instead of na.rm=TRUE (though in some particular cases functions take a skipmissing\nargument).\nJulia lacks the equivalent of R's assign or get.\nIn Julia, return does not require parentheses.\nIn R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression\nx[x>3] or in the statement x = x[x>3] to modify x in-place. In contrast, Julia provides\nthe higher order functions filter and filter!, allowing users to write\nfilter(z->z>3, x) and filter!(z->z>3, x) as alternatives to the corresponding transliterations\nx[x.>3] and x = x[x.>3]. Using filter! reduces the use of temporary arrays."},{"title":"Noteworthy differences from Python","page":"Noteworthy Differences from other Languages","location":"manual/noteworthy-differences.html#Noteworthy-differences-from-Python","category":"section","text":"Julia's for, if, while, etc. blocks are terminated by the end keyword. Indentation level\nis not significant as it is in Python. Unlike Python, Julia has no pass keyword.\nStrings are denoted by double quotation marks (\"text\") in Julia (with three double quotation marks for multi-line strings), whereas in Python they can be denoted either by single ('text') or double quotation marks (\"text\"). Single quotation marks are used for characters in Julia ('c').\nString concatenation is done with * in Julia, not + like in Python. Analogously, string repetition is done with ^, not *. Implicit string concatenation of string literals like in Python (e.g. 'ab' 'cd' == 'abcd') is not done in Julia.\nPython Lists—flexible but slow—correspond to the Julia Vector{Any} type or more generally Vector{T} where T is some non-concrete element type. \"Fast\" arrays like NumPy arrays that store elements in-place (i.e., dtype is np.float64, [('f1', np.uint64), ('f2', np.int32)], etc.) can be represented by Array{T} where T is a concrete, immutable element type. This includes built-in types like Float64, Int32, Int64 but also more complex types like Tuple{UInt64,Float64} and many user-defined types as well.\nIn Julia, indexing of arrays, strings, etc. is 1-based not 0-based.\nJulia's slice indexing includes the last element, unlike in Python. a[2:3] in Julia is a[1:3]\nin Python.\nUnlike Python, Julia allows AbstractArrays with arbitrary indexes.\nPython's special interpretation of negative indexing, a[-1] and a[-2], should be written\na[end] and a[end-1] in Julia.\nJulia requires end for indexing until the last element. x[2:end] in Julia is equivalent to x[1:] in Python.\nIn Julia, : before any object creates a Symbol or quotes an expression; so, x[:5] is the same as x[5]. If you want to get the first n elements of an array, then use range indexing.\nJulia's range indexing has the format of x[start:step:stop], whereas Python's format is x[start:(stop+1):step]. Hence, x[0:10:2] in Python is equivalent to x[1:2:10] in Julia. Similarly, x[::-1] in Python, which refers to the reversed array, is equivalent to x[end:-1:1] in Julia.\nIn Julia, ranges can be constructed independently as start:step:stop, the same syntax it uses\nin array-indexing. The range function is also supported.\nIn Julia, indexing a matrix with arrays like X[[1,2], [1,3]] refers to a sub-matrix that contains the intersections of the first and second rows with the first and third columns. In Python, X[[1,2], [1,3]] refers to a vector that contains the values of cell [1,1] and [2,3] in the matrix. X[[1,2], [1,3]] in Julia is equivalent with X[np.ix_([0,1],[0,2])] in Python. X[[0,1], [0,2]] in Python is equivalent with X[[CartesianIndex(1,1), CartesianIndex(2,3)]] in Julia.\nJulia has no line continuation syntax: if, at the end of a line, the input so far is a complete\nexpression, it is considered done; otherwise the input continues. One way to force an expression\nto continue is to wrap it in parentheses.\nJulia arrays are column-major (Fortran-ordered) whereas NumPy arrays are row-major (C-ordered)\nby default. To get optimal performance when looping over arrays, the order of the loops should\nbe reversed in Julia relative to NumPy (see relevant section of Performance Tips).\nJulia's updating operators (e.g. +=, -=, ...) are not in-place whereas NumPy's are. This\nmeans A = [1, 1]; B = A; B += [3, 3] doesn't change values in A, it rather rebinds the name B\nto the result of the right-hand side B = B + 3, which is a new array. For in-place operation, use B .+= 3\n(see also dot operators), explicit loops, or InplaceOps.jl.\nJulia evaluates default values of function arguments every time the method is invoked, unlike\nin Python where the default values are evaluated only once when the function is defined. For example,\nthe function f(x=rand()) = x returns a new random number every time it is invoked without argument.\nOn the other hand, the function g(x=[1,2]) = push!(x,3) returns [1,2,3] every time it is called\nas g().\nIn Julia, keyword arguments must be passed using keywords, unlike Python in which it is usually possible\nto pass them positionally. Attempting to pass a keyword argument positionally alters the method\nsignature leading to a MethodError or calling of the wrong method.\nIn Julia % is the remainder operator, whereas in Python it is the modulus.\nIn Julia, the commonly used Int type corresponds to the machine integer type (Int32 or Int64), unlike in Python, where int is an arbitrary length integer.\nThis means in Julia the Int type will overflow, such that 2^64 == 0. If you need larger values use another appropriate type,\nsuch as Int128, BigInt or a floating point type like Float64.\nThe imaginary unit sqrt(-1) is represented in Julia as im, not j as in Python.\nIn Julia, the exponentiation operator is ^, not ** as in Python.\nJulia uses nothing of type Nothing to represent a null value, whereas Python uses None of type NoneType.\nIn Julia, the standard operators over a matrix type are matrix operations, whereas, in Python, the standard operators are element-wise operations. When both A and B are matrices, A * B in Julia performs matrix multiplication, not element-wise multiplication as in Python. A * B in Julia is equivalent with A @ B in Python, whereas A * B in Python is equivalent with A .* B in Julia.\nIn Julia, when you want to apply a scalar-valued function elementwise to an array, use broadcasting\nsyntax: f.(A) instead of f(A). In some cases, both operations are defined but mean different things:\nnumpy.exp(A) applies elementwise and scipy.linalg.expm(A) is the matrix exponential,\nbut in Julia exp.(A) applies elementwise and exp(A) is the matrix exponential.\nThe adjoint operator ' in Julia returns an adjoint of a vector (a lazy representation of row vector), whereas the transpose operator .T over a vector in Python returns the original vector (non-op).\nIn Julia, a function may contain multiple concrete implementations (called methods), which are selected via multiple dispatch based on the types of all arguments to the call, as compared to functions in Python, which have a single implementation and no polymorphism (as opposed to Python method calls which use a different syntax and allows dispatch on the receiver of the method).\nThere are no classes in Julia. Instead there are structures (mutable or immutable), containing data but no methods.\nCalling a method of a class instance in Python (x = MyClass(*args); x.f(y)) corresponds to a function call in Julia, e.g. x = MyType(args...); f(x, y). In general, multiple dispatch is more flexible and powerful than the Python class system.\nJulia structures may have exactly one abstract supertype, whereas Python classes can inherit from one or more (abstract or concrete) superclasses.\nThe logical Julia program structure (Packages and Modules) is independent of the file structure, whereas the Python code structure is defined by directories (Packages) and files (Modules).\nIn Julia, it is idiomatic to split the text of large modules into multiple files, without introducing a new module per file. The code is reassembled inside a single module in a main file via include. While the Python equivalent (exec) is not typical for this use (it will silently clobber prior definitions), Julia programs are defined as a unit at the module level with using or import, which will only get executed once when first needed–like include in Python. Within those modules, the individual files that make up that module are loaded with include by listing them once in the intended order.\nThe ternary operator x > 0 ? 1 : -1 in Julia corresponds to a conditional expression in Python 1 if x > 0 else -1.\nIn Julia the @ symbol refers to a macro, whereas in Python it refers to a decorator.\nException handling in Julia is done using try — catch — finally, instead of try — except — finally. In contrast to Python, it is not recommended to use exception handling as part of the normal workflow in Julia (compared with Python, Julia is faster at ordinary control flow but slower at exception-catching).\nIn Julia loops are fast, there is no need to write \"vectorized\" code for performance reasons.\nBe careful with non-constant global variables in Julia, especially in tight loops. Since you can write close-to-metal code in Julia (unlike Python), the effect of globals can be drastic (see Performance Tips).\nIn Julia, rounding and truncation are explicit. Python's int(3.7) should be floor(Int, 3.7) or Int(floor(3.7)) and is distinguished from round(Int, 3.7). floor(x) and round(x) on their own return an integer value of the same type as x rather than always returning Int.\nIn Julia, parsing is explicit. Python's float(\"3.7\") would be parse(Float64, \"3.7\") in Julia.\nIn Python, the majority of values can be used in logical contexts (e.g. if \"a\": means the following block is executed, and if \"\": means it is not). In Julia, you need explicit conversion to Bool (e.g. if \"a\" throws an exception). If you want to test for a non-empty string in Julia, you would explicitly write if !isempty(\"\"). Perhaps surprisingly, in Python if \"False\" and bool(\"False\") both evaluate to True (because \"False\" is a non-empty string); in Julia, parse(Bool, \"false\") returns false.\nIn Julia, a new local scope is introduced by most code blocks, including loops and try — catch — finally. Note that comprehensions (list, generator, etc.) introduce a new local scope both in Python and Julia, whereas if blocks do not introduce a new local scope in both languages."},{"title":"Noteworthy differences from C/C++","page":"Noteworthy Differences from other Languages","location":"manual/noteworthy-differences.html#Noteworthy-differences-from-C/C","category":"section","text":"Julia arrays are indexed with square brackets, and can have more than one dimension A[i,j].\nThis syntax is not just syntactic sugar for a reference to a pointer or address as in C/C++. See\nthe manual entry about array construction.\nIn Julia, indexing of arrays, strings, etc. is 1-based not 0-based.\nJulia arrays are not copied when assigned to another variable. After A = B, changing elements of B will modify A\nas well. Updating operators like += do not operate in-place, they are equivalent to A = A + B\nwhich rebinds the left-hand side to the result of the right-hand side expression.\nJulia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by\ndefault. To get optimal performance when looping over arrays, the order of the loops should be\nreversed in Julia relative to C/C++ (see relevant section of Performance Tips).\nJulia values are not copied when assigned or passed to a function. If a function modifies an array, the changes\nwill be visible in the caller.\nIn Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing\nwhitespace from a Julia program.\nIn Julia, literal numbers without a decimal point (such as 42) create signed integers, of type\nInt, but literals too large to fit in the machine word size will automatically be promoted to\na larger size type, such as Int64 (if Int is Int32), Int128, or the arbitrarily large\nBigInt type. There are no numeric literal suffixes, such as L, LL, U, UL, ULL to indicate\nunsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals\n(which start with 0x like C/C++), are unsigned, unless when they encode more than 128 bits,\nin which case they are of type BigInt. Hexadecimal literals also, unlike C/C++/Java\nand unlike decimal literals in Julia, have a type based on the length of the literal, including\nleading 0s. For example, 0x0 and 0x00 have type UInt8, 0x000 and 0x0000 have type\nUInt16, then literals with 5 to 8 hex digits have type UInt32, 9 to 16 hex digits type\nUInt64, 17 to 32 hex digits type UInt128, and more that 32 hex digits type BigInt.\nThis needs to be taken into account when defining\nhexadecimal masks, for example ~0xf == 0xf0 is very different from ~0x000f == 0xfff0. 64 bit Float64\nand 32 bit Float32 bit literals are expressed as 1.0 and 1.0f0 respectively. Floating point\nliterals are rounded (and not promoted to the BigFloat type) if they can not be exactly represented.\n Floating point literals are closer in behavior to C/C++. Octal (prefixed with 0o) and binary\n(prefixed with 0b) literals are also treated as unsigned (or BigInt for more than 128 bits).\nIn Julia, the division operator / returns a floating point number when both operands\nare of integer type. To perform integer division, use div or ÷.\nIndexing an Array with floating point types is generally an error in Julia. The Julia\nequivalent of the C expression a[i / 2] is a[i ÷ 2 + 1], where i is of integer type.\nString literals can be delimited with either \"  or \"\"\", \"\"\" delimited literals can contain\n\" characters without quoting it like \"\\\"\". String literals can have values of other variables\nor expressions interpolated into them, indicated by $variablename or $(expression), which\nevaluates the variable name or the expression in the context of the function.\n// indicates a Rational number, and not a single-line comment (which is # in Julia)\n#= indicates the start of a multiline comment, and =# ends it.\nFunctions in Julia return values from their last expression(s) or the return keyword. Multiple\nvalues can be returned from functions and assigned as tuples, e.g. (a, b) = myfunction() or\na, b = myfunction(), instead of having to pass pointers to values as one would have to do in\nC/C++ (i.e. a = myfunction(&b).\nJulia does not require the use of semicolons to end statements. The results of expressions are\nnot automatically printed (except at the interactive prompt, i.e. the REPL), and lines of code\ndo not need to end with semicolons. println or @printf can be used to\nprint specific output. In the REPL, ; can be used to suppress output. ; also has a different\nmeaning within [ ], something to watch out for. ; can be used to separate expressions on a\nsingle line, but are not strictly necessary in many cases, and are more an aid to readability.\nIn Julia, the operator ⊻ (xor) performs the bitwise XOR operation, i.e.\n^ in C/C++. Also, the bitwise operators do not have the same precedence as C/C++, so\nparenthesis may be required.\nJulia's ^ is exponentiation (pow), not bitwise XOR as in C/C++ (use ⊻, or\nxor, in Julia)\nJulia has two right-shift operators, >> and >>>.  >> performs an arithmetic shift, >>>\nalways performs a logical shift, unlike C/C++, where the meaning of >> depends on the type of\nthe value being shifted.\nJulia's -> creates an anonymous function, it does not access a member via a pointer.\nJulia does not require parentheses when writing if statements or for/while loops: use for i in [1, 2, 3]\ninstead of for (int i=1; i <= 3; i++) and if i == 1 instead of if (i == 1).\nJulia does not treat the numbers 0 and 1 as Booleans. You cannot write if (1) in Julia,\nbecause if statements accept only booleans. Instead, you can write if true, if Bool(1),\nor if 1==1.\nJulia uses end to denote the end of conditional blocks, like if, loop blocks, like while/\nfor, and functions. In lieu of the one-line if ( cond ) statement, Julia allows statements\nof the form if cond; statement; end, cond && statement and !cond || statement. Assignment\nstatements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. cond && (x = value),\nbecause of the operator precedence.\nJulia has no line continuation syntax: if, at the end of a line, the input so far is a complete\nexpression, it is considered done; otherwise the input continues. One way to force an expression\nto continue is to wrap it in parentheses.\nJulia macros operate on parsed expressions, rather than the text of the program, which allows\nthem to perform sophisticated transformations of Julia code. Macro names start with the @ character,\nand have both a function-like syntax, @mymacro(arg1, arg2, arg3), and a statement-like syntax,\n@mymacro arg1 arg2 arg3. The forms are interchangeable; the function-like form is particularly\nuseful if the macro appears within another expression, and is often clearest. The statement-like\nform is often used to annotate blocks, as in the distributed for construct: @distributed for i in 1:n; #= body =#; end.\nWhere the end of the macro construct may be unclear, use the function-like form.\nJulia has an enumeration type, expressed using the macro @enum(name, value1, value2, ...)\nFor example: @enum(Fruit, banana=1, apple, pear)\nBy convention, functions that modify their arguments have a ! at the end of the name, for example\npush!.\nIn C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual,\nin order to have dynamic dispatch. On the other hand, in Julia every method is \"virtual\" (although\nit's more general than that since methods are dispatched on every argument type, not only this,\nusing the most-specific-declaration rule)."},{"title":"Julia ⇔ C/C++: Namespaces","page":"Noteworthy Differences from other Languages","location":"manual/noteworthy-differences.html#Julia-C/C:-Namespaces","category":"section","text":"C/C++ namespaces correspond roughly to Julia modules.\nThere are no private globals or fields in Julia. Everything is publicly accessible\nthrough fully qualified paths (or relative paths, if desired).\nusing MyNamespace::myfun (C++) corresponds roughly to import MyModule: myfun (Julia).\nusing namespace MyNamespace (C++) corresponds roughly to using MyModule (Julia)\nIn Julia, only exported symbols are made available to the calling module.\nIn C++, only elements found in the included (public) header files are made available.\nCaveat: import/using keywords (Julia) also load modules (see below).\nCaveat: import/using (Julia) works only at the global scope level (modules)\nIn C++, using namespace X works within arbitrary scopes (ex: function scope)."},{"title":"Julia ⇔ C/C++: Module loading","page":"Noteworthy Differences from other Languages","location":"manual/noteworthy-differences.html#Julia-C/C:-Module-loading","category":"section","text":"When you think of a C/C++ \"library\", you are likely looking for a Julia \"package\".\nCaveat: C/C++ libraries often house multiple \"software modules\" whereas Julia\n\"packages\" typically house one.\nReminder: Julia modules are global scopes (not necessarily \"software modules\").\nInstead of build/make scripts, Julia uses \"Project Environments\" (sometimes called\neither \"Project\" or \"Environment\").\nBuild scripts are only needed for more complex applications\n(like those needing to compile or download C/C++ executables).\nTo develop application or project in Julia, you can initialize its root directory\nas a \"Project Environment\", and house application-specific code/packages there.\nThis provides good control over project dependencies, and future reproducibility.\nAvailable packages are added to a \"Project Environment\" with the Pkg.add() function or Pkg REPL mode.\n(This does not load said package, however).\nThe list of available packages (direct dependencies) for a \"Project Environment\" are\nsaved in its Project.toml file.\nThe full dependency information for a \"Project Environment\" is auto-generated & saved\nin its Manifest.toml file by Pkg.resolve().\nPackages (\"software modules\") available to the \"Project Environment\" are loaded with\nimport or using.\nIn C/C++, you #include <moduleheader> to get object/function declarations, and link in\nlibraries when you build the executable.\nIn Julia, calling using/import again just brings the existing module into scope, but does not load it again\n(similar to adding the non-standard #pragma once to C/C++).\nDirectory-based package repositories (Julia) can be made available by adding repository\npaths to the Base.LOAD_PATH array.\nPackages from directory-based repositories do not require the Pkg.add() tool prior to\nbeing loaded with import or using. They are simply available to the project.\nDirectory-based package repositories are the quickest solution to developing local\nlibraries of \"software modules\"."},{"title":"Julia ⇔ C/C++: Assembling modules","page":"Noteworthy Differences from other Languages","location":"manual/noteworthy-differences.html#Julia-C/C:-Assembling-modules","category":"section","text":"In C/C++, .c/.cpp files are compiled & added to a library with build/make scripts.\nIn Julia, import [PkgName]/using [PkgName] statements load [PkgName].jl located\nin a package's [PkgName]/src/ subdirectory.\nIn turn, [PkgName].jl typically loads associated source files with calls to\ninclude \"[someotherfile].jl\".\ninclude \"./path/to/somefile.jl\" (Julia) is very similar to\n#include \"./path/to/somefile.jl\" (C/C++).\nHowever include \"...\" (Julia) is not used to include header files (not required).\nDo not use include \"...\" (Julia) to load code from other \"software modules\"\n(use import/using instead).\ninclude \"path/to/some/module.jl\" (Julia) would instantiate multiple versions of the\nsame code in different modules (creating distinct types (etc.) with the same names).\ninclude \"somefile.jl\" is typically used to assemble multiple files within the same\nJulia package (\"software module\"). It is therefore relatively straightforward to ensure\nfile are included only once (No #ifdef confusion)."},{"title":"Julia ⇔ C/C++: Module interface","page":"Noteworthy Differences from other Languages","location":"manual/noteworthy-differences.html#Julia-C/C:-Module-interface","category":"section","text":"C++ exposes interfaces using \"public\" .h/.hpp files whereas Julia modules mark\nspecific symbols that are intended for their users as publicor exported.\nOften, Julia modules simply add functionality by generating new \"methods\" to existing\nfunctions (ex: Base.push!).\nDevelopers of Julia packages therefore cannot rely on header files for interface\ndocumentation.\nInterfaces for Julia packages are typically described using docstrings, README.md,\nstatic web pages, ...\nSome developers choose not to export all symbols required to use their package/module,\nbut should still mark unexported user facing symbols as public.\nUsers might be expected to access these components by qualifying functions/structs/...\nwith the package/module name (ex: MyModule.run_this_task(...))."},{"title":"Julia ⇔ C/C++: Quick reference","page":"Noteworthy Differences from other Languages","location":"manual/noteworthy-differences.html#Julia-C/C:-Quick-reference","category":"section","text":"Software Concept Julia C/C++\nunnamed scope begin ... end { ... }\nfunction scope function x() ... end int x() { ... }\nglobal scope module MyMod ... end namespace MyNS { ... }\nsoftware module A Julia \"package\" .h/.hpp files<br>+compiled somelib.a\nassembling<br>software modules SomePkg.jl: ...<br>include(\"subfile1.jl\")<br>include(\"subfile2.jl\")<br>... $(AR) *.o ⇒ somelib.a\nimport<br>software module import SomePkg #include <somelib><br>+link in somelib.a\nmodule library LOAD_PATH[], *Git repository,<br>**custom package registry more .h/.hpp files<br>+bigger compiled somebiglib.a\n\n* The Julia package manager supports registering multiple packages from a single Git repository.<br>\n* This allows users to house a library of related packages in a single repository.<br>\n** Julia registries are primarily designed to provide versioning & distribution of packages.<br>\n** Custom package registries can be used to create a type of module library."},{"title":"Noteworthy differences from Common Lisp","page":"Noteworthy Differences from other Languages","location":"manual/noteworthy-differences.html#Noteworthy-differences-from-Common-Lisp","category":"section","text":"Julia uses 1-based indexing for arrays by default, and it can also handle arbitrary index offsets.\nFunctions and variables share the same namespace (“Lisp-1”).\nThere is a Pair type, but it is not meant to be used as a COMMON-LISP:CONS. Various iterable collections can be used interchangeably in most parts of the language (eg splatting, tuples, etc). Tuples are the closest to Common Lisp lists for short collections of heterogeneous elements. Use NamedTuples in place of alists. For larger collections of homogeneous types, Arrays and Dicts should be used.\nThe typical Julia workflow for prototyping also uses continuous manipulation of the image, implemented with the Revise.jl package.\nFor performance, Julia prefers that operations have type stability. Where Common Lisp abstracts away from the underlying machine operations, Julia cleaves closer to them. For example:\nInteger division using / always returns a floating-point result, even if the computation is exact.\n// always returns a rational result\n÷ always returns a (truncated) integer result\nBignums are supported, but conversion is not automatic; ordinary integers overflow.\nComplex numbers are supported, but to get complex results, you need complex inputs.\nThere are multiple Complex and Rational types, with different component types.\nModules (namespaces) can be hierarchical. import and using have a dual role: they load the code and make it available in the namespace. import for only the module name is possible (roughly equivalent to ASDF:LOAD-OP). Slot names don't need to be exported separately. Global variables can't be assigned to from outside the module (except with eval(mod, :(var = val)) as an escape hatch).\nMacros start with @, and are not as seamlessly integrated into the language as Common Lisp; consequently, macro usage is not as widespread as in the latter. A form of hygiene for macros is supported by the language. Because of the different surface syntax, there is no equivalent to COMMON-LISP:&BODY.\nAll functions are generic and use multiple dispatch. Argument lists don't have to follow the same template, which leads to a powerful idiom (see do). Optional and keyword arguments are handled differently. Method ambiguities are not resolved like in the Common Lisp Object System, necessitating the definition of a more specific method for the intersection.\nSymbols do not belong to any package, and do not contain any values per se. M.var evaluates the symbol var in the module M.\nA functional programming style is fully supported by the language, including closures, but isn't always the idiomatic solution for Julia. Some workarounds may be necessary for performance when modifying captured variables."},{"title":"File Events","page":"File Events","location":"stdlib/FileWatching.html#lib-filewatching","category":"section","text":""},{"title":"Pidfile","page":"File Events","location":"stdlib/FileWatching.html#Pidfile","category":"section","text":"A simple utility tool for creating advisory pidfiles (lock files)."},{"title":"Primary Functions","page":"File Events","location":"stdlib/FileWatching.html#Primary-Functions","category":"section","text":""},{"title":"Helper Functions","page":"File Events","location":"stdlib/FileWatching.html#Helper-Functions","category":"section","text":""},{"title":"FileWatching.poll_fd","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.poll_fd","category":"function","text":"poll_fd(fd, timeout_s::Real=-1; readable=false, writable=false)\n\nMonitor a file descriptor fd for changes in the read or write availability, and with a\ntimeout given by timeout_s seconds.\n\nThe keyword arguments determine which of read and/or write status should be monitored; at\nleast one of them must be set to true.\n\nThe returned value is an object with boolean fields readable, writable, and timedout,\ngiving the result of the polling.\n\nThis is a thin wrapper over calling wait on a FDWatcher, which implements the\nfunctionality but requires the user to call close manually when finished with it, or risk\nserious crashes.\n\n\n\n\n\n"},{"title":"FileWatching.poll_file","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.poll_file","category":"function","text":"poll_file(path::AbstractString, interval_s::Real=5.007, timeout_s::Real=-1) -> (previous::StatStruct, current)\n\nMonitor a file for changes by polling every interval_s seconds until a change occurs or\ntimeout_s seconds have elapsed. The interval_s should be a long period; the default is\n5.007 seconds.\n\nReturns a pair of status objects (previous, current) when a change is detected.\nThe previous status is always a StatStruct, but it may have all of the fields zeroed\n(indicating the file didn't previously exist, or wasn't previously accessible).\n\nThe current status object may be a StatStruct, an EOFError (indicating the timeout elapsed),\nor some other Exception subtype (if the stat operation failed: for example, if the path does not exist).\n\nTo determine when a file was modified, compare !(current isa StatStruct && prev == current) to detect\nnotification of changes to the mtime or inode. However, using watch_file for this operation\nis preferred, since it is more reliable and efficient, although in some situations it may not be available.\n\nThis is a thin wrapper over calling wait on a PollingFileWatcher, which implements\nthe functionality, but this function has a small race window between consecutive calls to\npoll_file where the file might change without being detected.\n\n\n\n\n\n"},{"title":"FileWatching.watch_file","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.watch_file","category":"function","text":"watch_file(path::AbstractString, timeout_s::Real=-1)\n\nWatch file or directory path for changes until a change occurs or timeout_s seconds have\nelapsed. This function does not poll the file system and instead uses platform-specific\nfunctionality to receive notifications from the operating system (e.g. via inotify on Linux).\nSee the NodeJS documentation linked below for details.\n\nThe returned value is an object with boolean fields renamed, changed, and timedout,\ngiving the result of watching the file.\n\nThis behavior of this function varies slightly across platforms. See\nhttps://nodejs.org/api/fs.html#fs_caveats for more detailed information.\n\nThis is a thin wrapper over calling wait on a FileMonitor. This function has a\nsmall race window between consecutive calls to watch_file where the file might change\nwithout being detected. To avoid this race, use\n\nfm = FileMonitor(path)\nwait(fm)\n\ndirectly, re-using the same fm each time you wait.\n\n\n\n\n\n"},{"title":"FileWatching.watch_folder","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.watch_folder","category":"function","text":"watch_folder(path::AbstractString, timeout_s::Real=-1)\n\nWatch a file or directory path for changes until a change has occurred or timeout_s\nseconds have elapsed. This function does not poll the file system and instead uses platform-specific\nfunctionality to receive notifications from the operating system (e.g. via inotify on Linux).\nSee the NodeJS documentation linked below for details.\n\nThis will continuing tracking changes for path in the background until\nunwatch_folder is called on the same path.\n\nThe returned value is an pair where the first field is the name of the changed file (if available)\nand the second field is an object with boolean fields renamed, changed, and timedout,\ngiving the event.\n\nThis behavior of this function varies slightly across platforms. See\nhttps://nodejs.org/api/fs.html#fs_caveats for more detailed information.\n\nThis function is a thin wrapper over calling wait on a FolderMonitor, with added timeout support.\n\n\n\n\n\n"},{"title":"FileWatching.unwatch_folder","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.unwatch_folder","category":"function","text":"unwatch_folder(path::AbstractString)\n\nStop background tracking of changes for path.\nIt is not recommended to do this while another task is waiting for\nwatch_folder to return on the same path, as the result may be unpredictable.\n\n\n\n\n\n"},{"title":"FileWatching.FileMonitor","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.FileMonitor","category":"type","text":"FileMonitor(path::AbstractString)\n\nWatch file or directory path (which must exist) for changes until a change occurs. This\nfunction does not poll the file system and instead uses platform-specific functionality to\nreceive notifications from the operating system (e.g. via inotify on Linux). See the NodeJS\ndocumentation linked below for details.\n\nfm = FileMonitor(path) acts like an auto-reset Event, so wait(fm) blocks until there has\nbeen at least one event in the file originally at the given path and then returns an object\nwith boolean fields renamed, changed, timedout summarizing all changes that have\noccurred since the last call to wait returned.\n\nThis behavior of this function varies slightly across platforms. See\nhttps://nodejs.org/api/fs.html#fs_caveats for more detailed information.\n\n\n\n\n\n"},{"title":"FileWatching.FolderMonitor","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.FolderMonitor","category":"type","text":"FolderMonitor(folder::AbstractString)\n\nWatch a file or directory path for changes until a change has occurred. This function does\nnot poll the file system and instead uses platform-specific functionality to receive\nnotifications from the operating system (e.g. via inotify on Linux). See the NodeJS\ndocumentation linked below for details.\n\nThis acts similar to a Channel, so calling take! (or wait) blocks until some change has\noccurred. The wait function will return a pair where the first field is the name of the\nchanged file (if available) and the second field is an object with boolean fields renamed\nand changed, giving the event that occurred on it.\n\nThis behavior of this function varies slightly across platforms. See\nhttps://nodejs.org/api/fs.html#fs_caveats for more detailed information.\n\n\n\n\n\n"},{"title":"FileWatching.PollingFileWatcher","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.PollingFileWatcher","category":"type","text":"PollingFileWatcher(path::AbstractString, interval_s::Real=5.007)\n\nMonitor a file for changes by polling stat every interval_s seconds until a change\noccurs or timeout_s seconds have elapsed. The interval_s should be a long period; the\ndefault is 5.007 seconds. Call stat on it to get the most recent, but old, result.\n\nThis acts like an auto-reset Event, so calling wait blocks until the stat result has\nchanged since the previous value captured upon entry to the wait call. The wait function\nwill return a pair of status objects (previous, current) once any stat change is\ndetected since the previous time that wait was called. The previous status is always a\nStatStruct, but it may have all of the fields zeroed (indicating the file didn't\npreviously exist, or wasn't previously accessible).\n\nThe current status object may be a StatStruct, an EOFError (if the wait is canceled by\nclosing this object), or some other Exception subtype (if the stat operation failed: for\nexample, if the path is removed). Note that stat value may be outdated if the file has\nchanged again multiple times.\n\nUsing FileMonitor for this operation is preferred, since it is more reliable and\nefficient, although in some situations it may not be available.\n\n\n\n\n\n"},{"title":"FileWatching.FDWatcher","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.FDWatcher","category":"type","text":"FDWatcher(fd::Union{RawFD,WindowsRawSocket}, readable::Bool, writable::Bool)\n\nMonitor a file descriptor fd for changes in the read or write availability.\n\nThe keyword arguments determine which of read and/or write status should be monitored; at\nleast one of them must be set to true.\n\nThe returned value is an object with boolean fields readable, writable, and timedout,\ngiving the result of the polling.\n\nThis acts like a level-set event, so calling wait blocks until one of those conditions is\nmet, but then continues to return without blocking until the condition is cleared (either\nthere is no more to read, or no more space in the write buffer, or both).\n\nwarning: Warning\nYou must call close manually, when finished with this object, before the fd\nargument is closed. Failure to do so risks serious crashes.\n\n\n\n\n\n"},{"title":"FileWatching.Pidfile.mkpidlock","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.Pidfile.mkpidlock","category":"function","text":"mkpidlock([f::Function], at::String, [pid::Cint]; kwopts...)\nmkpidlock(at::String, proc::Process; kwopts...)\n\nCreate a pidfile lock for the path \"at\" for the current process\nor the process identified by pid or proc. Can take a function to execute once locked,\nfor usage in do blocks, after which the lock will be automatically closed. If the lock fails\nand wait is false, then an error is thrown.\n\nThe lock will be released by either close, a finalizer, or shortly after proc exits.\nMake sure the return value is live through the end of the critical section of\nyour program, so the finalizer does not reclaim it early.\n\nOptional keyword arguments:\n\nmode: file access mode (modified by the process umask). Defaults to world-readable.\npoll_interval: Specify the maximum time to between attempts (if watch_file doesn't work)\nstale_age: Delete an existing pidfile (ignoring the lock) if it is older than this many seconds, based on its mtime.\n  The file won't be deleted until 5x longer than this if the pid in the file appears that it may be valid.\n  Or 25x longer if refresh is overridden to 0 to disable lock refreshing.\n  By default this is disabled (stale_age = 0), but a typical recommended value would be about 3-5x an\n  estimated normal completion time.\nrefresh: Keeps a lock from becoming stale by updating the mtime every interval of time that passes.\n  By default, this is set to stale_age/2, which is the recommended value.\nwait: If true, block until we get the lock, if false, raise error if lock fails.\n\n\n\n\n\n"},{"title":"FileWatching.Pidfile.trymkpidlock","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.Pidfile.trymkpidlock","category":"function","text":"trymkpidlock([f::Function], at::String, [pid::Cint]; kwopts...)\ntrymkpidlock(at::String, proc::Process; kwopts...)\n\nLike mkpidlock except returns false instead of waiting if the file is already locked.\n\ncompat: Julia 1.10\nThis function requires at least Julia 1.10.\n\n\n\n\n\n"},{"title":"Base.close","page":"File Events","location":"stdlib/FileWatching.html#Base.close-Tuple{FileWatching.Pidfile.LockMonitor}","category":"method","text":"close(lock::LockMonitor)\n\nRelease a pidfile lock.\n\n\n\n\n\n"},{"title":"FileWatching.Pidfile.open_exclusive","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.Pidfile.open_exclusive","category":"function","text":"open_exclusive(path::String; mode, poll_interval, wait, stale_age, refresh) :: File\n\nCreate a new a file for read-write advisory-exclusive access.\nIf wait is false then error out if the lock files exist\notherwise block until we get the lock.\n\nFor a description of the keyword arguments, see mkpidlock.\n\n\n\n\n\n"},{"title":"FileWatching.Pidfile.tryopen_exclusive","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.Pidfile.tryopen_exclusive","category":"function","text":"tryopen_exclusive(path::String, mode::Integer = 0o444) :: Union{Void, File}\n\nTry to create a new file for read-write advisory-exclusive access,\nreturn nothing if it already exists.\n\n\n\n\n\n"},{"title":"FileWatching.Pidfile.write_pidfile","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.Pidfile.write_pidfile","category":"function","text":"write_pidfile(io, pid)\n\nWrite our pidfile format to an open IO descriptor.\n\n\n\n\n\n"},{"title":"FileWatching.Pidfile.parse_pidfile","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.Pidfile.parse_pidfile","category":"function","text":"parse_pidfile(file::Union{IO, String}) => (pid, hostname, age)\n\nAttempt to parse our pidfile format,\nreplaced an element with (0, \"\", 0.0), respectively, for any read that failed.\n\n\n\n\n\n"},{"title":"FileWatching.Pidfile.stale_pidfile","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.Pidfile.stale_pidfile","category":"function","text":"stale_pidfile(path::String, stale_age::Real, refresh::Real) :: Bool\n\nHelper function for open_exclusive for deciding if a pidfile is stale.\n\n\n\n\n\n"},{"title":"FileWatching.Pidfile.isvalidpid","page":"File Events","location":"stdlib/FileWatching.html#FileWatching.Pidfile.isvalidpid","category":"function","text":"isvalidpid(hostname::String, pid::Cuint) :: Bool\n\nAttempt to conservatively estimate whether pid is a valid process id.\n\n\n\n\n\n"},{"title":"Base.Filesystem.touch","page":"File Events","location":"stdlib/FileWatching.html#Base.Filesystem.touch-Tuple{FileWatching.Pidfile.LockMonitor}","category":"method","text":"Base.touch(::Pidfile.LockMonitor)\n\nUpdate the mtime on the lock, to indicate it is still fresh.\n\nSee also the refresh keyword in the mkpidlock constructor.\n\n\n\n\n\n"},{"title":"Static analyzer annotations for GC correctness in C code","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#Static-analyzer-annotations-for-GC-correctness-in-C-code","category":"section","text":""},{"title":"Running the analysis","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#Running-the-analysis","category":"section","text":"The analyzer plugin that drives the analysis ships with julia. Its\nsource code can be found in src/clangsa. Running it requires\nthe clang dependency to be build. Set the BUILD_LLVM_CLANG variable\nin your Make.user in order to build an appropriate version of clang.\nYou may also want to use the prebuilt binaries using the\nUSE_BINARYBUILDER_LLVM options.\n\nAlternatively (or if these do not suffice), try\n\nmake -C src install-analysis-deps\n\nfrom Julia's toplevel directory.\n\nAfterwards, running the analysis over the source tree is as simple as running make -C src analyzegc."},{"title":"General Overview","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#General-Overview","category":"section","text":"Since Julia's GC is precise, it needs to maintain correct rooting\ninformation for any value that may be referenced at any time GC\nmay occur. These places are known as safepoints and in the\nfunction local context, we extend this designation to any function\ncall that may recursively end up at a safepoint.\n\nIn generated code, this is taken care of automatically by the GC\nroot placement pass (see the chapter on GC rooting in the LLVM\ncodegen devdocs). However, in C code, we need to inform the runtime\nof any GC roots manually. This is done using the following macros:\n\n// The value assigned to any slot passed as an argument to these\n// is rooted for the duration of this GC frame.\nJL_GC_PUSH{1,...,6}(args...)\n// The values assigned into the size `n` array `rts` are rooted\n// for the duration of this GC frame.\nJL_GC_PUSHARGS(rts, n)\n// Pop a GC frame\nJL_GC_POP\n\nIf these macros are not used where they need to be, or they are used\nincorrectly, the result is silent memory corruption. As such it\nis very important that they are placed correctly in all applicable\ncode.\n\nAs such, we employ static analysis (and in particular the clang static\nanalyzer) to help ensure that these macros\nare used correctly. The remainder of this document gives an overview\nof this static analysis and describes the support needed in the julia\ncode base to make things work."},{"title":"GC Invariants","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#GC-Invariants","category":"section","text":"There are two simple invariants for correctness:\n\nAll GC_PUSH calls need to be followed by an appropriate GC_POP (in practice we enforce this\nat the function level)\nIf a value was previously not rooted at any safepoint, it may no longer be referenced\nafterwards\n\nOf course the devil is in the details here. In particular to satisfy the second of the above\nconditions, we need to know:\n\nWhich calls are safepoints and which are not\nWhich values are rooted at any given safepoint and which are not\nWhen is a value referenced\n\nFor the second point in particular, we need to know which memory locations will be considered\nrooting at runtime (i.e. values assigned to such locations are rooted). This includes locations\nexplicitly designated as such by passing them to one of the GC_PUSH macros, globally rooted\nlocations and values, as well as any location recursively reachable from one of those locations."},{"title":"Static Analysis Algorithm","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#Static-Analysis-Algorithm","category":"section","text":"The idea itself is very simple, although the implementation is quite a bit more complicated\n(mainly due to a large number of special cases and intricacies of C and C++). In essence,\nwe keep track of all locations that are rooting, all values that are rootable and any\nexpression (assignments, allocations, etc) affect the rootedness of any rootable values.\nThen, at any safepoint, we perform a \"symbolic GC\" and poison any values that are not rooted\nat said location. If these values are later referenced, we emit an error.\n\nThe clang static analyzer works by constructing a graph of states and exploring this graph\nfor sources of errors. Several nodes in this graph are generated by the analyzer itself\n(e.g. for control flow), but the definitions above augment this graph with our own state.\n\nThe static analyzer is interprocedural and can analyze control flow across function boundaries.\nHowever, the static analyzer is not fully recursive and makes heuristic decisions about which\ncalls to explore (additionally some calls are cross-translation unit and invisible to the analyzer).\nIn our case, our definition of correctness requires total information.\nAs such, we need to annotate\nthe prototypes of all function calls with whatever information the analysis required,\neven if that information would otherwise be available by interprocedural static analysis.\n\nLuckily however, we can still use this interprocedural analysis to ensure that the annotations\nwe place on a given function are indeed correct given the implementation of said function."},{"title":"The analyzer annotations","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#The-analyzer-annotations","category":"section","text":"These annotations are found in src/support/analyzer_annotations.h.\nThey are only active when the analyzer is being used and expand either\nto nothing (for prototype annotations) or to no-ops (for function like annotations)."},{"title":"JL_NOTSAFEPOINT","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#JL_NOTSAFEPOINT","category":"section","text":"This is perhaps the most common annotation, and should be placed on any function\nthat is known not to possibly lead to reaching a GC safepoint. In general, it is\nonly safe for such a function to perform arithmetic, memory accesses and calls to\nfunctions either annotated JL_NOTSAFEPOINT or otherwise known not to be safepoints (e.g.\nfunction in the C standard library, which are hardcoded as such in the analyzer)\n\nIt is valid to keep values unrooted across calls to any function annotated with this\nattribute:\n\nUsage Example:\n\nvoid jl_get_one() JL_NOTSAFEPOINT {\n  return 1;\n}\n\njl_value_t *example() {\n  jl_value_t *val = jl_alloc_whatever();\n  // This is valid, even though `val` is unrooted, because\n  // jl_get_one is not a safepoint\n  jl_get_one();\n  return val;\n}"},{"title":"JL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#JL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY","category":"section","text":"When JL_MAYBE_UNROOTED is annotated as an argument on a function,\nindicates that said argument may be passed, even if it is not rooted.\nIn the ordinary course of events,\nthe julia ABI guarantees that callers root values before passing them to\ncallees. However, some functions do not follow this ABI and allow values\nto be passed to them even though they are not rooted. Note however, that\nthis does not automatically imply that said argument will be preserved.\nThe ROOTS_TEMPORARILY annotation provides the stronger guarantee that,\nnot only may the value be unrooted when passed, it will also be preserved\nacross any internal safepoints by the callee.\n\nNote that JL_NOTSAFEPOINT essentially implies JL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY,\nbecause the rootedness of an argument is irrelevant if the function contains\nno safepoints.\n\nOne additional point to note is that these annotations apply on both the\ncaller and the callee side. On the caller side, they lift rootedness\nrestrictions that are normally required for julia ABI functions. On\nthe callee side, they have the reverse effect of preventing these arguments\nfrom being considered implicitly rooted.\n\nIf either of these annotations is applied to the function as a whole, it applies\nto all arguments of the function. This should generally only be necessary for\nvarargs functions.\n\nUsage example:\n\nJL_DLLEXPORT void JL_NORETURN jl_throw(jl_value_t *e JL_MAYBE_UNROOTED);\njl_value_t *jl_alloc_error();\n\nvoid example() {\n  // The return value of the allocation is unrooted. This would normally\n  // be an error, but is allowed because of the above annotation.\n  jl_throw(jl_alloc_error());\n}"},{"title":"JL_PROPAGATES_ROOT","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#JL_PROPAGATES_ROOT","category":"section","text":"This annotation is commonly found on accessor functions that return one rootable\nobject stored within another. When annotated on a function argument, it tells\nthe analyzer that the root for that argument also applies to the value returned\nby the function.\n\nUsage Example:\n\njl_value_t *jl_svecref(jl_svec_t *t JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;\n\nsize_t example(jl_svec_t *svec) {\n  jl_value_t *val = jl_svecref(svec, 1)\n  // This is valid, because, as annotated by the PROPAGATES_ROOT annotation,\n  // jl_svecref propagates the rooted-ness from `svec` to `val`\n  jl_gc_safepoint();\n  return jl_unbox_long(val);\n}"},{"title":"JL_ROOTING_ARGUMENT/JL_ROOTED_ARGUMENT","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#JL_ROOTING_ARGUMENT/JL_ROOTED_ARGUMENT","category":"section","text":"This is essentially the assignment counterpart to JL_PROPAGATES_ROOT.\nWhen assigning a value to a field of another value that is already rooted,\nthe assigned value will inherit the root of the value it is assigned into.\n\nUsage Example:\n\nvoid jl_svecset(void *t JL_ROOTING_ARGUMENT, size_t i, void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT\n\n\nsize_t example(jl_svec_t *svec) {\n  jl_value_t *val = jl_box_long(10000);\n  jl_svecset(svec, val);\n  // This is valid, because the annotations imply that the\n  // jl_svecset propagates the rooted-ness from `svec` to `val`\n  jl_gc_safepoint();\n  return jl_unbox_long(val);\n}"},{"title":"JL_GC_DISABLED","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#JL_GC_DISABLED","category":"section","text":"This annotation implies that this function is only called with the GC runtime-disabled.\nFunctions of this kind are most often encountered during startup and in the GC code itself.\nNote that this annotation is checked against the runtime enable/disable calls, so clang will\nknow if you lie. This is not a good way to disable processing of a given function if the\nGC is not actually disabled (use ifdef __clang_analyzer__ for that if you must).\n\nUsage example:\n\nvoid jl_do_magic() JL_GC_DISABLED {\n  // Wildly allocate here with no regard for roots\n}\n\nvoid example() {\n  int en = jl_gc_enable(0);\n  jl_do_magic();\n  jl_gc_enable(en);\n}"},{"title":"JL_REQUIRE_ROOTED_SLOT","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#JL_REQUIRE_ROOTED_SLOT","category":"section","text":"This annotation requires the caller to pass in a slot that is rooted (i.e. values assigned\nto this slot will be rooted).\n\nUsage example:\n\nvoid jl_do_processing(jl_value_t **slot JL_REQUIRE_ROOTED_SLOT) {\n  *slot = jl_box_long(1);\n  // Ok, only, because the slot was annotated as rooting\n  jl_gc_safepoint();\n}\n\nvoid example() {\n  jl_value_t *slot = NULL;\n  JL_GC_PUSH1(&slot);\n  jl_do_processing(&slot);\n  JL_GC_POP();\n}"},{"title":"JL_GLOBALLY_ROOTED","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#JL_GLOBALLY_ROOTED","category":"section","text":"This annotation implies that a given value is always globally rooted.\nIt can be applied to global variable declarations, in which case it\nwill apply to the value of those variables (or values if the declaration\nif for an array), or to functions, in which case it will apply to the\nreturn value of such functions (e.g. for functions that always return\nsome private, globally rooted value).\n\nUsage example:\n\nextern JL_DLLEXPORT jl_datatype_t *jl_any_type JL_GLOBALLY_ROOTED;\njl_ast_context_t *jl_ast_ctx(fl_context_t *fl) JL_GLOBALLY_ROOTED;"},{"title":"JL_ALWAYS_LEAFTYPE","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#JL_ALWAYS_LEAFTYPE","category":"section","text":"This annotations is essentially equivalent to JL_GLOBALLY_ROOTED, except that\nis should only be used if those values are globally rooted by virtue of being\na leaftype. The rooting of leaftypes is a bit complicated. They are generally\nrooted through cache field of the corresponding TypeName, which itself is\nrooted by the containing module (so they're rooted as long as the containing\nmodule is ok) and we can generally assume that leaftypes are rooted where they\nare used, but we may refine this property in the future, so the separate\nannotation helps split out the reason for being globally rooted.\n\nThe analyzer also automatically detects checks for leaftype-ness and will not\ncomplain about missing GC roots on these paths.\n\nJL_DLLEXPORT jl_value_t *jl_apply_array_type(jl_value_t *type, size_t dim) JL_ALWAYS_LEAFTYPE;"},{"title":"JL_GC_PROMISE_ROOTED","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#JL_GC_PROMISE_ROOTED","category":"section","text":"This is a function-like annotation. Any value passed to this annotation will be considered\nrooted for the scope of the current function. It is designed as an escape hatch\nfor analyzer inadequacy or complicated situations. However, it should be used sparingly,\nin favor of improving the analyzer itself.\n\nvoid example() {\n  jl_value_t *val = jl_alloc_something();\n  if (some_condition) {\n    // We happen to know for complicated external reasons\n    // that val is rooted under these conditions\n    JL_GC_PROMISE_ROOTED(val);\n  }\n}"},{"title":"Completeness of analysis","page":"Static analyzer annotations for GC correctness in C code","location":"devdocs/gc-sa.html#Completeness-of-analysis","category":"section","text":"The analyzer only looks at local information. In particular, e.g. in the PROPAGATES_ROOT case\nabove, it assumes that such memory is only modified in ways it can see, not in any called\nfunctions (unless it happens to decide to consider them in its analysis) and not in any concurrently\nrunning threads. As such, it may miss a few problematic cases, though in practice such concurrent\nmodification is fairly rare. Improving the analyzer to handle more such cases may be an interesting\ntopic for future work."},{"title":"Statistics","page":"Statistics","location":"stdlib/Statistics.html#Statistics","category":"section","text":"The Statistics standard library module contains basic statistics functionality."},{"title":"Statistics.std","page":"Statistics","location":"stdlib/Statistics.html#Statistics.std","category":"function","text":"std(itr; corrected::Bool=true, mean=nothing[, dims])\n\nCompute the sample standard deviation of collection itr.\n\nThe algorithm returns an estimator of the generative distribution's standard\ndeviation under the assumption that each entry of itr is a sample drawn from\nthe same unknown distribution, with the samples uncorrelated.\nFor arrays, this computation is equivalent to calculating\nsqrt.(sum(abs2.(itr .- mean(itr))) / (length(itr) - 1)).\nIf corrected is true, then the sum is scaled with n-1,\nwhereas the sum is scaled with n if corrected is\nfalse with n the number of elements in itr.\n\nIf itr is an AbstractArray, dims can be provided to compute the standard deviation\nover dimensions.\n\nA pre-computed mean may be provided. When dims is specified, mean must be\nan array with the same shape as mean(itr, dims=dims) (additional trailing\nsingleton dimensions are allowed).\n\nnote: Note\nIf array contains NaN or missing values, the result is also\nNaN or missing (missing takes precedence if array contains both).\nUse the skipmissing function to omit missing entries and compute the\nstandard deviation of non-missing values.\n\n\n\n\n\n"},{"title":"Statistics.stdm","page":"Statistics","location":"stdlib/Statistics.html#Statistics.stdm","category":"function","text":"stdm(itr, mean; corrected::Bool=true[, dims])\n\nCompute the sample standard deviation of collection itr, with known mean(s) mean.\n\nThe algorithm returns an estimator of the generative distribution's standard\ndeviation under the assumption that each entry of itr is a sample drawn from\nthe same unknown distribution, with the samples uncorrelated.\nFor arrays, this computation is equivalent to calculating\nsqrt.(sum(abs2.(itr .- mean(itr))) / (length(itr) - 1)).\nIf corrected is true, then the sum is scaled with n-1,\nwhereas the sum is scaled with n if corrected is\nfalse with n the number of elements in itr.\n\nIf itr is an AbstractArray, dims can be provided to compute the standard deviation\nover dimensions. In that case, mean must be an array with the same shape as\nmean(itr, dims=dims) (additional trailing singleton dimensions are allowed).\n\nnote: Note\nIf array contains NaN or missing values, the result is also\nNaN or missing (missing takes precedence if array contains both).\nUse the skipmissing function to omit missing entries and compute the\nstandard deviation of non-missing values.\n\n\n\n\n\n"},{"title":"Statistics.var","page":"Statistics","location":"stdlib/Statistics.html#Statistics.var","category":"function","text":"var(itr; corrected::Bool=true, mean=nothing[, dims])\n\nCompute the sample variance of collection itr.\n\nThe algorithm returns an estimator of the generative distribution's variance\nunder the assumption that each entry of itr is a sample drawn from the same\nunknown distribution, with the samples uncorrelated.\nFor arrays, this computation is equivalent to calculating\nsum(abs2.(itr .- mean(itr))) / (length(itr) - 1).\nIf corrected is true, then the sum is scaled with n-1,\nwhereas the sum is scaled with n if corrected is\nfalse where n is the number of elements in itr.\n\nIf itr is an AbstractArray, dims can be provided to compute the variance\nover dimensions.\n\nA pre-computed mean may be provided. When dims is specified, mean must be\nan array with the same shape as mean(itr, dims=dims) (additional trailing\nsingleton dimensions are allowed).\n\nnote: Note\nIf array contains NaN or missing values, the result is also\nNaN or missing (missing takes precedence if array contains both).\nUse the skipmissing function to omit missing entries and compute the\nvariance of non-missing values.\n\n\n\n\n\n"},{"title":"Statistics.varm","page":"Statistics","location":"stdlib/Statistics.html#Statistics.varm","category":"function","text":"varm(itr, mean; dims, corrected::Bool=true)\n\nCompute the sample variance of collection itr, with known mean(s) mean.\n\nThe algorithm returns an estimator of the generative distribution's variance\nunder the assumption that each entry of itr is a sample drawn from the same\nunknown distribution, with the samples uncorrelated.\nFor arrays, this computation is equivalent to calculating\nsum(abs2.(itr .- mean(itr))) / (length(itr) - 1).\nIf corrected is true, then the sum is scaled with n-1,\nwhereas the sum is scaled with n if corrected is\nfalse with n the number of elements in itr.\n\nIf itr is an AbstractArray, dims can be provided to compute the variance\nover dimensions. In that case, mean must be an array with the same shape as\nmean(itr, dims=dims) (additional trailing singleton dimensions are allowed).\n\nnote: Note\nIf array contains NaN or missing values, the result is also\nNaN or missing (missing takes precedence if array contains both).\nUse the skipmissing function to omit missing entries and compute the\nvariance of non-missing values.\n\n\n\n\n\n"},{"title":"Statistics.cor","page":"Statistics","location":"stdlib/Statistics.html#Statistics.cor","category":"function","text":"cor(x::AbstractVector)\n\nReturn the number one.\n\n\n\n\n\ncor(X::AbstractMatrix; dims::Int=1)\n\nCompute the Pearson correlation matrix of the matrix X along the dimension dims.\n\n\n\n\n\ncor(x::AbstractVector, y::AbstractVector)\n\nCompute the Pearson correlation between the vectors x and y.\n\n\n\n\n\ncor(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims=1)\n\nCompute the Pearson correlation between the vectors or matrices X and Y along the dimension dims.\n\n\n\n\n\n"},{"title":"Statistics.cov","page":"Statistics","location":"stdlib/Statistics.html#Statistics.cov","category":"function","text":"cov(x::AbstractVector; corrected::Bool=true)\n\nCompute the variance of the vector x. If corrected is true (the default) then the sum\nis scaled with n-1, whereas the sum is scaled with n if corrected is false where n = length(x).\n\n\n\n\n\ncov(X::AbstractMatrix; dims::Int=1, corrected::Bool=true)\n\nCompute the covariance matrix of the matrix X along the dimension dims. If corrected\nis true (the default) then the sum is scaled with n-1, whereas the sum is scaled with n\nif corrected is false where n = size(X, dims).\n\n\n\n\n\ncov(x::AbstractVector, y::AbstractVector; corrected::Bool=true)\n\nCompute the covariance between the vectors x and y. If corrected is true (the\ndefault), computes frac1n-1sum_i=1^n (x_i-bar x) (y_i-bar y)^* where\n* denotes the complex conjugate and n = length(x) = length(y). If corrected is\nfalse, computes frac1nsum_i=1^n (x_i-bar x) (y_i-bar y)^*.\n\n\n\n\n\ncov(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims::Int=1, corrected::Bool=true)\n\nCompute the covariance between the vectors or matrices X and Y along the dimension\ndims. If corrected is true (the default) then the sum is scaled with n-1, whereas\nthe sum is scaled with n if corrected is false where n = size(X, dims) = size(Y, dims).\n\n\n\n\n\n"},{"title":"Statistics.mean!","page":"Statistics","location":"stdlib/Statistics.html#Statistics.mean!","category":"function","text":"mean!(r, v)\n\nCompute the mean of v over the singleton dimensions of r, and write results to r.\nNote that the target must not alias with the source.\n\nExamples\n\njulia> using Statistics\n\njulia> v = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> mean!([1., 1.], v)\n2-element Vector{Float64}:\n 1.5\n 3.5\n\njulia> mean!([1. 1.], v)\n1×2 Matrix{Float64}:\n 2.0  3.0\n\n\n\n\n\n"},{"title":"Statistics.mean","page":"Statistics","location":"stdlib/Statistics.html#Statistics.mean","category":"function","text":"mean(itr)\n\nCompute the mean of all elements in a collection.\n\nnote: Note\nIf itr contains NaN or missing values, the result is also\nNaN or missing (missing takes precedence if array contains both).\nUse the skipmissing function to omit missing entries and compute the\nmean of non-missing values.\n\nExamples\n\njulia> using Statistics\n\njulia> mean(1:20)\n10.5\n\njulia> mean([1, missing, 3])\nmissing\n\njulia> mean(skipmissing([1, missing, 3]))\n2.0\n\n\n\n\n\nmean(f, itr)\n\nApply the function f to each element of collection itr and take the mean.\n\njulia> using Statistics\n\njulia> mean(√, [1, 2, 3])\n1.3820881233139908\n\njulia> mean([√1, √2, √3])\n1.3820881233139908\n\n\n\n\n\nmean(f, A::AbstractArray; dims)\n\nApply the function f to each element of array A and take the mean over dimensions dims.\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\njulia> using Statistics\n\njulia> mean(√, [1, 2, 3])\n1.3820881233139908\n\njulia> mean([√1, √2, √3])\n1.3820881233139908\n\njulia> mean(√, [1 2 3; 4 5 6], dims=2)\n2×1 Matrix{Float64}:\n 1.3820881233139908\n 2.2285192400943226\n\n\n\n\n\nmean(A::AbstractArray; dims)\n\nCompute the mean of an array over the given dimensions.\n\ncompat: Julia 1.1\nmean for empty arrays requires at least Julia 1.1.\n\nExamples\n\njulia> using Statistics\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> mean(A, dims=1)\n1×2 Matrix{Float64}:\n 2.0  3.0\n\njulia> mean(A, dims=2)\n2×1 Matrix{Float64}:\n 1.5\n 3.5\n\n\n\n\n\n"},{"title":"Statistics.median!","page":"Statistics","location":"stdlib/Statistics.html#Statistics.median!","category":"function","text":"median!(v)\n\nLike median, but may overwrite the input vector.\n\n\n\n\n\n"},{"title":"Statistics.median","page":"Statistics","location":"stdlib/Statistics.html#Statistics.median","category":"function","text":"median(itr)\n\nCompute the median of all elements in a collection.\nFor an even number of elements no exact median element exists, so the result is\nequivalent to calculating mean of two median elements.\n\nnote: Note\nIf itr contains NaN or missing values, the result is also\nNaN or missing (missing takes precedence if itr contains both).\nUse the skipmissing function to omit missing entries and compute the\nmedian of non-missing values.\n\nExamples\n\njulia> using Statistics\n\njulia> median([1, 2, 3])\n2.0\n\njulia> median([1, 2, 3, 4])\n2.5\n\njulia> median([1, 2, missing, 4])\nmissing\n\njulia> median(skipmissing([1, 2, missing, 4]))\n2.0\n\n\n\n\n\nmedian(A::AbstractArray; dims)\n\nCompute the median of an array along the given dimensions.\n\nExamples\n\njulia> using Statistics\n\njulia> median([1 2; 3 4], dims=1)\n1×2 Matrix{Float64}:\n 2.0  3.0\n\n\n\n\n\nmedian(f, v)\n\nApply the function f to each element of collection v\nand then compute the median.\n\njulia> using Statistics\n\njulia> median(√, [1, 3, 2])\n1.4142135623730951\n\njulia> median([√1, √3, √2])\n1.4142135623730951\n\n\n\n\n\n"},{"title":"Statistics.middle","page":"Statistics","location":"stdlib/Statistics.html#Statistics.middle","category":"function","text":"middle(x)\n\nCompute the middle of a scalar value, which is equivalent to x itself, but of the type of middle(x, x) for consistency.\n\n\n\n\n\nmiddle(x, y)\n\nCompute the middle of two numbers x and y, which is\nequivalent in both value and type to computing their mean ((x + y) / 2).\n\n\n\n\n\nmiddle(a::AbstractArray)\n\nCompute the middle of an array a, which consists of finding its\nextrema and then computing their mean.\n\njulia> using Statistics\n\njulia> middle(1:10)\n5.5\n\njulia> a = [1,2,3.6,10.9]\n4-element Vector{Float64}:\n  1.0\n  2.0\n  3.6\n 10.9\n\njulia> middle(a)\n5.95\n\n\n\n\n\n"},{"title":"Statistics.quantile!","page":"Statistics","location":"stdlib/Statistics.html#Statistics.quantile!","category":"function","text":"quantile!([q::AbstractArray, ] v::AbstractVector, p; sorted=false, alpha::Real=1.0, beta::Real=alpha)\n\nCompute the quantile(s) of a vector v at a specified probability or vector or tuple of\nprobabilities p on the interval [0,1]. If p is a vector, an optional\noutput array q may also be specified. (If not provided, a new output array is created.)\nThe keyword argument sorted indicates whether v can be assumed to be sorted; if\nfalse (the default), then the elements of v will be partially sorted in-place.\n\nSamples quantile are defined by Q(p) = (1-γ)*x[j] + γ*x[j+1],\nwhere x[j] is the j-th order statistic of v, j = floor(n*p + m),\nm = alpha + p*(1 - alpha - beta) and γ = n*p + m - j.\n\nBy default (alpha = beta = 1), quantiles are computed via linear interpolation between the points\n((k-1)/(n-1), x[k]), for k = 1:n where n = length(v). This corresponds to Definition 7\nof Hyndman and Fan (1996), and is the same as the R and NumPy default.\n\nThe keyword arguments alpha and beta correspond to the same parameters in Hyndman and Fan,\nsetting them to different values allows to calculate quantiles with any of the methods 4-9\ndefined in this paper:\n\nDef. 4: alpha=0, beta=1\nDef. 5: alpha=0.5, beta=0.5 (MATLAB default)\nDef. 6: alpha=0, beta=0 (Excel PERCENTILE.EXC, Python default, Stata altdef)\nDef. 7: alpha=1, beta=1 (Julia, R and NumPy default, Excel PERCENTILE and PERCENTILE.INC, Python 'inclusive')\nDef. 8: alpha=1/3, beta=1/3\nDef. 9: alpha=3/8, beta=3/8\n\nnote: Note\nAn ArgumentError is thrown if v contains NaN or missing values.\n\nReferences\n\nHyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\",\nThe American Statistician, Vol. 50, No. 4, pp. 361-365\nQuantile on Wikipedia details the different quantile definitions\n\nExamples\n\njulia> using Statistics\n\njulia> x = [3, 2, 1];\n\njulia> quantile!(x, 0.5)\n2.0\n\njulia> x\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> y = zeros(3);\n\njulia> quantile!(y, x, [0.1, 0.5, 0.9]) === y\ntrue\n\njulia> y\n3-element Vector{Float64}:\n 1.2\n 2.0\n 2.8\n\n\n\n\n\n"},{"title":"Statistics.quantile","page":"Statistics","location":"stdlib/Statistics.html#Statistics.quantile","category":"function","text":"quantile(itr, p; sorted=false, alpha::Real=1.0, beta::Real=alpha)\n\nCompute the quantile(s) of a collection itr at a specified probability or vector or tuple of\nprobabilities p on the interval [0,1]. The keyword argument sorted indicates whether\nitr can be assumed to be sorted.\n\nSamples quantile are defined by Q(p) = (1-γ)*x[j] + γ*x[j+1],\nwhere x[j] is the j-th order statistic of itr, j = floor(n*p + m),\nm = alpha + p*(1 - alpha - beta) and γ = n*p + m - j.\n\nBy default (alpha = beta = 1), quantiles are computed via linear interpolation between the points\n((k-1)/(n-1), x[k]), for k = 1:n where n = length(itr). This corresponds to Definition 7\nof Hyndman and Fan (1996), and is the same as the R and NumPy default.\n\nThe keyword arguments alpha and beta correspond to the same parameters in Hyndman and Fan,\nsetting them to different values allows to calculate quantiles with any of the methods 4-9\ndefined in this paper:\n\nDef. 4: alpha=0, beta=1\nDef. 5: alpha=0.5, beta=0.5 (MATLAB default)\nDef. 6: alpha=0, beta=0 (Excel PERCENTILE.EXC, Python default, Stata altdef)\nDef. 7: alpha=1, beta=1 (Julia, R and NumPy default, Excel PERCENTILE and PERCENTILE.INC, Python 'inclusive')\nDef. 8: alpha=1/3, beta=1/3\nDef. 9: alpha=3/8, beta=3/8\n\nnote: Note\nAn ArgumentError is thrown if v contains NaN or missing values.\nUse the skipmissing function to omit missing entries and compute the\nquantiles of non-missing values.\n\nReferences\n\nHyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\",\nThe American Statistician, Vol. 50, No. 4, pp. 361-365\nQuantile on Wikipedia details the different quantile definitions\n\nExamples\n\njulia> using Statistics\n\njulia> quantile(0:20, 0.5)\n10.0\n\njulia> quantile(0:20, [0.1, 0.5, 0.9])\n3-element Vector{Float64}:\n  2.0\n 10.0\n 18.0\n\njulia> quantile(skipmissing([1, 10, missing]), 0.5)\n5.5\n\n\n\n\n\nquantile(f, v)\n\nApply the function f to each element of collection v\nand then compute the quantile(s) at a specified probability\nor vector or tuple of probabilities p on the interval [0,1].\n\njulia> using Statistics\n\njulia> quantile(√, [1, 3, 2], 0.3)\n1.248528137423857\n\njulia> quantile([√1, √3, √2], 0.3)\n1.248528137423857\n\njulia> quantile(√, [1, 3, 2], (0.3, 0.4, 0.5))\n(1.248528137423857, 1.3313708498984762, 1.4142135623730951)\n\njulia> quantile(.√[1, 3, 2], (0.3, 0.4, 0.5))\n(1.248528137423857, 1.3313708498984762, 1.4142135623730951)\n\n\n\n\n\n"},{"title":"Numbers","page":"Numbers","location":"base/numbers.html#lib-numbers","category":"section","text":""},{"title":"Standard Numeric Types","page":"Numbers","location":"base/numbers.html#Standard-Numeric-Types","category":"section","text":"A type tree for all subtypes of Number in Base is shown below.\nAbstract types have been marked, the rest are concrete types.\n\nNumber  (Abstract Type)\n├─ Complex\n└─ Real  (Abstract Type)\n   ├─ AbstractFloat  (Abstract Type)\n   │  ├─ Float16\n   │  ├─ Float32\n   │  ├─ Float64\n   │  └─ BigFloat\n   ├─ Integer  (Abstract Type)\n   │  ├─ Bool\n   │  ├─ Signed  (Abstract Type)\n   │  │  ├─ Int8\n   │  │  ├─ Int16\n   │  │  ├─ Int32\n   │  │  ├─ Int64\n   │  │  ├─ Int128\n   │  │  └─ BigInt\n   │  └─ Unsigned  (Abstract Type)\n   │     ├─ UInt8\n   │     ├─ UInt16\n   │     ├─ UInt32\n   │     ├─ UInt64\n   │     └─ UInt128\n   ├─ Rational\n   └─ AbstractIrrational  (Abstract Type)\n      └─ Irrational"},{"title":"Abstract number types","page":"Numbers","location":"base/numbers.html#Abstract-number-types","category":"section","text":""},{"title":"Concrete number types","page":"Numbers","location":"base/numbers.html#Concrete-number-types","category":"section","text":""},{"title":"Data Formats","page":"Numbers","location":"base/numbers.html#Data-Formats","category":"section","text":""},{"title":"General Number Functions and Constants","page":"Numbers","location":"base/numbers.html#General-Number-Functions-and-Constants","category":"section","text":""},{"title":"Integers","page":"Numbers","location":"base/numbers.html#Integers","category":"section","text":""},{"title":"BigFloats and BigInts","page":"Numbers","location":"base/numbers.html#BigFloats-and-BigInts","category":"section","text":"The BigFloat and BigInt types implement\narbitrary-precision floating point and integer arithmetic, respectively. For\nBigFloat the GNU MPFR library is used,\nand for BigInt the [GNU Multiple Precision Arithmetic Library (GMP)]\n(https://gmplib.org) is used."},{"title":"Core.Number","page":"Numbers","location":"base/numbers.html#Core.Number","category":"type","text":"Number\n\nAbstract supertype for all number types.\n\n\n\n\n\n"},{"title":"Core.Real","page":"Numbers","location":"base/numbers.html#Core.Real","category":"type","text":"Real <: Number\n\nAbstract supertype for all real numbers.\n\n\n\n\n\n"},{"title":"Core.AbstractFloat","page":"Numbers","location":"base/numbers.html#Core.AbstractFloat","category":"type","text":"AbstractFloat <: Real\n\nAbstract supertype for all floating point numbers.\n\n\n\n\n\n"},{"title":"Core.Integer","page":"Numbers","location":"base/numbers.html#Core.Integer","category":"type","text":"Integer <: Real\n\nAbstract supertype for all integers (e.g. Signed, Unsigned, and Bool).\n\nSee also isinteger, trunc, div.\n\nExamples\n\njulia> 42 isa Integer\ntrue\n\njulia> 1.0 isa Integer\nfalse\n\njulia> isinteger(1.0)\ntrue\n\n\n\n\n\n"},{"title":"Core.Signed","page":"Numbers","location":"base/numbers.html#Core.Signed","category":"type","text":"Signed <: Integer\n\nAbstract supertype for all signed integers.\n\n\n\n\n\n"},{"title":"Core.Unsigned","page":"Numbers","location":"base/numbers.html#Core.Unsigned","category":"type","text":"Unsigned <: Integer\n\nAbstract supertype for all unsigned integers.\n\nBuilt-in unsigned integers are printed in hexadecimal, with prefix 0x,\nand can be entered in the same way.\n\nExamples\n\njulia> typemax(UInt8)\n0xff\n\njulia> Int(0x00d)\n13\n\njulia> unsigned(true)\n0x0000000000000001\n\n\n\n\n\n"},{"title":"Base.AbstractIrrational","page":"Numbers","location":"base/numbers.html#Base.AbstractIrrational","category":"type","text":"AbstractIrrational <: Real\n\nNumber type representing an exact irrational value, which is automatically rounded to the correct precision in\narithmetic operations with other numeric quantities.\n\nSubtypes MyIrrational <: AbstractIrrational should implement at least ==(::MyIrrational, ::MyIrrational),\nhash(x::MyIrrational, h::UInt), and convert(::Type{F}, x::MyIrrational) where {F <: Union{BigFloat,Float32,Float64}}.\n\nIf a subtype is used to represent values that may occasionally be rational (e.g. a square-root type that represents √n\nfor integers n will give a rational result when n is a perfect square), then it should also implement\nisinteger, iszero, isone, and == with Real values (since all of these default to false for\nAbstractIrrational types), as well as defining hash to equal that of the corresponding Rational.\n\n\n\n\n\n"},{"title":"Core.Float16","page":"Numbers","location":"base/numbers.html#Core.Float16","category":"type","text":"Float16 <: AbstractFloat <: Real\n\n16-bit floating point number type (IEEE 754 standard).\nBinary format is 1 sign, 5 exponent, 10 fraction bits.\n\n\n\n\n\n"},{"title":"Core.Float32","page":"Numbers","location":"base/numbers.html#Core.Float32","category":"type","text":"Float32 <: AbstractFloat <: Real\n\n32-bit floating point number type (IEEE 754 standard).\nBinary format is 1 sign, 8 exponent, 23 fraction bits.\n\nThe exponent for scientific notation should be entered as lower-case f,\nthus 2f3 === 2.0f0 * 10^3 === Float32(2_000).\nFor array literals and comprehensions, the element type can be specified before\nthe square brackets: Float32[1,4,9] == Float32[i^2 for i in 1:3].\n\nSee also Inf32, NaN32, Float16, exponent, frexp.\n\n\n\n\n\n"},{"title":"Core.Float64","page":"Numbers","location":"base/numbers.html#Core.Float64","category":"type","text":"Float64 <: AbstractFloat <: Real\n\n64-bit floating point number type (IEEE 754 standard).\nBinary format is 1 sign, 11 exponent, 52 fraction bits.\nSee bitstring, signbit, exponent, frexp,\nand significand to access various bits.\n\nThis is the default for floating point literals, 1.0 isa Float64,\nand for many operations such as 1/2, 2pi, log(2), range(0,90,length=4).\nUnlike integers, this default does not change with Sys.WORD_SIZE.\n\nThe exponent for scientific notation can be entered as e or E,\nthus 2e3 === 2.0E3 === 2.0 * 10^3. Doing so is strongly preferred over\n10^n because integers overflow, thus 2.0 * 10^19 < 0 but 2e19 > 0.\n\nSee also Inf, NaN, floatmax, Float32, Complex.\n\n\n\n\n\n"},{"title":"Base.MPFR.BigFloat","page":"Numbers","location":"base/numbers.html#Base.MPFR.BigFloat","category":"type","text":"BigFloat <: AbstractFloat\n\nArbitrary precision floating point number type.\n\n\n\n\n\n"},{"title":"Core.Bool","page":"Numbers","location":"base/numbers.html#Core.Bool","category":"type","text":"Bool <: Integer\n\nBoolean type, containing the values true and false.\n\nBool is a kind of number: false is numerically\nequal to 0 and true is numerically equal to 1.\nMoreover, false acts as a multiplicative \"strong zero\"\nagainst NaN and Inf:\n\njulia> [true, false] == [1, 0]\ntrue\n\njulia> 42.0 + true\n43.0\n\njulia> 0 .* (NaN, Inf, -Inf)\n(NaN, NaN, NaN)\n\njulia> false .* (NaN, Inf, -Inf)\n(0.0, 0.0, -0.0)\n\nBranches via if and other conditionals only accept Bool.\nThere are no \"truthy\" values in Julia.\n\nComparisons typically return Bool, and broadcasted comparisons may\nreturn BitArray instead of an Array{Bool}.\n\njulia> [1 2 3 4 5] .< pi\n1×5 BitMatrix:\n 1  1  1  0  0\n\njulia> map(>(pi), [1 2 3 4 5])\n1×5 Matrix{Bool}:\n 0  0  0  1  1\n\nSee also trues, falses, ifelse.\n\n\n\n\n\n"},{"title":"Core.Int8","page":"Numbers","location":"base/numbers.html#Core.Int8","category":"type","text":"Int8 <: Signed <: Integer\n\n8-bit signed integer type.\n\nRepresents numbers n ∈ -128:127.\nNote that such integers overflow without warning,\nthus typemax(Int8) + Int8(1) < 0.\n\nSee also Int, widen, BigInt.\n\n\n\n\n\n"},{"title":"Core.UInt8","page":"Numbers","location":"base/numbers.html#Core.UInt8","category":"type","text":"UInt8 <: Unsigned <: Integer\n\n8-bit unsigned integer type.\n\nPrinted in hexadecimal, thus 0x07 == 7.\n\n\n\n\n\n"},{"title":"Core.Int16","page":"Numbers","location":"base/numbers.html#Core.Int16","category":"type","text":"Int16 <: Signed <: Integer\n\n16-bit signed integer type.\n\nRepresents numbers n ∈ -32768:32767.\nNote that such integers overflow without warning,\nthus typemax(Int16) + Int16(1) < 0.\n\nSee also Int, widen, BigInt.\n\n\n\n\n\n"},{"title":"Core.UInt16","page":"Numbers","location":"base/numbers.html#Core.UInt16","category":"type","text":"UInt16 <: Unsigned <: Integer\n\n16-bit unsigned integer type.\n\nPrinted in hexadecimal, thus 0x000f == 15.\n\n\n\n\n\n"},{"title":"Core.Int32","page":"Numbers","location":"base/numbers.html#Core.Int32","category":"type","text":"Int32 <: Signed <: Integer\n\n32-bit signed integer type.\n\nNote that such integers overflow without warning,\nthus typemax(Int32) + Int32(1) < 0.\n\nSee also Int, widen, BigInt.\n\n\n\n\n\n"},{"title":"Core.UInt32","page":"Numbers","location":"base/numbers.html#Core.UInt32","category":"type","text":"UInt32 <: Unsigned <: Integer\n\n32-bit unsigned integer type.\n\nPrinted in hexadecimal, thus 0x0000001f == 31.\n\n\n\n\n\n"},{"title":"Core.Int64","page":"Numbers","location":"base/numbers.html#Core.Int64","category":"type","text":"Int64 <: Signed <: Integer\n\n64-bit signed integer type.\n\nNote that such integers overflow without warning,\nthus typemax(Int64) + Int64(1) < 0.\n\nSee also Int, widen, BigInt.\n\n\n\n\n\n"},{"title":"Core.UInt64","page":"Numbers","location":"base/numbers.html#Core.UInt64","category":"type","text":"UInt64 <: Unsigned <: Integer\n\n64-bit unsigned integer type.\n\nPrinted in hexadecimal, thus 0x000000000000003f == 63.\n\n\n\n\n\n"},{"title":"Core.Int128","page":"Numbers","location":"base/numbers.html#Core.Int128","category":"type","text":"Int128 <: Signed <: Integer\n\n128-bit signed integer type.\n\nNote that such integers overflow without warning,\nthus typemax(Int128) + Int128(1) < 0.\n\nSee also Int, widen, BigInt.\n\n\n\n\n\n"},{"title":"Core.UInt128","page":"Numbers","location":"base/numbers.html#Core.UInt128","category":"type","text":"UInt128 <: Unsigned <: Integer\n\n128-bit unsigned integer type.\n\nPrinted in hexadecimal, thus 0x0000000000000000000000000000007f == 127.\n\n\n\n\n\n"},{"title":"Core.Int","page":"Numbers","location":"base/numbers.html#Core.Int","category":"type","text":"Int\n\nSys.WORD_SIZE-bit signed integer type, Int <: Signed <: Integer <: Real.\n\nThis is the default type of most integer literals and is an alias for either Int32\nor Int64, depending on Sys.WORD_SIZE. It is the type returned by functions such as\nlength, and the standard type for indexing arrays.\n\nNote that integers overflow without warning, thus typemax(Int) + 1 < 0 and 10^19 < 0.\nOverflow can be avoided by using BigInt.\nVery large integer literals will use a wider type, for instance 10_000_000_000_000_000_000 isa Int128.\n\nInteger division is div alias ÷,\nwhereas / acting on integers returns Float64.\n\nSee also Int64, widen, typemax, bitstring.\n\n\n\n\n\n"},{"title":"Core.UInt","page":"Numbers","location":"base/numbers.html#Core.UInt","category":"type","text":"UInt\n\nSys.WORD_SIZE-bit unsigned integer type, UInt <: Unsigned <: Integer.\n\nLike Int, the alias UInt may point to either UInt32 or UInt64,\naccording to the value of Sys.WORD_SIZE on a given computer.\n\nPrinted and parsed in hexadecimal: UInt(15) === 0x000000000000000f.\n\n\n\n\n\n"},{"title":"Base.GMP.BigInt","page":"Numbers","location":"base/numbers.html#Base.GMP.BigInt","category":"type","text":"BigInt <: Signed\n\nArbitrary precision integer type.\n\n\n\n\n\n"},{"title":"Base.Complex","page":"Numbers","location":"base/numbers.html#Base.Complex","category":"type","text":"Complex{T<:Real} <: Number\n\nComplex number type with real and imaginary part of type T.\n\nComplexF16, ComplexF32 and ComplexF64 are aliases for\nComplex{Float16}, Complex{Float32} and Complex{Float64} respectively.\n\nSee also: Real, complex, real.\n\n\n\n\n\n"},{"title":"Base.Rational","page":"Numbers","location":"base/numbers.html#Base.Rational","category":"type","text":"Rational{T<:Integer} <: Real\n\nRational number type, with numerator and denominator of type T.\nRationals are checked for overflow.\n\n\n\n\n\n"},{"title":"Base.Irrational","page":"Numbers","location":"base/numbers.html#Base.Irrational","category":"type","text":"Irrational{sym} <: AbstractIrrational\n\nNumber type representing an exact irrational value denoted by the\nsymbol sym, such as π, ℯ and γ.\n\nSee also AbstractIrrational.\n\n\n\n\n\n"},{"title":"Base.digits","page":"Numbers","location":"base/numbers.html#Base.digits","category":"function","text":"digits([T<:Integer], n::Integer; base::T = 10, pad::Integer = 1)\n\nReturn an array with element type T (default Int) of the digits of n in the given\nbase, optionally padded with zeros to a specified size. More significant digits are at\nhigher indices, such that n == sum(digits[k]*base^(k-1) for k in 1:length(digits)).\n\nSee also ndigits, digits!,\nand for base 2 also bitstring, count_ones.\n\nExamples\n\njulia> digits(10)\n2-element Vector{Int64}:\n 0\n 1\n\njulia> digits(10, base = 2)\n4-element Vector{Int64}:\n 0\n 1\n 0\n 1\n\njulia> digits(-256, base = 10, pad = 5)\n5-element Vector{Int64}:\n -6\n -5\n -2\n  0\n  0\n\njulia> n = rand(-999:999);\n\njulia> n == evalpoly(13, digits(n, base = 13))\ntrue\n\n\n\n\n\n"},{"title":"Base.digits!","page":"Numbers","location":"base/numbers.html#Base.digits!","category":"function","text":"digits!(array, n::Integer; base::Integer = 10)\n\nFills an array of the digits of n in the given base. More significant digits are at higher\nindices. If the array length is insufficient, the least significant digits are filled up to\nthe array length. If the array length is excessive, the excess portion is filled with zeros.\n\nExamples\n\njulia> digits!([2, 2, 2, 2], 10, base = 2)\n4-element Vector{Int64}:\n 0\n 1\n 0\n 1\n\njulia> digits!([2, 2, 2, 2, 2, 2], 10, base = 2)\n6-element Vector{Int64}:\n 0\n 1\n 0\n 1\n 0\n 0\n\n\n\n\n\n"},{"title":"Base.ndigits","page":"Numbers","location":"base/numbers.html#Base.ndigits","category":"function","text":"ndigits(n::Integer; base::Integer=10, pad::Integer=1)\n\nCompute the number of digits in integer n written in base base\n(base must not be in [-1, 0, 1]), optionally padded with zeros\nto a specified size (the result will never be less than pad).\n\nSee also digits, count_ones.\n\nExamples\n\njulia> ndigits(0)\n1\n\njulia> ndigits(12345)\n5\n\njulia> ndigits(1022, base=16)\n3\n\njulia> string(1022, base=16)\n\"3fe\"\n\njulia> ndigits(123, pad=5)\n5\n\njulia> ndigits(-123)\n3\n\n\n\n\n\n"},{"title":"Base.bitstring","page":"Numbers","location":"base/numbers.html#Base.bitstring","category":"function","text":"bitstring(n)\n\nA string giving the literal bit representation of a primitive type\n(in bigendian order, i.e. most-significant bit first).\n\nSee also count_ones, count_zeros, digits.\n\nExamples\n\njulia> bitstring(Int32(4))\n\"00000000000000000000000000000100\"\n\njulia> bitstring(2.2)\n\"0100000000000001100110011001100110011001100110011001100110011010\"\n\n\n\n\n\n"},{"title":"Base.parse","page":"Numbers","location":"base/numbers.html#Base.parse","category":"function","text":"parse(::Type{SimpleColor}, rgb::String)\n\nAn analogue of tryparse(SimpleColor, rgb::String) (which see),\nthat raises an error instead of returning nothing.\n\n\n\n\n\nparse(type, str; base)\n\nParse a string as a number. For Integer types, a base can be specified\n(the default is 10). For floating-point types, the string is parsed as a decimal\nfloating-point number.  Complex types are parsed from decimal strings\nof the form \"R±Iim\" as a Complex(R,I) of the requested type; \"i\" or \"j\" can also be\nused instead of \"im\", and \"R\" or \"Iim\" are also permitted.\nIf the string does not contain a valid number, an error is raised.\n\ncompat: Julia 1.1\nparse(Bool, str) requires at least Julia 1.1.\n\nExamples\n\njulia> parse(Int, \"1234\")\n1234\n\njulia> parse(Int, \"1234\", base = 5)\n194\n\njulia> parse(Int, \"afc\", base = 16)\n2812\n\njulia> parse(Float64, \"1.2e-3\")\n0.0012\n\njulia> parse(Complex{Float64}, \"3.2e-1 + 4.5im\")\n0.32 + 4.5im\n\n\n\n\n\nparse(::Type{Platform}, triplet::AbstractString)\n\nParses a string platform triplet back into a Platform object.\n\n\n\n\n\n"},{"title":"Base.tryparse","page":"Numbers","location":"base/numbers.html#Base.tryparse","category":"function","text":"tryparse(::Type{SimpleColor}, rgb::String)\n\nAttempt to parse rgb as a SimpleColor. If rgb starts with\n# and has a length of 7, it is converted into a RGBTuple-backed SimpleColor.\nIf rgb starts with a-z, rgb is interpreted as a color name\nand converted to a Symbol-backed SimpleColor.\n\nOtherwise, nothing is returned.\n\nExamples\n\njulia> tryparse(SimpleColor, \"blue\")\nSimpleColor(blue)\n\njulia> tryparse(SimpleColor, \"#9558b2\")\nSimpleColor(#9558b2)\n\njulia> tryparse(SimpleColor, \"#nocolor\")\n\n\n\n\n\ntryparse(type, str; base)\n\nLike parse, but returns either a value of the requested type,\nor nothing if the string does not contain a valid number.\n\n\n\n\n\n"},{"title":"Base.big","page":"Numbers","location":"base/numbers.html#Base.big","category":"function","text":"big(x)\n\nConvert a number to a maximum precision representation (typically BigInt or\nBigFloat). See BigFloat for\ninformation about some pitfalls with floating-point numbers.\n\n\n\n\n\n"},{"title":"Base.signed","page":"Numbers","location":"base/numbers.html#Base.signed","category":"function","text":"signed(x)\n\nConvert a number to a signed integer. If the argument is unsigned, it is reinterpreted as\nsigned without checking for overflow.\n\nSee also: unsigned, sign, signbit.\n\n\n\n\n\nsigned(T::Integer)\n\nConvert an integer bitstype to the signed type of the same size.\n\nExamples\n\njulia> signed(UInt16)\nInt16\njulia> signed(UInt64)\nInt64\n\n\n\n\n\n"},{"title":"Base.unsigned","page":"Numbers","location":"base/numbers.html#Base.unsigned","category":"function","text":"unsigned(T::Integer)\n\nConvert an integer bitstype to the unsigned type of the same size.\n\nExamples\n\njulia> unsigned(Int16)\nUInt16\njulia> unsigned(UInt64)\nUInt64\n\n\n\n\n\n"},{"title":"Base.float","page":"Numbers","location":"base/numbers.html#Base.float-Tuple{Any}","category":"method","text":"float(x)\n\nConvert a number or array to a floating point data type.\n\nSee also: complex, oftype, convert.\n\nExamples\n\njulia> float(typemax(Int32))\n2.147483647e9\n\n\n\n\n\n"},{"title":"Base.Math.significand","page":"Numbers","location":"base/numbers.html#Base.Math.significand","category":"function","text":"significand(x)\n\nExtract the significand (a.k.a. mantissa) of a floating-point number. If x is\na non-zero finite number, then the result will be a number of the same type and\nsign as x, and whose absolute value is on the interval 12). Otherwise\nx is returned.\n\nSee also frexp, exponent.\n\nExamples\n\njulia> significand(15.2)\n1.9\n\njulia> significand(-15.2)\n-1.9\n\njulia> significand(-15.2) * 2^3\n-15.2\n\njulia> significand(-Inf), significand(Inf), significand(NaN)\n(-Inf, Inf, NaN)\n\n\n\n\n\n"},{"title":"Base.Math.exponent","page":"Numbers","location":"base/numbers.html#Base.Math.exponent","category":"function","text":"exponent(x::Real)::Int\n\nReturn the largest integer y such that 2^y ≤ abs(x).\nFor a normalized floating-point number x, this corresponds to the exponent of x.\n\nThrows a DomainError when x is zero, infinite, or NaN.\nFor any other non-subnormal floating-point number x, this corresponds to the exponent bits of x.\n\nSee also signbit, significand, frexp, issubnormal, log2, ldexp.\n\nExamples\n\njulia> exponent(8)\n3\n\njulia> exponent(6.5)\n2\n\njulia> exponent(-1//4)\n-2\n\njulia> exponent(3.142e-4)\n-12\n\njulia> exponent(floatmin(Float32)), exponent(nextfloat(0.0f0))\n(-126, -149)\n\njulia> exponent(0.0)\nERROR: DomainError with 0.0:\nCannot be ±0.0.\n[...]\n\n\n\n\n\n"},{"title":"Base.Math.frexp","page":"Numbers","location":"base/numbers.html#Base.Math.frexp","category":"function","text":"frexp(val)\n\nReturn (x,exp) such that x has a magnitude in the interval 12 1) or 0,\nand val is equal to x times 2^exp.\n\nSee also significand, exponent, ldexp.\n\nExamples\n\njulia> frexp(6.0)\n(0.75, 3)\n\njulia> significand(6.0), exponent(6.0)  # interval [1, 2) instead\n(1.5, 2)\n\njulia> frexp(0.0), frexp(NaN), frexp(-Inf)  # exponent would give an error\n((0.0, 0), (NaN, 0), (-Inf, 0))\n\n\n\n\n\n"},{"title":"Base.Math.ldexp","page":"Numbers","location":"base/numbers.html#Base.Math.ldexp","category":"function","text":"ldexp(x, n)\n\nCompute x times 2^n.\n\nSee also frexp, exponent.\n\nExamples\n\njulia> ldexp(5.0, 2)\n20.0\n\n\n\n\n\n"},{"title":"Base.complex","page":"Numbers","location":"base/numbers.html#Base.complex-Tuple{Complex}","category":"method","text":"complex(r, [i])\n\nConvert real numbers or arrays to complex. i defaults to zero.\n\nExamples\n\njulia> complex(7)\n7 + 0im\n\n\n\n\n\n"},{"title":"Base.bswap","page":"Numbers","location":"base/numbers.html#Base.bswap","category":"function","text":"bswap(n)\n\nReverse the byte order of n.\n\n(See also ntoh and hton to convert between the current native byte order and big-endian order.)\n\nExamples\n\njulia> a = bswap(0x10203040)\n0x40302010\n\njulia> bswap(a)\n0x10203040\n\njulia> string(1, base = 2)\n\"1\"\n\njulia> string(bswap(1), base = 2)\n\"100000000000000000000000000000000000000000000000000000000\"\n\n\n\n\n\n"},{"title":"Base.hex2bytes","page":"Numbers","location":"base/numbers.html#Base.hex2bytes","category":"function","text":"hex2bytes(itr)\n\nGiven an iterable itr of ASCII codes for a sequence of hexadecimal digits, returns a\nVector{UInt8} of bytes  corresponding to the binary representation: each successive pair\nof hexadecimal digits in itr gives the value of one byte in the return vector.\n\nThe length of itr must be even, and the returned array has half of the length of itr.\nSee also hex2bytes! for an in-place version, and bytes2hex for the inverse.\n\ncompat: Julia 1.7\nCalling hex2bytes with iterators producing UInt8 values requires\nJulia 1.7 or later. In earlier versions, you can collect the iterator\nbefore calling hex2bytes.\n\nExamples\n\njulia> s = string(12345, base = 16)\n\"3039\"\n\njulia> hex2bytes(s)\n2-element Vector{UInt8}:\n 0x30\n 0x39\n\njulia> a = b\"01abEF\"\n6-element Base.CodeUnits{UInt8, String}:\n 0x30\n 0x31\n 0x61\n 0x62\n 0x45\n 0x46\n\njulia> hex2bytes(a)\n3-element Vector{UInt8}:\n 0x01\n 0xab\n 0xef\n\n\n\n\n\n"},{"title":"Base.hex2bytes!","page":"Numbers","location":"base/numbers.html#Base.hex2bytes!","category":"function","text":"hex2bytes!(dest::AbstractVector{UInt8}, itr)\n\nConvert an iterable itr of bytes representing a hexadecimal string to its binary\nrepresentation, similar to hex2bytes except that the output is written in-place\nto dest. The length of dest must be half the length of itr.\n\ncompat: Julia 1.7\nCalling hex2bytes! with iterators producing UInt8 requires\nversion 1.7. In earlier versions, you can collect the iterable\nbefore calling instead.\n\n\n\n\n\n"},{"title":"Base.bytes2hex","page":"Numbers","location":"base/numbers.html#Base.bytes2hex","category":"function","text":"bytes2hex(itr)::String\nbytes2hex(io::IO, itr)::Nothing\n\nConvert an iterator itr of bytes to its hexadecimal string representation, either\nreturning a String via bytes2hex(itr) or writing the string to an io stream\nvia bytes2hex(io, itr).  The hexadecimal characters are all lowercase.\n\ncompat: Julia 1.7\nCalling bytes2hex with arbitrary iterators producing UInt8 values requires\nJulia 1.7 or later. In earlier versions, you can collect the iterator\nbefore calling bytes2hex.\n\nExamples\n\njulia> a = string(12345, base = 16)\n\"3039\"\n\njulia> b = hex2bytes(a)\n2-element Vector{UInt8}:\n 0x30\n 0x39\n\njulia> bytes2hex(b)\n\"3039\"\n\n\n\n\n\n"},{"title":"Base.one","page":"Numbers","location":"base/numbers.html#Base.one","category":"function","text":"one(x)\none(T::Type)\n\nReturn a multiplicative identity for x: a value such that\none(x)*x == x*one(x) == x. If the multiplicative identity can\nbe deduced from the type alone, then a type may be given as\nan argument to one (e.g. one(Int) will work because the\nmultiplicative identity is the same for all instances of Int,\nbut one(Matrix{Int}) is not defined because matrices of\ndifferent shapes have different multiplicative identities.)\n\nIf possible, one(x) returns a value of the same type as x,\nand one(T) returns a value of type T.  However, this may\nnot be the case for types representing dimensionful quantities\n(e.g. time in days), since the multiplicative\nidentity must be dimensionless.  In that case, one(x)\nshould return an identity value of the same precision\n(and shape, for matrices) as x.\n\nIf you want a quantity that is of the same type as x, or of type T,\neven if x is dimensionful, use oneunit instead.\n\nSee also the identity function,\nand I in LinearAlgebra for the identity matrix.\n\nExamples\n\njulia> one(3.7)\n1.0\n\njulia> one(Int)\n1\n\njulia> import Dates; one(Dates.Day(1))\n1\n\n\n\n\n\n"},{"title":"Base.oneunit","page":"Numbers","location":"base/numbers.html#Base.oneunit","category":"function","text":"oneunit(x::T)\noneunit(T::Type)\n\nReturn T(one(x)), where T is either the type of the argument, or\nthe argument itself in cases where the oneunit can be deduced from\nthe type alone. This differs from one for dimensionful\nquantities: one is dimensionless (a multiplicative identity)\nwhile oneunit is dimensionful (of the same type as x, or of type T).\n\nExamples\n\njulia> oneunit(3.7)\n1.0\n\njulia> import Dates; oneunit(Dates.Day)\n1 day\n\n\n\n\n\n"},{"title":"Base.zero","page":"Numbers","location":"base/numbers.html#Base.zero","category":"function","text":"zero(x)\nzero(::Type)\n\nGet the additive identity element for x. If the additive identity can be deduced\nfrom the type alone, then a type may be given as an argument to zero.\n\nFor example, zero(Int) will work because the additive identity is the same for all\ninstances of Int, but zero(Vector{Int}) is not defined because vectors of different\nlengths have different additive identities.\n\nSee also iszero, one, oneunit, oftype.\n\nExamples\n\njulia> zero(1)\n0\n\njulia> zero(big\"2.0\")\n0.0\n\njulia> zero(rand(2,2))\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\n\n\n\n\n"},{"title":"Base.im","page":"Numbers","location":"base/numbers.html#Base.im","category":"constant","text":"im\n\nThe imaginary unit.\n\nSee also: imag, angle, complex.\n\nExamples\n\njulia> im * im\n-1 + 0im\n\njulia> (2.0 + 3im)^2\n-5.0 + 12.0im\n\n\n\n\n\n"},{"title":"Base.MathConstants.pi","page":"Numbers","location":"base/numbers.html#Base.MathConstants.pi","category":"constant","text":"π\npi\n\nThe constant pi.\n\nUnicode π can be typed by writing \\pi then pressing tab in the Julia REPL, and in many editors.\n\nSee also: sinpi, sincospi, deg2rad.\n\nExamples\n\njulia> pi\nπ = 3.1415926535897...\n\njulia> 1/2pi\n0.15915494309189535\n\n\n\n\n\n"},{"title":"Base.MathConstants.ℯ","page":"Numbers","location":"base/numbers.html#Base.MathConstants.ℯ","category":"constant","text":"ℯ\ne\n\nThe constant ℯ.\n\nUnicode ℯ can be typed by writing \\euler and pressing tab in the Julia REPL, and in many editors.\n\nSee also: exp, cis, cispi.\n\nExamples\n\njulia> ℯ\nℯ = 2.7182818284590...\n\njulia> log(ℯ)\n1\n\njulia> ℯ^(im)π ≈ -1\ntrue\n\n\n\n\n\n"},{"title":"Base.MathConstants.catalan","page":"Numbers","location":"base/numbers.html#Base.MathConstants.catalan","category":"constant","text":"catalan\n\nCatalan's constant.\n\nExamples\n\njulia> Base.MathConstants.catalan\ncatalan = 0.9159655941772...\n\njulia> sum(log(x)/(1+x^2) for x in 1:0.01:10^6) * 0.01\n0.9159466120554123\n\n\n\n\n\n"},{"title":"Base.MathConstants.eulergamma","page":"Numbers","location":"base/numbers.html#Base.MathConstants.eulergamma","category":"constant","text":"γ\neulergamma\n\nEuler's constant.\n\nExamples\n\njulia> Base.MathConstants.eulergamma\nγ = 0.5772156649015...\n\njulia> dx = 10^-6;\n\njulia> sum(-exp(-x) * log(x) for x in dx:dx:100) * dx\n0.5772078382499133\n\n\n\n\n\n"},{"title":"Base.MathConstants.golden","page":"Numbers","location":"base/numbers.html#Base.MathConstants.golden","category":"constant","text":"φ\ngolden\n\nThe golden ratio.\n\nExamples\n\njulia> Base.MathConstants.golden\nφ = 1.6180339887498...\n\njulia> (2ans - 1)^2 ≈ 5\ntrue\n\n\n\n\n\n"},{"title":"Base.Inf","page":"Numbers","location":"base/numbers.html#Base.Inf","category":"constant","text":"Inf, Inf64\n\nPositive infinity of type Float64.\n\nSee also: isfinite, typemax, NaN, Inf32.\n\nExamples\n\njulia> π/0\nInf\n\njulia> +1.0 / -0.0\n-Inf\n\njulia> ℯ^-Inf\n0.0\n\n\n\n\n\n"},{"title":"Base.Inf64","page":"Numbers","location":"base/numbers.html#Base.Inf64","category":"constant","text":"Inf, Inf64\n\nPositive infinity of type Float64.\n\nSee also: isfinite, typemax, NaN, Inf32.\n\nExamples\n\njulia> π/0\nInf\n\njulia> +1.0 / -0.0\n-Inf\n\njulia> ℯ^-Inf\n0.0\n\n\n\n\n\n"},{"title":"Base.Inf32","page":"Numbers","location":"base/numbers.html#Base.Inf32","category":"constant","text":"Inf32\n\nPositive infinity of type Float32.\n\n\n\n\n\n"},{"title":"Base.Inf16","page":"Numbers","location":"base/numbers.html#Base.Inf16","category":"constant","text":"Inf16\n\nPositive infinity of type Float16.\n\n\n\n\n\n"},{"title":"Base.NaN","page":"Numbers","location":"base/numbers.html#Base.NaN","category":"constant","text":"NaN, NaN64\n\nA not-a-number value of type Float64.\n\nSee also: isnan, missing, NaN32, Inf.\n\nExamples\n\njulia> 0/0\nNaN\n\njulia> Inf - Inf\nNaN\n\njulia> NaN == NaN, isequal(NaN, NaN), isnan(NaN)\n(false, true, true)\n\nnote: Note\nAlways use isnan or isequal for checking for NaN.\nUsing x === NaN may give unexpected results:julia> reinterpret(UInt32, NaN32)\n0x7fc00000\n\njulia> NaN32p1 = reinterpret(Float32, 0x7fc00001)\nNaN32\n\njulia> NaN32p1 === NaN32, isequal(NaN32p1, NaN32), isnan(NaN32p1)\n(false, true, true)\n\n\n\n\n\n"},{"title":"Base.NaN64","page":"Numbers","location":"base/numbers.html#Base.NaN64","category":"constant","text":"NaN, NaN64\n\nA not-a-number value of type Float64.\n\nSee also: isnan, missing, NaN32, Inf.\n\nExamples\n\njulia> 0/0\nNaN\n\njulia> Inf - Inf\nNaN\n\njulia> NaN == NaN, isequal(NaN, NaN), isnan(NaN)\n(false, true, true)\n\nnote: Note\nAlways use isnan or isequal for checking for NaN.\nUsing x === NaN may give unexpected results:julia> reinterpret(UInt32, NaN32)\n0x7fc00000\n\njulia> NaN32p1 = reinterpret(Float32, 0x7fc00001)\nNaN32\n\njulia> NaN32p1 === NaN32, isequal(NaN32p1, NaN32), isnan(NaN32p1)\n(false, true, true)\n\n\n\n\n\n"},{"title":"Base.NaN32","page":"Numbers","location":"base/numbers.html#Base.NaN32","category":"constant","text":"NaN32\n\nA not-a-number value of type Float32.\n\nSee also: NaN.\n\n\n\n\n\n"},{"title":"Base.NaN16","page":"Numbers","location":"base/numbers.html#Base.NaN16","category":"constant","text":"NaN16\n\nA not-a-number value of type Float16.\n\nSee also: NaN.\n\n\n\n\n\n"},{"title":"Base.issubnormal","page":"Numbers","location":"base/numbers.html#Base.issubnormal","category":"function","text":"issubnormal(f)::Bool\n\nTest whether a floating point number is subnormal.\n\nAn IEEE floating point number is subnormal\nwhen its exponent bits are zero and its significand is not zero.\n\nExamples\n\njulia> floatmin(Float32)\n1.1754944f-38\n\njulia> issubnormal(1.0f-37)\nfalse\n\njulia> issubnormal(1.0f-38)\ntrue\n\n\n\n\n\n"},{"title":"Base.isfinite","page":"Numbers","location":"base/numbers.html#Base.isfinite","category":"function","text":"isfinite(f)::Bool\n\nTest whether a number is finite.\n\nExamples\n\njulia> isfinite(5)\ntrue\n\njulia> isfinite(NaN32)\nfalse\n\n\n\n\n\n"},{"title":"Base.isinf","page":"Numbers","location":"base/numbers.html#Base.isinf","category":"function","text":"isinf(f)::Bool\n\nTest whether a number is infinite.\n\nSee also: Inf, iszero, isfinite, isnan.\n\n\n\n\n\n"},{"title":"Base.isnan","page":"Numbers","location":"base/numbers.html#Base.isnan","category":"function","text":"isnan(f)::Bool\n\nTest whether a number value is a NaN, an indeterminate value which is neither an infinity\nnor a finite number (\"not a number\").\n\nSee also: iszero, isone, isinf, ismissing.\n\n\n\n\n\n"},{"title":"Base.iszero","page":"Numbers","location":"base/numbers.html#Base.iszero","category":"function","text":"iszero(x)\n\nReturn true if x == zero(x); if x is an array, this checks whether\nall of the elements of x are zero.\n\nSee also: isone, isinteger, isfinite, isnan.\n\nExamples\n\njulia> iszero(0.0)\ntrue\n\njulia> iszero([1, 9, 0])\nfalse\n\njulia> iszero([false, 0, 0])\ntrue\n\n\n\n\n\n"},{"title":"Base.isone","page":"Numbers","location":"base/numbers.html#Base.isone","category":"function","text":"isone(x)\n\nReturn true if x == one(x); if x is an array, this checks whether\nx is an identity matrix.\n\nExamples\n\njulia> isone(1.0)\ntrue\n\njulia> isone([1 0; 0 2])\nfalse\n\njulia> isone([1 0; 0 true])\ntrue\n\n\n\n\n\n"},{"title":"Base.nextfloat","page":"Numbers","location":"base/numbers.html#Base.nextfloat","category":"function","text":"nextfloat(x::AbstractFloat)\n\nReturn the smallest floating point number y of the same type as x such that x < y.\nIf no such y exists (e.g. if x is Inf or NaN), then return x.\n\nSee also: prevfloat, eps, issubnormal.\n\n\n\n\n\nnextfloat(x::AbstractFloat, n::Integer)\n\nThe result of n iterative applications of nextfloat to x if n >= 0, or -n\napplications of prevfloat if n < 0.\n\n\n\n\n\n"},{"title":"Base.prevfloat","page":"Numbers","location":"base/numbers.html#Base.prevfloat","category":"function","text":"prevfloat(x::AbstractFloat)\n\nReturn the largest floating point number y of the same type as x such that y < x.\nIf no such y exists (e.g. if x is -Inf or NaN), then return x.\n\n\n\n\n\nprevfloat(x::AbstractFloat, n::Integer)\n\nThe result of n iterative applications of prevfloat to x if n >= 0, or -n\napplications of nextfloat if n < 0.\n\n\n\n\n\n"},{"title":"Base.isinteger","page":"Numbers","location":"base/numbers.html#Base.isinteger","category":"function","text":"isinteger(x)::Bool\n\nTest whether x is numerically equal to some integer.\n\nExamples\n\njulia> isinteger(4.0)\ntrue\n\n\n\n\n\n"},{"title":"Base.isreal","page":"Numbers","location":"base/numbers.html#Base.isreal","category":"function","text":"isreal(x)::Bool\n\nTest whether x or all its elements are numerically equal to some real number\nincluding infinities and NaNs. isreal(x) is true if isequal(x, real(x))\nis true.\n\nExamples\n\njulia> isreal(5.)\ntrue\n\njulia> isreal(1 - 3im)\nfalse\n\njulia> isreal(Inf + 0im)\ntrue\n\njulia> isreal([4.; complex(0,1)])\nfalse\n\n\n\n\n\n"},{"title":"Core.Float32","page":"Numbers","location":"base/numbers.html#Core.Float32-Tuple{Any}","category":"method","text":"Float32(x [, mode::RoundingMode])\n\nCreate a Float32 from x. If x is not exactly representable then mode determines how\nx is rounded.\n\nExamples\n\njulia> Float32(1/3, RoundDown)\n0.3333333f0\n\njulia> Float32(1/3, RoundUp)\n0.33333334f0\n\nSee RoundingMode for available rounding modes.\n\n\n\n\n\n"},{"title":"Core.Float64","page":"Numbers","location":"base/numbers.html#Core.Float64-Tuple{Any}","category":"method","text":"Float64(x [, mode::RoundingMode])\n\nCreate a Float64 from x. If x is not exactly representable then mode determines how\nx is rounded.\n\nExamples\n\njulia> Float64(pi, RoundDown)\n3.141592653589793\n\njulia> Float64(pi, RoundUp)\n3.1415926535897936\n\nSee RoundingMode for available rounding modes.\n\n\n\n\n\n"},{"title":"Base.Rounding.rounding","page":"Numbers","location":"base/numbers.html#Base.Rounding.rounding","category":"function","text":"rounding(T)\n\nGet the current floating point rounding mode for type T, controlling the rounding of basic\narithmetic functions (+, -, *, /\nand sqrt) and type conversion.\n\nSee RoundingMode for available modes.\n\n\n\n\n\n"},{"title":"Base.Rounding.setrounding","page":"Numbers","location":"base/numbers.html#Base.Rounding.setrounding-Tuple{Type, Any}","category":"method","text":"setrounding(T, mode)\n\nSet the rounding mode of floating point type T, controlling the rounding of basic\narithmetic functions (+, -, *,\n/ and sqrt) and type conversion. Other numerical\nfunctions may give incorrect or invalid values when using rounding modes other than the\ndefault RoundNearest.\n\nNote that this is currently only supported for T == BigFloat.\n\nwarning: Warning\nThis function is not thread-safe. It will affect code running on all threads, but\nits behavior is undefined if called concurrently with computations that use the\nsetting.\n\n\n\n\n\n"},{"title":"Base.Rounding.setrounding","page":"Numbers","location":"base/numbers.html#Base.Rounding.setrounding-Tuple{Function, Type, RoundingMode}","category":"method","text":"setrounding(f::Function, T, mode)\n\nChange the rounding mode of floating point type T for the duration of f. It is logically\nequivalent to:\n\nold = rounding(T)\nsetrounding(T, mode)\nf()\nsetrounding(T, old)\n\nSee RoundingMode for available rounding modes.\n\n\n\n\n\n"},{"title":"Base.Rounding.get_zero_subnormals","page":"Numbers","location":"base/numbers.html#Base.Rounding.get_zero_subnormals","category":"function","text":"get_zero_subnormals()::Bool\n\nReturn false if operations on subnormal floating-point values (\"denormals\") obey rules\nfor IEEE arithmetic, and true if they might be converted to zeros.\n\nwarning: Warning\nThis function only affects the current thread.\n\n\n\n\n\n"},{"title":"Base.Rounding.set_zero_subnormals","page":"Numbers","location":"base/numbers.html#Base.Rounding.set_zero_subnormals","category":"function","text":"set_zero_subnormals(yes::Bool)::Bool\n\nIf yes is false, subsequent floating-point operations follow rules for IEEE arithmetic\non subnormal values (\"denormals\"). Otherwise, floating-point operations are permitted (but\nnot required) to convert subnormal inputs or outputs to zero. Returns true unless\nyes==true but the hardware does not support zeroing of subnormal numbers.\n\nset_zero_subnormals(true) can speed up some computations on some hardware. However, it can\nbreak identities such as (x-y==0) == (x==y).\n\nwarning: Warning\nThis function only affects the current thread.\n\n\n\n\n\n"},{"title":"Base.count_ones","page":"Numbers","location":"base/numbers.html#Base.count_ones","category":"function","text":"count_ones(x::Integer)::Integer\n\nNumber of ones in the binary representation of x.\n\nExamples\n\njulia> count_ones(7)\n3\n\njulia> count_ones(Int32(-1))\n32\n\n\n\n\n\n"},{"title":"Base.count_zeros","page":"Numbers","location":"base/numbers.html#Base.count_zeros","category":"function","text":"count_zeros(x::Integer)::Integer\n\nNumber of zeros in the binary representation of x.\n\nExamples\n\njulia> count_zeros(Int32(2 ^ 16 - 1))\n16\n\njulia> count_zeros(-1)\n0\n\n\n\n\n\n"},{"title":"Base.leading_zeros","page":"Numbers","location":"base/numbers.html#Base.leading_zeros","category":"function","text":"leading_zeros(x::Integer)::Integer\n\nNumber of zeros leading the binary representation of x.\n\nExamples\n\njulia> leading_zeros(Int32(1))\n31\n\n\n\n\n\n"},{"title":"Base.leading_ones","page":"Numbers","location":"base/numbers.html#Base.leading_ones","category":"function","text":"leading_ones(x::Integer)::Integer\n\nNumber of ones leading the binary representation of x.\n\nExamples\n\njulia> leading_ones(UInt32(2 ^ 32 - 2))\n31\n\n\n\n\n\n"},{"title":"Base.trailing_zeros","page":"Numbers","location":"base/numbers.html#Base.trailing_zeros","category":"function","text":"trailing_zeros(x::Integer)::Integer\n\nNumber of zeros trailing the binary representation of x.\n\nExamples\n\njulia> trailing_zeros(2)\n1\n\n\n\n\n\n"},{"title":"Base.trailing_ones","page":"Numbers","location":"base/numbers.html#Base.trailing_ones","category":"function","text":"trailing_ones(x::Integer)::Integer\n\nNumber of ones trailing the binary representation of x.\n\nExamples\n\njulia> trailing_ones(3)\n2\n\n\n\n\n\n"},{"title":"Base.isodd","page":"Numbers","location":"base/numbers.html#Base.isodd","category":"function","text":"isodd(x::Number)::Bool\n\nReturn true if x is an odd integer (that is, an integer not divisible by 2), and false otherwise.\n\ncompat: Julia 1.7\nNon-Integer arguments require Julia 1.7 or later.\n\nExamples\n\njulia> isodd(9)\ntrue\n\njulia> isodd(10)\nfalse\n\n\n\n\n\n"},{"title":"Base.iseven","page":"Numbers","location":"base/numbers.html#Base.iseven","category":"function","text":"iseven(x::Number)::Bool\n\nReturn true if x is an even integer (that is, an integer divisible by 2), and false otherwise.\n\ncompat: Julia 1.7\nNon-Integer arguments require Julia 1.7 or later.\n\nExamples\n\njulia> iseven(9)\nfalse\n\njulia> iseven(10)\ntrue\n\n\n\n\n\n"},{"title":"Core.@int128_str","page":"Numbers","location":"base/numbers.html#Core.@int128_str","category":"macro","text":"@int128_str str\n\nParse str as an Int128.\nThrow an ArgumentError if the string is not a valid integer.\n\nExamples\n\njulia> int128\"123456789123\"\n123456789123\n\njulia> int128\"123456789123.4\"\nERROR: LoadError: ArgumentError: invalid base 10 digit '.' in \"123456789123.4\"\n[...]\n\n\n\n\n\n"},{"title":"Core.@uint128_str","page":"Numbers","location":"base/numbers.html#Core.@uint128_str","category":"macro","text":"@uint128_str str\n\nParse str as an UInt128.\nThrow an ArgumentError if the string is not a valid integer.\n\nExamples\n\njulia> uint128\"123456789123\"\n0x00000000000000000000001cbe991a83\n\njulia> uint128\"-123456789123\"\nERROR: LoadError: ArgumentError: invalid base 10 digit '-' in \"-123456789123\"\n[...]\n\n\n\n\n\n"},{"title":"Base.MPFR.BigFloat","page":"Numbers","location":"base/numbers.html#Base.MPFR.BigFloat-Tuple{Any, RoundingMode}","category":"method","text":"BigFloat(x::Union{Real, AbstractString} [, rounding::RoundingMode=rounding(BigFloat)]; [precision::Integer=precision(BigFloat)])\n\nCreate an arbitrary precision floating point number from x, with precision\nprecision. The rounding argument specifies the direction in which the result should be\nrounded if the conversion cannot be done exactly. If not provided, these are set by the current global values.\n\nBigFloat(x::Real) is the same as convert(BigFloat,x), except if x itself is already\nBigFloat, in which case it will return a value with the precision set to the current\nglobal precision; convert will always return x.\n\nBigFloat(x::AbstractString) is identical to parse. This is provided for\nconvenience since decimal literals are converted to Float64 when parsed, so\nBigFloat(2.1) may not yield what you expect.\n\nSee also:\n\n@big_str\nrounding and setrounding\nprecision and setprecision\n\ncompat: Julia 1.1\nprecision as a keyword argument requires at least Julia 1.1.\nIn Julia 1.0 precision is the second positional argument (BigFloat(x, precision)).\n\nExamples\n\njulia> BigFloat(2.1) # 2.1 here is a Float64\n2.100000000000000088817841970012523233890533447265625\n\njulia> BigFloat(\"2.1\") # the closest BigFloat to 2.1\n2.099999999999999999999999999999999999999999999999999999999999999999999999999986\n\njulia> BigFloat(\"2.1\", RoundUp)\n2.100000000000000000000000000000000000000000000000000000000000000000000000000021\n\njulia> BigFloat(\"2.1\", RoundUp, precision=128)\n2.100000000000000000000000000000000000007\n\n\n\n\n\n"},{"title":"Base.precision","page":"Numbers","location":"base/numbers.html#Base.precision","category":"function","text":"precision(num::AbstractFloat; base::Integer=2)\nprecision(T::Type; base::Integer=2)\n\nGet the precision of a floating point number, as defined by the effective number of bits in\nthe significand, or the precision of a floating-point type T (its current default, if\nT is a variable-precision type like BigFloat).\n\nIf base is specified, then it returns the maximum corresponding\nnumber of significand digits in that base.\n\ncompat: Julia 1.8\nThe base keyword requires at least Julia 1.8.\n\n\n\n\n\n"},{"title":"Base.MPFR.setprecision","page":"Numbers","location":"base/numbers.html#Base.MPFR.setprecision","category":"function","text":"setprecision(f::Function, [T=BigFloat,] precision::Integer; base=2)\n\nChange the T arithmetic precision (in the given base) for the duration of f.\nIt is logically equivalent to:\n\nold = precision(BigFloat)\nsetprecision(BigFloat, precision)\nf()\nsetprecision(BigFloat, old)\n\nOften used as setprecision(T, precision) do ... end\n\nNote: nextfloat(), prevfloat() do not use the precision mentioned by\nsetprecision.\n\nwarning: Warning\nThere is a fallback implementation of this method that calls precision\nand setprecision, but it should no longer be relied on. Instead, you\nshould define the 3-argument form directly in a way that uses ScopedValue,\nor recommend that callers use ScopedValue and @with themselves.\n\ncompat: Julia 1.8\nThe base keyword requires at least Julia 1.8.\n\n\n\n\n\nsetprecision([T=BigFloat,] precision::Int; base=2)\n\nSet the precision (in bits, by default) to be used for T arithmetic.\nIf base is specified, then the precision is the minimum required to give\nat least precision digits in the given base.\n\nwarning: Warning\nThis function is not thread-safe. It will affect code running on all threads, but\nits behavior is undefined if called concurrently with computations that use the\nsetting.\n\ncompat: Julia 1.8\nThe base keyword requires at least Julia 1.8.\n\n\n\n\n\n"},{"title":"Base.GMP.BigInt","page":"Numbers","location":"base/numbers.html#Base.GMP.BigInt-Tuple{Any}","category":"method","text":"BigInt(x)\n\nCreate an arbitrary precision integer. x may be an Int (or anything that can be\nconverted to an Int). The usual mathematical operators are defined for this type, and\nresults are promoted to a BigInt.\n\nInstances can be constructed from strings via parse, or using the big\nstring literal.\n\nExamples\n\njulia> parse(BigInt, \"42\")\n42\n\njulia> big\"313\"\n313\n\njulia> BigInt(10)^19\n10000000000000000000\n\n\n\n\n\n"},{"title":"Core.@big_str","page":"Numbers","location":"base/numbers.html#Core.@big_str","category":"macro","text":"@big_str str\n\nParse a string into a BigInt or BigFloat,\nand throw an ArgumentError if the string is not a valid number.\nFor integers _ is allowed in the string as a separator.\n\nExamples\n\njulia> big\"123_456\"\n123456\n\njulia> big\"7891.5\"\n7891.5\n\njulia> big\"_\"\nERROR: ArgumentError: invalid number format _ for BigInt or BigFloat\n[...]\n\nwarning: Warning\nUsing @big_str for constructing BigFloat values may not result\nin the behavior that might be naively expected: as a macro, @big_str\nobeys the global precision (setprecision) and rounding mode\n(setrounding) settings as they are at load time. Thus, a\nfunction like () -> precision(big\"0.3\") returns a constant whose value\ndepends on the value of the precision at the point when the function is\ndefined, not at the precision at the time when the function is called.\n\n\n\n\n\n"},{"title":"Memory layout of Julia Objects","page":"Memory layout of Julia Objects","location":"devdocs/object.html#Memory-layout-of-Julia-Objects","category":"section","text":""},{"title":"Object layout (jl_value_t)","page":"Memory layout of Julia Objects","location":"devdocs/object.html#Object-layout-(jl_value_t)","category":"section","text":"The jl_value_t struct is the name for a block of memory owned by the Julia Garbage Collector,\nrepresenting the data associated with a Julia object in memory. Absent any type information, it\nis simply an opaque pointer:\n\ntypedef struct jl_value_t* jl_pvalue_t;\n\nEach jl_value_t struct is contained in a jl_typetag_t struct that contains metadata information\nabout the Julia object, such as its type and garbage collector (gc) reachability:\n\ntypedef struct {\n    opaque metadata;\n    jl_value_t value;\n} jl_typetag_t;\n\nThe type of any Julia object is an instance of a leaf jl_datatype_t object. The jl_typeof()\nfunction can be used to query for it:\n\njl_value_t *jl_typeof(jl_value_t *v);\n\nThe layout of the object depends on its type. Reflection methods can be used to inspect that layout.\nA field can be accessed by calling one of the get-field methods:\n\njl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);\njl_value_t *jl_get_field(jl_value_t *o, char *fld);\n\nIf the field types are known, a priori, to be all pointers, the values can also be extracted directly\nas an array access:\n\njl_value_t *v = value->fieldptr[n];\n\nAs an example, a \"boxed\" uint16_t is stored as follows:\n\nstruct {\n    opaque metadata;\n    struct {\n        uint16_t data;        // -- 2 bytes\n    } jl_value_t;\n};\n\nThis object is created by jl_box_uint16(). Note that the jl_value_t pointer references the\ndata portion, not the metadata at the top of the struct.\n\nA value may be stored \"unboxed\" in many circumstances (just the data, without the metadata, and\npossibly not even stored but just kept in registers), so it is unsafe to assume that the address\nof a box is a unique identifier. The \"egal\" test (corresponding to the === function in Julia),\nshould instead be used to compare two unknown objects for equivalence:\n\nint jl_egal(jl_value_t *a, jl_value_t *b);\n\nThis optimization should be relatively transparent to the API, since the object will be \"boxed\"\non-demand, whenever a jl_value_t pointer is needed.\n\nNote that modification of a jl_value_t pointer in memory is permitted only if the object is\nmutable. Otherwise, modification of the value may corrupt the program and the result will be undefined.\nThe mutability property of a value can be queried for with:\n\nint jl_is_mutable(jl_value_t *v);\n\nIf the object being stored is a jl_value_t, the Julia garbage collector must be notified also:\n\nvoid jl_gc_wb(jl_value_t *parent, jl_value_t *ptr);\n\nHowever, the Embedding Julia section of the manual is also required reading at this point,\nfor covering other details of boxing and unboxing various types, and understanding the gc interactions.\n\nMirror structs for some of the built-in types are defined in julia.h.\nThe corresponding global jl_datatype_t objects are created by jl_init_types in jltypes.c."},{"title":"Garbage collector mark bits","page":"Memory layout of Julia Objects","location":"devdocs/object.html#Garbage-collector-mark-bits","category":"section","text":"The garbage collector uses several bits from the metadata portion of the jl_typetag_t to track\neach object in the system. Further details about this algorithm can be found in the comments of\nthe garbage collector implementation in gc-stock.c."},{"title":"Object allocation","page":"Memory layout of Julia Objects","location":"devdocs/object.html#Object-allocation","category":"section","text":"Most new objects are allocated by jl_new_structv():\n\njl_value_t *jl_new_struct(jl_datatype_t *type, ...);\njl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args, uint32_t na);\n\nAlthough, isbits objects can be also constructed directly from memory:\n\njl_value_t *jl_new_bits(jl_value_t *bt, void *data)\n\nAnd some objects have special constructors that must be used instead of the above functions:\n\nTypes:\n\njl_datatype_t *jl_apply_type(jl_datatype_t *tc, jl_tuple_t *params);\njl_datatype_t *jl_apply_array_type(jl_datatype_t *type, size_t dim);\n\nWhile these are the most commonly used options, there are more low-level constructors too, which\nyou can find declared in julia.h.\nThese are used in jl_init_types() to create the initial types needed to bootstrap the creation\nof the Julia system image.\n\nTuples:\n\njl_tuple_t *jl_tuple(size_t n, ...);\njl_tuple_t *jl_tuplev(size_t n, jl_value_t **v);\njl_tuple_t *jl_alloc_tuple(size_t n);\n\nThe representation of tuples is highly unique in the Julia object representation ecosystem. In\nsome cases, a Base.tuple() object may be an array of pointers to the objects contained\nby the tuple equivalent to:\n\ntypedef struct {\n    size_t length;\n    jl_value_t *data[length];\n} jl_tuple_t;\n\nHowever, in other cases, the tuple may be converted to an anonymous isbits type and\nstored unboxed, or it may not stored at all (if it is not being used in a generic context as a\njl_value_t*).\n\nSymbols:\n\njl_sym_t *jl_symbol(const char *str);\n\nFunctions and MethodInstance:\n\njl_value_t *jl_new_generic_function(jl_sym_t *name);\njl_method_instance_t *jl_new_method_instance(jl_value_t *ast, jl_tuple_t *sparams);\n\nArrays:\n\njl_array_t *jl_new_array(jl_value_t *atype, jl_tuple_t *dims);\njl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);\njl_array_t *jl_alloc_array_nd(jl_value_t *atype, size_t *dims, size_t ndims);\n\nNote that many of these have alternative allocation functions for various special-purposes. The\nlist here reflects the more common usages, but a more complete list can be found by reading the\njulia.h header file.\n\nInternal to Julia, storage is typically allocated by newstruct() (or newobj() for the special\ntypes):\n\njl_value_t *newstruct(jl_value_t *type);\njl_value_t *newobj(jl_value_t *type, size_t nfields);\n\nAnd at the lowest level, memory is getting allocated by a call to the garbage collector (in gc-stock.c),\nthen tagged with its type:\n\njl_value_t *jl_gc_allocobj(size_t nbytes);\nvoid jl_set_typeof(jl_value_t *v, jl_datatype_t *type);\n\nnote: Out of date Warning\nThe documentation and usage for the function jl_gc_allocobj may be out of date\n\nNote that all objects are allocated in multiples of 4 bytes and aligned to the platform pointer\nsize. Memory is allocated from a pool for smaller objects, or directly with malloc() for large\nobjects.\n\nsidebar: Singleton Types\nSingleton types have only one instance and no data fields. Singleton instances have a size of\n0 bytes, and consist only of their metadata. e.g. nothing::Nothing.See Singleton Types and Nothingness and missing values"},{"title":"gdb debugging tips","page":"gdb debugging tips","location":"devdocs/debuggingtips.html#gdb-debugging-tips","category":"section","text":""},{"title":"Displaying Julia variables","page":"gdb debugging tips","location":"devdocs/debuggingtips.html#Displaying-Julia-variables","category":"section","text":"Within gdb, any jl_value_t* object obj can be displayed using\n\n(gdb) call jl_(obj)\n\nThe object will be displayed in the julia session, not in the gdb session. This is a useful\nway to discover the types and values of objects being manipulated by Julia's C code.\n\nSimilarly, if you're debugging some of Julia's internals (e.g., compiler.jl), you can print\nobj using\n\nccall(:jl_, Cvoid, (Any,), obj)\n\nThis is a good way to circumvent problems that arise from the order in which julia's output streams\nare initialized.\n\nJulia's flisp interpreter uses value_t objects; these can be displayed with call fl_print(fl_ctx, ios_stdout, obj)."},{"title":"Useful Julia variables for Inspecting","page":"gdb debugging tips","location":"devdocs/debuggingtips.html#Useful-Julia-variables-for-Inspecting","category":"section","text":"While the addresses of many variables, like singletons, can be useful to print for many failures,\nthere are a number of additional variables (see julia.h for a complete list) that are even more\nuseful.\n\n(when in jl_apply_generic) mfunc and jl_uncompress_ast(mfunc->def, mfunc->code) :: for\nfiguring out a bit about the call-stack\njl_lineno and jl_filename :: for figuring out what line in a test to go start debugging from\n(or figure out how far into a file has been parsed)\n$1 :: not really a variable, but still a useful shorthand for referring to the result of the\nlast gdb command (such as print)\njl_options :: sometimes useful, since it lists all of the command line options that were successfully\nparsed\njl_uv_stderr :: because who doesn't like to be able to interact with stdio"},{"title":"Useful Julia functions for Inspecting those variables","page":"gdb debugging tips","location":"devdocs/debuggingtips.html#Useful-Julia-functions-for-Inspecting-those-variables","category":"section","text":"jl_print_task_backtraces(0) :: Similar to gdb's thread apply all bt or lldb's thread backtrace all. Runs all threads while printing backtraces for all existing tasks.\njl_gdblookup($pc) :: For looking up the current function and line.\njl_gdblookupinfo($pc) :: For looking up the current method instance object.\njl_gdbdumpcode(mi) :: For dumping all of code_typed/code_llvm/code_asm when the REPL is not working right.\njlbacktrace() :: For dumping the current Julia backtrace stack to stderr. Only usable after\nrecord_backtrace() has been called.\njl_dump_llvm_value(Value*) :: For invoking Value->dump() in gdb, where it doesn't work natively.\nFor example, f->linfo->functionObject, f->linfo->specFunctionObject, and to_function(f->linfo).\njl_dump_llvm_module(Module*) :: For invoking Module->dump() in gdb, where it doesn't work natively.\nType->dump() :: only works in lldb. Note: add something like ;1 to prevent lldb from printing\nits prompt over the output\njl_eval_string(\"expr\") :: for invoking side-effects to modify the current state or to lookup\nsymbols\njl_typeof(jl_value_t*) :: for extracting the type tag of a Julia value (in gdb, call macro define jl_typeof jl_typeof\nfirst, or pick something short like ty for the first arg to define a shorthand)"},{"title":"Inserting breakpoints for inspection from gdb","page":"gdb debugging tips","location":"devdocs/debuggingtips.html#Inserting-breakpoints-for-inspection-from-gdb","category":"section","text":"In your gdb session, set a breakpoint in jl_breakpoint like so:\n\n(gdb) break jl_breakpoint\n\nThen within your Julia code, insert a call to jl_breakpoint by adding\n\nccall(:jl_breakpoint, Cvoid, (Any,), obj)\n\nwhere obj can be any variable or tuple you want to be accessible in the breakpoint.\n\nIt's particularly helpful to back up to the jl_apply frame, from which you can display the arguments\nto a function using, e.g.,\n\n(gdb) call jl_(args[0])\n\nAnother useful frame is to_function(jl_method_instance_t *li, bool cstyle). The jl_method_instance_t*\nargument is a struct with a reference to the final AST sent into the compiler. However, the AST\nat this point will usually be compressed; to view the AST, call jl_uncompress_ast and then pass\nthe result to jl_:\n\n#2  0x00007ffff7928bf7 in to_function (li=0x2812060, cstyle=false) at codegen.cpp:584\n584          abort();\n(gdb) p jl_(jl_uncompress_ast(li, li->ast))"},{"title":"Inserting breakpoints upon certain conditions","page":"gdb debugging tips","location":"devdocs/debuggingtips.html#Inserting-breakpoints-upon-certain-conditions","category":"section","text":""},{"title":"Loading a particular file","page":"gdb debugging tips","location":"devdocs/debuggingtips.html#Loading-a-particular-file","category":"section","text":"Let's say the file is sysimg.jl:\n\n(gdb) break jl_load if strcmp(fname, \"sysimg.jl\")==0"},{"title":"Calling a particular method","page":"gdb debugging tips","location":"devdocs/debuggingtips.html#Calling-a-particular-method","category":"section","text":"(gdb) break jl_apply_generic if strcmp((char*)(jl_symbol_name)(jl_gf_mtable(F)->name), \"method_to_break\")==0\n\nSince this function is used for every call, you will make everything 1000x slower if you do this."},{"title":"Dealing with signals","page":"gdb debugging tips","location":"devdocs/debuggingtips.html#Dealing-with-signals","category":"section","text":"Julia requires a few signals to function properly. The profiler uses SIGUSR2 for sampling and\nthe garbage collector uses SIGSEGV for threads synchronization. If you are debugging some code\nthat uses the profiler or multiple threads, you may want to let the debugger ignore these signals\nsince they can be triggered very often during normal operations. The command to do this in GDB\nis (replace SIGSEGV with SIGUSR2 or other signals you want to ignore):\n\n(gdb) handle SIGSEGV noprint nostop pass\n\nThe corresponding LLDB command is (after the process is started):\n\n(lldb) pro hand -p true -s false -n false SIGSEGV\n\nIf you are debugging a segfault with threaded code, you can set a breakpoint on jl_fprint_critical_error\n(sigdie_handler should also work on Linux and BSD) in order to only catch the actual segfault\nrather than the GC synchronization points."},{"title":"Debugging during Julia's build process (bootstrap)","page":"gdb debugging tips","location":"devdocs/debuggingtips.html#Debugging-during-Julia's-build-process-(bootstrap)","category":"section","text":"Errors that occur during make need special handling. Julia is built in two stages, constructing\nsys0 and sys.ji. To see what commands are running at the time of failure, use make VERBOSE=1.\n\nAt the time of this writing, you can debug build errors during the sys0 phase from the base\ndirectory using:\n\njulia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys0 sysimg.jl\n\nYou might need to delete all the files in usr/lib/julia/ to get this to work.\n\nYou can debug the sys.ji phase using:\n\njulia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys -J ../usr/lib/julia/sys0.ji sysimg.jl\n\nBy default, any errors will cause Julia to exit, even under gdb. To catch an error \"in the act\",\nset a breakpoint in jl_error (there are several other useful spots, for specific kinds of failures,\nincluding: jl_too_few_args, jl_too_many_args, and jl_throw).\n\nOnce an error is caught, a useful technique is to walk up the stack and examine the function by\ninspecting the related call to jl_apply. To take a real-world example:\n\nBreakpoint 1, jl_throw (e=0x7ffdf42de400) at task.c:802\n802 {\n(gdb) p jl_(e)\nErrorException(\"auto_unbox: unable to determine argument type\")\n$2 = void\n(gdb) bt 10\n#0  jl_throw (e=0x7ffdf42de400) at task.c:802\n#1  0x00007ffff65412fe in jl_error (str=0x7ffde56be000 <_j_str267> \"auto_unbox:\n   unable to determine argument type\")\n   at builtins.c:39\n#2  0x00007ffde56bd01a in julia_convert_16886 ()\n#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281\n...\n\nThe most recent jl_apply is at frame #3, so we can go back there and look at the AST for the\nfunction julia_convert_16886. This is the uniqued name for some method of convert. f in\nthis frame is a jl_value_t*, so we can look at the type signature, if any, from the specTypes\nfield:\n\n(gdb) f 3\n#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281\n1281            return f->fptr((jl_value_t*)f, args, nargs);\n(gdb) p f->linfo->specTypes\n$4 = (jl_tupletype_t *) 0x7ffdf39b1030\n(gdb) p jl_( f->linfo->specTypes )\nTuple{Type{Float32}, Float64}           # <-- type signature for julia_convert_16886\n\nThen, we can look at the AST for this function:\n\n(gdb) p jl_( jl_uncompress_ast(f->linfo, f->linfo->ast) )\nExpr(:lambda, Array{Any, 1}[:#s29, :x], Array{Any, 1}[Array{Any, 1}[], Array{Any, 1}[Array{Any, 1}[:#s29, :Any, 0], Array{Any, 1}[:x, :Any, 0]], Array{Any, 1}[], 0], Expr(:body,\nExpr(:line, 90, :float.jl)::Any,\nExpr(:return, Expr(:call, :box, :Float32, Expr(:call, :fptrunc, :Float32, :x)::Any)::Any)::Any)::Any)::Any\n\nFinally, and perhaps most usefully, we can force the function to be recompiled in order to step\nthrough the codegen process. To do this, clear the cached functionObject from the jl_lambda_info_t*:\n\n(gdb) p f->linfo->functionObject\n$8 = (void *) 0x1289d070\n(gdb) set f->linfo->functionObject = NULL\n\nThen, set a breakpoint somewhere useful (e.g. emit_function, emit_expr, emit_call, etc.),\nand run codegen:\n\n(gdb) p jl_compile(f)\n... # your breakpoint here"},{"title":"Debugging precompilation errors","page":"gdb debugging tips","location":"devdocs/debuggingtips.html#Debugging-precompilation-errors","category":"section","text":"Module precompilation spawns a separate Julia process to precompile each module. Setting a breakpoint\nor catching failures in a precompile worker requires attaching a debugger to the worker. The easiest\napproach is to set the debugger watch for new process launches matching a given name. For example:\n\n(gdb) attach -w -n julia-debug\n\nor:\n\n(lldb) process attach -w -n julia-debug\n\nThen run a script/command to start precompilation. As described earlier, use conditional breakpoints\nin the parent process to catch specific file-loading events and narrow the debugging window. (some\noperating systems may require alternative approaches, such as following each fork from the parent\nprocess)"},{"title":"Mozilla's Record and Replay Framework (rr)","page":"gdb debugging tips","location":"devdocs/debuggingtips.html#Mozilla's-Record-and-Replay-Framework-(rr)","category":"section","text":"Julia now works out of the box with rr, the lightweight recording and\ndeterministic debugging framework from Mozilla. This allows you to replay the trace of an execution\ndeterministically. The replayed execution's address spaces, register contents, syscall data etc\nare exactly the same in every run.\n\nA recent version of rr (3.1.0 or higher) is required."},{"title":"Reproducing concurrency bugs with rr","page":"gdb debugging tips","location":"devdocs/debuggingtips.html#Reproducing-concurrency-bugs-with-rr","category":"section","text":"rr simulates a single-threaded machine by default. In order to debug concurrent\ncode you can use rr record --chaos which will cause rr to simulate between\none to eight cores, chosen randomly. You might therefore want to set JULIA_NUM_THREADS=8\nand rerun your code under rr until you have caught your bug."},{"title":"RISC-V (Linux)","page":"RISC-V (Linux)","location":"devdocs/build/riscv.html#RISC-V-(Linux)","category":"section","text":"Julia has experimental support for 64-bit RISC-V (RV64) processors running\nLinux. This file provides general guidelines for compilation, in addition to\ninstructions for specific devices.\n\nA list of known issues\nfor RISC-V is available. If you encounter difficulties, please create an issue\nincluding the output from cat /proc/cpuinfo."},{"title":"Compiling Julia","page":"RISC-V (Linux)","location":"devdocs/build/riscv.html#Compiling-Julia","category":"section","text":"To compilie Julia for RISC-V, you need to manually indicate what architecture, and\noptionally which CPU to build for. This can be done by setting the MARCH and MCPU\nvariables in Make.user\n\nThe MARCH variable needs to be set to a RISC-V ISA string, which can be found by\nlooking at the documentation of your device, or by inspecting /proc/cpuinfo. Only\nuse flags that your compiler supports, e.g., run gcc -march=help to see a list of\nsupported flags. A common value is rv64gc, which is a good starting point.\n\nThe MCPU variable is optional, and can be used to further optimize the\ngenerated code for a specific CPU. If you are unsure, it is recommended to leave\nit unset. You can find a list of supported values by running gcc --target-help.\n\nFor example, if you are using a StarFive VisionFive2, which contains a JH7110\nprocessor based on the SiFive U74, you can set these flags as follows:\n\nMARCH := rv64gc_zba_zbb\nMCPU := sifive-u74\n\nIf you prefer a portable build, you could use:\n\nMARCH := rv64gc\n\n# also set JULIA_CPU_TARGET to the expanded form of rv64gc\n# (it normally copies the value of MCPU, which we don't set)\nJULIA_CPU_TARGET := generic-rv64,i,m,a,f,d,zicsr,zifencei,c"},{"title":"Cross-compilation","page":"RISC-V (Linux)","location":"devdocs/build/riscv.html#Cross-compilation","category":"section","text":"A native build on a RISC-V device may take a very long time, so it's also\npossible to cross-compile Julia on a faster machine.\n\nFirst, get a hold of a RISC-V cross-compilation toolchain that provides\nsupport for C, C++ and Fortran. This can be done by checking-out the\nriscv-gnu-toolchain\nrepository and building it as follows:\n\nsudo mkdir /opt/riscv && sudo chown $USER /opt/riscv\n./configure --prefix=/opt/riscv --with-languages=c,c++,fortran\nmake linux -j$(nproc)\n\nThen, install the QEMU user-mode emulator for RISC-V, along with binfmt\nsupport to enable execution of RISC-V binaries on the host machine. The\nexact steps depend on your distribution, e.g., on Arch Linux it involves\ninstalling the qemu-user-static and qemu-user-static-binfmt packages.\nNote that to actually execute RISC-V binaries, QEMU will need to be able to\nfind the RISC-V system root, which can be achieved by setting the\nQEMU_LD_PREFIX environment variable to the path of the root filesystem.\n\nFinally, compile Julia with the following Make.user variables (in addition to\nthe ones from the previous section):\n\nXC_HOST=riscv64-unknown-linux-gnu\nOS=Linux\nexport QEMU_LD_PREFIX=/opt/riscv/sysroot\n\nNote that you will have to execute make with PATH set to include the\ncross-compilation toolchain, e.g., by running:\n\nPATH=/opt/riscv/bin:$PATH make -j$(nproc)\n\nBecause of the RISC-V sysroot we use being very barren, you may need to\nadd additional libraries that the Julia build system currently expects\nto be available system-wide. For example, the build currently relies on\na system-provided libz, so you may need to copy this library from the\nJulia build into the system root:\n\nmake -C deps install-zlib\ncp -v usr/lib/libz.*   /opt/riscv/sysroot/usr/lib\ncp -v usr/include/z*.h /opt/riscv/sysroot/usr/include"},{"title":"Strings","page":"Strings","location":"base/strings.html#lib-strings","category":"section","text":"This section gives a reference list of string related functions in Julia's Base\nmodule. For a general introduction to strings in Julia language, please refer to the\nStrings section of the Julia language manual."},{"title":"Characters","page":"Strings","location":"base/strings.html#Characters","category":"section","text":""},{"title":"String Basics","page":"Strings","location":"base/strings.html#String-Basics","category":"section","text":""},{"title":"Concatenation","page":"Strings","location":"base/strings.html#Concatenation","category":"section","text":""},{"title":"Comparison","page":"Strings","location":"base/strings.html#Comparison","category":"section","text":""},{"title":"Encoding","page":"Strings","location":"base/strings.html#Encoding","category":"section","text":""},{"title":"Non-Standard String Literals","page":"Strings","location":"base/strings.html#Non-Standard-String-Literals","category":"section","text":"This section describes several additional string types, and also\nnon-standard string literals.\nThe list here is not exhaustive, for example there are also\nversion number literals of the form v\"...\",\nmarkdown string literals of the form md\"...\", and\nregular expressions and substitution string literals."},{"title":"Regular Expressions","page":"Strings","location":"base/strings.html#base-regex-literals","category":"section","text":"See also the Julia manual section about this topic."},{"title":"Padding, Truncating, Chopping and Stripping","page":"Strings","location":"base/strings.html#Padding,-Truncating,-Chopping-and-Stripping","category":"section","text":""},{"title":"Splitting and Joining","page":"Strings","location":"base/strings.html#Splitting-and-Joining","category":"section","text":""},{"title":"Find and Replace","page":"Strings","location":"base/strings.html#Find-and-Replace","category":"section","text":"See also the section about regular expressions."},{"title":"Transforming Strings","page":"Strings","location":"base/strings.html#Transforming-Strings","category":"section","text":""},{"title":"Annotated Strings","page":"Strings","location":"base/strings.html#base-annotated-strings","category":"section","text":"note: Note\nThe API for AnnotatedStrings is considered experimental and is subject to change between\nJulia versions."},{"title":"Core.AbstractChar","page":"Strings","location":"base/strings.html#Core.AbstractChar","category":"type","text":"The AbstractChar type is the supertype of all character implementations\nin Julia. A character normally represents a Unicode codepoint (and can\nalso encapsulate other information from an encoded byte sequence as described below),\nand characters can be converted to integer codepoint values via the codepoint\nfunction, or can be constructed from the same integer.  At least for valid,\nproperly encoded Unicode characters, these numerical codepoint values\ndetermine how characters are compared with < and ==, for example.\nNew T <: AbstractChar types should define a codepoint(::T)\nmethod and a T(::UInt32) constructor, at minimum.\n\nA given AbstractChar subtype may be capable of representing only a subset\nof Unicode, in which case conversion from an unsupported UInt32 value\nmay throw an error. Conversely, the built-in Char type represents\na superset of Unicode (in order to losslessly encode invalid byte streams),\nin which case conversion of a non-Unicode value to UInt32 throws an error\n(see Base.ismalformed), and on the other hand a Char can also represent\na nonstandard \"overlong\" encoding (Base.isoverlong) of a codepoint.\nThe isvalid function can be used to check which codepoints are\nrepresentable in a given AbstractChar type.\n\nInternally, an AbstractChar type may use a variety of encodings.  Conversion\nvia codepoint(char) will not reveal this encoding because it always returns the\nUnicode value of the character. print(io, c) of any c::AbstractChar\nproduces an encoding determined by io (UTF-8 for all built-in IO\ntypes), via conversion to Char if necessary.\n\nwrite(io, c), in contrast, may emit an encoding depending on\ntypeof(c), and read(io, typeof(c)) should read the same encoding as write.\nNew AbstractChar types must provide their own implementations of\nwrite and read.\n\n\n\n\n\n"},{"title":"Core.Char","page":"Strings","location":"base/strings.html#Core.Char","category":"type","text":"Char(c::Union{Number,AbstractChar})\n\nChar is a 32-bit AbstractChar type that is the default representation\nof characters in Julia. Char is the type used for character literals like 'x'\nand it is also the element type of String.\n\nIn order to losslessly represent arbitrary byte streams stored in a String,\na Char value may store information that cannot be converted to a Unicode\ncodepoint — converting such a Char to UInt32 will throw an error.\nThe isvalid(c::Char) function can be used to query whether c\nrepresents a valid Unicode character.\n\n\n\n\n\n"},{"title":"Base.codepoint","page":"Strings","location":"base/strings.html#Base.codepoint","category":"function","text":"codepoint(c::AbstractChar)::Integer\n\nReturn the Unicode codepoint (an unsigned integer) corresponding\nto the character c (or throw an exception if c represents\na malformed character). For Char, this is a UInt32 value, but\nAbstractChar types that represent only a subset of Unicode may\nreturn a different-sized integer (e.g. UInt8).\n\nShould succeed for any non-malformed character, i.e. when\nBase.ismalformed(c) returns false.   This includes\ninvalid Unicode characters (such as unpaired surrogates)\nand overlong encodings.\n\ncompat: Julia 1.12\nPrior to Julia 1.12, codepoint(c) fails for overlong encodings (when\nBase.isoverlong(c) is true), and Base.decode_overlong(c) was needed.\n\n\n\n\n\n"},{"title":"Base.Unicode.iscntrl","page":"Strings","location":"base/strings.html#Base.Unicode.iscntrl","category":"function","text":"iscntrl(c::AbstractChar)::Bool\n\nTests whether a character is a control character.\nControl characters are the non-printing characters of the Latin-1 subset of Unicode.\n\nExamples\n\njulia> iscntrl('\\x01')\ntrue\n\njulia> iscntrl('a')\nfalse\n\n\n\n\n\n"},{"title":"Base.Unicode.isdigit","page":"Strings","location":"base/strings.html#Base.Unicode.isdigit","category":"function","text":"isdigit(c::AbstractChar)::Bool\n\nTests whether a character is an ASCII decimal digit (0-9).\n\nSee also: isletter.\n\nExamples\n\njulia> isdigit('❤')\nfalse\n\njulia> isdigit('9')\ntrue\n\njulia> isdigit('α')\nfalse\n\n\n\n\n\n"},{"title":"Base.Unicode.isletter","page":"Strings","location":"base/strings.html#Base.Unicode.isletter","category":"function","text":"isletter(c::AbstractChar)::Bool\n\nTest whether a character is a letter.\nA character is classified as a letter if it belongs to the Unicode general\ncategory Letter, i.e. a character whose category code begins with 'L'.\n\nSee also: isdigit.\n\nExamples\n\njulia> isletter('❤')\nfalse\n\njulia> isletter('α')\ntrue\n\njulia> isletter('9')\nfalse\n\n\n\n\n\n"},{"title":"Base.Unicode.islowercase","page":"Strings","location":"base/strings.html#Base.Unicode.islowercase","category":"function","text":"islowercase(c::AbstractChar)::Bool\n\nTests whether a character is a lowercase letter (according to the Unicode\nstandard's Lowercase derived property).\n\nSee also isuppercase.\n\nExamples\n\njulia> islowercase('α')\ntrue\n\njulia> islowercase('Γ')\nfalse\n\njulia> islowercase('❤')\nfalse\n\n\n\n\n\n"},{"title":"Base.Unicode.isnumeric","page":"Strings","location":"base/strings.html#Base.Unicode.isnumeric","category":"function","text":"isnumeric(c::AbstractChar)::Bool\n\nTests whether a character is numeric.\nA character is classified as numeric if it belongs to the Unicode general category Number,\ni.e. a character whose category code begins with 'N'.\n\nNote that this broad category includes characters such as ¾ and ௰.\nUse isdigit to check whether a character is a decimal digit between 0 and 9.\n\nExamples\n\njulia> isnumeric('௰')\ntrue\n\njulia> isnumeric('9')\ntrue\n\njulia> isnumeric('α')\nfalse\n\njulia> isnumeric('❤')\nfalse\n\n\n\n\n\n"},{"title":"Base.Unicode.isprint","page":"Strings","location":"base/strings.html#Base.Unicode.isprint","category":"function","text":"isprint(c::AbstractChar)::Bool\n\nTests whether a character is printable, including spaces, but not a control character.\n\nExamples\n\njulia> isprint('\\x01')\nfalse\n\njulia> isprint('A')\ntrue\n\n\n\n\n\n"},{"title":"Base.Unicode.ispunct","page":"Strings","location":"base/strings.html#Base.Unicode.ispunct","category":"function","text":"ispunct(c::AbstractChar)::Bool\n\nTests whether a character belongs to the Unicode general category Punctuation, i.e. a\ncharacter whose category code begins with 'P'.\n\nnote: Note\nThis behavior is different from the ispunct function in C.\n\nExamples\n\njulia> ispunct('α')\nfalse\n\njulia> ispunct('=')\nfalse\n\njulia> ispunct('/')\ntrue\n\njulia> ispunct(';')\ntrue\n\n\n\n\n\n"},{"title":"Base.Unicode.isspace","page":"Strings","location":"base/strings.html#Base.Unicode.isspace","category":"function","text":"isspace(c::AbstractChar)::Bool\n\nTests whether a character is any whitespace character. Includes ASCII characters '\\t',\n'\\n', '\\v', '\\f', '\\r', and ' ', Latin-1 character U+0085, and characters in Unicode\ncategory Zs.\n\nExamples\n\njulia> isspace('\\n')\ntrue\n\njulia> isspace('\\r')\ntrue\n\njulia> isspace(' ')\ntrue\n\njulia> isspace('\\x20')\ntrue\n\n\n\n\n\n"},{"title":"Base.Unicode.isuppercase","page":"Strings","location":"base/strings.html#Base.Unicode.isuppercase","category":"function","text":"isuppercase(c::AbstractChar)::Bool\n\nTests whether a character is an uppercase letter (according to the Unicode\nstandard's Uppercase derived property).\n\nSee also islowercase.\n\nExamples\n\njulia> isuppercase('γ')\nfalse\n\njulia> isuppercase('Γ')\ntrue\n\njulia> isuppercase('❤')\nfalse\n\n\n\n\n\n"},{"title":"Base.Unicode.isxdigit","page":"Strings","location":"base/strings.html#Base.Unicode.isxdigit","category":"function","text":"isxdigit(c::AbstractChar)::Bool\n\nTest whether a character is a valid hexadecimal digit. Note that this does not\ninclude x (as in the standard 0x prefix).\n\nExamples\n\njulia> isxdigit('a')\ntrue\n\njulia> isxdigit('x')\nfalse\n\n\n\n\n\n"},{"title":"Core.AbstractString","page":"Strings","location":"base/strings.html#Core.AbstractString","category":"type","text":"The AbstractString type is the supertype of all string implementations in\nJulia. Strings are encodings of sequences of Unicode\ncode points as represented by the AbstractChar type. Julia makes a few assumptions\nabout strings:\n\nStrings are encoded in terms of fixed-size \"code units\"\nCode units can be extracted with codeunit(s, i)\nThe first code unit has index 1\nThe last code unit has index ncodeunits(s)\nAny index i such that 1 ≤ i ≤ ncodeunits(s) is in bounds\nString indexing is done in terms of these code units:\nCharacters are extracted by s[i] with a valid string index i\nEach AbstractChar in a string is encoded by one or more code units\nOnly the index of the first code unit of an AbstractChar is a valid index\nThe encoding of an AbstractChar is independent of what precedes or follows it\nString encodings are self-synchronizing – i.e. isvalid(s, i) is O(1)\n\nSome string functions that extract code units, characters or substrings from\nstrings error if you pass them out-of-bounds or invalid string indices. This\nincludes codeunit(s, i) and s[i]. Functions that do string\nindex arithmetic take a more relaxed approach to indexing and give you the\nclosest valid string index when in-bounds, or when out-of-bounds, behave as if\nthere were an infinite number of characters padding each side of the string.\nUsually these imaginary padding characters have code unit length 1 but string\ntypes may choose different \"imaginary\" character sizes as makes sense for their\nimplementations (e.g. substrings may pass index arithmetic through to the\nunderlying string they provide a view into). Relaxed indexing functions include\nthose intended for index arithmetic: thisind, nextind and prevind. This\nmodel allows index arithmetic to work with out-of-bounds indices as\nintermediate values so long as one never uses them to retrieve a character,\nwhich often helps avoid needing to code around edge cases.\n\nSee also codeunit, ncodeunits, thisind,\nnextind, prevind.\n\n\n\n\n\n"},{"title":"Core.String","page":"Strings","location":"base/strings.html#Core.String","category":"type","text":"String <: AbstractString\n\nThe default string type in Julia, used by e.g. string literals.\n\nStrings are immutable sequences of Chars. A String is stored internally as\na contiguous byte array, and while they are interpreted as being UTF-8 encoded,\nthey can be composed of any byte sequence. Use isvalid to validate\nthat the underlying byte sequence is valid as UTF-8.\n\n\n\n\n\n"},{"title":"Base.string","page":"Strings","location":"base/strings.html#Base.string","category":"function","text":"string(xs...)\n\nCreate a string from any values using the print function.\n\nstring should usually not be defined directly. Instead, define a method\nprint(io::IO, x::MyType). If string(x) for a certain type needs to be\nhighly efficient, then it may make sense to add a method to string and\ndefine print(io::IO, x::MyType) = print(io, string(x)) to ensure the\nfunctions are consistent.\n\nSee also: String, repr, sprint, show.\n\nExamples\n\njulia> string(\"a\", 1, true)\n\"a1true\"\n\n\n\n\n\nstring(n::Integer; base::Integer = 10, pad::Integer = 1)\n\nConvert an integer n to a string in the given base,\noptionally specifying a number of digits to pad to.\n\nSee also digits, bitstring, count_zeros,\nand the Printf standard library.\n\nExamples\n\njulia> string(5, base = 13, pad = 4)\n\"0005\"\n\njulia> string(-13, base = 5, pad = 4)\n\"-0023\"\n\njulia> using Printf\n\njulia> @sprintf(\"%04i\", 5)\n\"0005\"\n\njulia> @sprintf(\"%4i\", 5)\n\"   5\"\n\n\n\n\n\n"},{"title":"Base.repr","page":"Strings","location":"base/strings.html#Base.repr-Tuple{Any}","category":"method","text":"repr(x; context=nothing)\n\nCreate a string representation of any value using the 2-argument show(io, x) function,\nwhich aims to produce a string that is parseable Julia code, where possible.\ni.e. eval(Meta.parse(repr(x))) == x should hold true.\nYou should not add methods to repr; define a show method instead.\n\nThe optional keyword argument context can be set to a :key=>value pair, a\ntuple of :key=>value pairs, or an IO or IOContext object whose\nattributes are used for the I/O stream passed to show.\n\nNote that repr(x) is usually similar to how the value of x would\nbe entered in Julia.  See also repr(MIME(\"text/plain\"), x) to instead\nreturn a \"pretty-printed\" version of x designed more for human consumption,\nequivalent to the REPL display of x, using the 3-argument show(io, mime, x).\n\ncompat: Julia 1.7\nPassing a tuple to keyword context requires Julia 1.7 or later.\n\nExamples\n\njulia> repr(1)\n\"1\"\n\njulia> repr(zeros(3))\n\"[0.0, 0.0, 0.0]\"\n\njulia> repr(big(1/3))\n\"0.333333333333333314829616256247390992939472198486328125\"\n\njulia> repr(big(1/3), context=:compact => true)\n\"0.333333\"\n\n\n\n\n\n\n"},{"title":"Core.String","page":"Strings","location":"base/strings.html#Core.String-Tuple{AbstractString}","category":"method","text":"String(s::AbstractString)\n\nCreate a new String from an existing AbstractString.\n\n\n\n\n\n"},{"title":"Base.length","page":"Strings","location":"base/strings.html#Base.length-Tuple{AbstractString}","category":"method","text":"length(s::AbstractString)::Int\nlength(s::AbstractString, i::Integer, j::Integer)::Int\n\nReturn the number of characters in string s from indices i through j.\n\nThis is computed as the number of code unit indices from i to j which are\nvalid character indices. With only a single string argument, this computes\nthe number of characters in the entire string. With i and j arguments it\ncomputes the number of indices between i and j inclusive that are valid\nindices in the string s. In addition to in-bounds values, i may take the\nout-of-bounds value ncodeunits(s) + 1 and j may take the out-of-bounds\nvalue 0.\n\nnote: Note\nThe time complexity of this operation is linear in general. That is, it\nwill take the time proportional to the number of bytes or characters in\nthe string because it counts the value on the fly. This is in contrast to\nthe method for arrays, which is a constant-time operation.\n\nSee also isvalid, ncodeunits, lastindex,\nthisind, nextind, prevind.\n\nExamples\n\njulia> length(\"jμΛIα\")\n5\n\n\n\n\n\n"},{"title":"Base.sizeof","page":"Strings","location":"base/strings.html#Base.sizeof-Tuple{AbstractString}","category":"method","text":"sizeof(str::AbstractString)\n\nSize, in bytes, of the string str. Equal to the number of code units in str multiplied by\nthe size, in bytes, of one code unit in str.\n\nExamples\n\njulia> sizeof(\"\")\n0\n\njulia> sizeof(\"∀\")\n3\n\n\n\n\n\n"},{"title":"Base.Unicode.textwidth","page":"Strings","location":"base/strings.html#Base.Unicode.textwidth","category":"function","text":"textwidth(s::AbstractString)\n\nGive the number of columns needed to print a string.\n\nExamples\n\njulia> textwidth(\"March\")\n5\n\n\n\n\n\ntextwidth(c)\n\nGive the number of columns needed to print a character.\n\nExamples\n\njulia> textwidth('α')\n1\n\njulia> textwidth('⛵')\n2\n\n\n\n\n\n"},{"title":"Base.SubString","page":"Strings","location":"base/strings.html#Base.SubString","category":"type","text":"SubString(s::AbstractString, i::Integer, j::Integer=lastindex(s))\nSubString(s::AbstractString, r::UnitRange{<:Integer})\n\nLike getindex, but returns a view into the parent string s\nwithin range i:j or r respectively instead of making a copy.\n\nThe @views macro converts any string slices s[i:j] into\nsubstrings SubString(s, i, j) in a block of code.\n\nExamples\n\njulia> SubString(\"abc\", 1, 2)\n\"ab\"\n\njulia> SubString(\"abc\", 1:2)\n\"ab\"\n\njulia> SubString(\"abc\", 2)\n\"bc\"\n\n\n\n\n\n"},{"title":"Base.LazyString","page":"Strings","location":"base/strings.html#Base.LazyString","category":"type","text":"LazyString <: AbstractString\n\nA lazy representation of string interpolation. This is useful when a string\nneeds to be constructed in a context where performing the actual interpolation\nand string construction is unnecessary or undesirable (e.g. in error paths\nof functions).\n\nThis type is designed to be cheap to construct at runtime, trying to offload\nas much work as possible to either the macro or later printing operations.\n\nExamples\n\njulia> n = 5; str = LazyString(\"n is \", n)\n\"n is 5\"\n\nSee also @lazy_str.\n\ncompat: Julia 1.8\nLazyString requires Julia 1.8 or later.\n\nExtended help\n\nSafety properties for concurrent programs\n\nA lazy string itself does not introduce any concurrency problems even if it is printed in\nmultiple Julia tasks.  However, if print methods on a captured value can have a\nconcurrency issue when invoked without synchronizations, printing the lazy string may cause\nan issue.  Furthermore, the print methods on the captured values may be invoked multiple\ntimes, though only exactly one result will be returned.\n\ncompat: Julia 1.9\nLazyString is safe in the above sense in Julia 1.9 and later.\n\n\n\n\n\n"},{"title":"Base.:*","page":"Strings","location":"base/strings.html#Base.:*-Tuple{Union{AbstractChar, AbstractString}, Vararg{Union{AbstractChar, AbstractString}}}","category":"method","text":"*(s::Union{AbstractString, AbstractChar}, t::Union{AbstractString, AbstractChar}...)::AbstractString\n\nConcatenate strings and/or characters, producing a String or\nAnnotatedString (as appropriate). This is equivalent to calling the\nstring or annotatedstring function on the arguments. Concatenation of built-in string\ntypes always produces a value of type String but other string types may choose\nto return a string of a different type as appropriate.\n\nExamples\n\njulia> \"Hello \" * \"world\"\n\"Hello world\"\n\njulia> 'j' * \"ulia\"\n\"julia\"\n\n\n\n\n\n"},{"title":"Base.:^","page":"Strings","location":"base/strings.html#Base.:^-Tuple{Union{AbstractChar, AbstractString}, Integer}","category":"method","text":"^(s::Union{AbstractString,AbstractChar}, n::Integer)::AbstractString\n\nRepeat a string or character n times. This can also be written as repeat(s, n).\n\nSee also repeat.\n\nExamples\n\njulia> \"Test \"^3\n\"Test Test Test \"\n\n\n\n\n\n"},{"title":"Base.repeat","page":"Strings","location":"base/strings.html#Base.repeat-Tuple{AbstractString, Integer}","category":"method","text":"repeat(s::AbstractString, r::Integer)\n\nRepeat a string r times. This can be written as s^r.\n\nSee also ^.\n\nExamples\n\njulia> repeat(\"ha\", 3)\n\"hahaha\"\n\n\n\n\n\n"},{"title":"Base.repeat","page":"Strings","location":"base/strings.html#Base.repeat-Tuple{AbstractChar, Integer}","category":"method","text":"repeat(c::AbstractChar, r::Integer)::String\n\nRepeat a character r times. This can equivalently be accomplished by calling\nc^r.\n\nExamples\n\njulia> repeat('A', 3)\n\"AAA\"\n\n\n\n\n\n"},{"title":"Base.isless","page":"Strings","location":"base/strings.html#Base.isless-Tuple{AbstractString, AbstractString}","category":"method","text":"isless(a::AbstractString, b::AbstractString)::Bool\n\nTest whether string a comes before string b in alphabetical order\n(technically, in lexicographical order by Unicode code points).\n\nExamples\n\njulia> isless(\"a\", \"b\")\ntrue\n\njulia> isless(\"β\", \"α\")\nfalse\n\njulia> isless(\"a\", \"a\")\nfalse\n\n\n\n\n\n"},{"title":"Base.:==","page":"Strings","location":"base/strings.html#Base.:==-Tuple{AbstractString, AbstractString}","category":"method","text":"==(a::AbstractString, b::AbstractString)::Bool\n\nTest whether two strings are equal character by character (technically, Unicode\ncode point by code point). Should either string be a AnnotatedString the\nstring properties must match too.\n\nExamples\n\njulia> \"abc\" == \"abc\"\ntrue\n\njulia> \"abc\" == \"αβγ\"\nfalse\n\n\n\n\n\n"},{"title":"Base.cmp","page":"Strings","location":"base/strings.html#Base.cmp-Tuple{AbstractString, AbstractString}","category":"method","text":"cmp(a::AbstractString, b::AbstractString)::Int\n\nCompare two strings. Return 0 if both strings have the same length and the character\nat each index is the same in both strings. Return -1 if a is a prefix of b, or if\na comes before b in alphabetical order. Return 1 if b is a prefix of a, or if\nb comes before a in alphabetical order (technically, lexicographical order by Unicode\ncode points).\n\nExamples\n\njulia> cmp(\"abc\", \"abc\")\n0\n\njulia> cmp(\"ab\", \"abc\")\n-1\n\njulia> cmp(\"abc\", \"ab\")\n1\n\njulia> cmp(\"ab\", \"ac\")\n-1\n\njulia> cmp(\"ac\", \"ab\")\n1\n\njulia> cmp(\"α\", \"a\")\n1\n\njulia> cmp(\"b\", \"β\")\n-1\n\n\n\n\n\n"},{"title":"Base.transcode","page":"Strings","location":"base/strings.html#Base.transcode","category":"function","text":"transcode(T, src)\n\nConvert string data between Unicode encodings. src is either a\nString or a Vector{UIntXX} of UTF-XX code units, where\nXX is 8, 16, or 32. T indicates the encoding of the return value:\nString to return a (UTF-8 encoded) String or UIntXX\nto return a Vector{UIntXX} of UTF-XX data. (The alias Cwchar_t\ncan also be used as the integer type, for converting wchar_t* strings\nused by external C libraries.)\n\nThe transcode function succeeds as long as the input data can be\nreasonably represented in the target encoding; it always succeeds for\nconversions between UTF-XX encodings, even for invalid Unicode data.\n\nOnly conversion to/from UTF-8 is currently supported.\n\nExamples\n\njulia> str = \"αβγ\"\n\"αβγ\"\n\njulia> transcode(UInt16, str)\n3-element Vector{UInt16}:\n 0x03b1\n 0x03b2\n 0x03b3\n\njulia> transcode(String, transcode(UInt16, str))\n\"αβγ\"\n\n\n\n\n\n"},{"title":"Base.ncodeunits","page":"Strings","location":"base/strings.html#Base.ncodeunits-Tuple{AbstractString}","category":"method","text":"ncodeunits(s::AbstractString)::Int\n\nReturn the number of code units in a string. Indices that are in bounds to\naccess this string must satisfy 1 ≤ i ≤ ncodeunits(s). Not all such indices\nare valid – they may not be the start of a character, but they will return a\ncode unit value when calling codeunit(s,i).\n\nExamples\n\njulia> ncodeunits(\"The Julia Language\")\n18\n\njulia> ncodeunits(\"∫eˣ\")\n6\n\njulia> ncodeunits('∫'), ncodeunits('e'), ncodeunits('ˣ')\n(3, 1, 2)\n\nSee also codeunit, checkbounds, sizeof,\nlength, lastindex.\n\n\n\n\n\n"},{"title":"Base.codeunit","page":"Strings","location":"base/strings.html#Base.codeunit","category":"function","text":"codeunit(s::AbstractString, i::Integer)::Union{UInt8, UInt16, UInt32}\n\nReturn the code unit value in the string s at index i. Note that\n\ncodeunit(s, i) :: codeunit(s)\n\nI.e. the value returned by codeunit(s, i) is of the type returned by\ncodeunit(s).\n\nExamples\n\njulia> a = codeunit(\"Hello\", 2)\n0x65\n\njulia> typeof(a)\nUInt8\n\nSee also ncodeunits, checkbounds.\n\n\n\n\n\ncodeunit(s::AbstractString)::Type{<:Union{UInt8, UInt16, UInt32}}\n\nReturn the code unit type of the given string object. For ASCII, Latin-1, or\nUTF-8 encoded strings, this would be UInt8; for UCS-2 and UTF-16 it would be\nUInt16; for UTF-32 it would be UInt32. The code unit type need not be\nlimited to these three types, but it's hard to think of widely used string\nencodings that don't use one of these units. codeunit(s) is the same as\ntypeof(codeunit(s,1)) when s is a non-empty string.\n\nSee also ncodeunits.\n\n\n\n\n\n"},{"title":"Base.codeunits","page":"Strings","location":"base/strings.html#Base.codeunits","category":"function","text":"codeunits(s::AbstractString)\n\nObtain a vector-like object containing the code units of a string.\nReturns a CodeUnits wrapper by default, but codeunits may optionally be defined\nfor new string types if necessary.\n\nExamples\n\njulia> codeunits(\"Juλia\")\n6-element Base.CodeUnits{UInt8, String}:\n 0x4a\n 0x75\n 0xce\n 0xbb\n 0x69\n 0x61\n\n\n\n\n\n"},{"title":"Base.ascii","page":"Strings","location":"base/strings.html#Base.ascii","category":"function","text":"ascii(s::AbstractString)\n\nConvert a string to String type and check that it contains only ASCII data, otherwise\nthrowing an ArgumentError indicating the position of the first non-ASCII byte.\n\nSee also the isascii predicate to filter or replace non-ASCII characters.\n\nExamples\n\njulia> ascii(\"abcdeγfgh\")\nERROR: ArgumentError: invalid ASCII at index 6 in \"abcdeγfgh\"\nStacktrace:\n[...]\n\njulia> ascii(\"abcdefgh\")\n\"abcdefgh\"\n\n\n\n\n\n"},{"title":"Base.isascii","page":"Strings","location":"base/strings.html#Base.isascii","category":"function","text":"isascii(cu::AbstractVector{CU}) where {CU <: Integer}::Bool\n\nTest whether all values in the vector belong to the ASCII character set (0x00 to 0x7f).\nThis function is intended to be used by other string implementations that need a fast ASCII check.\n\n\n\n\n\nisascii(c::Union{AbstractChar,AbstractString})::Bool\n\nTest whether a character belongs to the ASCII character set, or whether this is true for\nall elements of a string.\n\nExamples\n\njulia> isascii('a')\ntrue\n\njulia> isascii('α')\nfalse\n\njulia> isascii(\"abc\")\ntrue\n\njulia> isascii(\"αβγ\")\nfalse\n\nFor example, isascii can be used as a predicate function for filter or replace\nto remove or replace non-ASCII characters, respectively:\n\njulia> filter(isascii, \"abcdeγfgh\") # discard non-ASCII chars\n\"abcdefgh\"\n\njulia> replace(\"abcdeγfgh\", !isascii=>' ') # replace non-ASCII chars with spaces\n\"abcde fgh\"\n\n\n\n\n\n"},{"title":"Base.unsafe_string","page":"Strings","location":"base/strings.html#Base.unsafe_string","category":"function","text":"unsafe_string(p::Ptr{T}, [length::Integer]) where {T<:Union{UInt16,UInt32,Cwchar_t}}\nunsafe_string(p::Cwstring)\n\nTranscode a string from the address of a C-style (NUL-terminated) string encoded as UTF-16\n(T=UInt16), UTF-32 (T=UInt32), or the system-dependent wchar_t (T=Cwchar_t or Cwstring),\nreturning a String (UTF-8 encoding), similar to transcode but reading directly\nfrom a pointer.  (The pointer can be safely freed afterwards.) If length is specified\n(the length of the data in encoding units), the string does not have to be NUL-terminated.\n\nThis function is labeled \"unsafe\" because it will crash if p is not\na valid memory address to data of the requested length (or NUL-terminated data).\n\n\n\n\n\nunsafe_string(p::Ptr{UInt8}, [length::Integer])\nunsafe_string(p::Cstring)\n\nCopy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8.\n(The pointer can be safely freed afterwards.) If length is specified\n(the length of the data in bytes), the string does not have to be NUL-terminated.\n\nThis function is labeled \"unsafe\" because it will crash if p is not\na valid memory address to data of the requested length.\n\n\n\n\n\n"},{"title":"Base.thisind","page":"Strings","location":"base/strings.html#Base.thisind","category":"function","text":"thisind(s::AbstractString, i::Integer)::Int\n\nIf i is in bounds in s return the index of the start of the character whose\nencoding code unit i is part of. In other words, if i is the start of a\ncharacter, return i; if i is not the start of a character, rewind until the\nstart of a character and return that index. If i is equal to 0 or ncodeunits(s)+1\nreturn i. In all other cases throw BoundsError.\n\nExamples\n\njulia> thisind(\"α\", 0)\n0\n\njulia> thisind(\"α\", 1)\n1\n\njulia> thisind(\"α\", 2)\n1\n\njulia> thisind(\"α\", 3)\n3\n\njulia> thisind(\"α\", 4)\nERROR: BoundsError: attempt to access 2-codeunit String at index [4]\n[...]\n\njulia> thisind(\"α\", -1)\nERROR: BoundsError: attempt to access 2-codeunit String at index [-1]\n[...]\n\n\n\n\n\n"},{"title":"Base.nextind","page":"Strings","location":"base/strings.html#Base.nextind-Tuple{AbstractString, Integer, Integer}","category":"method","text":"nextind(str::AbstractString, i::Integer, n::Integer=1)::Int\n\nCase n == 1\nIf i is in bounds in str return the index of the start of the character whose\nencoding starts after index i. In other words, if i is the start of a\ncharacter, return the start of the next character; if i is not the start\nof a character, move forward until the start of a character and return that index.\nIf i is equal to 0 return 1.\nIf i is in bounds but greater or equal to lastindex(str) return ncodeunits(str)+1.\nOtherwise throw BoundsError.\nCase n > 1\nBehaves like applying n times nextind for n==1. The only difference\nis that if n is so large that applying nextind would reach ncodeunits(str)+1 then\neach remaining iteration increases the returned value by 1. This means that in this\ncase nextind can return a value greater than ncodeunits(str)+1.\nCase n == 0\nReturn i only if i is a valid index in str or is equal to 0.\nOtherwise StringIndexError or BoundsError is thrown.\n\nExamples\n\njulia> nextind(\"α\", 0)\n1\n\njulia> nextind(\"α\", 1)\n3\n\njulia> nextind(\"α\", 3)\nERROR: BoundsError: attempt to access 2-codeunit String at index [3]\n[...]\n\njulia> nextind(\"α\", 0, 2)\n3\n\njulia> nextind(\"α\", 1, 2)\n4\n\n\n\n\n\n"},{"title":"Base.prevind","page":"Strings","location":"base/strings.html#Base.prevind-Tuple{AbstractString, Integer, Integer}","category":"method","text":"prevind(str::AbstractString, i::Integer, n::Integer=1)::Int\n\nCase n == 1\nIf i is in bounds in str return the index of the start of the character whose\nencoding starts before index i. In other words, if i is the start of a\ncharacter, return the start of the previous character; if i is not the start\nof a character, rewind until the start of a character and return that index.\nIf i is equal to 1 return 0.\nIf i is equal to ncodeunits(str)+1 return lastindex(str).\nOtherwise throw BoundsError.\nCase n > 1\nBehaves like applying n times prevind for n==1. The only difference\nis that if n is so large that applying prevind would reach 0 then each remaining\niteration decreases the returned value by 1.\nThis means that in this case prevind can return a negative value.\nCase n == 0\nReturn i only if i is a valid index in str or is equal to ncodeunits(str)+1.\nOtherwise StringIndexError or BoundsError is thrown.\n\nExamples\n\njulia> prevind(\"α\", 3)\n1\n\njulia> prevind(\"α\", 1)\n0\n\njulia> prevind(\"α\", 0)\nERROR: BoundsError: attempt to access 2-codeunit String at index [0]\n[...]\n\njulia> prevind(\"α\", 2, 2)\n0\n\njulia> prevind(\"α\", 2, 3)\n-1\n\n\n\n\n\n"},{"title":"Base.isvalid","page":"Strings","location":"base/strings.html#Base.isvalid-Tuple{Any}","category":"method","text":"isvalid(value)::Bool\n\nReturn true if the given value is valid for its type, which currently can be either\nAbstractChar or String or SubString{String}.\n\nExamples\n\njulia> isvalid(Char(0xd800))\nfalse\n\njulia> isvalid(SubString(String(UInt8[0xfe,0x80,0x80,0x80,0x80,0x80]),1,2))\nfalse\n\njulia> isvalid(Char(0xd799))\ntrue\n\n\n\n\n\n"},{"title":"Base.isvalid","page":"Strings","location":"base/strings.html#Base.isvalid-Tuple{Any, Any}","category":"method","text":"isvalid(T, value)::Bool\n\nReturn true if the given value is valid for that type. Types currently can\nbe either AbstractChar or String. Values for AbstractChar can be of type AbstractChar or UInt32.\nValues for String can be of that type, SubString{String}, Vector{UInt8},\nor a contiguous subarray thereof.\n\nExamples\n\njulia> isvalid(Char, 0xd800)\nfalse\n\njulia> isvalid(String, SubString(\"thisisvalid\",1,5))\ntrue\n\njulia> isvalid(Char, 0xd799)\ntrue\n\ncompat: Julia 1.6\nSupport for subarray values was added in Julia 1.6.\n\n\n\n\n\n"},{"title":"Base.isvalid","page":"Strings","location":"base/strings.html#Base.isvalid-Tuple{AbstractString, Integer}","category":"method","text":"isvalid(s::AbstractString, i::Integer)::Bool\n\nPredicate indicating whether the given index is the start of the encoding of a\ncharacter in s or not. If isvalid(s, i) is true then s[i] will return the\ncharacter whose encoding starts at that index, if it's false, then s[i] will\nraise an invalid index error or a bounds error depending on if i is in bounds.\nIn order for isvalid(s, i) to be an O(1) function, the encoding of s must be\nself-synchronizing. This\nis a basic assumption of Julia's generic string support.\n\nSee also getindex, iterate, thisind,\nnextind, prevind, length.\n\nExamples\n\njulia> str = \"αβγdef\";\n\njulia> isvalid(str, 1)\ntrue\n\njulia> str[1]\n'α': Unicode U+03B1 (category Ll: Letter, lowercase)\n\njulia> isvalid(str, 2)\nfalse\n\njulia> str[2]\nERROR: StringIndexError: invalid index [2], valid nearby indices [1]=>'α', [3]=>'β'\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"Base.ismalformed","page":"Strings","location":"base/strings.html#Base.ismalformed","category":"function","text":"ismalformed(c::AbstractChar)::Bool\n\nReturn true if c represents malformed (non-codepoint / mis-encoded) data according to the\nencoding used by c. Defaults to false for non-Char types.\n\nAny non-malformed c can be mapped to an integer codepoint\nby codepoint(c); this includes codepoints that are\nnot valid Unicode characters (isvalid(c) is false).\nFor example, well-formed characters can include invalid Unicode\ncodepoints like '\\U110000', unpaired surrogates such as '\\ud800',\nand can also include overlong encodings (Base.isoverlong).\nMalformed data, in contrast, cannot be decoded to a codepoint\n(codepoint will throw an exception).\n\nSee also Base.show_invalid.\n\n\n\n\n\n"},{"title":"Base.isoverlong","page":"Strings","location":"base/strings.html#Base.isoverlong","category":"function","text":"isoverlong(c::AbstractChar)::Bool\n\nReturn true if c represents an overlong UTF-8 sequence. Defaults\nto false for non-Char types.\n\nSee also Base.show_invalid.\n\n\n\n\n\n"},{"title":"Base.show_invalid","page":"Strings","location":"base/strings.html#Base.show_invalid","category":"function","text":"Base.show_invalid(io::IO, c::AbstractChar)\n\nCalled by show(io, c) when isoverlong(c) or\nismalformed(c) return true.   Subclasses\nof AbstractChar should define Base.show_invalid methods\nif they support storing invalid character data.\n\n\n\n\n\n"},{"title":"Base.@lazy_str","page":"Strings","location":"base/strings.html#Base.@lazy_str","category":"macro","text":"lazy\"str\"\n\nCreate a LazyString using regular string interpolation syntax.\nNote that interpolations are evaluated at LazyString construction time,\nbut printing is delayed until the first access to the string.\n\nSee LazyString documentation for the safety properties for concurrent programs.\n\nExamples\n\njulia> n = 5; str = lazy\"n is $n\"\n\"n is 5\"\n\njulia> typeof(str)\nLazyString\n\ncompat: Julia 1.8\nlazy\"str\" requires Julia 1.8 or later.\n\n\n\n\n\n"},{"title":"Base.@raw_str","page":"Strings","location":"base/strings.html#Base.@raw_str","category":"macro","text":"@raw_str -> String\n\nCreate a raw string without interpolation and unescaping.\nThe exception is that quotation marks still must be escaped. Backslashes\nescape both quotation marks and other backslashes, but only when a sequence\nof backslashes precedes a quote character. Thus, 2n backslashes followed by\na quote encode n backslashes and the end of the literal while 2n+1 backslashes\nfollowed by a quote encode n backslashes followed by a quote character.\n\nExamples\n\njulia> println(raw\"\\ $x\")\n\\ $x\n\njulia> println(raw\"\\\"\")\n\"\n\njulia> println(raw\"\\\\\\\"\")\n\\\"\n\njulia> println(raw\"\\\\x \\\\\\\"\")\n\\\\x \\\"\n\n\n\n\n\n"},{"title":"Base.@b_str","page":"Strings","location":"base/strings.html#Base.@b_str","category":"macro","text":"@b_str\n\nCreate an immutable byte (UInt8) vector using string syntax.\n\nExamples\n\njulia> v = b\"12\\x01\\x02\"\n4-element Base.CodeUnits{UInt8, String}:\n 0x31\n 0x32\n 0x01\n 0x02\n\njulia> v[2]\n0x32\n\n\n\n\n\n"},{"title":"Base.Docs.@html_str","page":"Strings","location":"base/strings.html#Base.Docs.@html_str","category":"macro","text":"@html_str -> Docs.HTML\n\nCreate an HTML object from a literal string.\n\nExamples\n\njulia> html\"Julia\"\nHTML{String}(\"Julia\")\n\n\n\n\n\n"},{"title":"Base.Docs.@text_str","page":"Strings","location":"base/strings.html#Base.Docs.@text_str","category":"macro","text":"@text_str -> Docs.Text\n\nCreate a Text object from a literal string.\n\nExamples\n\njulia> text\"Julia\"\nJulia\n\n\n\n\n\n"},{"title":"Base.Regex","page":"Strings","location":"base/strings.html#Base.Regex","category":"type","text":"Regex(pattern[, flags]) <: AbstractPattern\n\nA type representing a regular expression. Regex objects can be used to match strings\nwith match.\n\nRegex objects can be created using the @r_str string macro. The\nRegex(pattern[, flags]) constructor is usually used if the pattern string needs\nto be interpolated. See the documentation of the string macro for details on flags.\n\nnote: Note\nTo escape interpolated variables use \\Q and \\E (e.g. Regex(\"\\\\Q$x\\\\E\"))\n\n\n\n\n\n"},{"title":"Base.@r_str","page":"Strings","location":"base/strings.html#Base.@r_str","category":"macro","text":"@r_str -> Regex\n\nConstruct a regex, such as r\"^[a-z]*$\", without interpolation and unescaping (except for\nquotation mark \" which still has to be escaped). The regex also accepts one or more flags,\nlisted after the ending quote, to change its behaviour:\n\ni enables case-insensitive matching\nm treats the ^ and $ tokens as matching the start and end of individual lines, as\nopposed to the whole string.\ns allows the . modifier to match newlines.\nx enables \"free-spacing mode\": whitespace between regex tokens is ignored except when escaped with \\,\n and # in the regex is treated as starting a comment (which is ignored to the line ending).\na enables ASCII mode (disables UTF and UCP modes). By default \\B, \\b, \\D,\n\\d, \\S, \\s, \\W, \\w, etc. match based on Unicode character properties. With\nthis option, these sequences only match ASCII characters. This includes \\u also, which\nwill emit the specified character value directly as a single byte, and not attempt to\nencode it into UTF-8. Importantly, this option allows matching against invalid UTF-8\nstrings, by treating both matcher and target as simple bytes (as if they were ISO/IEC\n8859-1 / Latin-1 bytes) instead of as character encodings. In this case, this option is\noften combined with s. This option can be further refined by starting the pattern with\n(UCP) or (UTF).\n\nSee Regex if interpolation is needed.\n\nExamples\n\njulia> match(r\"a+.*b+.*?d$\"ism, \"Goodbye,\\nOh, angry,\\nBad world\\n\")\nRegexMatch(\"angry,\\nBad world\")\n\nThis regex has the first three flags enabled.\n\n\n\n\n\n"},{"title":"Base.SubstitutionString","page":"Strings","location":"base/strings.html#Base.SubstitutionString","category":"type","text":"SubstitutionString(substr) <: AbstractString\n\nStores the given string substr as a SubstitutionString, for use in regular expression\nsubstitutions. Most commonly constructed using the @s_str macro.\n\nExamples\n\njulia> SubstitutionString(\"Hello \\\\g<name>, it's \\\\1\")\ns\"Hello \\g<name>, it's \\1\"\n\njulia> subst = s\"Hello \\g<name>, it's \\1\"\ns\"Hello \\g<name>, it's \\1\"\n\njulia> typeof(subst)\nSubstitutionString{String}\n\n\n\n\n\n"},{"title":"Base.@s_str","page":"Strings","location":"base/strings.html#Base.@s_str","category":"macro","text":"@s_str -> SubstitutionString\n\nConstruct a substitution string, used for regular expression substitutions.  Within the\nstring, sequences of the form \\N refer to the Nth capture group in the regex, and\n\\g<groupname> refers to a named capture group with name groupname.\n\nExamples\n\njulia> msg = \"#Hello# from Julia\";\n\njulia> replace(msg, r\"#(.+)# from (?<from>\\w+)\" => s\"FROM: \\g<from>; MESSAGE: \\1\")\n\"FROM: Julia; MESSAGE: Hello\"\n\n\n\n\n\n"},{"title":"Base.match","page":"Strings","location":"base/strings.html#Base.match","category":"function","text":"match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])\n\nSearch for the first match of the regular expression r in s and return a RegexMatch\nobject containing the match, or nothing if the match failed.\nThe optional idx argument specifies an index at which to start the search.\nThe matching substring can be retrieved by accessing m.match, the captured sequences can be retrieved by accessing m.captures.\nThe resulting RegexMatch object can be used to construct other collections: e.g. Tuple(m), NamedTuple(m).\n\ncompat: Julia 1.11\nConstructing NamedTuples and Dicts requires Julia 1.11\n\nExamples\n\njulia> rx = r\"a(.)a\"\nr\"a(.)a\"\n\njulia> m = match(rx, \"cabac\")\nRegexMatch(\"aba\", 1=\"b\")\n\njulia> m.captures\n1-element Vector{Union{Nothing, SubString{String}}}:\n \"b\"\n\njulia> m.match\n\"aba\"\n\njulia> match(rx, \"cabac\", 3) === nothing\ntrue\n\nSee also\n\neachmatch, occursin, findfirst\n\n\n\n\n\n"},{"title":"Base.eachmatch","page":"Strings","location":"base/strings.html#Base.eachmatch","category":"function","text":"eachmatch(r::Regex, s::AbstractString; overlap::Bool=false)\n\nSearch for all matches of the regular expression r in s and return an iterator over the\nmatches. If overlap is true, the matching sequences are allowed to overlap indices in the\noriginal string, otherwise they must be from distinct character ranges.\n\nExamples\n\njulia> rx = r\"a.a\"\nr\"a.a\"\n\njulia> m = eachmatch(rx, \"a1a2a3a\")\nBase.RegexMatchIterator{String}(r\"a.a\", \"a1a2a3a\", false)\n\njulia> collect(m)\n2-element Vector{RegexMatch}:\n RegexMatch(\"a1a\")\n RegexMatch(\"a3a\")\n\njulia> collect(eachmatch(rx, \"a1a2a3a\", overlap = true))\n3-element Vector{RegexMatch}:\n RegexMatch(\"a1a\")\n RegexMatch(\"a2a\")\n RegexMatch(\"a3a\")\n\nSee also\n\nmatch, findall, count\n\n\n\n\n\n"},{"title":"Base.RegexMatch","page":"Strings","location":"base/strings.html#Base.RegexMatch","category":"type","text":"RegexMatch <: AbstractMatch\n\nA type representing a single match to a Regex found in a string.\nTypically created from the match function.\n\nThe match field stores the substring of the entire matched string.\nThe captures field stores the substrings for each capture group, indexed by number.\nTo index by capture group name, the entire match object should be indexed instead,\nas shown in the examples.\nThe location of the start of the match is stored in the offset field.\nThe offsets field stores the locations of the start of each capture group,\nwith 0 denoting a group that was not captured.\n\nThis type can be used as an iterator over the capture groups of the Regex,\nyielding the substrings captured in each group.\nBecause of this, the captures of a match can be destructured.\nIf a group was not captured, nothing will be yielded instead of a substring.\n\nMethods that accept a RegexMatch object are defined for iterate,\nlength, eltype, keys, haskey, and\ngetindex, where keys are the names or numbers of a capture group.\nSee keys for more information.\n\nTuple(m), NamedTuple(m), and Dict(m) can be used to construct more flexible collection types from RegexMatch objects.\n\ncompat: Julia 1.11\nConstructing NamedTuples and Dicts from RegexMatches requires Julia 1.11\n\nExamples\n\njulia> m = match(r\"(?<hour>\\d+):(?<minute>\\d+)(am|pm)?\", \"11:30 in the morning\")\nRegexMatch(\"11:30\", hour=\"11\", minute=\"30\", 3=nothing)\n\njulia> m.match\n\"11:30\"\n\njulia> m.captures\n3-element Vector{Union{Nothing, SubString{String}}}:\n \"11\"\n \"30\"\n nothing\n\n\njulia> m[\"minute\"]\n\"30\"\n\njulia> hr, min, ampm = m; # destructure capture groups by iteration\n\njulia> hr\n\"11\"\n\njulia> Dict(m)\nDict{Any, Union{Nothing, SubString{String}}} with 3 entries:\n  \"hour\"   => \"11\"\n  3        => nothing\n  \"minute\" => \"30\"\n\n\n\n\n\n"},{"title":"Base.keys","page":"Strings","location":"base/strings.html#Base.keys-Tuple{RegexMatch}","category":"method","text":"keys(m::RegexMatch)::Vector\n\nReturn a vector of keys for all capture groups of the underlying regex.\nA key is included even if the capture group fails to match.\nThat is, idx will be in the return value even if m[idx] == nothing.\n\nUnnamed capture groups will have integer keys corresponding to their index.\nNamed capture groups will have string keys.\n\ncompat: Julia 1.7\nThis method was added in Julia 1.7\n\nExamples\n\njulia> keys(match(r\"(?<hour>\\d+):(?<minute>\\d+)(am|pm)?\", \"11:30\"))\n3-element Vector{Any}:\n  \"hour\"\n  \"minute\"\n 3\n\n\n\n\n\n"},{"title":"Base.:*","page":"Strings","location":"base/strings.html#Base.:*-Tuple{Union{Regex, AbstractChar, AbstractString}, Vararg{Union{Regex, AbstractChar, AbstractString}}}","category":"method","text":"*(s::Regex, t::Union{Regex,AbstractString,AbstractChar})::Regex\n*(s::Union{Regex,AbstractString,AbstractChar}, t::Regex)::Regex\n\nConcatenate regexes, strings and/or characters, producing a Regex.\nString and character arguments must be matched exactly in the resulting regex,\nmeaning that the contained characters are devoid of any special meaning\n(they are quoted with \"\\Q\" and \"\\E\").\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\nExamples\n\njulia> match(r\"Hello|Good bye\" * ' ' * \"world\", \"Hello world\")\nRegexMatch(\"Hello world\")\n\njulia> r = r\"a|b\" * \"c|d\"\nr\"(?:a|b)\\Qc|d\\E\"\n\njulia> match(r, \"ac\") == nothing\ntrue\n\njulia> match(r, \"ac|d\")\nRegexMatch(\"ac|d\")\n\n\n\n\n\n"},{"title":"Base.:^","page":"Strings","location":"base/strings.html#Base.:^-Tuple{Regex, Integer}","category":"method","text":"^(s::Regex, n::Integer)::Regex\n\nRepeat a regex n times.\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\nExamples\n\njulia> r\"Test \"^2\nr\"(?:Test ){2}\"\n\njulia> match(r\"Test \"^2, \"Test Test \")\nRegexMatch(\"Test Test \")\n\n\n\n\n\n"},{"title":"Base.lpad","page":"Strings","location":"base/strings.html#Base.lpad","category":"function","text":"lpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ')::String\n\nStringify s and pad the resulting string on the left with p to make it n\ncharacters (in textwidth) long. If s is already n characters long, an equal\nstring is returned. Pad with spaces by default.\n\nExamples\n\njulia> lpad(\"March\", 10)\n\"     March\"\n\ncompat: Julia 1.7\nIn Julia 1.7, this function was changed to use textwidth rather than a raw character (codepoint) count.\n\n\n\n\n\n"},{"title":"Base.rpad","page":"Strings","location":"base/strings.html#Base.rpad","category":"function","text":"rpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ')::String\n\nStringify s and pad the resulting string on the right with p to make it n\ncharacters (in textwidth) long. If s is already n characters long, an equal\nstring is returned. Pad with spaces by default.\n\nExamples\n\njulia> rpad(\"March\", 20)\n\"March               \"\n\ncompat: Julia 1.7\nIn Julia 1.7, this function was changed to use textwidth rather than a raw character (codepoint) count.\n\n\n\n\n\n"},{"title":"Base.ltruncate","page":"Strings","location":"base/strings.html#Base.ltruncate","category":"function","text":"ltruncate(str::AbstractString, maxwidth::Integer, replacement::Union{AbstractString,AbstractChar} = '…')\n\nTruncate str to at most maxwidth columns (as estimated by textwidth), replacing the first characters\nwith replacement if necessary. The default replacement string is \"…\".\n\nExamples\n\njulia> s = ltruncate(\"🍕🍕 I love 🍕\", 10)\n\"…I love 🍕\"\n\njulia> textwidth(s)\n10\n\njulia> ltruncate(\"foo\", 3)\n\"foo\"\n\ncompat: Julia 1.12\nThis function was added in Julia 1.12.\n\nSee also rtruncate and ctruncate.\n\n\n\n\n\n"},{"title":"Base.rtruncate","page":"Strings","location":"base/strings.html#Base.rtruncate","category":"function","text":"rtruncate(str::AbstractString, maxwidth::Integer, replacement::Union{AbstractString,AbstractChar} = '…')\n\nTruncate str to at most maxwidth columns (as estimated by textwidth), replacing the last characters\nwith replacement if necessary. The default replacement string is \"…\".\n\nExamples\n\njulia> s = rtruncate(\"🍕🍕 I love 🍕\", 10)\n\"🍕🍕 I lo…\"\n\njulia> textwidth(s)\n10\n\njulia> rtruncate(\"foo\", 3)\n\"foo\"\n\ncompat: Julia 1.12\nThis function was added in Julia 1.12.\n\nSee also ltruncate and ctruncate.\n\n\n\n\n\n"},{"title":"Base.ctruncate","page":"Strings","location":"base/strings.html#Base.ctruncate","category":"function","text":"ctruncate(str::AbstractString, maxwidth::Integer, replacement::Union{AbstractString,AbstractChar} = '…'; prefer_left::Bool = true)\n\nTruncate str to at most maxwidth columns (as estimated by textwidth), replacing the middle characters\nwith replacement if necessary. The default replacement string is \"…\". By default, the truncation\nprefers keeping chars on the left, but this can be changed by setting prefer_left to false.\n\nExamples\n\njulia> s = ctruncate(\"🍕🍕 I love 🍕\", 10)\n\"🍕🍕 …e 🍕\"\n\njulia> textwidth(s)\n10\n\njulia> ctruncate(\"foo\", 3)\n\"foo\"\n\ncompat: Julia 1.12\nThis function was added in Julia 1.12.\n\nSee also ltruncate and rtruncate.\n\n\n\n\n\n"},{"title":"Base.first","page":"Strings","location":"base/strings.html#Base.first-Tuple{AbstractString, Integer}","category":"method","text":"first(s::AbstractString, n::Integer)\n\nGet a string consisting of the first n characters of s.\n\nExamples\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 0)\n\"\"\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 1)\n\"∀\"\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 3)\n\"∀ϵ≠\"\n\n\n\n\n\n"},{"title":"Base.last","page":"Strings","location":"base/strings.html#Base.last-Tuple{AbstractString, Integer}","category":"method","text":"last(s::AbstractString, n::Integer)\n\nGet a string consisting of the last n characters of s.\n\nExamples\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 0)\n\"\"\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 1)\n\"0\"\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 3)\n\"²>0\"\n\n\n\n\n\n"},{"title":"Base.chop","page":"Strings","location":"base/strings.html#Base.chop","category":"function","text":"chop(s::AbstractString; head::Integer = 0, tail::Integer = 1)\n\nRemove the first head and the last tail characters from s.\nThe call chop(s) removes the last character from s.\nIf it is requested to remove more characters than length(s)\nthen an empty string is returned.\n\nSee also chomp, startswith, first.\n\nExamples\n\njulia> a = \"March\"\n\"March\"\n\njulia> chop(a)\n\"Marc\"\n\njulia> chop(a, head = 1, tail = 2)\n\"ar\"\n\njulia> chop(a, head = 5, tail = 5)\n\"\"\n\n\n\n\n\n"},{"title":"Base.chopprefix","page":"Strings","location":"base/strings.html#Base.chopprefix","category":"function","text":"chopprefix(s::AbstractString, prefix::Union{AbstractString,Regex,AbstractChar})::SubString\n\nRemove the prefix prefix from s. If s does not start with prefix, a string equal to s is returned.\n\nSee also chopsuffix.\n\ncompat: Julia 1.8\nThis function is available as of Julia 1.8.\n\ncompat: Julia 1.13\nThe method which accepts an AbstractChar prefix is available as of Julia 1.13.\n\nExamples\n\njulia> chopprefix(\"Hamburger\", \"Ham\")\n\"burger\"\n\njulia> chopprefix(\"Hamburger\", \"hotdog\")\n\"Hamburger\"\n\n\n\n\n\n"},{"title":"Base.chopsuffix","page":"Strings","location":"base/strings.html#Base.chopsuffix","category":"function","text":"chopsuffix(s::AbstractString, suffix::Union{AbstractString,Regex,AbstractChar})::SubString\n\nRemove the suffix suffix from s. If s does not end with suffix, a string equal to s is returned.\n\nSee also chopprefix.\n\ncompat: Julia 1.8\nThis function is available as of Julia 1.8.\n\ncompat: Julia 1.13\nThe method which accepts an AbstractChar suffix is available as of Julia 1.13.\n\nExamples\n\njulia> chopsuffix(\"Hamburger\", \"er\")\n\"Hamburg\"\n\njulia> chopsuffix(\"Hamburger\", \"hotdog\")\n\"Hamburger\"\n\n\n\n\n\n"},{"title":"Base.chomp","page":"Strings","location":"base/strings.html#Base.chomp","category":"function","text":"chomp(s::AbstractString)::SubString\n\nRemove a single trailing newline (i.e. \"\\r\\n\" or \"\\n\") from a string.\n\nSee also chop.\n\nExamples\n\njulia> chomp(\"Hello\\n\")\n\"Hello\"\n\njulia> chomp(\"World\\r\\n\")\n\"World\"\n\njulia> chomp(\"Julia\\r\\n\\n\")\n\"Julia\\r\\n\"\n\n\n\n\n\n"},{"title":"Base.strip","page":"Strings","location":"base/strings.html#Base.strip","category":"function","text":"strip([pred=isspace,] str::AbstractString)::SubString\nstrip(str::AbstractString, chars)::SubString\n\nRemove leading and trailing characters from str, either those specified by chars or\nthose for which the function pred returns true.\n\nThe default behaviour is to remove leading and trailing whitespace and delimiters: see\nisspace for precise details.\n\nThe optional chars argument specifies which characters to remove: it can be a single\ncharacter, vector or set of characters.\n\nSee also lstrip and rstrip.\n\ncompat: Julia 1.2\nThe method which accepts a predicate function requires Julia 1.2 or later.\n\nExamples\n\njulia> strip(\"{3, 5}\\n\", ['{', '}', '\\n'])\n\"3, 5\"\n\n\n\n\n\n"},{"title":"Base.lstrip","page":"Strings","location":"base/strings.html#Base.lstrip","category":"function","text":"lstrip([pred=isspace,] str::AbstractString)::SubString\nlstrip(str::AbstractString, chars)::SubString\n\nRemove leading characters from str, either those specified by chars or those for\nwhich the function pred returns true.\n\nThe default behaviour is to remove leading whitespace and delimiters: see\nisspace for precise details.\n\nThe optional chars argument specifies which characters to remove: it can be a single\ncharacter, or a vector or set of characters.\n\nSee also strip and rstrip.\n\nExamples\n\njulia> a = lpad(\"March\", 20)\n\"               March\"\n\njulia> lstrip(a)\n\"March\"\n\n\n\n\n\n"},{"title":"Base.rstrip","page":"Strings","location":"base/strings.html#Base.rstrip","category":"function","text":"rstrip([pred=isspace,] str::AbstractString)::SubString\nrstrip(str::AbstractString, chars)::SubString\n\nRemove trailing characters from str, either those specified by chars or those for\nwhich the function pred returns true.\n\nThe default behaviour is to remove trailing whitespace and delimiters: see\nisspace for precise details.\n\nThe optional chars argument specifies which characters to remove: it can be a single\ncharacter, or a vector or set of characters.\n\nSee also strip and lstrip.\n\nExamples\n\njulia> a = rpad(\"March\", 20)\n\"March               \"\n\njulia> rstrip(a)\n\"March\"\n\n\n\n\n\n"},{"title":"Base.eachsplit","page":"Strings","location":"base/strings.html#Base.eachsplit","category":"function","text":"eachsplit(str::AbstractString, dlm; limit::Integer=0, keepempty::Bool=true)\neachsplit(str::AbstractString; limit::Integer=0, keepempty::Bool=false)\n\nSplit str on occurrences of the delimiter(s) dlm and return an iterator over the\nsubstrings.  dlm can be any of the formats allowed by findnext's first argument\n(i.e. as a string, regular expression or a function), or as a single character or collection\nof characters.\n\nIf dlm is omitted, it defaults to isspace.\n\nThe optional keyword arguments are:\n\nlimit: the maximum size of the result. limit=0 implies no maximum (default)\nkeepempty: whether empty fields should be kept in the result. Default is false without\na dlm argument, true with a dlm argument.\n\nSee also split.\n\ncompat: Julia 1.8\nThe eachsplit function requires at least Julia 1.8.\n\nExamples\n\njulia> a = \"Ma.rch\"\n\"Ma.rch\"\n\njulia> b = eachsplit(a, \".\")\nBase.SplitIterator{String, String}(\"Ma.rch\", \".\", 0, true)\n\njulia> collect(b)\n2-element Vector{SubString{String}}:\n \"Ma\"\n \"rch\"\n\n\n\n\n\n"},{"title":"Base.eachrsplit","page":"Strings","location":"base/strings.html#Base.eachrsplit","category":"function","text":"eachrsplit(str::AbstractString, dlm; limit::Integer=0, keepempty::Bool=true)\neachrsplit(str::AbstractString; limit::Integer=0, keepempty::Bool=false)\n\nReturn an iterator over SubStrings of str, produced when splitting on\nthe delimiter(s) dlm, and yielded in reverse order (from right to left).\ndlm can be any of the formats allowed by findprev's first argument\n(i.e. a string, a single character or a function), or a collection of characters.\n\nIf dlm is omitted, it defaults to isspace, and keepempty default to false.\n\nThe optional keyword arguments are:\n\nIf limit > 0, the iterator will split at most limit - 1 times before returning\nthe rest of the string unsplit. limit < 1 implies no cap to splits (default).\nkeepempty: whether empty fields should be returned when iterating\nDefault is false without a dlm argument, true with a dlm argument.\n\nNote that unlike split, rsplit and eachsplit, this\nfunction iterates the substrings right to left as they occur in the input.\n\nSee also eachsplit, rsplit.\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\nExamples\n\njulia> a = \"Ma.r.ch\";\n\njulia> collect(eachrsplit(a, \".\")) == [\"ch\", \"r\", \"Ma\"]\ntrue\n\njulia> collect(eachrsplit(a, \".\"; limit=2)) == [\"ch\", \"Ma.r\"]\ntrue\n\n\n\n\n\n"},{"title":"Base.split","page":"Strings","location":"base/strings.html#Base.split","category":"function","text":"split(str::AbstractString, dlm; limit::Integer=0, keepempty::Bool=true)\nsplit(str::AbstractString; limit::Integer=0, keepempty::Bool=false)\n\nSplit str into an array of substrings on occurrences of the delimiter(s) dlm.  dlm\ncan be any of the formats allowed by findnext's first argument (i.e. as a\nstring, regular expression or a function), or as a single character or collection of\ncharacters.\n\nIf dlm is omitted, it defaults to isspace.\n\nThe optional keyword arguments are:\n\nlimit: the maximum size of the result. limit=0 implies no maximum (default)\nkeepempty: whether empty fields should be kept in the result. Default is false without\na dlm argument, true with a dlm argument.\n\nSee also rsplit, eachsplit.\n\nExamples\n\njulia> a = \"Ma.rch\"\n\"Ma.rch\"\n\njulia> split(a, \".\")\n2-element Vector{SubString{String}}:\n \"Ma\"\n \"rch\"\n\n\n\n\n\n"},{"title":"Base.rsplit","page":"Strings","location":"base/strings.html#Base.rsplit","category":"function","text":"rsplit(s::AbstractString; limit::Integer=0, keepempty::Bool=false)\nrsplit(s::AbstractString, chars; limit::Integer=0, keepempty::Bool=true)\n\nSimilar to split, but starting from the end of the string.\n\nExamples\n\njulia> a = \"M.a.r.c.h\"\n\"M.a.r.c.h\"\n\njulia> rsplit(a, \".\")\n5-element Vector{SubString{String}}:\n \"M\"\n \"a\"\n \"r\"\n \"c\"\n \"h\"\n\njulia> rsplit(a, \".\"; limit=1)\n1-element Vector{SubString{String}}:\n \"M.a.r.c.h\"\n\njulia> rsplit(a, \".\"; limit=2)\n2-element Vector{SubString{String}}:\n \"M.a.r.c\"\n \"h\"\n\n\n\n\n\n"},{"title":"Base.join","page":"Strings","location":"base/strings.html#Base.join","category":"function","text":"join([io::IO,] iterator [, delim [, last]])\n\nJoin any iterator into a single string, inserting the given delimiter (if any) between\nadjacent items.  If last is given, it will be used instead of delim between the last\ntwo items.  Each item of iterator is converted to a string via print(io::IOBuffer, x).\nIf io is given, the result is written to io rather than returned as a String.\n\nExamples\n\njulia> join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")\n\"apples, bananas and pineapples\"\n\njulia> join([1,2,3,4,5])\n\"12345\"\n\n\n\n\n\n"},{"title":"Base.findfirst","page":"Strings","location":"base/strings.html#Base.findfirst-Tuple{AbstractString, AbstractString}","category":"method","text":"findfirst(pattern::AbstractString, string::AbstractString)\nfindfirst(pattern::AbstractPattern, string::String)\n\nFind the first occurrence of pattern in string. Equivalent to\nfindnext(pattern, string, firstindex(s)).\n\nExamples\n\njulia> findfirst(\"z\", \"Hello to the world\") # returns nothing, but not printed in the REPL\n\njulia> findfirst(\"Julia\", \"JuliaLang\")\n1:5\n\n\n\n\n\n"},{"title":"Base.findnext","page":"Strings","location":"base/strings.html#Base.findnext-Tuple{AbstractString, AbstractString, Integer}","category":"method","text":"findnext(pattern::AbstractString, string::AbstractString, start::Integer)\nfindnext(pattern::AbstractPattern, string::String, start::Integer)\n\nFind the next occurrence of pattern in string starting at position start.\npattern can be either a string, or a regular expression, in which case string\nmust be of type String.\n\nThe return value is a range of indices where the matching sequence is found, such that\ns[findnext(x, s, i)] == x:\n\nfindnext(\"substring\", string, i) == start:stop such that\nstring[start:stop] == \"substring\" and i <= start, or nothing if unmatched.\n\nExamples\n\njulia> findnext(\"z\", \"Hello to the world\", 1) === nothing\ntrue\n\njulia> findnext(\"o\", \"Hello to the world\", 6)\n8:8\n\njulia> findnext(\"Lang\", \"JuliaLang\", 2)\n6:9\n\n\n\n\n\n"},{"title":"Base.findnext","page":"Strings","location":"base/strings.html#Base.findnext-Tuple{AbstractChar, AbstractString, Integer}","category":"method","text":"findnext(ch::AbstractChar, string::AbstractString, start::Integer)\n\nFind the next occurrence of character ch in string starting at position start.\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\nExamples\n\njulia> findnext('z', \"Hello to the world\", 1) === nothing\ntrue\n\njulia> findnext('o', \"Hello to the world\", 6)\n8\n\n\n\n\n\n"},{"title":"Base.findlast","page":"Strings","location":"base/strings.html#Base.findlast-Tuple{AbstractString, AbstractString}","category":"method","text":"findlast(pattern::AbstractString, string::AbstractString)\n\nFind the last occurrence of pattern in string. Equivalent to\nfindprev(pattern, string, lastindex(string)).\n\nExamples\n\njulia> findlast(\"o\", \"Hello to the world\")\n15:15\n\njulia> findlast(\"Julia\", \"JuliaLang\")\n1:5\n\n\n\n\n\n"},{"title":"Base.findlast","page":"Strings","location":"base/strings.html#Base.findlast-Tuple{AbstractChar, AbstractString}","category":"method","text":"findlast(ch::AbstractChar, string::AbstractString)\n\nFind the last occurrence of character ch in string.\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\nExamples\n\njulia> findlast('p', \"happy\")\n4\n\njulia> findlast('z', \"happy\") === nothing\ntrue\n\n\n\n\n\n"},{"title":"Base.findprev","page":"Strings","location":"base/strings.html#Base.findprev-Tuple{AbstractString, AbstractString, Integer}","category":"method","text":"findprev(pattern::AbstractString, string::AbstractString, start::Integer)\n\nFind the previous occurrence of pattern in string starting at position start.\n\nThe return value is a range of indices where the matching sequence is found, such that\ns[findprev(x, s, i)] == x:\n\nfindprev(\"substring\", string, i) == start:stop such that\nstring[start:stop] == \"substring\" and stop <= i, or nothing if unmatched.\n\nExamples\n\njulia> findprev(\"z\", \"Hello to the world\", 18) === nothing\ntrue\n\njulia> findprev(\"o\", \"Hello to the world\", 18)\n15:15\n\njulia> findprev(\"Julia\", \"JuliaLang\", 6)\n1:5\n\n\n\n\n\n"},{"title":"Base.occursin","page":"Strings","location":"base/strings.html#Base.occursin","category":"function","text":"occursin(haystack)\n\nCreate a function that checks whether its argument occurs in haystack, i.e.\na function equivalent to needle -> occursin(needle, haystack).\n\nThe returned function is of type Base.Fix2{typeof(occursin)}.\n\ncompat: Julia 1.6\nThis method requires Julia 1.6 or later.\n\nExamples\n\njulia> search_f = occursin(\"JuliaLang is a programming language\");\n\njulia> search_f(\"JuliaLang\")\ntrue\n\njulia> search_f(\"Python\")\nfalse\n\n\n\n\n\noccursin(needle::Union{AbstractString,AbstractPattern,AbstractChar}, haystack::AbstractString)\n\nDetermine whether the first argument is a substring of the second. If needle\nis a regular expression, checks whether haystack contains a match.\n\nExamples\n\njulia> occursin(\"Julia\", \"JuliaLang is pretty cool!\")\ntrue\n\njulia> occursin('a', \"JuliaLang is pretty cool!\")\ntrue\n\njulia> occursin(r\"a.a\", \"aba\")\ntrue\n\njulia> occursin(r\"a.a\", \"abba\")\nfalse\n\nSee also contains.\n\n\n\n\n\n"},{"title":"Base.contains","page":"Strings","location":"base/strings.html#Base.contains","category":"function","text":"contains(needle)\n\nCreate a function that checks whether its argument contains needle, i.e.\na function equivalent to haystack -> contains(haystack, needle).\n\nThe returned function is of type Base.Fix2{typeof(contains)}, which can be\nused to implement specialized methods.\n\n\n\n\n\ncontains(haystack::AbstractString, needle)\n\nReturn true if haystack contains needle.\nThis is the same as occursin(needle, haystack), but is provided for consistency with\nstartswith(haystack, needle) and endswith(haystack, needle).\n\nSee also occursin, in, issubset.\n\nExamples\n\njulia> contains(\"JuliaLang is pretty cool!\", \"Julia\")\ntrue\n\njulia> contains(\"JuliaLang is pretty cool!\", 'a')\ntrue\n\njulia> contains(\"aba\", r\"a.a\")\ntrue\n\njulia> contains(\"abba\", r\"a.a\")\nfalse\n\ncompat: Julia 1.5\nThe contains function requires at least Julia 1.5.\n\n\n\n\n\n"},{"title":"Base.startswith","page":"Strings","location":"base/strings.html#Base.startswith","category":"function","text":"startswith(s::AbstractString, prefix::Regex)\n\nReturn true if s starts with the regex pattern, prefix.\n\nnote: Note\nstartswith does not compile the anchoring into the regular\nexpression, but instead passes the anchoring as\nmatch_option to PCRE. If compile time is amortized,\noccursin(r\"^...\", s) is faster than startswith(s, r\"...\").\n\nSee also occursin, endswith, match\n\ncompat: Julia 1.2\nThis method requires at least Julia 1.2.\n\nExamples\n\njulia> startswith(\"JuliaLang\", r\"Julia|Romeo\")\ntrue\n\n\n\n\n\nstartswith(prefix)\n\nCreate a function that checks whether its argument starts with prefix, i.e.\na function equivalent to y -> startswith(y, prefix).\n\nThe returned function is of type Base.Fix2{typeof(startswith)}, which can be\nused to implement specialized methods.\n\ncompat: Julia 1.5\nThe single argument startswith(prefix) requires at least Julia 1.5.\n\nExamples\n\njulia> startswith(\"Julia\")(\"JuliaLang\")\ntrue\n\njulia> startswith(\"Julia\")(\"Ends with Julia\")\nfalse\n\n\n\n\n\nstartswith(io::IO, prefix::Union{AbstractString,Base.Chars})\n\nCheck if an IO object starts with a prefix, which can be either a string, a\ncharacter, or a tuple/vector/set of characters.  See also peek.\n\n\n\n\n\nstartswith(s::AbstractString, prefix::Union{AbstractString,Base.Chars})\n\nReturn true if s starts with prefix, which can be a string, a character,\nor a tuple/vector/set of characters. If prefix is a tuple/vector/set\nof characters, test whether the first character of s belongs to that set.\n\nSee also endswith, contains.\n\nExamples\n\njulia> startswith(\"JuliaLang\", \"Julia\")\ntrue\n\n\n\n\n\n"},{"title":"Base.endswith","page":"Strings","location":"base/strings.html#Base.endswith","category":"function","text":"endswith(s::AbstractString, suffix::Regex)\n\nReturn true if s ends with the regex pattern, suffix.\n\nnote: Note\nendswith does not compile the anchoring into the regular\nexpression, but instead passes the anchoring as\nmatch_option to PCRE. If compile time is amortized,\noccursin(r\"...$\", s) is faster than endswith(s, r\"...\").\n\nSee also occursin, startswith, match\n\ncompat: Julia 1.2\nThis method requires at least Julia 1.2.\n\nExamples\n\njulia> endswith(\"JuliaLang\", r\"Lang|Roberts\")\ntrue\n\n\n\n\n\nendswith(suffix)\n\nCreate a function that checks whether its argument ends with suffix, i.e.\na function equivalent to y -> endswith(y, suffix).\n\nThe returned function is of type Base.Fix2{typeof(endswith)}, which can be\nused to implement specialized methods.\n\ncompat: Julia 1.5\nThe single argument endswith(suffix) requires at least Julia 1.5.\n\nExamples\n\njulia> endswith(\"Julia\")(\"Ends with Julia\")\ntrue\n\njulia> endswith(\"Julia\")(\"JuliaLang\")\nfalse\n\n\n\n\n\nendswith(s::AbstractString, suffix::Union{AbstractString,Base.Chars})\n\nReturn true if s ends with suffix, which can be a string, a character,\nor a tuple/vector/set of characters. If suffix is a tuple/vector/set\nof characters, test whether the last character of s belongs to that set.\n\nSee also startswith, contains.\n\nExamples\n\njulia> endswith(\"Sunday\", \"day\")\ntrue\n\n\n\n\n\n"},{"title":"Base.replace","page":"Strings","location":"base/strings.html#Base.replace-Tuple{IO, AbstractString, Vararg{Pair}}","category":"method","text":"replace([io::IO], s::AbstractString, pat=>r, [pat2=>r2, ...]; [count::Integer])\n\nSearch for the given pattern pat in s, and replace each occurrence with r.\nIf count is provided, replace at most count occurrences.\npat may be a single character, a vector or a set of characters, a string,\nor a regular expression.\nIf r is a function, each occurrence is replaced with r(s)\nwhere s is the matched substring (when pat is a AbstractPattern or AbstractString) or\ncharacter (when pat is an AbstractChar or a collection of AbstractChar).\nIf pat is a regular expression and r is a SubstitutionString, then capture group\nreferences in r are replaced with the corresponding matched text.\nTo remove instances of pat from string, set r to the empty String (\"\").\n\nThe return value is a new string after the replacements.  If the io::IO argument\nis supplied, the transformed string is instead written to io (returning io).\n(For example, this can be used in conjunction with an IOBuffer to re-use\na pre-allocated buffer array in-place.)\n\nMultiple patterns can be specified: The input string will be scanned only once\nfrom start (left) to end (right), and the first matching replacement\nwill be applied to each substring. Replacements are applied in the order of\nthe arguments provided if they match substrings starting at the same\ninput string position. Thus, only one pattern will be applied to any character, and the\npatterns will only be applied to the input text, not the replacements.\n\ncompat: Julia 1.7\nSupport for multiple patterns requires version 1.7.\n\ncompat: Julia 1.10\nThe io::IO argument requires version 1.10.\n\nExamples\n\njulia> replace(\"Python is a programming language.\", \"Python\" => \"Julia\")\n\"Julia is a programming language.\"\n\njulia> replace(\"The quick foxes run quickly.\", \"quick\" => \"slow\", count=1)\n\"The slow foxes run quickly.\"\n\njulia> replace(\"The quick foxes run quickly.\", \"quick\" => \"\", count=1)\n\"The  foxes run quickly.\"\n\njulia> replace(\"The quick foxes run quickly.\", r\"fox(es)?\" => s\"bus\\1\")\n\"The quick buses run quickly.\"\n\njulia> replace(\"abcabc\", \"a\" => \"b\", \"b\" => \"c\", r\".+\" => \"a\")\n\"bca\"\n\n\n\n\n\n"},{"title":"Base.reverse","page":"Strings","location":"base/strings.html#Base.reverse-Tuple{Union{SubString{String}, String}}","category":"method","text":"reverse(s::AbstractString)::AbstractString\n\nReverses a string. Technically, this function reverses the codepoints in a string and its\nmain utility is for reversed-order string processing, especially for reversed\nregular-expression searches. See also reverseind to convert indices in s to\nindices in reverse(s) and vice-versa, and graphemes from module Unicode to\noperate on user-visible \"characters\" (graphemes) rather than codepoints.\nSee also Iterators.reverse for\nreverse-order iteration without making a copy. Custom string types must implement the\nreverse function themselves and should typically return a string with the same type\nand encoding. If they return a string with a different encoding, they must also override\nreverseind for that string type to satisfy s[reverseind(s,i)] == reverse(s)[i].\n\nExamples\n\njulia> reverse(\"JuliaLang\")\n\"gnaLailuJ\"\n\nnote: Note\nThe examples below may be rendered differently on different systems.\nThe comments indicate how they're supposed to be rendered\n\nCombining characters can lead to surprising results:\n\njulia> reverse(\"ax̂e\") # hat is above x in the input, above e in the output\n\"êxa\"\n\njulia> using Unicode\n\njulia> join(reverse(collect(graphemes(\"ax̂e\")))) # reverses graphemes; hat is above x in both in- and output\n\"ex̂a\"\n\n\n\n\n\n"},{"title":"Base.Unicode.uppercase","page":"Strings","location":"base/strings.html#Base.Unicode.uppercase","category":"function","text":"uppercase(s::AbstractString)\n\nReturn s with all characters converted to uppercase.\n\nSee also lowercase, titlecase, uppercasefirst.\n\nExamples\n\njulia> uppercase(\"Julia\")\n\"JULIA\"\n\n\n\n\n\nuppercase(c::AbstractChar)\n\nConvert c to uppercase.\n\nSee also lowercase, titlecase.\n\nExamples\n\njulia> uppercase('a')\n'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n\njulia> uppercase('ê')\n'Ê': Unicode U+00CA (category Lu: Letter, uppercase)\n\n\n\n\n\n"},{"title":"Base.Unicode.lowercase","page":"Strings","location":"base/strings.html#Base.Unicode.lowercase","category":"function","text":"lowercase(s::AbstractString)\n\nReturn s with all characters converted to lowercase.\n\nSee also uppercase, titlecase, lowercasefirst.\n\nExamples\n\njulia> lowercase(\"STRINGS AND THINGS\")\n\"strings and things\"\n\n\n\n\n\nlowercase(c::AbstractChar)\n\nConvert c to lowercase.\n\nSee also uppercase, titlecase.\n\nExamples\n\njulia> lowercase('A')\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> lowercase('Ö')\n'ö': Unicode U+00F6 (category Ll: Letter, lowercase)\n\n\n\n\n\n"},{"title":"Base.Unicode.titlecase","page":"Strings","location":"base/strings.html#Base.Unicode.titlecase","category":"function","text":"titlecase(s::AbstractString; [wordsep::Function], strict::Bool=true)::String\n\nCapitalize the first character of each word in s;\nif strict is true, every other character is\nconverted to lowercase, otherwise they are left unchanged.\nBy default, all non-letters beginning a new grapheme are considered as word separators;\na predicate can be passed as the wordsep keyword to determine\nwhich characters should be considered as word separators.\nSee also uppercasefirst to capitalize only the first\ncharacter in s.\n\nSee also uppercase, lowercase, uppercasefirst.\n\nExamples\n\njulia> titlecase(\"the JULIA programming language\")\n\"The Julia Programming Language\"\n\njulia> titlecase(\"ISS - international space station\", strict=false)\n\"ISS - International Space Station\"\n\njulia> titlecase(\"a-a b-b\", wordsep = c->c==' ')\n\"A-a B-b\"\n\n\n\n\n\ntitlecase(c::AbstractChar)\n\nConvert c to titlecase. This may differ from uppercase for digraphs,\ncompare the example below.\n\nSee also uppercase, lowercase.\n\nExamples\n\njulia> titlecase('a')\n'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n\njulia> titlecase('ǆ')\n'ǅ': Unicode U+01C5 (category Lt: Letter, titlecase)\n\njulia> uppercase('ǆ')\n'Ǆ': Unicode U+01C4 (category Lu: Letter, uppercase)\n\n\n\n\n\n"},{"title":"Base.Unicode.uppercasefirst","page":"Strings","location":"base/strings.html#Base.Unicode.uppercasefirst","category":"function","text":"uppercasefirst(s::AbstractString)::String\n\nReturn s with the first character converted to uppercase (technically \"title\ncase\" for Unicode). See also titlecase to capitalize the first\ncharacter of every word in s.\n\nSee also lowercasefirst, uppercase, lowercase,\ntitlecase.\n\nExamples\n\njulia> uppercasefirst(\"python\")\n\"Python\"\n\n\n\n\n\n"},{"title":"Base.Unicode.lowercasefirst","page":"Strings","location":"base/strings.html#Base.Unicode.lowercasefirst","category":"function","text":"lowercasefirst(s::AbstractString)\n\nReturn s with the first character converted to lowercase.\n\nSee also uppercasefirst, uppercase, lowercase,\ntitlecase.\n\nExamples\n\njulia> lowercasefirst(\"Julia\")\n\"julia\"\n\n\n\n\n\n"},{"title":"Base.escape_string","page":"Strings","location":"base/strings.html#Base.escape_string","category":"function","text":"escape_string(str::AbstractString[, esc]; keep=(), ascii=false, fullhex=false)::AbstractString\nescape_string(io, str::AbstractString[, esc]; keep=())::Nothing\n\nGeneral escaping of traditional C and Unicode escape sequences. The first form returns the\nescaped string, the second prints the result to io.\n\nBackslashes (\\) are escaped with a double-backslash (\"\\\\\"). Non-printable\ncharacters are escaped either with their standard C escape codes, \"\\0\" for NUL (if\nunambiguous), unicode code point (\"\\u\" prefix) or hex (\"\\x\" prefix).\n\nThe optional esc argument specifies any additional characters that should also be\nescaped by a prepending backslash (\" is also escaped by default in the first form).\n\nThe argument keep specifies a collection of characters which are to be kept as\nthey are. Notice that esc has precedence here.\n\nThe argument ascii can be set to true to escape all non-ASCII characters,\nwhereas the default ascii=false outputs printable Unicode characters as-is.\n(keep takes precedence over ascii.)\n\nThe argument fullhex can be set to true to require all \\u escapes to be\nprinted with 4 hex digits, and \\U escapes to be printed with 8 hex digits,\nwhereas by default (fullhex=false) they are printed with fewer digits if\npossible (omitting leading zeros).\n\nSee also unescape_string for the reverse operation.\n\ncompat: Julia 1.7\nThe keep argument is available as of Julia 1.7.\n\ncompat: Julia 1.12\nThe ascii and fullhex arguments require Julia 1.12.\n\nExamples\n\njulia> escape_string(\"aaa\\nbbb\")\n\"aaa\\\\nbbb\"\n\njulia> escape_string(\"aaa\\nbbb\"; keep = '\\n')\n\"aaa\\nbbb\"\n\njulia> escape_string(\"\\xfe\\xff\") # invalid utf-8\n\"\\\\xfe\\\\xff\"\n\njulia> escape_string(string('\\u2135','\\0')) # unambiguous\n\"ℵ\\\\0\"\n\njulia> escape_string(string('\\u2135','\\0','0')) # \\0 would be ambiguous\n\"ℵ\\\\x000\"\n\n\n\n\n\n"},{"title":"Base.escape_raw_string","page":"Strings","location":"base/strings.html#Base.escape_raw_string","category":"function","text":"escape_raw_string(s::AbstractString, delim='\"')::AbstractString\nescape_raw_string(io, s::AbstractString, delim='\"')\n\nEscape a string in the manner used for parsing raw string literals.\nFor each double-quote (\") character in input string s (or delim if\nspecified), this function counts the number n of preceding backslash (\\)\ncharacters, and then increases there the number of backslashes from n to\n2n+1 (even for n = 0). It also doubles a sequence of backslashes at the end\nof the string.\n\nThis escaping convention is used in raw strings and other non-standard\nstring literals. (It also happens to be the escaping convention\nexpected by the Microsoft C/C++ compiler runtime when it parses a\ncommand-line string into the argv[] array.)\n\nSee also Base.escape_string().\n\n\n\n\n\n"},{"title":"Base.unescape_string","page":"Strings","location":"base/strings.html#Base.unescape_string","category":"function","text":"unescape_string(str::AbstractString, keep = ())::AbstractString\nunescape_string(io, s::AbstractString, keep = ())::Nothing\n\nGeneral unescaping of traditional C and Unicode escape sequences. The first form returns\nthe escaped string, the second prints the result to io.\nThe argument keep specifies a collection of characters which (along with backlashes) are\nto be kept as they are.\n\nThe following escape sequences are recognised:\n\nEscaped backslash (\\\\)\nEscaped double-quote (\\\")\nStandard C escape sequences (\\a, \\b, \\t, \\n, \\v, \\f, \\r, \\e)\nUnicode BMP code points (\\u with 1-4 trailing hex digits)\nAll Unicode code points (\\U with 1-8 trailing hex digits; max value = 0010ffff)\nHex bytes (\\x with 1-2 trailing hex digits)\nOctal bytes (\\ with 1-3 trailing octal digits)\n\nSee also escape_string.\n\nExamples\n\njulia> unescape_string(\"aaa\\\\nbbb\") # C escape sequence\n\"aaa\\nbbb\"\n\njulia> unescape_string(\"\\\\u03c0\") # unicode\n\"π\"\n\njulia> unescape_string(\"\\\\101\") # octal\n\"A\"\n\njulia> unescape_string(\"aaa \\\\g \\\\n\", ['g']) # using `keep` argument\n\"aaa \\\\g \\n\"\n\n\n\n\n\n"},{"title":"Base.AnnotatedString","page":"Strings","location":"base/strings.html#Base.AnnotatedString","category":"type","text":"AnnotatedString{S <: AbstractString} <: AbstractString\n\nA string with metadata, in the form of annotated regions.\n\nMore specifically, this is a simple wrapper around any other\nAbstractString that allows for regions of the wrapped string to be\nannotated with labeled values.\n\n                           C\n                    ┌──────┸─────────┐\n  \"this is an example annotated string\"\n  └──┰────────┼─────┘         │\n     A        └─────┰─────────┘\n                    B\n\nThe above diagram represents a AnnotatedString where three ranges have been\nannotated (labeled A, B, and C). Each annotation holds a label (Symbol)\nand a value (Any). These three pieces of information are held as a\n@NamedTuple{region::UnitRange{Int64}, label::Symbol, value}.\n\nLabels do not need to be unique, the same region can hold multiple annotations\nwith the same label.\n\nCode written for AnnotatedStrings in general should conserve the following\nproperties:\n\nWhich characters an annotation is applied to\nThe order in which annotations are applied to each character\n\nAdditional semantics may be introduced by specific uses of AnnotatedStrings.\n\nA corollary of these rules is that adjacent, consecutively placed, annotations\nwith identical labels and values are equivalent to a single annotation spanning\nthe combined range.\n\nSee also AnnotatedChar, annotatedstring,\nannotations, and annotate!.\n\nConstructors\n\nAnnotatedString(s::S<:AbstractString) -> AnnotatedString{S}\nAnnotatedString(s::S<:AbstractString, annotations::Vector{@NamedTuple{region::UnitRange{Int64}, label::Symbol, value}})\n\nA AnnotatedString can also be created with annotatedstring, which acts much\nlike string but preserves any annotations present in the arguments.\n\nExamples\n\njulia> AnnotatedString(\"this is an example annotated string\",\n                    [(1:18, :A, 1), (12:28, :B, 2), (18:35, :C, 3)])\n\"this is an example annotated string\"\n\n\n\n\n\n"},{"title":"Base.AnnotatedChar","page":"Strings","location":"base/strings.html#Base.AnnotatedChar","category":"type","text":"AnnotatedChar{S <: AbstractChar} <: AbstractChar\n\nA Char with annotations.\n\nMore specifically, this is a simple wrapper around any other\nAbstractChar, which holds a list of arbitrary labelled annotations\n(@NamedTuple{label::Symbol, value}) with the wrapped character.\n\nSee also: AnnotatedString, annotatedstring, annotations,\nand annotate!.\n\nConstructors\n\nAnnotatedChar(s::S) -> AnnotatedChar{S}\nAnnotatedChar(s::S, annotations::Vector{@NamedTuple{label::Symbol, value}})\n\nExamples\n\njulia> AnnotatedChar('j', [(:label, 1)])\n'j': ASCII/Unicode U+006A (category Ll: Letter, lowercase)\n\n\n\n\n\n"},{"title":"Base.annotatedstring","page":"Strings","location":"base/strings.html#Base.annotatedstring","category":"function","text":"annotatedstring(values...)\n\nCreate a AnnotatedString from any number of values using their\nprinted representation.\n\nThis acts like string, but takes care to preserve any annotations\npresent (in the form of AnnotatedString or AnnotatedChar values).\n\nSee also AnnotatedString and AnnotatedChar.\n\nExamples\n\njulia> annotatedstring(\"now an AnnotatedString\")\n\"now an AnnotatedString\"\n\njulia> annotatedstring(AnnotatedString(\"annotated\", [(1:9, :label, 1)]), \", and unannotated\")\n\"annotated, and unannotated\"\n\n\n\n\n\n"},{"title":"Base.annotations","page":"Strings","location":"base/strings.html#Base.annotations","category":"function","text":"annotations(chr::AnnotatedChar)::Vector{@NamedTuple{label::Symbol, value}}\n\nGet all annotations of chr, in the form of a vector of annotation pairs.\n\n\n\n\n\nannotations(str::Union{AnnotatedString, SubString{AnnotatedString}},\n            [position::Union{Integer, UnitRange}]) ->\n    Vector{@NamedTuple{region::UnitRange{Int64}, label::Symbol, value}}\n\nGet all annotations that apply to str. Should position be provided, only\nannotations that overlap with position will be returned.\n\nAnnotations are provided together with the regions they apply to, in the form of\na vector of region–annotation tuples.\n\nIn accordance with the semantics documented in AnnotatedString, the\norder of annotations returned matches the order in which they were applied.\n\nSee also: annotate!.\n\n\n\n\n\n"},{"title":"Base.annotate!","page":"Strings","location":"base/strings.html#Base.annotate!","category":"function","text":"annotate!(char::AnnotatedChar, label::Symbol, value::Any)\n\nAnnotate char with the labeled value (label, value).\n\n\n\n\n\nannotate!(str::AnnotatedString, [range::UnitRange{Int}], label::Symbol, value)\nannotate!(str::SubString{AnnotatedString}, [range::UnitRange{Int}], label::Symbol, value)\n\nAnnotate a range of str (or the entire string) with a labeled value (label, value).\nTo remove existing label annotations, use a value of nothing.\n\nThe order in which annotations are applied to str is semantically meaningful,\nas described in AnnotatedString.\n\n\n\n\n\n"},{"title":"Essentials","page":"Essentials","location":"base/base.html#Essentials","category":"section","text":""},{"title":"Introduction","page":"Essentials","location":"base/base.html#Introduction","category":"section","text":"Julia Base contains a range of functions and macros appropriate for performing\nscientific and numerical computing, but is also as broad as those of many general-purpose programming\nlanguages. Additional functionality is available from a growing collection of\navailable packages.\nFunctions are grouped by topic below.\n\nSome general notes:\n\nTo use module functions, use import Module to import the module, and Module.fn(x) to use the\nfunctions.\nAlternatively, using Module will import all exported Module functions into the current namespace.\nBy convention, function names ending with an exclamation point (!) modify their arguments.\nSome functions have both modifying (e.g., sort!) and non-modifying (sort) versions.\n\nThe behaviors of Base and standard libraries are stable as defined in\nSemVer only if they are documented; i.e., included in the\nJulia documentation and not marked as unstable.\nSee API FAQ for more information."},{"title":"Getting Around","page":"Essentials","location":"base/base.html#Getting-Around","category":"section","text":""},{"title":"Keywords","page":"Essentials","location":"base/base.html#Keywords","category":"section","text":"This is the list of reserved keywords in Julia:\nbaremodule, begin, break, catch, const, continue, do,\nelse, elseif, end, export, false, finally, for, function,\nglobal, if, import, let, local, macro, module, quote,\nreturn, struct, true, try, using, while.\nThose keywords are not allowed to be used as variable names.\n\nThe following two-word sequences are reserved:\nabstract type, mutable struct, primitive type.\nHowever, you can create variables with names:\nabstract, mutable, primitive and type.\n\nFinally:\nwhere is parsed as an infix operator for writing parametric method and type definitions;\nin and isa are parsed as infix operators;\npublic is parsed as a keyword when beginning a toplevel statement;\nouter is parsed as a keyword when used to modify the scope of a variable in an iteration specification of a for loop;\nand as is used as a keyword to rename an identifier brought into scope by import or using.\nCreation of variables named where, in, isa, outer and as is allowed, though."},{"title":"Standard Modules","page":"Essentials","location":"base/base.html#standard-modules","category":"section","text":""},{"title":"Base Submodules","page":"Essentials","location":"base/base.html#base-submodules","category":"section","text":""},{"title":"All Objects","page":"Essentials","location":"base/base.html#All-Objects","category":"section","text":""},{"title":"Properties of Types","page":"Essentials","location":"base/base.html#Properties-of-Types","category":"section","text":""},{"title":"Type relations","page":"Essentials","location":"base/base.html#Type-relations","category":"section","text":""},{"title":"Declared structure","page":"Essentials","location":"base/base.html#Declared-structure","category":"section","text":""},{"title":"Memory layout","page":"Essentials","location":"base/base.html#Memory-layout","category":"section","text":""},{"title":"Special values","page":"Essentials","location":"base/base.html#Special-values","category":"section","text":""},{"title":"Special Types","page":"Essentials","location":"base/base.html#Special-Types","category":"section","text":""},{"title":"Generic Functions","page":"Essentials","location":"base/base.html#Generic-Functions","category":"section","text":""},{"title":"Syntax","page":"Essentials","location":"base/base.html#Syntax","category":"section","text":""},{"title":"Managing deprecations","page":"Essentials","location":"base/base.html#Managing-deprecations","category":"section","text":""},{"title":"Missing Values","page":"Essentials","location":"base/base.html#Missing-Values","category":"section","text":""},{"title":"System","page":"Essentials","location":"base/base.html#System","category":"section","text":""},{"title":"Versioning","page":"Essentials","location":"base/base.html#Versioning","category":"section","text":""},{"title":"Errors","page":"Essentials","location":"base/base.html#Errors","category":"section","text":""},{"title":"Events","page":"Essentials","location":"base/base.html#Events","category":"section","text":""},{"title":"Reflection","page":"Essentials","location":"base/base.html#Reflection","category":"section","text":""},{"title":"Documentation","page":"Essentials","location":"base/base.html#Documentation","category":"section","text":"(See also the documentation chapter.)"},{"title":"Code loading","page":"Essentials","location":"base/base.html#Code-loading","category":"section","text":""},{"title":"Internals","page":"Essentials","location":"base/base.html#Internals","category":"section","text":""},{"title":"Meta","page":"Essentials","location":"base/base.html#Meta","category":"section","text":""},{"title":"Base.exit","page":"Essentials","location":"base/base.html#Base.exit","category":"function","text":"exit(code=0)\n\nStop the program with an exit code. The default exit code is zero, indicating that the\nprogram completed successfully. In an interactive session, exit() can be called with\nthe keyboard shortcut ^D.\n\n\n\n\n\n"},{"title":"Base.atexit","page":"Essentials","location":"base/base.html#Base.atexit","category":"function","text":"atexit(f)\n\nRegister a zero- or one-argument function f() to be called at process exit.\natexit() hooks are called in last in first out (LIFO) order and run before\nobject finalizers.\n\nIf f has a method defined for one integer argument, it will be called as\nf(n::Int32), where n is the current exit code, otherwise it will be called\nas f().\n\ncompat: Julia 1.9\nThe one-argument form requires Julia 1.9\n\nExit hooks are allowed to call exit(n), in which case Julia will exit with\nexit code n (instead of the original exit code). If more than one exit hook\ncalls exit(n), then Julia will exit with the exit code corresponding to the\nlast called exit hook that calls exit(n). (Because exit hooks are called in\nLIFO order, \"last called\" is equivalent to \"first registered\".)\n\nNote: Once all exit hooks have been called, no more exit hooks can be registered,\nand any call to atexit(f) after all hooks have completed will throw an exception.\nThis situation may occur if you are registering exit hooks from background Tasks that\nmay still be executing concurrently during shutdown.\n\n\n\n\n\n"},{"title":"Base.isinteractive","page":"Essentials","location":"base/base.html#Base.isinteractive","category":"function","text":"isinteractive()::Bool\n\nDetermine whether Julia is running an interactive session.\n\n\n\n\n\n"},{"title":"Base.summarysize","page":"Essentials","location":"base/base.html#Base.summarysize","category":"function","text":"Base.summarysize(obj; count = false, exclude=Union{...}, chargeall=Union{...})::Int\n\nCompute all unique objects reachable from the argument and return either their size in\nmemory (in bytes) or the number of allocations they span.\n\nKeyword Arguments\n\ncount: if false, return the total size of the objects in memory. if true, return the\nnumber of allocations spanned by the object.\nexclude: specifies the types of objects to exclude from the traversal.\nchargeall: specifies the types of objects to always charge the size of all of their\nfields, even if those fields would normally be excluded.\n\nSee also sizeof.\n\nExamples\n\njulia> Base.summarysize(1.0)\n8\n\njulia> Base.summarysize(Ref(rand(100)))\n848\n\njulia> sizeof(Ref(rand(100)))\n8\n\njulia> Base.summarysize(Core.svec(1.0, \"testing\", true); count=true)\n4\n\n\n\n\n\n"},{"title":"Base.__precompile__","page":"Essentials","location":"base/base.html#Base.__precompile__","category":"function","text":"__precompile__(isprecompilable::Bool)\n\nSpecify whether the file calling this function is precompilable, defaulting to true.\nIf a module or file is not safely precompilable, it should call __precompile__(false) in\norder to throw an error if Julia attempts to precompile it.\n\n\n\n\n\n"},{"title":"Base.include","page":"Essentials","location":"base/base.html#Base.include","category":"function","text":"Base.include([mapexpr::Function,] m::Module, path::AbstractString)\n\nEvaluate the contents of the input source file in the global scope of module m.\nEvery module (except those defined with baremodule) has its own\ndefinition of include omitting the m argument, which evaluates the file in that module.\nReturns the result of the last evaluated expression of the input file. During including,\na task-local include path is set to the directory containing the file. Nested calls to\ninclude will search relative to that path. This function is typically used to load source\ninteractively, or to combine files in packages that are broken into multiple source files.\n\nThe optional first argument mapexpr can be used to transform the included code before\nit is evaluated: for each parsed expression expr in path, the include function\nactually evaluates mapexpr(expr).  If it is omitted, mapexpr defaults to identity.\n\ncompat: Julia 1.5\nJulia 1.5 is required for passing the mapexpr argument.\n\n\n\n\n\n"},{"title":"include","page":"Essentials","location":"base/base.html#include","category":"function","text":"include([mapexpr::Function,] path::AbstractString)\n\nEvaluate the contents of the input source file in the global scope of the containing module.\nEvery Module (except those defined with baremodule) has a private 1-argument definition\nof include, which evaluates the file in that module, for use inside that module.\nReturns the result of the last evaluated expression of the input file. During including,\na task-local include path is set to the directory containing the file. Nested calls to\ninclude will search relative to that path. This function is typically used to load source\ninteractively, or to combine files in packages that are broken into multiple source files.\nThe argument path is normalized using normpath which will resolve\nrelative path tokens such as .. and convert / to the appropriate path separator.\n\nThe optional first argument mapexpr can be used to transform the included code before\nit is evaluated: for each parsed expression expr in path, the include function\nactually evaluates mapexpr(expr).  If it is omitted, mapexpr defaults to identity.\n\nUse Base.include to evaluate a file into another module.\n\nnote: Note\nJulia's syntax lowering recognizes an explicit call to a literal include\nat top-level and inserts an implicit @Core.latestworld to make any include'd\ndefinitions visible to subsequent code. Note however that this recognition\nis syntactic. I.e. assigning const myinclude = include may require\nan explicit @Core.latestworld call after myinclude.\n\ncompat: Julia 1.5\nJulia 1.5 is required for passing the mapexpr argument.\n\n\n\n\n\n"},{"title":"Base.include_string","page":"Essentials","location":"base/base.html#Base.include_string","category":"function","text":"include_string([mapexpr::Function,] m::Module, code::AbstractString, filename::AbstractString=\"string\")\n\nLike include, except reads code from the given string rather than from a file.\n\nThe optional first argument mapexpr can be used to transform the included code before\nit is evaluated: for each parsed expression expr in code, the include_string function\nactually evaluates mapexpr(expr).  If it is omitted, mapexpr defaults to identity.\n\ncompat: Julia 1.5\nJulia 1.5 is required for passing the mapexpr argument.\n\n\n\n\n\n"},{"title":"Base.include_dependency","page":"Essentials","location":"base/base.html#Base.include_dependency","category":"function","text":"include_dependency(path::AbstractString; track_content::Bool=true)\n\nIn a module, declare that the file, directory, or symbolic link specified by path\n(relative or absolute) is a dependency for precompilation; that is, if track_content=true\nthe module will need to be recompiled if the content of path changes\n(if path is a directory the content equals join(readdir(path))).\nIf track_content=false recompilation is triggered when the modification time mtime of path changes.\n\nThis is only needed if your module depends on a path that is not used via include. It has\nno effect outside of compilation.\n\ncompat: Julia 1.11\nKeyword argument track_content requires at least Julia 1.11.\nAn error is now thrown if path is not readable.\n\n\n\n\n\n"},{"title":"__init__","page":"Essentials","location":"base/base.html#__init__","category":"keyword","text":"__init__\n\nThe __init__() function in a module executes immediately after the module is loaded at\nruntime for the first time. It is called once, after all other statements in the module\nhave been executed. Because it is called after fully importing the module, __init__\nfunctions of submodules will be executed first. Two typical uses of __init__ are calling\nruntime initialization functions of external C libraries and initializing global constants\nthat involve pointers returned by external libraries.\nSee the manual section about modules for more details.\n\nSee also: OncePerProcess.\n\nExamples\n\nconst foo_data_ptr = Ref{Ptr{Cvoid}}(0)\nfunction __init__()\n    ccall((:foo_init, :libfoo), Cvoid, ())\n    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())\n    nothing\nend\n\n\n\n\n\n"},{"title":"Base.OncePerProcess","page":"Essentials","location":"base/base.html#Base.OncePerProcess","category":"type","text":"OncePerProcess{T}(init::Function)() -> T\n\nCalling a OncePerProcess object returns a value of type T by running the\nfunction initializer exactly once per process. All concurrent and future\ncalls in the same process will return exactly the same value. This is useful in\ncode that will be precompiled, as it allows setting up caches or other state\nwhich won't get serialized.\n\ncompat: Julia 1.12\nThis type requires Julia 1.12 or later.\n\nExample\n\njulia> const global_state = Base.OncePerProcess{Vector{UInt32}}() do\n           println(\"Making lazy global value...done.\")\n           return [Libc.rand()]\n       end;\n\njulia> (procstate = global_state()) |> typeof\nMaking lazy global value...done.\nVector{UInt32} (alias for Array{UInt32, 1})\n\njulia> procstate === global_state()\ntrue\n\njulia> procstate === fetch(@async global_state())\ntrue\n\n\n\n\n\n"},{"title":"Base.OncePerTask","page":"Essentials","location":"base/base.html#Base.OncePerTask","category":"type","text":"OncePerTask{T}(init::Function)() -> T\n\nCalling a OncePerTask object returns a value of type T by running the function initializer\nexactly once per Task. All future calls in the same Task will return exactly the same value.\n\nSee also: task_local_storage.\n\ncompat: Julia 1.12\nThis type requires Julia 1.12 or later.\n\nExample\n\njulia> const task_state = Base.OncePerTask{Vector{UInt32}}() do\n           println(\"Making lazy task value...done.\")\n           return [Libc.rand()]\n       end;\n\njulia> (taskvec = task_state()) |> typeof\nMaking lazy task value...done.\nVector{UInt32} (alias for Array{UInt32, 1})\n\njulia> taskvec === task_state()\ntrue\n\njulia> taskvec === fetch(@async task_state())\nMaking lazy task value...done.\nfalse\n\n\n\n\n\n"},{"title":"Base.OncePerThread","page":"Essentials","location":"base/base.html#Base.OncePerThread","category":"type","text":"OncePerThread{T}(init::Function)() -> T\n\nCalling a OncePerThread object returns a value of type T by running the function\ninitializer exactly once per thread. All future calls in the same thread, and\nconcurrent or future calls with the same thread id, will return exactly the\nsame value. The object can also be indexed by the threadid for any existing\nthread, to get (or initialize on this thread) the value stored for that\nthread. Incorrect usage can lead to data-races or memory corruption so use only\nif that behavior is correct within your library's threading-safety design.\n\nwarning: Warning\nIt is not necessarily true that a Task only runs on one thread, therefore the value\nreturned here may alias other values or change in the middle of your program. This function\nmay get deprecated in the future. If initializer yields, the thread running the current\ntask after the call might not be the same as the one at the start of the call.\n\nSee also: OncePerTask.\n\ncompat: Julia 1.12\nThis type requires Julia 1.12 or later.\n\nExample\n\njulia> const thread_state = Base.OncePerThread{Vector{UInt32}}() do\n           println(\"Making lazy thread value...done.\")\n           return [Libc.rand()]\n       end;\n\njulia> (threadvec = thread_state()) |> typeof\nMaking lazy thread value...done.\nVector{UInt32} (alias for Array{UInt32, 1})\n\njulia> threadvec === fetch(@async thread_state())\ntrue\n\njulia> threadvec === thread_state[Threads.threadid()]\ntrue\n\n\n\n\n\n"},{"title":"Base.which","page":"Essentials","location":"base/base.html#Base.which-Tuple{Any, Any}","category":"method","text":"which(f, types)\n\nReturn the method of f (a Method object) that would be called for arguments of the given types.\n\nIf types is an abstract type, then the method that would be called by invoke is returned.\n\nSee also: parentmodule, @which, and @edit.\n\n\n\n\n\n"},{"title":"Base.methods","page":"Essentials","location":"base/base.html#Base.methods","category":"function","text":"methods(f, [types], [module])\n\nReturn the method table for f.\n\nIf types is specified, return an array of methods whose types match.\nIf module is specified, return an array of methods defined in that module.\nA list of modules can also be specified as an array or set.\n\ncompat: Julia 1.4\nAt least Julia 1.4 is required for specifying a module.\n\nSee also: which, @which and methodswith.\n\n\n\n\n\n"},{"title":"Base.@show","page":"Essentials","location":"base/base.html#Base.@show","category":"macro","text":"@show exs...\n\nPrints one or more expressions, and their results, to stdout, and returns the last result.\n\nSee also: show, @info, println.\n\nExamples\n\njulia> x = @show 1+2\n1 + 2 = 3\n3\n\njulia> @show x^2 x/2;\nx ^ 2 = 9\nx / 2 = 1.5\n\n\n\n\n\n"},{"title":"Base.MainInclude.ans","page":"Essentials","location":"base/base.html#Base.MainInclude.ans","category":"constant","text":"ans\n\nA variable referring to the last computed value, automatically imported to the interactive prompt.\n\n\n\n\n\n"},{"title":"Base.MainInclude.err","page":"Essentials","location":"base/base.html#Base.MainInclude.err","category":"constant","text":"err\n\nA variable referring to the last thrown errors, automatically imported to the interactive prompt.\nThe thrown errors are collected in a stack of exceptions.\n\n\n\n\n\n"},{"title":"Base.active_project","page":"Essentials","location":"base/base.html#Base.active_project","category":"function","text":"active_project()\n\nReturn the path of the active Project.toml file. See also Base.set_active_project.\n\n\n\n\n\n"},{"title":"Base.set_active_project","page":"Essentials","location":"base/base.html#Base.set_active_project","category":"function","text":"set_active_project(projfile::Union{AbstractString,Nothing})\n\nSet the active Project.toml file to projfile. See also Base.active_project.\n\ncompat: Julia 1.8\nThis function requires at least Julia 1.8.\n\n\n\n\n\n"},{"title":"Base.active_manifest","page":"Essentials","location":"base/base.html#Base.active_manifest","category":"function","text":"active_manifest()\nactive_manifest(project_file::AbstractString)\n\nReturn the path of the active manifest file, or the manifest file that would be used for a given project_file.\n\nIn a stacked environment (where multiple environments exist in the load path), this returns the manifest\nfile for the primary (active) environment only, not the manifests from other environments in the stack.\nSee the manual section on Environment stacks for more details on how stacked environments work.\n\nSee Project environments for details on the difference between a project and a manifest, and the naming\noptions and their priority in package loading.\n\nSee also Base.active_project, Base.set_active_project.\n\n\n\n\n\n"},{"title":"module","page":"Essentials","location":"base/base.html#module","category":"keyword","text":"module\n\nmodule declares a Module, which is a separate global variable workspace. Within a\nmodule, you can control which names from other modules are visible (via importing), and\nspecify which of your names are intended to be public (via export and public).\nModules allow you to create top-level definitions without worrying about name conflicts\nwhen your code is used together with somebody else’s.\nSee the manual section about modules for more details.\n\nExamples\n\nmodule Foo\nimport Base.show\nexport MyType, foo\n\nstruct MyType\n    x\nend\n\nbar(x) = 2x\nfoo(a::MyType) = bar(a.x) + 1\nshow(io::IO, a::MyType) = print(io, \"MyType $(a.x)\")\nend\n\n\n\n\n\n"},{"title":"export","page":"Essentials","location":"base/base.html#export","category":"keyword","text":"export\n\nexport is used within modules to tell Julia which names should be\nmade available to the user. For example: export foo makes the name\nfoo available when using the module.\nSee the manual section about modules for details.\n\n\n\n\n\n"},{"title":"public","page":"Essentials","location":"base/base.html#public","category":"keyword","text":"public\n\npublic is used within modules to tell Julia which names are part of the\npublic API of the module. For example: public foo indicates that the name\nfoo is public, without making it available when using the module.\n\nAs export already indicates that a name is public, it is\nunnecessary and an error to declare a name both as public and as exported.\nSee the manual section about modules for details.\n\ncompat: Julia 1.11\nThe public keyword was added in Julia 1.11. Prior to this the notion\nof publicness was less explicit.\n\n\n\n\n\n"},{"title":"import","page":"Essentials","location":"base/base.html#import","category":"keyword","text":"import\n\nimport Foo will load the module or package Foo.\nNames from the imported Foo module can be accessed with dot syntax\n(e.g. Foo.foo to access the name foo).\nSee the manual section about modules for details.\n\n\n\n\n\n"},{"title":"using","page":"Essentials","location":"base/base.html#using","category":"keyword","text":"using\n\nusing Foo will load the module or package Foo and make its exported names\navailable for direct use. Names can also be used via dot syntax (e.g. Foo.foo to access\nthe name foo), whether they are exported or not.\nSee the manual section about modules for details.\n\nnote: Note\nWhen two or more packages/modules export a name and that name does not refer to the\nsame thing in each of the packages, and the packages are loaded via using without\nan explicit list of names, it is an error to reference that name without qualification.\nIt is thus recommended that code intended to be forward-compatible with future versions\nof its dependencies and of Julia, e.g., code in released packages, list the names it\nuses from each loaded package, e.g., using Foo: Foo, f rather than using Foo.\n\n\n\n\n\n"},{"title":"as","page":"Essentials","location":"base/base.html#as","category":"keyword","text":"as\n\nas is used as a keyword to rename an identifier brought into scope by\nimport or using, for the purpose of working around name conflicts as\nwell as for shortening names.  (Outside of import or using statements,\nas is not a keyword and can be used as an ordinary identifier.)\n\nimport LinearAlgebra as LA brings the imported LinearAlgebra standard library\ninto scope as LA.\n\nimport LinearAlgebra: eigen as eig, cholesky as chol brings the eigen and cholesky methods\nfrom LinearAlgebra into scope as eig and chol respectively.\n\nas works with using only when individual identifiers are brought into scope.\nFor example, using LinearAlgebra: eigen as eig or using LinearAlgebra: eigen as eig, cholesky as chol works,\nbut using LinearAlgebra as LA is invalid syntax, since it is nonsensical to\nrename all exported names from LinearAlgebra to LA.\n\n\n\n\n\n"},{"title":"baremodule","page":"Essentials","location":"base/base.html#baremodule","category":"keyword","text":"baremodule\n\nbaremodule declares a module that does not contain using Base or local definitions of\neval and include. It does still import Core. In other words,\n\nmodule Mod\n\n...\n\nend\n\nis equivalent to\n\nbaremodule Mod\n\nusing Base\n\neval(x) = Core.eval(Mod, x)\ninclude(p) = Base.include(Mod, p)\n\n...\n\nend\n\n\n\n\n\n"},{"title":"function","page":"Essentials","location":"base/base.html#function","category":"keyword","text":"function\n\nFunctions are defined with the function keyword:\n\nfunction add(a, b)\n    return a + b\nend\n\nOr the short form notation:\n\nadd(a, b) = a + b\n\nThe use of the return keyword is exactly the same as in other languages,\nbut is often optional. A function without an explicit return statement will return\nthe last expression in the function body.\n\n\n\n\n\n"},{"title":"macro","page":"Essentials","location":"base/base.html#macro","category":"keyword","text":"macro\n\nmacro defines a method for inserting generated code into a program.\nA macro maps a sequence of argument expressions to a returned expression, and the\nresulting expression is substituted directly into the program at the point where\nthe macro is invoked.\nMacros are a way to run generated code without calling eval,\nsince the generated code instead simply becomes part of the surrounding program.\nMacro arguments may include expressions, literal values, and symbols. Macros can be defined for\nvariable number of arguments (varargs), but do not accept keyword arguments.\nEvery macro also implicitly gets passed the arguments __source__, which contains the line number\nand file name the macro is called from, and __module__, which is the module the macro is expanded\nin.\n\nSee the manual section on Metaprogramming for more information about how to write a macro.\n\nExamples\n\njulia> macro sayhello(name)\n           return :( println(\"Hello, \", $name, \"!\") )\n       end\n@sayhello (macro with 1 method)\n\njulia> @sayhello \"Charlie\"\nHello, Charlie!\n\njulia> macro saylots(x...)\n           return :( println(\"Say: \", $(x...)) )\n       end\n@saylots (macro with 1 method)\n\njulia> @saylots \"hey \" \"there \" \"friend\"\nSay: hey there friend\n\n\n\n\n\n"},{"title":"return","page":"Essentials","location":"base/base.html#return","category":"keyword","text":"return\n\nreturn x causes the enclosing function to exit early, passing the given value x\nback to its caller. return by itself with no value is equivalent to return nothing\n(see nothing).\n\nfunction compare(a, b)\n    a == b && return \"equal to\"\n    a < b ? \"less than\" : \"greater than\"\nend\n\nIn general you can place a return statement anywhere within a function body, including\nwithin deeply nested loops or conditionals, but be careful with do blocks. For\nexample:\n\nfunction test1(xs)\n    for x in xs\n        iseven(x) && return 2x\n    end\nend\n\nfunction test2(xs)\n    map(xs) do x\n        iseven(x) && return 2x\n        x\n    end\nend\n\nIn the first example, the return breaks out of test1 as soon as it hits\nan even number, so test1([5,6,7]) returns 12.\n\nYou might expect the second example to behave the same way, but in fact the return\nthere only breaks out of the inner function (inside the do block) and gives a value\nback to map. test2([5,6,7]) then returns [5,12,7].\n\nWhen used in a top-level expression (i.e. outside any function), return causes\nthe entire current top-level expression to terminate early.\n\n\n\n\n\n"},{"title":"do","page":"Essentials","location":"base/base.html#do","category":"keyword","text":"do\n\nCreate an anonymous function and pass it as the first argument to\na function call.\nFor example:\n\nmap(1:10) do x\n    2x\nend\n\nis equivalent to map(x->2x, 1:10).\n\nUse multiple arguments like so:\n\nmap(1:10, 11:20) do x, y\n    x + y\nend\n\n\n\n\n\n"},{"title":"begin","page":"Essentials","location":"base/base.html#begin","category":"keyword","text":"begin\n\nbegin...end denotes a block of code.\n\nbegin\n    println(\"Hello, \")\n    println(\"World!\")\nend\n\nUsually begin will not be necessary, since keywords such as function and let\nimplicitly begin blocks of code. See also ;.\n\nbegin may also be used when indexing to represent the first index of a\ncollection or the first index of a dimension of an array. For example,\na[begin] is the first element of an array a.\n\ncompat: Julia 1.4\nUse of begin as an index requires Julia 1.4 or later.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> A[begin, :]\n2-element Matrix{Int64}:\n 1\n 2\n\n\n\n\n\n"},{"title":"end","page":"Essentials","location":"base/base.html#end","category":"keyword","text":"end\n\nend marks the conclusion of a block of expressions, for example\nmodule, struct, mutable struct,\nbegin, let, for etc.\n\nend may also be used when indexing to represent the last index of a\ncollection or the last index of a dimension of an array.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> A[end, :]\n2-element Vector{Int64}:\n 3\n 4\n\n\n\n\n\n"},{"title":"let","page":"Essentials","location":"base/base.html#let","category":"keyword","text":"let\n\nlet blocks create a new hard scope and optionally introduce new local bindings.\n\nJust like the other scope constructs, let blocks define\nthe block of code where newly introduced local variables are accessible.\nAdditionally, the syntax has a special meaning for comma-separated assignments\nand variable names that may optionally appear on the same line as the let:\n\nlet var1 = value1, var2, var3 = value3\n    code\nend\n\nThe variables introduced on this line are local to the let block and the assignments are\nevaluated in order, with each right-hand side evaluated in the scope\nwithout considering the name on the left-hand side. Therefore it makes\nsense to write something like let x = x, since the two x variables are distinct with\nthe left-hand side locally shadowing the x from the outer scope. This can even\nbe a useful idiom as new local variables are freshly created each time local scopes\nare entered, but this is only observable in the case of variables that outlive their\nscope via closures.  A let variable without an assignment, such as var2 in the\nexample above, declares a new local variable that is not yet bound to a value.\n\nBy contrast, begin blocks also group multiple expressions together but do\nnot introduce scope or have the special assignment syntax.\n\nExamples\n\nIn the function below, there is a single x that is iteratively updated three times by the map.\nThe closures returned all reference that one x at its final value:\n\njulia> function test_outer_x()\n           x = 0\n           map(1:3) do _\n               x += 1\n               return ()->x\n           end\n       end\ntest_outer_x (generic function with 1 method)\n\njulia> [f() for f in test_outer_x()]\n3-element Vector{Int64}:\n 3\n 3\n 3\n\nIf, however, we add a let block that introduces a new local variable we will end up\nwith three distinct variables being captured (one at each iteration) even though we\nchose to use (shadow) the same name.\n\njulia> function test_let_x()\n           x = 0\n           map(1:3) do _\n               x += 1\n               let x = x\n                   return ()->x\n               end\n           end\n       end\ntest_let_x (generic function with 1 method)\n\njulia> [f() for f in test_let_x()]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\nAll scope constructs that introduce new local variables behave this way\nwhen repeatedly run; the distinctive feature of let is its ability\nto succinctly declare new locals that may shadow outer variables of the same\nname. For example, directly using the argument of the do function similarly\ncaptures three distinct variables:\n\njulia> function test_do_x()\n           map(1:3) do x\n               return ()->x\n           end\n       end\ntest_do_x (generic function with 1 method)\n\njulia> [f() for f in test_do_x()]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\n\n"},{"title":"if","page":"Essentials","location":"base/base.html#if","category":"keyword","text":"if/elseif/else\n\nif/elseif/else performs conditional evaluation, which allows portions of code to\nbe evaluated or not evaluated depending on the value of a boolean expression. Here is\nthe anatomy of the if/elseif/else conditional syntax:\n\nif x < y\n    println(\"x is less than y\")\nelseif x > y\n    println(\"x is greater than y\")\nelse\n    println(\"x is equal to y\")\nend\n\nIf the condition expression x < y is true, then the corresponding block is evaluated;\notherwise the condition expression x > y is evaluated, and if it is true, the\ncorresponding block is evaluated; if neither expression is true, the else block is\nevaluated. The elseif and else blocks are optional, and as many elseif blocks as\ndesired can be used.\n\nIn contrast to some other languages conditions must be of type Bool. It does not\nsuffice for conditions to be convertible to Bool.\n\njulia> if 1 end\nERROR: TypeError: non-boolean (Int64) used in boolean context\n\n\n\n\n\n"},{"title":"for","page":"Essentials","location":"base/base.html#for","category":"keyword","text":"for\n\nfor loops repeatedly evaluate a block of statements while\niterating over a sequence of values.\n\nThe iteration variable is always a new variable, even if a variable of the same name\nexists in the enclosing scope.\nUse outer to reuse an existing local variable for iteration.\n\nExamples\n\njulia> for i in [1, 4, 0]\n           println(i)\n       end\n1\n4\n0\n\n\n\n\n\n"},{"title":"while","page":"Essentials","location":"base/base.html#while","category":"keyword","text":"while\n\nwhile loops repeatedly evaluate a conditional expression, and continue evaluating the\nbody of the while loop as long as the expression remains true. If the condition\nexpression is false when the while loop is first reached, the body is never evaluated.\n\nExamples\n\njulia> i = 1\n1\n\njulia> while i < 5\n           println(i)\n           global i += 1\n       end\n1\n2\n3\n4\n\n\n\n\n\n"},{"title":"break","page":"Essentials","location":"base/base.html#break","category":"keyword","text":"break\n\nBreak out of a loop immediately.\n\nExamples\n\njulia> i = 0\n0\n\njulia> while true\n           global i += 1\n           i > 5 && break\n           println(i)\n       end\n1\n2\n3\n4\n5\n\n\n\n\n\n"},{"title":"continue","page":"Essentials","location":"base/base.html#continue","category":"keyword","text":"continue\n\nSkip the rest of the current loop iteration.\n\nExamples\n\njulia> for i = 1:6\n           iseven(i) && continue\n           println(i)\n       end\n1\n3\n5\n\n\n\n\n\n"},{"title":"try","page":"Essentials","location":"base/base.html#try","category":"keyword","text":"try/catch\n\nA try/catch statement allows intercepting errors (exceptions) thrown\nby throw so that program execution can continue.\nFor example, the following code attempts to write a file, but warns the user\nand proceeds instead of terminating execution if the file cannot be written:\n\ntry\n    open(\"/danger\", \"w\") do f\n        println(f, \"Hello\")\n    end\ncatch\n    @warn \"Could not write file.\"\nend\n\nor, when the file cannot be read into a variable:\n\nlines = try\n    open(\"/danger\", \"r\") do f\n        readlines(f)\n    end\ncatch\n    @warn \"File not found.\"\nend\n\nThe syntax catch e (where e is any variable) assigns the thrown\nexception object to the given variable within the catch block.\n\ntry\n    a_dangerous_operation()\ncatch e\n    if isa(e, EOFError)\n        @warn \"The operation failed - EOF.\"\n    elseif isa(e, OutOfMemoryError)\n        @warn \"The operation failed - OOM.\"\n    else\n        rethrow() # ensure other exceptions can bubble up the call stack\n    end\nend\n\nThe power of the try/catch construct lies in the ability to unwind a deeply\nnested computation immediately to a much higher level in the stack of calling functions.\n\nA try/catch block can also have an else clause that executes only if no exception occurred:\n\ntry\n    a_dangerous_operation()\ncatch\n    @warn \"The operation failed.\"\nelse\n    @info \"The operation succeeded.\"\nend\n\nA try or try/catch block can also have a finally clause that executes\nat the end, regardless of whether an exception occurred.  For example, this can be\nused to guarantee that an opened file is closed:\n\nf = open(\"file\")\ntry\n    operate_on_file(f)\ncatch\n    @warn \"An error occurred!\"\nfinally\n    close(f)\nend\n\n(finally can also be used without a catch block.)\n\ncompat: Julia 1.8\nElse clauses require at least Julia 1.8.\n\n\n\n\n\n"},{"title":"finally","page":"Essentials","location":"base/base.html#finally","category":"keyword","text":"finally\n\nRun some code when a given try block of code exits, regardless\nof how it exits. For example, here is how we can guarantee that an opened file is\nclosed:\n\nf = open(\"file\")\ntry\n    operate_on_file(f)\nfinally\n    close(f)\nend\n\nWhen control leaves the try block (for example, due to a return, or just finishing\nnormally), close(f) will be executed. If the try block exits due to an exception,\nthe exception will continue propagating. A catch block may be combined with try and\nfinally as well. In this case the finally block will run after catch has handled\nthe error.\n\nWhen evaluating a try/catch/else/finally expression, the value of the entire\nexpression is the value of the last block executed, excluding the finally\nblock. For example:\n\njulia> try\n           1\n       finally\n           2\n       end\n1\n\njulia> try\n           error(\"\")\n       catch\n           1\n       else\n           2\n       finally\n           3\n       end\n1\n\njulia> try\n           0\n       catch\n           1\n       else\n           2\n       finally\n           3\n       end\n2\n\n\n\n\n\n"},{"title":"quote","page":"Essentials","location":"base/base.html#quote","category":"keyword","text":"quote\n\nquote creates multiple expression objects in a block without using the explicit\nExpr constructor. For example:\n\nex = quote\n    x = 1\n    y = 2\n    x + y\nend\n\nUnlike the other means of quoting, :( ... ), this form introduces QuoteNode elements\nto the expression tree, which must be considered when directly manipulating the tree.\nFor other purposes, :( ... ) and quote .. end blocks are treated identically.\n\n\n\n\n\n"},{"title":"local","page":"Essentials","location":"base/base.html#local","category":"keyword","text":"local\n\nlocal introduces a new local variable.\nSee the manual section on variable scoping for more information.\n\nExamples\n\njulia> function foo(n)\n           x = 0\n           for i = 1:n\n               local x # introduce a loop-local x\n               x = i\n           end\n           x\n       end\nfoo (generic function with 1 method)\n\njulia> foo(10)\n0\n\n\n\n\n\n"},{"title":"global","page":"Essentials","location":"base/base.html#global","category":"keyword","text":"global\n\nglobal x makes x in the current scope and its inner scopes refer to the global\nvariable of that name.\nSee the manual section on variable scoping for more information.\n\nExamples\n\njulia> z = 3\n3\n\njulia> function foo()\n           global z = 6 # use the z variable defined outside foo\n       end\nfoo (generic function with 1 method)\n\njulia> foo()\n6\n\njulia> z\n6\n\n\n\n\n\n"},{"title":"outer","page":"Essentials","location":"base/base.html#outer","category":"keyword","text":"for outer\n\nReuse an existing local variable for iteration in a for loop.\n\nSee the manual section on variable scoping for more information.\n\nSee also for.\n\nExamples\n\njulia> function f()\n           i = 0\n           for i = 1:3\n               # empty\n           end\n           return i\n       end;\n\njulia> f()\n0\n\njulia> function f()\n           i = 0\n           for outer i = 1:3\n               # empty\n           end\n           return i\n       end;\n\njulia> f()\n3\n\njulia> i = 0 # global variable\n       for outer i = 1:3\n       end\nERROR: syntax: no outer local variable declaration exists for \"for outer\"\n[...]\n\n\n\n\n\n"},{"title":"const","page":"Essentials","location":"base/base.html#const","category":"keyword","text":"const\n\nconst is used to declare global variables whose values will not change. In almost all code\n(and particularly performance sensitive code) global variables should be declared\nconstant in this way.\n\nconst x = 5\n\nMultiple variables can be declared within a single const:\n\nconst y, z = 7, 11\n\nNote that const only applies to one = operation, therefore const x = y = 1\ndeclares x to be constant but not y. On the other hand, const x = const y = 1\ndeclares both x and y constant.\n\nNote that \"constant-ness\" does not extend into mutable containers; only the\nassociation between a variable and its value is constant.\nIf x is an array or dictionary (for example) you can still modify, add, or remove elements.\n\nIn some cases changing the value of a const variable gives a warning instead of\nan error.\nHowever, this can produce unpredictable behavior or corrupt the state of your program,\nand so should be avoided.\nThis feature is intended only for convenience during interactive use.\n\n\n\n\n\n"},{"title":"struct","page":"Essentials","location":"base/base.html#struct","category":"keyword","text":"struct\n\nThe most commonly used kind of type in Julia is a struct, specified as a name and a\nset of fields.\n\nstruct Point\n    x\n    y\nend\n\nFields can have type restrictions, which may be parameterized:\n\nstruct Point{X}\n    x::X\n    y::Float64\nend\n\nA struct can also declare an abstract super type via <: syntax:\n\nstruct Point <: AbstractPoint\n    x\n    y\nend\n\nstructs are immutable by default; an instance of one of these types cannot\nbe modified after construction. Use mutable struct instead to declare a\ntype whose instances can be modified.\n\nSee the manual section on Composite Types for more details,\nsuch as how to define constructors.\n\n\n\n\n\n"},{"title":"mutable struct","page":"Essentials","location":"base/base.html#mutable struct","category":"keyword","text":"mutable struct\n\nmutable struct is similar to struct, but additionally allows the\nfields of the type to be set after construction.\n\nIndividual fields of a mutable struct can be marked as const to make them immutable:\n\nmutable struct Baz\n    a::Int\n    const b::Float64\nend\n\ncompat: Julia 1.8\nThe const keyword for fields of mutable structs requires at least Julia 1.8.\n\nSee the manual section on Composite Types for more information.\n\n\n\n\n\n"},{"title":"Base.@kwdef","page":"Essentials","location":"base/base.html#Base.@kwdef","category":"macro","text":"@kwdef typedef\n\nThis is a helper macro that automatically defines a keyword-based constructor for the type\ndeclared in the expression typedef, which must be a struct or mutable struct\nexpression. The default argument is supplied by declaring fields of the form field::T = default or field = default. If no default is provided then the keyword argument becomes\na required keyword argument in the resulting type constructor.\n\nInner constructors can still be defined, but at least one should accept arguments in the\nsame form as the default inner constructor (i.e. one positional argument per field) in\norder to function correctly with the keyword outer constructor.\n\ncompat: Julia 1.1\nBase.@kwdef for parametric structs, and structs with supertypes\nrequires at least Julia 1.1.\n\ncompat: Julia 1.9\nThis macro is exported as of Julia 1.9.\n\nExamples\n\njulia> @kwdef struct Foo\n           a::Int = 1         # specified default\n           b::String          # required keyword\n       end\nFoo\n\njulia> Foo(b=\"hi\")\nFoo(1, \"hi\")\n\njulia> Foo()\nERROR: UndefKeywordError: keyword argument `b` not assigned\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"abstract type","page":"Essentials","location":"base/base.html#abstract type","category":"keyword","text":"abstract type\n\nabstract type declares a type that cannot be instantiated, and serves only as a node in the\ntype graph, thereby describing sets of related concrete types: those concrete types\nwhich are their descendants. Abstract types form the conceptual hierarchy which makes\nJulia’s type system more than just a collection of object implementations. For example:\n\nabstract type Number end\nabstract type Real <: Number end\n\nNumber has no supertype, whereas Real is an abstract subtype of Number.\n\n\n\n\n\n"},{"title":"primitive type","page":"Essentials","location":"base/base.html#primitive type","category":"keyword","text":"primitive type\n\nprimitive type declares a concrete type whose data consists only of a series of bits. Classic\nexamples of primitive types are integers and floating-point values. Some example built-in\nprimitive type declarations:\n\nprimitive type Char 32 end\nprimitive type Bool <: Integer 8 end\n\nThe number after the name indicates how many bits of storage the type requires. Currently,\nonly sizes that are multiples of 8 bits are supported.\nThe Bool declaration shows how a primitive type can be optionally\ndeclared to be a subtype of some supertype.\n\n\n\n\n\n"},{"title":"where","page":"Essentials","location":"base/base.html#where","category":"keyword","text":"where\n\nThe where keyword creates a UnionAll type, which may be thought of as an iterated union of other types, over all\nvalues of some variable. For example Vector{T} where T<:Real includes all Vectors\nwhere the element type is some kind of Real number.\n\nThe variable bound defaults to Any if it is omitted:\n\nVector{T} where T    # short for `where T<:Any`\n\nVariables can also have lower bounds:\n\nVector{T} where T>:Int\nVector{T} where Int<:T<:Real\n\nThere is also a concise syntax for nested where expressions. For example, this:\n\nPair{T, S} where S<:Array{T} where T<:Number\n\ncan be shortened to:\n\nPair{T, S} where {T<:Number, S<:Array{T}}\n\nThis form is often found on method signatures.\n\nNote that in this form, the variables are listed outermost-first. This matches the\norder in which variables are substituted when a type is \"applied\" to parameter values\nusing the syntax T{p1, p2, ...}.\n\n\n\n\n\n"},{"title":"...","page":"Essentials","location":"base/base.html#...","category":"keyword","text":"...\n\nThe \"splat\" operator, ..., represents a sequence of arguments.\n... can be used in function definitions, to indicate that the function\naccepts an arbitrary number of arguments.\n... can also be used to apply a function to a sequence of arguments.\n\nExamples\n\njulia> add(xs...) = reduce(+, xs)\nadd (generic function with 1 method)\n\njulia> add(1, 2, 3, 4, 5)\n15\n\njulia> add([1, 2, 3]...)\n6\n\njulia> add(7, 1:100..., 1000:1100...)\n111107\n\n\n\n\n\n"},{"title":";","page":"Essentials","location":"base/base.html#;","category":"keyword","text":";\n\nSemicolons are used as statement separators and mark the beginning of keyword arguments in function declarations or calls.\n\n\n\n\n\n"},{"title":"=","page":"Essentials","location":"base/base.html#=","category":"keyword","text":"=\n\n= is the assignment operator.\n\nFor variable a and expression b, a = b makes a refer to the value of b.\nFor functions f(x), f(x) = x defines a new function constant f, or adds a new method to f if f is already defined; this usage is equivalent to function f(x); x; end.\na[i] = v calls setindex!(a,v,i).\na.b = c calls setproperty!(a,:b,c).\nInside a function call, f(a=b) passes b as the value of keyword argument a.\nInside parentheses with commas, (a=1,) constructs a NamedTuple.\n\nExamples\n\nAssigning a to b does not create a copy of b; instead use copy or deepcopy.\n\njulia> b = [1]; a = b; b[1] = 2; a\n1-element Vector{Int64}:\n 2\n\njulia> b = [1]; a = copy(b); b[1] = 2; a\n1-element Vector{Int64}:\n 1\n\n\nCollections passed to functions are also not copied. Functions can modify (mutate) the contents of the objects their arguments refer to. (The names of functions which do this are conventionally suffixed with '!'.)\n\njulia> function f!(x); x[:] .+= 1; end\nf! (generic function with 1 method)\n\njulia> a = [1]; f!(a); a\n1-element Vector{Int64}:\n 2\n\n\nAssignment can operate on multiple variables in parallel, taking values from an iterable:\n\njulia> a, b = 4, 5\n(4, 5)\n\njulia> a, b = 1:3\n1:3\n\njulia> a, b\n(1, 2)\n\n\nAssignment can operate on multiple variables in series, and will return the value of the right-hand-most expression:\n\njulia> a = [1]; b = [2]; c = [3]; a = b = c\n1-element Vector{Int64}:\n 3\n\njulia> b[1] = 2; a, b, c\n([2], [2], [2])\n\n\nAssignment at out-of-bounds indices does not grow a collection. If the collection is a Vector it can instead be grown with push! or append!.\n\njulia> a = [1, 1]; a[3] = 2\nERROR: BoundsError: attempt to access 2-element Vector{Int64} at index [3]\n[...]\n\njulia> push!(a, 2, 3)\n4-element Vector{Int64}:\n 1\n 1\n 2\n 3\n\n\nAssigning [] does not eliminate elements from a collection; instead use filter!.\n\njulia> a = collect(1:3); a[a .<= 1] = []\nERROR: DimensionMismatch: tried to assign 0 elements to 1 destinations\n[...]\n\njulia> filter!(x -> x > 1, a) # in-place & thus more efficient than a = a[a .> 1]\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n\n\n"},{"title":"?:","page":"Essentials","location":"base/base.html#?:","category":"keyword","text":"a ? b : c\n\nShort form for conditionals; read \"if a, evaluate b otherwise evaluate c\".\nAlso known as the ternary operator.\n\nThis syntax is equivalent to if a; b else c end, but is often used to\nemphasize the value b-or-c which is being used as part of a larger\nexpression, rather than the side effects that evaluating b or c may have.\n\nSee the manual section on control flow for more details.\n\nExamples\n\njulia> x = 1; y = 2;\n\njulia> x > y ? println(\"x is larger\") : println(\"x is not larger\")\nx is not larger\n\njulia> x > y ? \"x is larger\" : x == y ? \"x and y are equal\" : \"y is larger\"\n\"y is larger\"\n\n\n\n\n\n"},{"title":".=","page":"Essentials","location":"base/base.html#.=","category":"keyword","text":".=\n\nPerform broadcasted assignment. The right-side argument is expanded as in\nbroadcast and then assigned into the left-side argument in-place.\nFuses with other dotted operators in the same expression; i.e. the whole\nassignment expression is converted into a single loop.\n\nA .= B is similar to broadcast!(identity, A, B).\n\nExamples\n\njulia> A = zeros(4, 4); B = [1, 2, 3, 4];\n\njulia> A .= B\n4×4 Matrix{Float64}:\n 1.0  1.0  1.0  1.0\n 2.0  2.0  2.0  2.0\n 3.0  3.0  3.0  3.0\n 4.0  4.0  4.0  4.0\n\njulia> A\n4×4 Matrix{Float64}:\n 1.0  1.0  1.0  1.0\n 2.0  2.0  2.0  2.0\n 3.0  3.0  3.0  3.0\n 4.0  4.0  4.0  4.0\n\n\n\n\n\n"},{"title":".","page":"Essentials","location":"base/base.html#.","category":"keyword","text":".\n\nThe dot operator is used to access fields or properties of objects and access\nvariables defined inside modules.\n\nIn general, a.b calls getproperty(a, :b) (see getproperty).\n\nExamples\n\njulia> z = 1 + 2im; z.im\n2\n\njulia> Iterators.product\nproduct (generic function with 1 method)\n\n\n\n\n\n"},{"title":"->","page":"Essentials","location":"base/base.html#->","category":"keyword","text":"x -> y\n\nCreate an anonymous function mapping argument(s) x to the function body y.\n\njulia> f = x -> x^2 + 2x - 1\n#1 (generic function with 1 method)\n\njulia> f(2)\n7\n\nAnonymous functions can also be defined for multiple arguments.\n\njulia> g = (x,y) -> x^2 + y^2\n#2 (generic function with 1 method)\n\njulia> g(2,3)\n13\n\nSee the manual section on anonymous functions for more details.\n\n\n\n\n\n"},{"title":"Base.::","page":"Essentials","location":"base/base.html#Base.::","category":"function","text":":expr\n\nQuote an expression expr, returning the abstract syntax tree (AST) of expr.\nThe AST may be of type Expr, Symbol, or a literal value.\nThe syntax :identifier evaluates to a Symbol.\n\nSee also: Expr, Symbol, Meta.parse\n\nExamples\n\njulia> expr = :(a = b + 2*x)\n:(a = b + 2x)\n\njulia> sym = :some_identifier\n:some_identifier\n\njulia> value = :0xff\n0xff\n\njulia> typeof((expr, sym, value))\nTuple{Expr, Symbol, UInt8}\n\n\n\n\n\n"},{"title":"::","page":"Essentials","location":"base/base.html#::","category":"keyword","text":"::\n\nThe :: operator either asserts that a value has the given type, or declares that\na local variable or function return always has the given type.\n\nGiven expression::T, expression is first evaluated. If the result is of type\nT, the value is simply returned. Otherwise, a TypeError is thrown.\n\nIn local scope, the syntax local x::T or x::T = expression declares that local variable\nx always has type T. When a value is assigned to the variable, it will be\nconverted to type T by calling convert.\n\nIn a method declaration, the syntax function f(x)::T causes any value returned by\nthe method to be converted to type T.\n\nSee the manual section on Type Declarations.\n\nExamples\n\njulia> (1+2)::AbstractFloat\nERROR: TypeError: typeassert: expected AbstractFloat, got a value of type Int64\n\njulia> (1+2)::Int\n3\n\njulia> let\n           local x::Int\n           x = 2.0\n           x\n       end\n2\n\n\n\n\n\n"},{"title":"[]","page":"Essentials","location":"base/base.html#[]","category":"keyword","text":"[]\n\nSquare brackets are used for indexing (getindex),\nindexed assignment (setindex!),\narray literals (Base.vect),\narray concatenation (vcat, hcat, hvcat, hvncat),\nand array comprehensions (collect).\n\n\n\n\n\n"},{"title":"Main","page":"Essentials","location":"base/base.html#Main","category":"module","text":"Main\n\nMain is the top-level module, and Julia starts with Main set as the current module.  Variables defined at the prompt go in Main, and varinfo lists variables in Main.\n\njulia> @__MODULE__\nMain\n\n\n\n\n\n"},{"title":"Core","page":"Essentials","location":"base/base.html#Core","category":"module","text":"Core\n\nCore is the module that contains all identifiers considered \"built in\" to the language, i.e. part of the core language and not libraries. Every module implicitly specifies using Core, since you can't do anything without those definitions.\n\n\n\n\n\n"},{"title":"Base","page":"Essentials","location":"base/base.html#Base","category":"module","text":"Base\n\nThe base library of Julia. Base is a module that contains basic functionality (the contents of base/). All modules implicitly contain using Base, since this is needed in the vast majority of cases.\n\n\n\n\n\n"},{"title":"Base.Broadcast","page":"Essentials","location":"base/base.html#Base.Broadcast","category":"module","text":"Base.Broadcast\n\nModule containing the broadcasting implementation.\n\n\n\n\n\n"},{"title":"Base.Docs","page":"Essentials","location":"base/base.html#Base.Docs","category":"module","text":"Docs\n\nThe Docs module provides the @doc macro which can be used to set and retrieve\ndocumentation metadata for Julia objects.\n\nPlease see the manual section on documentation for more\ninformation.\n\n\n\n\n\n"},{"title":"Base.Iterators","page":"Essentials","location":"base/base.html#Base.Iterators","category":"module","text":"Methods for working with Iterators.\n\n\n\n\n\n"},{"title":"Base.Libc","page":"Essentials","location":"base/base.html#Base.Libc","category":"module","text":"Interface to libc, the C standard library.\n\n\n\n\n\n"},{"title":"Base.Meta","page":"Essentials","location":"base/base.html#Base.Meta","category":"module","text":"Convenience functions for metaprogramming.\n\n\n\n\n\n"},{"title":"Base.StackTraces","page":"Essentials","location":"base/base.html#Base.StackTraces","category":"module","text":"Tools for collecting and manipulating stack traces. Mainly used for building errors.\n\n\n\n\n\n"},{"title":"Base.Sys","page":"Essentials","location":"base/base.html#Base.Sys","category":"module","text":"Provide methods for retrieving information about hardware and the operating system.\n\n\n\n\n\n"},{"title":"Base.Threads","page":"Essentials","location":"base/base.html#Base.Threads","category":"module","text":"Multithreading support.\n\n\n\n\n\n"},{"title":"Base.GC","page":"Essentials","location":"base/base.html#Base.GC","category":"module","text":"Base.GC\n\nModule with garbage collection utilities.\n\n\n\n\n\n"},{"title":"Core.:===","page":"Essentials","location":"base/base.html#Core.:===","category":"function","text":"===(x,y)::Bool\n≡(x,y)::Bool\n\nDetermine whether x and y are identical, in the sense that no program could distinguish\nthem. First the types of x and y are compared. If those are identical, mutable objects\nare compared by address in memory and immutable objects (such as numbers) are compared by\ncontents at the bit level. This function is sometimes called \"egal\".\nIt always returns a Bool value.\n\nExamples\n\njulia> a = [1, 2]; b = [1, 2];\n\njulia> a == b\ntrue\n\njulia> a === b\nfalse\n\njulia> a === a\ntrue\n\n\n\n\n\n"},{"title":"Core.isa","page":"Essentials","location":"base/base.html#Core.isa","category":"function","text":"isa(x, type)::Bool\n\nDetermine whether x is of the given type. Can also be used as an infix operator, e.g.\nx isa type.\n\nExamples\n\njulia> isa(1, Int)\ntrue\n\njulia> isa(1, Matrix)\nfalse\n\njulia> isa(1, Char)\nfalse\n\njulia> isa(1, Number)\ntrue\n\njulia> 1 isa Number\ntrue\n\n\n\n\n\n"},{"title":"Base.isequal","page":"Essentials","location":"base/base.html#Base.isequal","category":"function","text":"isequal(x)\n\nCreate a function that compares its argument to x using isequal, i.e.\na function equivalent to y -> isequal(y, x).\n\nThe returned function is of type Base.Fix2{typeof(isequal)}, which can be\nused to implement specialized methods.\n\n\n\n\n\nisequal(x, y)::Bool\n\nSimilar to ==, except for the treatment of floating point numbers\nand of missing values. isequal treats all floating-point NaN values as equal\nto each other, treats -0.0 as unequal to 0.0, and missing as equal\nto missing. Always returns a Bool value.\n\nisequal is an equivalence relation - it is reflexive (=== implies isequal), symmetric\n(isequal(a, b) implies isequal(b, a)) and transitive (isequal(a, b) and\nisequal(b, c) implies isequal(a, c)).\n\nImplementation\n\nThe default implementation of isequal calls ==, so a type that does not involve\nfloating-point values generally only needs to define ==.\n\nisequal is the comparison function used by hash tables (Dict). isequal(x,y) must imply\nthat hash(x) == hash(y).\n\nThis typically means that types for which a custom == or isequal method exists must\nimplement a corresponding hash method (and vice versa). Collections typically\nimplement isequal by calling isequal recursively on all contents.\n\nFurthermore, isequal is linked with isless, and they work together to\ndefine a fixed total ordering, where exactly one of isequal(x, y), isless(x, y), or\nisless(y, x) must be true (and the other two false).\n\nScalar types generally do not need to implement isequal separate from ==, unless they\nrepresent floating-point numbers amenable to a more efficient implementation than that\nprovided as a generic fallback (based on isnan, signbit, and ==).\n\nExamples\n\njulia> isequal([1., NaN], [1., NaN])\ntrue\n\njulia> [1., NaN] == [1., NaN]\nfalse\n\njulia> 0.0 == -0.0\ntrue\n\njulia> isequal(0.0, -0.0)\nfalse\n\njulia> missing == missing\nmissing\n\njulia> isequal(missing, missing)\ntrue\n\n\n\n\n\n"},{"title":"Base.isless","page":"Essentials","location":"base/base.html#Base.isless","category":"function","text":"isless(x, y)\n\nTest whether x is less than y, according to a fixed total order (defined together with\nisequal). isless is not defined for pairs (x, y) of all types. However, if it\nis defined, it is expected to satisfy the following:\n\nIf isless(x, y) is defined, then so is isless(y, x) and isequal(x, y),\nand exactly one of those three yields true.\nThe relation defined by isless is transitive, i.e.,\nisless(x, y) && isless(y, z) implies isless(x, z).\n\nValues that are normally unordered, such as NaN,\nare ordered after regular values.\nmissing values are ordered last.\n\nThis is the default comparison used by sort!.\n\nImplementation\n\nNon-numeric types with a total order should implement this function.\nNumeric types only need to implement it if they have special values such as NaN.\nTypes with a partial order should implement <.\nSee the documentation on Alternate Orderings for how to define alternate\nordering methods that can be used in sorting and related functions.\n\nExamples\n\njulia> isless(1, 3)\ntrue\n\njulia> isless(\"Red\", \"Blue\")\nfalse\n\n\n\n\n\n"},{"title":"Base.ispositive","page":"Essentials","location":"base/base.html#Base.ispositive","category":"function","text":"ispositive(x)\n\nTest whether x > 0. See also isnegative.\n\ncompat: Julia 1.13\nThis function requires at least Julia 1.13.\n\nExamples\n\njulia> ispositive(-4.0)\nfalse\n\njulia> ispositive(99)\ntrue\n\njulia> ispositive(0.0)\nfalse\n\n\n\n\n\n"},{"title":"Base.isnegative","page":"Essentials","location":"base/base.html#Base.isnegative","category":"function","text":"isnegative(x)\n\nTest whether x < 0. See also ispositive.\n\ncompat: Julia 1.13\nThis function requires at least Julia 1.13.\n\nExamples\n\njulia> isnegative(-4.0)\ntrue\n\njulia> isnegative(99)\nfalse\n\njulia> isnegative(-0.0)\nfalse\n\n\n\n\n\n"},{"title":"Base.isunordered","page":"Essentials","location":"base/base.html#Base.isunordered","category":"function","text":"isunordered(x)\n\nReturn true if x is a value that is not orderable according to <, such as NaN\nor missing.\n\nThe values that evaluate to true with this predicate may be orderable with respect to other\norderings such as isless.\n\ncompat: Julia 1.7\nThis function requires Julia 1.7 or later.\n\n\n\n\n\n"},{"title":"Base.ifelse","page":"Essentials","location":"base/base.html#Base.ifelse","category":"function","text":"ifelse(condition::Bool, x, y)\n\nReturn x if condition is true, otherwise return y. This differs from ? or if in\nthat it is an ordinary function, so all the arguments are evaluated first. In some cases,\nusing ifelse instead of an if statement can eliminate the branch in generated code and\nprovide higher performance in tight loops.\n\nExamples\n\njulia> ifelse(1 > 2, 1, 2)\n2\n\n\n\n\n\n"},{"title":"Core.typeassert","page":"Essentials","location":"base/base.html#Core.typeassert","category":"function","text":"typeassert(x, type)\n\nThrow a TypeError unless x isa type.\nThe syntax x::type calls this function.\n\nExamples\n\njulia> typeassert(2.5, Int)\nERROR: TypeError: in typeassert, expected Int64, got a value of type Float64\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"Core.typeof","page":"Essentials","location":"base/base.html#Core.typeof","category":"function","text":"typeof(x)\n\nGet the concrete type of x.\n\nSee also eltype.\n\nExamples\n\njulia> a = 1//2;\n\njulia> typeof(a)\nRational{Int64}\n\njulia> M = [1 2; 3.5 4];\n\njulia> typeof(M)\nMatrix{Float64} (alias for Array{Float64, 2})\n\n\n\n\n\n"},{"title":"Core.tuple","page":"Essentials","location":"base/base.html#Core.tuple","category":"function","text":"tuple(xs...)\n\nConstruct a tuple of the given objects.\n\nSee also Tuple, ntuple, NamedTuple.\n\nExamples\n\njulia> tuple(1, 'b', pi)\n(1, 'b', π)\n\njulia> ans === (1, 'b', π)\ntrue\n\njulia> Tuple(Real[1, 2, pi])  # takes a collection\n(1, 2, π)\n\n\n\n\n\n"},{"title":"Base.ntuple","page":"Essentials","location":"base/base.html#Base.ntuple","category":"function","text":"ntuple(f, ::Val{N})\n\nCreate a tuple of length N, computing each element as f(i),\nwhere i is the index of the element. By taking a Val(N)\nargument, it is possible that this version of ntuple may\ngenerate more efficient code than the version taking the\nlength as an integer. But ntuple(f, N) is preferable to\nntuple(f, Val(N)) in cases where N cannot be determined\nat compile time.\n\nExamples\n\njulia> ntuple(i -> 2*i, Val(4))\n(2, 4, 6, 8)\n\n\n\n\n\nntuple(f, n::Integer)\n\nCreate a tuple of length n, computing each element as f(i),\nwhere i is the index of the element.\n\nExamples\n\njulia> ntuple(i -> 2*i, 4)\n(2, 4, 6, 8)\n\n\n\n\n\n"},{"title":"Base.objectid","page":"Essentials","location":"base/base.html#Base.objectid","category":"function","text":"objectid(x)::UInt\n\nGet a hash value for x based on object identity. This value is not unique nor\nstable between Julia processes or versions.\n\nIf x === y then objectid(x) == objectid(y), and usually when x !== y, objectid(x) != objectid(y).\n\nSee also hash, IdDict.\n\n\n\n\n\n"},{"title":"Base.hash","page":"Essentials","location":"base/base.html#Base.hash","category":"function","text":"hash(x[, h::UInt])::UInt\n\nCompute an integer hash code such that isequal(x,y) implies isequal(hash(x), hash(y)). The\noptional second argument h is another hash code to be mixed with the result.\n\nNew types should implement the 2-argument form, typically by calling the 2-argument hash\nmethod recursively in order to mix hashes of the contents with each other (and with h).\nTypically, any type that implements hash should also implement its own == (hence\nisequal) to guarantee the property mentioned above.\n\nThe hash value may change when a new Julia process is started.\n\nwarning: Warning\nWhen implementing the 2-argument form, the second argument h should not be given a\ndefault value such h = UInt(0) as this will implicitly create a 1-argument method that\nis more specific than the fallback (see Note on Optional and keyword Arguments),\nbut potentially with the wrong seed, causing hash inconsistencies.\n\njulia> a = hash(10)\n0x759d18cc5346a65f\n\njulia> hash(10, a) # only use the output of another hash function as the second argument\n0x03158cd61b1b0bd1\n\nSee also: objectid, Dict, Set.\n\n\n\n\n\n"},{"title":"Base.finalizer","page":"Essentials","location":"base/base.html#Base.finalizer","category":"function","text":"finalizer(f, x)\n\nRegister a function f(x) to be called when there are no program-accessible references to\nx, and return x. The type of x must be a mutable struct, otherwise the function\nwill throw.\n\nf must not cause a task switch, which excludes most I/O operations such as println.\nUsing the @async macro (to defer context switching to outside of the finalizer) or\nccall to directly invoke IO functions in C may be helpful for debugging purposes.\n\nNote that there is no guaranteed world age for the execution of f. It may be\ncalled in the world age in which the finalizer was registered or any later world age.\n\nExamples\n\nfinalizer(my_mutable_struct) do x\n    @async println(\"Finalizing $x.\")\nend\n\nfinalizer(my_mutable_struct) do x\n    ccall(:jl_safe_printf, Cvoid, (Cstring, Cstring), \"Finalizing %s.\", repr(x))\nend\n\nA finalizer may be registered at object construction. In the following example note that\nwe implicitly rely on the finalizer returning the newly created mutable struct x.\n\nmutable struct MyMutableStruct\n    bar\n    function MyMutableStruct(bar)\n        x = new(bar)\n        f(t) = @async println(\"Finalizing $t.\")\n        finalizer(f, x)\n    end\nend\n\n\n\n\n\n"},{"title":"Base.finalize","page":"Essentials","location":"base/base.html#Base.finalize","category":"function","text":"finalize(x)\n\nImmediately run finalizers registered for object x.\n\n\n\n\n\n"},{"title":"Base.copy","page":"Essentials","location":"base/base.html#Base.copy","category":"function","text":"copy(x)\n\nCreate a shallow copy of x: the outer structure is copied, but not all internal values.\nFor example, copying an array produces a new array with identically-same elements as the\noriginal.\n\nSee also copy!, copyto!, deepcopy.\n\n\n\n\n\n"},{"title":"Base.deepcopy","page":"Essentials","location":"base/base.html#Base.deepcopy","category":"function","text":"deepcopy(x)\n\nCreate a deep copy of x: everything is copied recursively, resulting in a fully\nindependent object. For example, deep-copying an array creates deep copies of all\nthe objects it contains and produces a new array with the consistent relationship\nstructure (e.g., if the first two elements are the same object in the original array,\nthe first two elements of the new array will also be the same deepcopyed object).\nCalling deepcopy on an object should generally\nhave the same effect as serializing and then deserializing it.\n\nWhile it isn't normally necessary, user-defined types can override the default deepcopy\nbehavior by defining a specialized version of the function\ndeepcopy_internal(x::T, dict::IdDict) (which shouldn't otherwise be used),\nwhere T is the type to be specialized for, and dict keeps track of objects copied\nso far within the recursion. Within the definition, deepcopy_internal should be used\nin place of deepcopy, and the dict variable should be\nupdated as appropriate before returning.\n\nwarning: Warning\nIt is better to avoid this function in favor of custom copy methods or use-case-specific\ncopying functions. deepcopy is slow and can easily copy too many objects, or generate an\nobject that violates invariants, since it does not respect abstraction boundaries.\n\n\n\n\n\n"},{"title":"Base.getproperty","page":"Essentials","location":"base/base.html#Base.getproperty","category":"function","text":"getproperty(value, name::Symbol)\ngetproperty(value, name::Symbol, order::Symbol)\n\nThe syntax a.b calls getproperty(a, :b).\nThe syntax @atomic order a.b calls getproperty(a, :b, :order) and\nthe syntax @atomic a.b calls getproperty(a, :b, :sequentially_consistent).\n\nExamples\n\njulia> struct MyType{T <: Number}\n           x::T\n       end\n\njulia> function Base.getproperty(obj::MyType, sym::Symbol)\n           if sym === :special\n               return obj.x + 1\n           else # fallback to getfield\n               return getfield(obj, sym)\n           end\n       end\n\njulia> obj = MyType(1);\n\njulia> obj.special\n2\n\njulia> obj.x\n1\n\nOne should overload getproperty only when necessary, as it can be confusing if\nthe behavior of the syntax obj.f is unusual.\nAlso note that using methods is often preferable. See also this style guide documentation\nfor more information: Prefer exported methods over direct field access.\n\nSee also getfield,\npropertynames and\nsetproperty!.\n\n\n\n\n\n"},{"title":"Base.setproperty!","page":"Essentials","location":"base/base.html#Base.setproperty!","category":"function","text":"setproperty!(value, name::Symbol, x)\nsetproperty!(value, name::Symbol, x, order::Symbol)\n\nThe syntax a.b = c calls setproperty!(a, :b, c).\nThe syntax @atomic order a.b = c calls setproperty!(a, :b, c, :order)\nand the syntax @atomic a.b = c calls setproperty!(a, :b, c, :sequentially_consistent).\n\ncompat: Julia 1.8\nsetproperty! on modules requires at least Julia 1.8.\n\nSee also setfield!,\npropertynames and\ngetproperty.\n\n\n\n\n\n"},{"title":"Base.replaceproperty!","page":"Essentials","location":"base/base.html#Base.replaceproperty!","category":"function","text":"replaceproperty!(x, f::Symbol, expected, desired, success_order::Symbol=:not_atomic, fail_order::Symbol=success_order)\n\nPerform a compare-and-swap operation on x.f from expected to desired, per\negal. The syntax @atomicreplace x.f expected => desired can be used instead\nof the function call form.\n\nSee also replacefield!\nsetproperty!,\nsetpropertyonce!.\n\n\n\n\n\n"},{"title":"Base.swapproperty!","page":"Essentials","location":"base/base.html#Base.swapproperty!","category":"function","text":"swapproperty!(x, f::Symbol, v, order::Symbol=:not_atomic)\n\nThe syntax @atomic a.b, _ = c, a.b returns (c, swapproperty!(a, :b, c, :sequentially_consistent)),\nwhere there must be one getproperty expression common to both sides.\n\nSee also swapfield!\nand setproperty!.\n\n\n\n\n\n"},{"title":"Base.modifyproperty!","page":"Essentials","location":"base/base.html#Base.modifyproperty!","category":"function","text":"modifyproperty!(x, f::Symbol, op, v, order::Symbol=:not_atomic)\n\nThe syntax @atomic op(x.f, v) (and its equivalent @atomic x.f op v) returns\nmodifyproperty!(x, :f, op, v, :sequentially_consistent), where the first argument\nmust be a getproperty expression and is modified atomically.\n\nInvocation of op(getproperty(x, f), v) must return a value that can be stored in the field\nf of the object x by default.  In particular, unlike the default behavior of\nsetproperty!, the convert function is not called\nautomatically.\n\nSee also modifyfield!\nand setproperty!.\n\n\n\n\n\n"},{"title":"Base.setpropertyonce!","page":"Essentials","location":"base/base.html#Base.setpropertyonce!","category":"function","text":"setpropertyonce!(x, f::Symbol, value, success_order::Symbol=:not_atomic, fail_order::Symbol=success_order)\n\nPerform a compare-and-swap operation on x.f to set it to value if previously unset.\nThe syntax @atomiconce x.f = value can be used instead of the function call form.\n\nSee also setfieldonce!,\nsetproperty!,\nreplaceproperty!.\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\n\n\n\n\n"},{"title":"Base.propertynames","page":"Essentials","location":"base/base.html#Base.propertynames","category":"function","text":"propertynames(x, private=false)\n\nGet a tuple or a vector of the properties (x.property) of an object x.\nThis is typically the same as fieldnames(typeof(x)), but types\nthat overload getproperty should generally overload propertynames\nas well to get the properties of an instance of the type.\n\npropertynames(x) may return only \"public\" property names that are part\nof the documented interface of x.   If you want it to also return \"private\"\nproperty names intended for internal use, pass true for the optional second argument.\nREPL tab completion on x. shows only the private=false properties.\n\nSee also: hasproperty, hasfield.\n\n\n\n\n\n"},{"title":"Base.hasproperty","page":"Essentials","location":"base/base.html#Base.hasproperty","category":"function","text":"hasproperty(x, s::Symbol)\n\nReturn a boolean indicating whether the object x has s as one of its own properties.\n\ncompat: Julia 1.2\nThis function requires at least Julia 1.2.\n\nSee also: propertynames, hasfield.\n\n\n\n\n\n"},{"title":"Core.getfield","page":"Essentials","location":"base/base.html#Core.getfield","category":"function","text":"getfield(value, name::Symbol, [order::Symbol], [boundscheck::Bool=true])\ngetfield(value, i::Int, [order::Symbol], [boundscheck::Bool=true])\n\nExtract a field from a composite value by name or position.\n\nOptionally, an ordering can be defined for the operation.\nIf the field was declared @atomic, the specification is strongly recommended to be\ncompatible with the stores to that location.\nOtherwise, if not declared as @atomic, this parameter must be :not_atomic if specified.\n\nThe bounds check may be disabled, in which case the behavior of this function is\nundefined if i is out of bounds.\n\nSee also getproperty and fieldnames.\n\nExamples\n\njulia> a = 1//2\n1//2\n\njulia> getfield(a, :num)\n1\n\njulia> a.num\n1\n\njulia> getfield(a, 1)\n1\n\n\n\n\n\n"},{"title":"Core.setfield!","page":"Essentials","location":"base/base.html#Core.setfield!","category":"function","text":"setfield!(value, name::Symbol, x, [order::Symbol])\nsetfield!(value, i::Int, x, [order::Symbol])\n\nAssign x to a named field in value of composite type. The value must be\nmutable and x must be a subtype of fieldtype(typeof(value), name).\nAdditionally, an ordering can be specified for this operation. If the field was\ndeclared @atomic, this specification is mandatory. Otherwise, if not declared\nas @atomic, it must be :not_atomic if specified.\nSee also setproperty!.\n\nExamples\n\njulia> mutable struct MyMutableStruct\n           field::Int\n       end\n\njulia> a = MyMutableStruct(1);\n\njulia> setfield!(a, :field, 2);\n\njulia> getfield(a, :field)\n2\n\njulia> a = 1//2\n1//2\n\njulia> setfield!(a, :num, 3);\nERROR: setfield!: immutable struct of type Rational cannot be changed\n\n\n\n\n\n"},{"title":"Core.modifyfield!","page":"Essentials","location":"base/base.html#Core.modifyfield!","category":"function","text":"modifyfield!(value, name::Symbol, op, x, [order::Symbol])::Pair\nmodifyfield!(value, i::Int, op, x, [order::Symbol])::Pair\n\nAtomically perform the operations to get and set a field after applying\nthe function op.\n\ny = getfield(value, name)\nz = op(y, x)\nsetfield!(value, name, z)\nreturn y => z\n\nIf supported by the hardware (for example, atomic increment), this may be\noptimized to the appropriate hardware instruction, otherwise it'll use a loop.\n\ncompat: Julia 1.7\nThis function requires Julia 1.7 or later.\n\n\n\n\n\n"},{"title":"Core.replacefield!","page":"Essentials","location":"base/base.html#Core.replacefield!","category":"function","text":"replacefield!(value, name::Symbol, expected, desired,\n              [success_order::Symbol, [fail_order::Symbol=success_order]) -> (; old, success::Bool)\nreplacefield!(value, i::Int, expected, desired,\n              [success_order::Symbol, [fail_order::Symbol=success_order]) -> (; old, success::Bool)\n\nAtomically perform the operations to get and conditionally set a field to\na given value.\n\ny = getfield(value, name, fail_order)\nok = y === expected\nif ok\n    setfield!(value, name, desired, success_order)\nend\nreturn (; old = y, success = ok)\n\nIf supported by the hardware, this may be optimized to the appropriate hardware\ninstruction, otherwise it'll use a loop.\n\ncompat: Julia 1.7\nThis function requires Julia 1.7 or later.\n\n\n\n\n\n"},{"title":"Core.swapfield!","page":"Essentials","location":"base/base.html#Core.swapfield!","category":"function","text":"swapfield!(value, name::Symbol, x, [order::Symbol])\nswapfield!(value, i::Int, x, [order::Symbol])\n\nAtomically perform the operations to simultaneously get and set a field:\n\ny = getfield(value, name)\nsetfield!(value, name, x)\nreturn y\n\ncompat: Julia 1.7\nThis function requires Julia 1.7 or later.\n\n\n\n\n\n"},{"title":"Core.setfieldonce!","page":"Essentials","location":"base/base.html#Core.setfieldonce!","category":"function","text":"setfieldonce!(value, name::Union{Int,Symbol}, desired,\n              [success_order::Symbol, [fail_order::Symbol=success_order]) -> success::Bool\n\nAtomically perform the operations to set a field to\na given value, only if it was previously not set.\n\nok = !isdefined(value, name, fail_order)\nif ok\n    setfield!(value, name, desired, success_order)\nend\nreturn ok\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\n\n\n\n\n"},{"title":"Core.isdefined","page":"Essentials","location":"base/base.html#Core.isdefined","category":"function","text":"isdefined(m::Module, s::Symbol, [order::Symbol])\nisdefined(object, s::Symbol, [order::Symbol])\nisdefined(object, index::Int, [order::Symbol])\n\nTests whether a global variable or object field is defined. The arguments can\nbe a module and a symbol or a composite object and field name (as a symbol) or\nindex. Optionally, an ordering can be defined for the operation. If the field\nwas declared @atomic, the specification is strongly recommended to be\ncompatible with the stores to that location. Otherwise, if not declared as\n@atomic, this parameter must be :not_atomic if specified.\n\nTo test whether an array element is defined, use isassigned instead.\n\nThe global variable variant is supported for compatibility with older julia\nreleases. For new code, prefer isdefinedglobal.\n\nSee also @isdefined.\n\nExamples\n\njulia> isdefined(Base, :sum)\ntrue\n\njulia> isdefined(Base, :NonExistentMethod)\nfalse\n\njulia> a = 1//2;\n\njulia> isdefined(a, 2)\ntrue\n\njulia> isdefined(a, 3)\nfalse\n\njulia> isdefined(a, :num)\ntrue\n\njulia> isdefined(a, :numerator)\nfalse\n\n\n\n\n\n"},{"title":"Core.isdefinedglobal","page":"Essentials","location":"base/base.html#Core.isdefinedglobal","category":"function","text":"isdefinedglobal(m::Module, s::Symbol, [allow_import::Bool=true, [order::Symbol=:unordered]])\n\nTests whether a global variable s is defined in module m (in the current world age).\nA variable is considered defined if and only if a value may be read from this global variable\nand an access will not throw. This includes both constants and global variables that have\na value set.\n\nIf allow_import is false, the global variable must be defined inside m\nand may not be imported from another module.\n\ncompat: Julia 1.12\nThis function requires Julia 1.12 or later.\n\nSee also @isdefined.\n\nExamples\n\njulia> isdefinedglobal(Base, :sum)\ntrue\n\njulia> isdefinedglobal(Base, :NonExistentMethod)\nfalse\n\njulia> isdefinedglobal(Base, :sum, false)\ntrue\n\njulia> isdefinedglobal(Main, :sum, false)\nfalse\n\n\n\n\n\n"},{"title":"Base.@isdefined","page":"Essentials","location":"base/base.html#Base.@isdefined","category":"macro","text":"@isdefined(s)::Bool\n\nTests whether variable s is defined in the current scope.\n\nSee also isdefined for field properties and isassigned for\narray indexes or haskey for other mappings.\n\nExamples\n\njulia> @isdefined newvar\nfalse\n\njulia> newvar = 1\n1\n\njulia> @isdefined newvar\ntrue\n\njulia> function f()\n           println(@isdefined x)\n           x = 3\n           println(@isdefined x)\n       end\nf (generic function with 1 method)\n\njulia> f()\nfalse\ntrue\n\n\n\n\n\n"},{"title":"Base.convert","page":"Essentials","location":"base/base.html#Base.convert","category":"function","text":"convert(T, x)\n\nConvert x to a value of type T.\n\nIf T is an Integer type, an InexactError will be raised if x\nis not representable by T, for example if x is not integer-valued, or is outside the\nrange supported by T.\n\nExamples\n\njulia> convert(Int, 3.0)\n3\n\njulia> convert(Int, 3.5)\nERROR: InexactError: Int64(3.5)\nStacktrace:\n[...]\n\nIf T is an AbstractFloat type, then it will return the\nclosest value to x representable by T. Inf is treated as one\nulp greater than floatmax(T) for purposes of determining nearest.\n\njulia> x = 1/3\n0.3333333333333333\n\njulia> convert(Float32, x)\n0.33333334f0\n\njulia> convert(BigFloat, x)\n0.333333333333333314829616256247390992939472198486328125\n\nIf T is a collection type and x a collection, the result of\nconvert(T, x) may share memory with all or part of x.\n\njulia> x = Int[1, 2, 3];\n\njulia> y = convert(Vector{Int}, x);\n\njulia> y === x\ntrue\n\nSee also: round, trunc, oftype, reinterpret.\n\n\n\n\n\n"},{"title":"Base.promote","page":"Essentials","location":"base/base.html#Base.promote","category":"function","text":"promote(xs...)\n\nConvert all arguments to a common type, and return them all (as a tuple).\nIf no arguments can be converted, an error is raised.\n\nSee also: promote_type, promote_rule.\n\nExamples\n\njulia> promote(Int8(1), Float16(4.5), Float32(4.1))\n(1.0f0, 4.5f0, 4.1f0)\n\njulia> promote_type(Int8, Float16, Float32)\nFloat32\n\njulia> reduce(Base.promote_typejoin, (Int8, Float16, Float32))\nReal\n\njulia> promote(1, \"x\")\nERROR: promotion of types Int64 and String failed to change any arguments\n[...]\n\njulia> promote_type(Int, String)\nAny\n\n\n\n\n\n"},{"title":"Base.oftype","page":"Essentials","location":"base/base.html#Base.oftype","category":"function","text":"oftype(x, y)\n\nConvert y to the type of x i.e. convert(typeof(x), y).\n\nExamples\n\njulia> x = 4;\n\njulia> y = 3.;\n\njulia> oftype(x, y)\n3\n\njulia> oftype(y, x)\n4.0\n\n\n\n\n\n"},{"title":"Base.widen","page":"Essentials","location":"base/base.html#Base.widen","category":"function","text":"widen(x)\n\nIf x is a type, return a \"larger\" type, defined so that arithmetic operations\n+ and - are guaranteed not to overflow nor lose precision for any combination\nof values that type x can hold.\n\nFor fixed-size integer types less than 128 bits, widen will return a type with\ntwice the number of bits.\n\nIf x is a value, it is converted to widen(typeof(x)).\n\nExamples\n\njulia> widen(Int32)\nInt64\n\njulia> widen(1.5f0)\n1.5\n\n\n\n\n\n"},{"title":"Base.identity","page":"Essentials","location":"base/base.html#Base.identity","category":"function","text":"identity(x)\n\nThe identity function. Returns its argument.\n\nSee also: one, oneunit, and LinearAlgebra's I.\n\nExamples\n\njulia> identity(\"Well, what did you expect?\")\n\"Well, what did you expect?\"\n\n\n\n\n\n"},{"title":"Core.WeakRef","page":"Essentials","location":"base/base.html#Core.WeakRef","category":"type","text":"WeakRef(x)\n\nw = WeakRef(x) constructs a weak reference\nto the Julia value x: although w contains a reference to x, it does not prevent x from being\ngarbage collected. w.value is either x (if x has not been garbage-collected yet) or nothing\n(if x has been garbage-collected).\n\njulia> x = \"a string\"\n\"a string\"\n\njulia> w = WeakRef(x)\nWeakRef(\"a string\")\n\njulia> GC.gc()\n\njulia> w           # a reference is maintained via `x`\nWeakRef(\"a string\")\n\njulia> x = nothing # clear reference\n\njulia> GC.gc()\n\njulia> w\nWeakRef(nothing)\n\n\n\n\n\n"},{"title":"Base.supertype","page":"Essentials","location":"base/base.html#Base.supertype","category":"function","text":"supertype(T::Union{DataType, UnionAll})\n\nReturn the direct supertype of type T.\nT can be a DataType or a UnionAll type. Does not support\ntype Unions. Also see info on Types.\n\nExamples\n\njulia> supertype(Int32)\nSigned\n\njulia> supertype(Vector)\nDenseVector (alias for DenseArray{T, 1} where T)\n\n\n\n\n\n"},{"title":"Core.Type","page":"Essentials","location":"base/base.html#Core.Type","category":"type","text":"Core.Type{T}\n\nCore.Type is an abstract type which has all type objects as its instances.\nThe only instance of the singleton type Core.Type{T} is the object\nT.\n\nExamples\n\njulia> isa(Type{Float64}, Type)\ntrue\n\njulia> isa(Float64, Type)\ntrue\n\njulia> isa(Real, Type{Float64})\nfalse\n\njulia> isa(Real, Type{Real})\ntrue\n\n\n\n\n\n"},{"title":"Core.DataType","page":"Essentials","location":"base/base.html#Core.DataType","category":"type","text":"DataType <: Type{T}\n\nDataType represents explicitly declared types that have names, explicitly\ndeclared supertypes, and, optionally, parameters.  Every concrete value in the\nsystem is an instance of some DataType.\n\nExamples\n\njulia> typeof(Real)\nDataType\n\njulia> typeof(Int)\nDataType\n\njulia> struct Point\n           x::Int\n           y\n       end\n\njulia> typeof(Point)\nDataType\n\n\n\n\n\n"},{"title":"Core.:<:","page":"Essentials","location":"base/base.html#Core.:<:","category":"function","text":"<:(T1, T2)::Bool\n\nSubtyping relation, defined between two types. In Julia, a type S is said to be a\nsubtype of a type T if and only if we have S <: T.\n\nFor any type L and any type R, L <: R implies that any value v of type L\nis also of type R. I.e., (L <: R) && (v isa L) implies v isa R.\n\nThe subtyping relation is a partial order. I.e., <: is:\n\nreflexive: for any type T, T <: T holds\nantisymmetric: for any type A and any type B, (A <: B) && (B <: A)\nimplies A == B\ntransitive: for any type A, any type B and any type C;\n(A <: B) && (B <: C) implies A <: C\n\nSee also info on Types, Union{}, Any, isa.\n\nExamples\n\njulia> Float64 <: AbstractFloat\ntrue\n\njulia> Vector{Int} <: AbstractArray\ntrue\n\njulia> Matrix{Float64} <: Matrix{AbstractFloat}  # `Matrix` is invariant\nfalse\n\njulia> Tuple{Float64} <: Tuple{AbstractFloat}    # `Tuple` is covariant\ntrue\n\njulia> Union{} <: Int  # The bottom type, `Union{}`, subtypes each type.\ntrue\n\njulia> Union{} <: Float32 <: AbstractFloat <: Real <: Number <: Any  # Operator chaining\ntrue\n\nThe <: keyword also has several syntactic uses which represent the same subtyping relation,\nbut which do not execute the operator or return a Bool:\n\nTo specify the lower bound and the upper bound on a parameter of a\nUnionAll type in a where statement.\nTo specify the lower bound and the upper bound on a (static) parameter of a\nmethod, see Parametric Methods.\nTo define a subtyping relation while declaring a new type, see struct\nand abstract type.\n\n\n\n\n\n"},{"title":"Core.:>:","page":"Essentials","location":"base/base.html#Core.:>:","category":"function","text":">:(T1, T2)\n\nSupertype operator, equivalent to T2 <: T1.\n\n\n\n\n\n"},{"title":"Base.typejoin","page":"Essentials","location":"base/base.html#Base.typejoin","category":"function","text":"typejoin(T, S, ...)\n\nReturn the closest common ancestor of types T and S, i.e. the narrowest type from which\nthey both inherit. Recurses on additional varargs.\n\nExamples\n\njulia> typejoin(Int, Float64)\nReal\n\njulia> typejoin(Int, Float64, ComplexF32)\nNumber\n\n\n\n\n\n"},{"title":"Base.typeintersect","page":"Essentials","location":"base/base.html#Base.typeintersect","category":"function","text":"typeintersect(T::Type, S::Type)\n\nCompute a type that contains the intersection of T and S. Usually this will be the\nsmallest such type or one close to it.\n\nA special case where exact behavior is guaranteed: when T <: S,\ntypeintersect(S, T) == T == typeintersect(T, S).\n\n\n\n\n\n"},{"title":"Base.promote_type","page":"Essentials","location":"base/base.html#Base.promote_type","category":"function","text":"promote_type(type1, type2, ...)\n\nPromotion refers to converting values of mixed types to a single common type.\npromote_type represents the default promotion behavior in Julia when\noperators (usually mathematical) are given arguments of differing types.\npromote_type generally tries to return a type which can at least approximate\nmost values of either input type without excessively widening.  Some loss is\ntolerated; for example, promote_type(Int64, Float64) returns\nFloat64 even though strictly, not all Int64 values can be\nrepresented exactly as Float64 values.\n\nSee also: promote, promote_typejoin, promote_rule.\n\nExamples\n\njulia> promote_type(Int64, Float64)\nFloat64\n\njulia> promote_type(Int32, Int64)\nInt64\n\njulia> promote_type(Float32, BigInt)\nBigFloat\n\njulia> promote_type(Int16, Float16)\nFloat16\n\njulia> promote_type(Int64, Float16)\nFloat16\n\njulia> promote_type(Int8, UInt16)\nUInt16\n\nwarning: Don't overload this directly\nTo overload promotion for your own types you should overload promote_rule.\npromote_type calls promote_rule internally to determine the type.\nOverloading promote_type directly can cause ambiguity errors.\n\n\n\n\n\n"},{"title":"Base.promote_rule","page":"Essentials","location":"base/base.html#Base.promote_rule","category":"function","text":"promote_rule(type1, type2)\n\nSpecifies what type should be used by promote when given values of types type1 and\ntype2. This function should not be called directly, but should have definitions added to\nit for new types as appropriate.\n\n\n\n\n\n"},{"title":"Base.promote_typejoin","page":"Essentials","location":"base/base.html#Base.promote_typejoin","category":"function","text":"promote_typejoin(T, S)\n\nCompute a type that contains both T and S, which could be\neither a parent of both types, or a Union if appropriate.\nFalls back to typejoin.\n\nSee instead promote, promote_type.\n\nExamples\n\njulia> Base.promote_typejoin(Int, Float64)\nReal\n\njulia> Base.promote_type(Int, Float64)\nFloat64\n\n\n\n\n\n"},{"title":"Base.iskindtype","page":"Essentials","location":"base/base.html#Base.iskindtype","category":"function","text":"Base.iskindtype(T)\n\nDetermine whether T is a kind, that is, the type of a Julia type:\na DataType, Union, UnionAll,\nor Core.TypeofBottom.\n\nAll kinds are concrete because types are Julia values.\n\n\n\n\n\n"},{"title":"Base.isdispatchtuple","page":"Essentials","location":"base/base.html#Base.isdispatchtuple","category":"function","text":"isdispatchtuple(T)\n\nDetermine whether type T is a Tuple that could appear as a type\nsignature in dispatch.  For this to be true, every element of the tuple type\nmust be either:\n\nconcrete but not a kind type\na Type{U} with no free type variables in U\n\nnote: Note\nA dispatch tuple is relevant for method dispatch because it has no inhabited\nsubtypes.For example, Tuple{Int, DataType} is concrete, but is not a dispatch tuple\nbecause Tuple{Int, Type{Bool}} is an inhabited subtype.Tuple{Tuple{DataType}} is a dispatch tuple because Tuple{DataType} is\nconcrete and not a kind; the subtype Tuple{Tuple{Type{Int}}} is not\ninhabited.\n\nIf T is not a type, then return false.\n\nExamples\n\njulia> isdispatchtuple(Int)\nfalse\n\njulia> isdispatchtuple(Tuple{Int})\ntrue\n\njulia> isdispatchtuple(Tuple{Number})\nfalse\n\njulia> isdispatchtuple(Tuple{DataType})\nfalse\n\njulia> isdispatchtuple(Tuple{Type{Int}})\ntrue\n\njulia> isdispatchtuple(Tuple{Type})\nfalse\n\n\n\n\n\n"},{"title":"Base.ismutable","page":"Essentials","location":"base/base.html#Base.ismutable","category":"function","text":"ismutable(v)::Bool\n\nReturn true if and only if value v is mutable.  See Mutable Composite Types\nfor a discussion of immutability. Note that this function works on values, so if you\ngive it a DataType, it will tell you that a value of the type is mutable.\n\nnote: Note\nFor technical reasons, ismutable returns true for values of certain special types\n(for example String and Symbol) even though they cannot be mutated in a permissible way.\n\nSee also isbits, isstructtype.\n\nExamples\n\njulia> ismutable(1)\nfalse\n\njulia> ismutable([1,2])\ntrue\n\ncompat: Julia 1.5\nThis function requires at least Julia 1.5.\n\n\n\n\n\n"},{"title":"Base.isimmutable","page":"Essentials","location":"base/base.html#Base.isimmutable","category":"function","text":"isimmutable(v) -> Bool\n\nwarning: Warning\nConsider using !ismutable(v) instead, as isimmutable(v) will be replaced by !ismutable(v) in a future release. (Since Julia 1.5)\n\nReturn true iff value v is immutable.  See Mutable Composite Types\nfor a discussion of immutability. Note that this function works on values, so if you give it\na type, it will tell you that a value of DataType is mutable.\n\nExamples\n\njulia> isimmutable(1)\ntrue\n\njulia> isimmutable([1,2])\nfalse\n\n\n\n\n\n"},{"title":"Base.ismutabletype","page":"Essentials","location":"base/base.html#Base.ismutabletype","category":"function","text":"ismutabletype(T)::Bool\n\nDetermine whether type T was declared as a mutable type\n(i.e. using mutable struct keyword).\nIf T is not a type, then return false.\n\ncompat: Julia 1.7\nThis function requires at least Julia 1.7.\n\n\n\n\n\n"},{"title":"Base.isabstracttype","page":"Essentials","location":"base/base.html#Base.isabstracttype","category":"function","text":"isabstracttype(T)\n\nDetermine whether type T was declared as an abstract type\n(i.e. using the abstract type syntax).\nIf T is not a type, then return false.\n\nnote: Note\nWhile abstract types are not concrete and\nvice versa, types can be neither concrete nor abstract (for example,\nVector (a UnionAll)).\n\nSee also: isconcretetype.\n\nExamples\n\njulia> isabstracttype(AbstractArray)\ntrue\n\njulia> isabstracttype(Vector)\nfalse\n\n\n\n\n\n"},{"title":"Base.isprimitivetype","page":"Essentials","location":"base/base.html#Base.isprimitivetype","category":"function","text":"isprimitivetype(T)::Bool\n\nDetermine whether type T was declared as a primitive type\n(i.e. using the primitive type syntax).\nIf T is not a type, then return false.\n\n\n\n\n\n"},{"title":"Base.issingletontype","page":"Essentials","location":"base/base.html#Base.issingletontype","category":"function","text":"Base.issingletontype(T)\n\nDetermine whether type T has exactly one possible instance; for example, a\nstruct type with no fields except other singleton values.\nIf T is not a concrete type, then return false.\n\n\n\n\n\n"},{"title":"Base.isstructtype","page":"Essentials","location":"base/base.html#Base.isstructtype","category":"function","text":"isstructtype(T)::Bool\n\nDetermine whether type T was declared as a struct type\n(i.e. using the struct or mutable struct keyword).\nIf T is not a type, then return false.\n\n\n\n\n\n"},{"title":"Base.nameof","page":"Essentials","location":"base/base.html#Base.nameof-Tuple{DataType}","category":"method","text":"nameof(t::DataType)::Symbol\n\nGet the name of a (potentially UnionAll-wrapped) DataType (without its parent module)\nas a symbol.\n\nExamples\n\njulia> module Foo\n           struct S{T}\n           end\n       end\nFoo\n\njulia> nameof(Foo.S{T} where T)\n:S\n\n\n\n\n\n"},{"title":"Base.fieldnames","page":"Essentials","location":"base/base.html#Base.fieldnames","category":"function","text":"fieldnames(x::DataType)\n\nGet a tuple with the names of the fields of a DataType.\n\nEach name is a Symbol, except when x <: Tuple, in which case each name (actually the\nindex of the field) is an Int.\n\nSee also propertynames, hasfield.\n\nExamples\n\njulia> fieldnames(Rational)\n(:num, :den)\n\njulia> fieldnames(typeof(1+im))\n(:re, :im)\n\njulia> fieldnames(Tuple{String,Int})\n(1, 2)\n\n\n\n\n\n"},{"title":"Base.fieldname","page":"Essentials","location":"base/base.html#Base.fieldname","category":"function","text":"fieldname(x::DataType, i::Integer)\n\nGet the name of field i of a DataType.\n\nThe return type is Symbol, except when x <: Tuple, in which case the index of the field is returned, of type Int.\n\nExamples\n\njulia> fieldname(Rational, 1)\n:num\n\njulia> fieldname(Rational, 2)\n:den\n\njulia> fieldname(Tuple{String,Int}, 2)\n2\n\n\n\n\n\n"},{"title":"Base.fieldindex","page":"Essentials","location":"base/base.html#Base.fieldindex","category":"function","text":"fieldindex(T, name::Symbol, err:Bool=true)\n\nGet the index of a named field, throwing an error if the field does not exist (when err==true)\nor returning 0 (when err==false).\n\nExamples\n\njulia> struct Foo\n           x::Int64\n           y::String\n       end\n\njulia> fieldindex(Foo, :y)\n2\n\njulia> fieldindex(Foo, :z)\nERROR: FieldError: type Foo has no field `z`, available fields: `x`, `y`\nStacktrace:\n[...]\n\njulia> fieldindex(Foo, :z, false)\n0\n\ncompat: Julia 1.13\nThis function is exported as of Julia 1.13.\n\n\n\n\n\n"},{"title":"Core.fieldtype","page":"Essentials","location":"base/base.html#Core.fieldtype","category":"function","text":"fieldtype(T, name::Symbol | index::Int)\n\nDetermine the declared type of a field (specified by name or index) in a composite DataType T.\n\nExamples\n\njulia> struct Foo\n           x::Int64\n           y::String\n       end\n\njulia> fieldtype(Foo, :x)\nInt64\n\njulia> fieldtype(Foo, 2)\nString\n\n\n\n\n\n"},{"title":"Base.fieldtypes","page":"Essentials","location":"base/base.html#Base.fieldtypes","category":"function","text":"fieldtypes(T::Type)\n\nThe declared types of all fields in a composite DataType T as a tuple.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\nExamples\n\njulia> struct Foo\n           x::Int64\n           y::String\n       end\n\njulia> fieldtypes(Foo)\n(Int64, String)\n\n\n\n\n\n"},{"title":"Base.fieldcount","page":"Essentials","location":"base/base.html#Base.fieldcount","category":"function","text":"fieldcount(t::Type)\n\nGet the number of fields that an instance of the given type would have.\nAn error is thrown if the type is too abstract to determine this.\n\n\n\n\n\n"},{"title":"Base.hasfield","page":"Essentials","location":"base/base.html#Base.hasfield","category":"function","text":"hasfield(T::Type, name::Symbol)\n\nReturn a boolean indicating whether T has name as one of its own fields.\n\nSee also fieldnames, fieldcount, hasproperty.\n\ncompat: Julia 1.2\nThis function requires at least Julia 1.2.\n\nExamples\n\njulia> struct Foo\n            bar::Int\n       end\n\njulia> hasfield(Foo, :bar)\ntrue\n\njulia> hasfield(Foo, :x)\nfalse\n\n\n\n\n\n"},{"title":"Core.nfields","page":"Essentials","location":"base/base.html#Core.nfields","category":"function","text":"nfields(x)::Int\n\nGet the number of fields in the given object.\n\nExamples\n\njulia> a = 1//2;\n\njulia> nfields(a)\n2\n\njulia> b = 1\n1\n\njulia> nfields(b)\n0\n\njulia> ex = ErrorException(\"I've done a bad thing\");\n\njulia> nfields(ex)\n1\n\nIn these examples, a is a Rational, which has two fields.\nb is an Int, which is a primitive bitstype with no fields at all.\nex is an ErrorException, which has one field.\n\n\n\n\n\n"},{"title":"Base.isconst","page":"Essentials","location":"base/base.html#Base.isconst","category":"function","text":"isconst(t::DataType, s::Union{Int,Symbol})::Bool\n\nDetermine whether a field s is const in a given type t\nin the sense that a read from said field is consistent\nfor egal objects. Note in particular that out-of-bounds\nfields are considered const under this definition (because\nthey always throw).\n\n\n\n\n\nisconst(m::Module, s::Symbol)::Bool\nisconst(g::GlobalRef)::Bool\n\nDetermine whether a global is const in a given module m, either\nbecause it was declared constant or because it was imported from a\nconstant binding. Note that constant-ness is specific to a particular\nworld age, so the result of this function may not be assumed to hold\nafter a world age update.\n\n\n\n\n\n"},{"title":"Base.isfieldatomic","page":"Essentials","location":"base/base.html#Base.isfieldatomic","category":"function","text":"isfieldatomic(t::DataType, s::Union{Int,Symbol})::Bool\n\nDetermine whether a field s is declared @atomic in a given type t.\n\n\n\n\n\n"},{"title":"Base.sizeof","page":"Essentials","location":"base/base.html#Base.sizeof-Tuple{Type}","category":"method","text":"sizeof(T::DataType)\nsizeof(obj)\n\nSize, in bytes, of the canonical binary representation of the given DataType T, if any.\nOr the size, in bytes, of object obj if it is not a DataType.\n\nSee also Base.summarysize.\n\nExamples\n\njulia> sizeof(Float32)\n4\n\njulia> sizeof(ComplexF64)\n16\n\njulia> sizeof(1.0)\n8\n\njulia> sizeof(collect(1.0:10.0))\n80\n\njulia> struct StructWithPadding\n           x::Int64\n           flag::Bool\n       end\n\njulia> sizeof(StructWithPadding) # not the sum of `sizeof` of fields due to padding\n16\n\njulia> sizeof(Int64) + sizeof(Bool) # different from above\n9\n\nIf DataType T does not have a specific size, an error is thrown.\n\njulia> sizeof(AbstractArray)\nERROR: Abstract type AbstractArray does not have a definite size.\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"Base.isconcretetype","page":"Essentials","location":"base/base.html#Base.isconcretetype","category":"function","text":"isconcretetype(T)\n\nDetermine whether type T is a concrete type, meaning it could have direct instances\n(values x such that typeof(x) === T).\nNote that this is not the negation of isabstracttype(T).\nIf T is not a type, then return false.\n\nnote: Note\nWhile concrete types are not abstract and\nvice versa, types can be neither concrete nor abstract (for example,\nVector (a UnionAll)).\n\nnote: Note\nT must be the exact type that would be returned from typeof.  It is\npossible for a type U to exist such that T == U, isconcretetype(T),\nbut !isconcretetype(U).\n\nSee also: isbits, isabstracttype, issingletontype.\n\nExamples\n\njulia> isconcretetype(Complex)\nfalse\n\njulia> isconcretetype(Complex{Float32})\ntrue\n\njulia> isconcretetype(Vector)\nfalse\n\njulia> isconcretetype(Vector{Complex})\ntrue\n\njulia> isconcretetype(Vector{Complex{Float32}})\ntrue\n\njulia> isconcretetype(Union{})\nfalse\n\njulia> isconcretetype(Union{Int,String})\nfalse\n\njulia> isconcretetype(Tuple{T} where T<:Int)\nfalse\n\n\n\n\n\n"},{"title":"Base.isbits","page":"Essentials","location":"base/base.html#Base.isbits","category":"function","text":"isbits(x)\n\nReturn true if x is an instance of an isbitstype type.\n\n\n\n\n\n"},{"title":"Base.isbitstype","page":"Essentials","location":"base/base.html#Base.isbitstype","category":"function","text":"isbitstype(T)\n\nReturn true if type T is a \"plain data\" type,\nmeaning it is immutable and contains no references to other values,\nonly primitive types and other isbitstype types.\nTypical examples are numeric types such as UInt8,\nFloat64, and Complex{Float64}.\nThis category of types is significant since they are valid as type parameters,\nmay not track isdefined / isassigned status,\nand have a defined layout that is compatible with C.\nIf T is not a type, then return false.\n\nSee also isbits, isprimitivetype, ismutable.\n\nExamples\n\njulia> isbitstype(Complex{Float64})\ntrue\n\njulia> isbitstype(Complex)\nfalse\n\n\n\n\n\n"},{"title":"Base.fieldoffset","page":"Essentials","location":"base/base.html#Base.fieldoffset","category":"function","text":"fieldoffset(type, name::Symbol | i::Integer)\n\nThe byte offset of a field (specified by name or index) of a type relative to its start.\n\nExamples\n\njulia> struct Foo\n           x::Int64\n           y::String\n       end\n\njulia> fieldoffset(Foo, 2)\n0x0000000000000008\n\njulia> fieldoffset(Foo, :x)\n0x0000000000000000\n\nWe can use it to summarize information about a struct:\n\njulia> structinfo(T) = [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i = 1:fieldcount(T)];\n\njulia> structinfo(Base.Filesystem.StatStruct)\n14-element Vector{Tuple{UInt64, Symbol, Type}}:\n (0x0000000000000000, :desc, Union{RawFD, String})\n (0x0000000000000008, :device, UInt64)\n (0x0000000000000010, :inode, UInt64)\n (0x0000000000000018, :mode, UInt64)\n (0x0000000000000020, :nlink, Int64)\n (0x0000000000000028, :uid, UInt64)\n (0x0000000000000030, :gid, UInt64)\n (0x0000000000000038, :rdev, UInt64)\n (0x0000000000000040, :size, Int64)\n (0x0000000000000048, :blksize, Int64)\n (0x0000000000000050, :blocks, Int64)\n (0x0000000000000058, :mtime, Float64)\n (0x0000000000000060, :ctime, Float64)\n (0x0000000000000068, :ioerrno, Int32)\n\ncompat: Julia 1.13\nSpecifying the field by name rather than index requires Julia 1.13 or later.\n\n\n\n\n\n"},{"title":"Base.datatype_alignment","page":"Essentials","location":"base/base.html#Base.datatype_alignment","category":"function","text":"Base.datatype_alignment(dt::DataType)::Int\n\nMemory allocation minimum alignment for instances of this type.\nCan be called on any isconcretetype, although for Memory it will give the\nalignment of the elements, not the whole object.\n\n\n\n\n\n"},{"title":"Base.datatype_haspadding","page":"Essentials","location":"base/base.html#Base.datatype_haspadding","category":"function","text":"Base.datatype_haspadding(dt::DataType)::Bool\n\nReturn whether the fields of instances of this type are packed in memory,\nwith no intervening padding bits (defined as bits whose value does not impact\nthe semantic value of the instance itself).\nCan be called on any isconcretetype.\n\n\n\n\n\n"},{"title":"Base.datatype_pointerfree","page":"Essentials","location":"base/base.html#Base.datatype_pointerfree","category":"function","text":"Base.datatype_pointerfree(dt::DataType)::Bool\n\nReturn whether instances of this type can contain references to gc-managed memory.\nCan be called on any isconcretetype.\n\n\n\n\n\n"},{"title":"Base.typemin","page":"Essentials","location":"base/base.html#Base.typemin","category":"function","text":"typemin(T)\n\nThe lowest value representable by the given (real) numeric DataType T.\n\nSee also: floatmin, maxintfloat, typemax, eps.\n\nExamples\n\njulia> typemin(Int8)\n-128\n\njulia> typemin(UInt32)\n0x00000000\n\njulia> typemin(Float16)\n-Inf16\n\njulia> typemin(Float32)\n-Inf32\n\njulia> floatmin(Float32)  # smallest positive finite Float32 floating point number\n1.1754944f-38\n\njulia> nextfloat(-Inf32) == -floatmax(Float32)  # equivalent ways of getting the lowest finite Float32 floating point number\ntrue\n\n\n\n\n\n"},{"title":"Base.typemax","page":"Essentials","location":"base/base.html#Base.typemax","category":"function","text":"typemax(T)\n\nThe highest value representable by the given (real) numeric DataType.\n\nSee also: floatmax, maxintfloat, typemin, eps.\n\nExamples\n\njulia> typemax(Int8)\n127\n\njulia> typemax(UInt32)\n0xffffffff\n\njulia> typemax(Float64)\nInf\n\njulia> typemax(Float32)\nInf32\n\njulia> floatmax(Float32)  # largest positive finite Float32 floating point number\n3.4028235f38\n\n\n\n\n\n"},{"title":"Base.floatmin","page":"Essentials","location":"base/base.html#Base.floatmin","category":"function","text":"floatmin(T = Float64)\n\nReturn the smallest positive normal number representable by the floating-point\ntype T.\n\nSee also: typemin, maxintfloat, floatmax, eps.\n\nExamples\n\njulia> floatmin(Float16)\nFloat16(6.104e-5)\n\njulia> floatmin(Float32)\n1.1754944f-38\n\njulia> floatmin()\n2.2250738585072014e-308\n\n\n\n\n\n"},{"title":"Base.floatmax","page":"Essentials","location":"base/base.html#Base.floatmax","category":"function","text":"floatmax(T = Float64)\n\nReturn the largest finite number representable by the floating-point type T.\n\nSee also: typemax, maxintfloat, floatmin, eps.\n\nExamples\n\njulia> floatmax(Float16)\nFloat16(6.55e4)\n\njulia> floatmax(Float32)\n3.4028235f38\n\njulia> floatmax()\n1.7976931348623157e308\n\njulia> typemax(Float64)\nInf\n\n\n\n\n\n"},{"title":"Base.maxintfloat","page":"Essentials","location":"base/base.html#Base.maxintfloat","category":"function","text":"maxintfloat(T, S)\n\nThe largest consecutive integer representable in the given floating-point type T that\nalso does not exceed the maximum integer representable by the integer type S.  Equivalently,\nit is the minimum of maxintfloat(T) and typemax(S).\n\n\n\n\n\nmaxintfloat(T=Float64)\n\nThe largest consecutive integer-valued floating-point number that is exactly represented in\nthe given floating-point type T (which defaults to Float64).\n\nThat is, maxintfloat returns the smallest positive integer-valued floating-point number\nn such that n+1 is not exactly representable in the type T.\n\nWhen an Integer-type value is needed, use Integer(maxintfloat(T)).\n\nSee also: typemax, floatmax.\n\n\n\n\n\n"},{"title":"Base.eps","page":"Essentials","location":"base/base.html#Base.eps-Tuple{Type{<:AbstractFloat}}","category":"method","text":"eps(::Type{T}) where T<:AbstractFloat\neps()\n\nReturn the machine epsilon of the floating point type T (T = Float64 by\ndefault). This is defined as the gap between 1 and the next largest value representable by\ntypeof(one(T)), and is equivalent to eps(one(T)).  (Since eps(T) is a\nbound on the relative error of T, it is a \"dimensionless\" quantity like one.)\n\nExamples\n\njulia> eps()\n2.220446049250313e-16\n\njulia> eps(Float32)\n1.1920929f-7\n\njulia> 1.0 + eps()\n1.0000000000000002\n\njulia> 1.0 + eps()/2\n1.0\n\nMore generally, for any floating-point numeric type, eps corresponds to an\nupper bound on the distance to the nearest floating-point complex value: if extfl(x) is the closest\nfloating-point value to a number x (e.g. an arbitrary real number), then extfl(x)\nsatisfies x - \textfl(x)  \texteps(x)2, not including overflow cases.\nThis allows the definition of eps to be extended to complex numbers,\nfor which extfl(a + ib) = \textfl(a) + i \textfl(b).\n\n\n\n\n\n"},{"title":"Base.eps","page":"Essentials","location":"base/base.html#Base.eps-Tuple{AbstractFloat}","category":"method","text":"eps(x::AbstractFloat)\n\nReturn the unit in last place (ulp) of x. This is the distance between consecutive\nrepresentable floating point values at x. In most cases, if the distance on either side\nof x is different, then the larger of the two is taken, that is\n\neps(x) == max(x-prevfloat(x), nextfloat(x)-x)\n\nThe exceptions to this rule are the smallest and largest finite values\n(e.g. nextfloat(-Inf) and prevfloat(Inf) for Float64), which round to the\nsmaller of the values.\n\nThe rationale for this behavior is that eps bounds the floating point rounding\nerror. Under the default RoundNearest rounding mode, if y is a real number and x\nis the nearest floating point number to y, then\n\ny-x leq operatornameeps(x)2\n\nSee also: nextfloat, issubnormal, floatmax.\n\nExamples\n\njulia> eps(1.0)\n2.220446049250313e-16\n\njulia> eps(prevfloat(2.0))\n2.220446049250313e-16\n\njulia> eps(2.0)\n4.440892098500626e-16\n\njulia> x = prevfloat(Inf)      # largest finite Float64\n1.7976931348623157e308\n\njulia> x + eps(x)/2            # rounds up\nInf\n\njulia> x + prevfloat(eps(x)/2) # rounds down\n1.7976931348623157e308\n\n\n\n\n\n"},{"title":"Base.instances","page":"Essentials","location":"base/base.html#Base.instances","category":"function","text":"instances(T::Type)\n\nReturn a collection of all instances of the given type, if applicable. Mostly used for\nenumerated types (see @enum).\n\nExamples\n\njulia> @enum Color red blue green\n\njulia> instances(Color)\n(red, blue, green)\n\n\n\n\n\n"},{"title":"Core.Any","page":"Essentials","location":"base/base.html#Core.Any","category":"type","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore\ndescribes the entire universe of possible values. For example Integer is a subset of Any that includes Int,\nInt8, and other integer types.\n\n\n\n\n\n"},{"title":"Core.Union","page":"Essentials","location":"base/base.html#Core.Union","category":"type","text":"Union{Types...}\n\nA Union type is an abstract type which includes all instances of any of its argument types.\nThis means that T <: Union{T,S} and S <: Union{T,S}.\n\nLike other abstract types, it cannot be instantiated, even if all of its arguments are non\nabstract.\n\nExamples\n\njulia> IntOrString = Union{Int,AbstractString}\nUnion{Int64, AbstractString}\n\njulia> 1 isa IntOrString # instance of Int is included in the union\ntrue\n\njulia> \"Hello!\" isa IntOrString # String is also included\ntrue\n\njulia> 1.0 isa IntOrString # Float64 is not included because it is neither Int nor AbstractString\nfalse\n\nExtended Help\n\nUnlike most other parametric types, unions are covariant in their parameters. For example,\nUnion{Real, String} is a subtype of Union{Number, AbstractString}.\n\nThe empty union Union{} is the bottom type of Julia.\n\n\n\n\n\n"},{"title":"Union{}","page":"Essentials","location":"base/base.html#Union{}","category":"keyword","text":"Union{}\n\nUnion{}, the empty Union of types, is the bottom type of the type system. That is, for each\nT::Type, Union{} <: T. Also see the subtyping operator's documentation: <:.\n\nAs such, Union{} is also an empty/uninhabited type, meaning that it has no values. That is, for each x,\nisa(x, Union{}) == false.\n\nBase.Bottom is defined as its alias and the type of Union{} is Core.TypeofBottom.\n\nExamples\n\njulia> isa(nothing, Union{})\nfalse\n\njulia> Union{} <: Int\ntrue\n\njulia> typeof(Union{}) === Core.TypeofBottom\ntrue\n\njulia> isa(Union{}, Union)\nfalse\n\n\n\n\n\n"},{"title":"Core.TypeofBottom","page":"Essentials","location":"base/base.html#Core.TypeofBottom","category":"type","text":"Core.TypeofBottom\n\nThe singleton type containing only the value Union{} (which represents the empty type).\n\n\n\n\n\n"},{"title":"Core.UnionAll","page":"Essentials","location":"base/base.html#Core.UnionAll","category":"type","text":"UnionAll\n\nA union of types over all values of a type parameter. UnionAll is used to describe parametric types\nwhere the values of some parameters are not known. See the manual section on UnionAll Types.\n\nExamples\n\njulia> typeof(Vector)\nUnionAll\n\njulia> typeof(Vector{Int})\nDataType\n\n\n\n\n\n"},{"title":"Core.Tuple","page":"Essentials","location":"base/base.html#Core.Tuple","category":"type","text":"Tuple{Types...}\n\nA tuple is a fixed-length container that can hold any values of different\ntypes, but cannot be modified (it is immutable). The values can be accessed via\nindexing. Tuple literals are written with commas and parentheses:\n\njulia> (1, 1+1)\n(1, 2)\n\njulia> (1,)\n(1,)\n\njulia> x = (0.0, \"hello\", 6*7)\n(0.0, \"hello\", 42)\n\njulia> x[2]\n\"hello\"\n\njulia> typeof(x)\nTuple{Float64, String, Int64}\n\nA length-1 tuple must be written with a comma, (1,), since (1) would just\nbe a parenthesized value. () represents the empty (length-0) tuple.\n\nA tuple can be constructed from an iterator by using a Tuple type as constructor:\n\njulia> Tuple([\"a\", 1])\n(\"a\", 1)\n\njulia> Tuple{String, Float64}([\"a\", 1])\n(\"a\", 1.0)\n\nTuple types are covariant in their parameters: Tuple{Int} is a subtype of Tuple{Any}. Therefore Tuple{Any}\nis considered an abstract type, and tuple types are only concrete if their parameters are. Tuples do not have\nfield names; fields are only accessed by index.\nTuple types may have any number of parameters.\n\nSee the manual section on Tuple Types.\n\nSee also Vararg, NTuple, ntuple, tuple, NamedTuple.\n\n\n\n\n\n"},{"title":"Core.NTuple","page":"Essentials","location":"base/base.html#Core.NTuple","category":"type","text":"NTuple{N, T}\n\nA compact way of representing the type for a tuple of length N where all elements are of type T.\n\nExamples\n\njulia> isa((1, 2, 3, 4, 5, 6), NTuple{6, Int})\ntrue\n\nSee also ntuple.\n\n\n\n\n\n"},{"title":"Core.NamedTuple","page":"Essentials","location":"base/base.html#Core.NamedTuple","category":"type","text":"NamedTuple\n\nNamedTuples are, as their name suggests, named Tuples. That is, they're a\ntuple-like collection of values, where each entry has a unique name, represented as a\nSymbol. Like Tuples, NamedTuples are immutable; neither the names nor the values\ncan be modified in place after construction.\n\nA named tuple can be created as a tuple literal with keys, e.g. (a=1, b=2),\nor as a tuple literal with semicolon after the opening parenthesis, e.g. (; a=1, b=2) (this form also accepts programmatically generated names as\ndescribed below), or using a NamedTuple type as constructor, e.g.\nNamedTuple{(:a, :b)}((1,2)).\n\nAccessing the value associated with a name in a named tuple can be done using field\naccess syntax, e.g. x.a, or using getindex, e.g. x[:a] or x[(:a, :b)].\nA tuple of the names can be obtained using keys, and a tuple of the values\ncan be obtained using values.\n\nnote: Note\nIteration over NamedTuples produces the values without the names. (See example\nbelow.) To iterate over the name-value pairs, use the pairs function.\n\nThe @NamedTuple macro can be used for conveniently declaring NamedTuple types.\n\nExamples\n\njulia> x = (a=1, b=2)\n(a = 1, b = 2)\n\njulia> x.a\n1\n\njulia> x[:a]\n1\n\njulia> x[(:a,)]\n(a = 1,)\n\njulia> keys(x)\n(:a, :b)\n\njulia> values(x)\n(1, 2)\n\njulia> collect(x)\n2-element Vector{Int64}:\n 1\n 2\n\njulia> collect(pairs(x))\n2-element Vector{Pair{Symbol, Int64}}:\n :a => 1\n :b => 2\n\nIn a similar fashion as to how one can define keyword arguments programmatically,\na named tuple can be created by giving pairs name::Symbol => value after a\nsemicolon inside a tuple literal. This and the name=value syntax can be mixed:\n\njulia> (; :a => 1, :b => 2, c=3)\n(a = 1, b = 2, c = 3)\n\nThe name-value pairs can also be provided by splatting a named tuple or any\niterator that yields two-value collections holding each a symbol as first\nvalue:\n\njulia> keys = (:a, :b, :c); values = (1, 2, 3);\n\njulia> NamedTuple{keys}(values)\n(a = 1, b = 2, c = 3)\n\njulia> (; (keys .=> values)...)\n(a = 1, b = 2, c = 3)\n\njulia> nt1 = (a=1, b=2);\n\njulia> nt2 = (c=3, d=4);\n\njulia> (; nt1..., nt2..., b=20) # the final b overwrites the value from nt1\n(a = 1, b = 20, c = 3, d = 4)\n\njulia> (; zip(keys, values)...) # zip yields tuples such as (:a, 1)\n(a = 1, b = 2, c = 3)\n\nAs in keyword arguments, identifiers and dot expressions imply names:\n\njulia> x = 0\n0\n\njulia> t = (; x)\n(x = 0,)\n\njulia> (; t.x)\n(x = 0,)\n\ncompat: Julia 1.5\nImplicit names from identifiers and dot expressions are available as of Julia 1.5.\n\ncompat: Julia 1.7\nUse of getindex methods with multiple Symbols is available as of Julia 1.7.\n\n\n\n\n\n"},{"title":"Base.@NamedTuple","page":"Essentials","location":"base/base.html#Base.@NamedTuple","category":"macro","text":"@NamedTuple{key1::Type1, key2::Type2, ...}\n@NamedTuple begin key1::Type1; key2::Type2; ...; end\n\nThis macro gives a more convenient syntax for declaring NamedTuple types. It returns a NamedTuple\ntype with the given keys and types, equivalent to NamedTuple{(:key1, :key2, ...), Tuple{Type1,Type2,...}}.\nIf the ::Type declaration is omitted, it is taken to be Any.   The begin ... end form allows the\ndeclarations to be split across multiple lines (similar to a struct declaration), but is otherwise\nequivalent. The NamedTuple macro is used when printing NamedTuple types to e.g. the REPL.\n\nFor example, the tuple (a=3.1, b=\"hello\") has a type NamedTuple{(:a, :b), Tuple{Float64, String}}, which\ncan also be declared via @NamedTuple as:\n\njulia> @NamedTuple{a::Float64, b::String}\n@NamedTuple{a::Float64, b::String}\n\njulia> @NamedTuple begin\n           a::Float64\n           b::String\n       end\n@NamedTuple{a::Float64, b::String}\n\ncompat: Julia 1.5\nThis macro is available as of Julia 1.5.\n\n\n\n\n\n"},{"title":"Base.@Kwargs","page":"Essentials","location":"base/base.html#Base.@Kwargs","category":"macro","text":"@Kwargs{key1::Type1, key2::Type2, ...}\n\nThis macro gives a convenient way to construct the type representation of keyword arguments\nfrom the same syntax as @NamedTuple.\nFor example, when we have a function call like func([positional arguments]; kw1=1.0, kw2=\"2\"),\nwe can use this macro to construct the internal type representation of the keyword arguments\nas @Kwargs{kw1::Float64, kw2::String}.\nThe macro syntax is specifically designed to simplify the signature type of a keyword method\nwhen it is printed in the stack trace view.\n\njulia> @Kwargs{init::Int} # the internal representation of keyword arguments\nBase.Pairs{Symbol, Int64, Nothing, @NamedTuple{init::Int64}}\n\njulia> sum(\"julia\"; init=1)\nERROR: MethodError: no method matching +(::Char, ::Char)\nThe function `+` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  +(::Any, ::Any, ::Any, ::Any...)\n   @ Base operators.jl:585\n  +(::Integer, ::AbstractChar)\n   @ Base char.jl:247\n  +(::T, ::Integer) where T<:AbstractChar\n   @ Base char.jl:237\n\nStacktrace:\n  [1] add_sum(x::Char, y::Char)\n    @ Base ./reduce.jl:24\n  [2] BottomRF\n    @ Base ./reduce.jl:86 [inlined]\n  [3] _foldl_impl(op::Base.BottomRF{typeof(Base.add_sum)}, init::Int64, itr::String)\n    @ Base ./reduce.jl:62\n  [4] foldl_impl(op::Base.BottomRF{typeof(Base.add_sum)}, nt::Int64, itr::String)\n    @ Base ./reduce.jl:48 [inlined]\n  [5] mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), nt::Int64, itr::String)\n    @ Base ./reduce.jl:44 [inlined]\n  [6] mapfoldl(f::typeof(identity), op::typeof(Base.add_sum), itr::String; init::Int64)\n    @ Base ./reduce.jl:175 [inlined]\n  [7] mapreduce(f::typeof(identity), op::typeof(Base.add_sum), itr::String; kw::@Kwargs{init::Int64})\n    @ Base ./reduce.jl:307 [inlined]\n  [8] sum(f::typeof(identity), a::String; kw::@Kwargs{init::Int64})\n    @ Base ./reduce.jl:535 [inlined]\n  [9] sum(a::String; kw::@Kwargs{init::Int64})\n    @ Base ./reduce.jl:564 [inlined]\n [10] top-level scope\n    @ REPL[12]:1\n\ncompat: Julia 1.10\nThis macro is available as of Julia 1.10.\n\n\n\n\n\n"},{"title":"Base.Val","page":"Essentials","location":"base/base.html#Base.Val","category":"type","text":"Val(c)\n\nReturn Val{c}(), which contains no run-time data. Types like this can be used to\npass the information between functions through the value c, which must be an isbits\nvalue or a Symbol. The intent of this construct is to be able to dispatch on constants\ndirectly (at compile time) without having to test the value of the constant at run time.\n\nExamples\n\njulia> f(::Val{true}) = \"Good\"\nf (generic function with 1 method)\n\njulia> f(::Val{false}) = \"Bad\"\nf (generic function with 2 methods)\n\njulia> f(Val(true))\n\"Good\"\n\n\n\n\n\n"},{"title":"Core.Vararg","page":"Essentials","location":"base/base.html#Core.Vararg","category":"constant","text":"Vararg{T,N}\n\nThe last parameter of a tuple type Tuple can be the special value Vararg, which denotes any\nnumber of trailing elements. Vararg{T,N} corresponds to exactly N elements of type T. Finally\nVararg{T} corresponds to zero or more elements of type T. Vararg tuple types are used to represent the\narguments accepted by varargs methods (see the section on Varargs Functions in the manual.)\n\nSee also NTuple.\n\nExamples\n\njulia> mytupletype = Tuple{AbstractString, Vararg{Int}}\nTuple{AbstractString, Vararg{Int64}}\n\njulia> isa((\"1\",), mytupletype)\ntrue\n\njulia> isa((\"1\",1), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2,3.0), mytupletype)\nfalse\n\n\n\n\n\n"},{"title":"Core.Nothing","page":"Essentials","location":"base/base.html#Core.Nothing","category":"type","text":"Nothing\n\nA type with no fields that is the type of nothing.\n\nSee also: isnothing, Some, Missing.\n\n\n\n\n\n"},{"title":"Base.isnothing","page":"Essentials","location":"base/base.html#Base.isnothing","category":"function","text":"isnothing(x)\n\nReturn true if x === nothing, and return false if not.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\nSee also something, Base.notnothing, ismissing.\n\n\n\n\n\n"},{"title":"Base.notnothing","page":"Essentials","location":"base/base.html#Base.notnothing","category":"function","text":"notnothing(x)\n\nThrow an error if x === nothing, and return x if not.\n\n\n\n\n\n"},{"title":"Base.Some","page":"Essentials","location":"base/base.html#Base.Some","category":"type","text":"Some{T}\n\nA wrapper type used in Union{Some{T}, Nothing} to distinguish between the absence\nof a value (nothing) and the presence of a nothing value (i.e. Some(nothing)).\n\nUse something to access the value wrapped by a Some object.\n\n\n\n\n\n"},{"title":"Base.something","page":"Essentials","location":"base/base.html#Base.something","category":"function","text":"something(x...)\n\nReturn the first value in the arguments which is not equal to nothing,\nif any. Otherwise throw an error.\nArguments of type Some are unwrapped.\n\nSee also coalesce, skipmissing, @something.\n\nExamples\n\njulia> something(nothing, 1)\n1\n\njulia> something(Some(1), nothing)\n1\n\njulia> something(Some(nothing), 2) === nothing\ntrue\n\njulia> something(missing, nothing)\nmissing\n\njulia> something(nothing, nothing)\nERROR: ArgumentError: No value arguments present\n\n\n\n\n\n"},{"title":"Base.@something","page":"Essentials","location":"base/base.html#Base.@something","category":"macro","text":"@something(x...)\n\nShort-circuiting version of something.\n\nExamples\n\njulia> f(x) = (println(\"f($x)\"); nothing);\n\njulia> a = 1;\n\njulia> a = @something a f(2) f(3) error(\"Unable to find default for `a`\")\n1\n\njulia> b = nothing;\n\njulia> b = @something b f(2) f(3) error(\"Unable to find default for `b`\")\nf(2)\nf(3)\nERROR: Unable to find default for `b`\n[...]\n\njulia> b = @something b f(2) f(3) Some(nothing)\nf(2)\nf(3)\n\njulia> b === nothing\ntrue\n\ncompat: Julia 1.7\nThis macro is available as of Julia 1.7.\n\n\n\n\n\n"},{"title":"Base.Enums.Enum","page":"Essentials","location":"base/base.html#Base.Enums.Enum","category":"type","text":"Enum{T<:Integer}\n\nThe abstract supertype of all enumerated types defined with @enum.\n\n\n\n\n\n"},{"title":"Base.Enums.@enum","page":"Essentials","location":"base/base.html#Base.Enums.@enum","category":"macro","text":"@enum EnumName[::BaseType] value1[=x] value2[=y]\n\nCreate an Enum{BaseType} subtype with name EnumName and enum member values of\nvalue1 and value2 with optional assigned values of x and y, respectively.\nEnumName can be used just like other types and enum member values as regular values, such as\n\nExamples\n\njulia> @enum Fruit apple=1 orange=2 kiwi=3\n\njulia> f(x::Fruit) = \"I'm a Fruit with value: $(Int(x))\"\nf (generic function with 1 method)\n\njulia> f(apple)\n\"I'm a Fruit with value: 1\"\n\njulia> Fruit(1)\napple::Fruit = 1\n\nValues can also be specified inside a begin block, e.g.\n\n@enum EnumName begin\n    value1\n    value2\nend\n\nBaseType, which defaults to Int32, must be a primitive subtype of Integer.\nMember values can be converted between the enum type and BaseType. read and write\nperform these conversions automatically. In case the enum is created with a non-default\nBaseType, Integer(value1) will return the integer value1 with the type BaseType.\n\nTo list all the instances of an enum use instances, e.g.\n\njulia> instances(Fruit)\n(apple, orange, kiwi)\n\nIt is possible to construct a symbol from an enum instance:\n\njulia> Symbol(apple)\n:apple\n\n\n\n\n\n"},{"title":"Core.Expr","page":"Essentials","location":"base/base.html#Core.Expr","category":"type","text":"Expr(head::Symbol, args...)\n\nA type representing compound expressions in parsed julia code (ASTs).\nEach expression consists of a head Symbol identifying which kind of\nexpression it is (e.g. a call, for loop, conditional statement, etc.),\nand subexpressions (e.g. the arguments of a call).\nThe subexpressions are stored in a Vector{Any} field called args.\n\nSee the manual chapter on Metaprogramming and the developer\ndocumentation Julia ASTs.\n\nExamples\n\njulia> Expr(:call, :+, 1, 2)\n:(1 + 2)\n\njulia> dump(:(a ? b : c))\nExpr\n  head: Symbol if\n  args: Array{Any}((3,))\n    1: Symbol a\n    2: Symbol b\n    3: Symbol c\n\n\n\n\n\n"},{"title":"Core.Symbol","page":"Essentials","location":"base/base.html#Core.Symbol","category":"type","text":"Symbol\n\nThe type of object used to represent identifiers in parsed julia code (ASTs).\nAlso often used as a name or label to identify an entity (e.g. as a dictionary key).\nSymbols can be entered using the : quote operator:\n\njulia> :name\n:name\n\njulia> typeof(:name)\nSymbol\n\njulia> x = 42\n42\n\njulia> eval(:x)\n42\n\nSymbols can also be constructed from strings or other values by calling the\nconstructor Symbol(x...).\n\nSymbols are immutable and their implementation re-uses the same object for all Symbols\nwith the same name.\n\nUnlike strings, Symbols are \"atomic\" or \"scalar\" entities that do not support\niteration over characters.\n\n\n\n\n\n"},{"title":"Core.Symbol","page":"Essentials","location":"base/base.html#Core.Symbol-Tuple","category":"method","text":"Symbol(x...)::Symbol\n\nCreate a Symbol by concatenating the string representations of the arguments together.\n\nExamples\n\njulia> Symbol(\"my\", \"name\")\n:myname\n\njulia> Symbol(\"day\", 4)\n:day4\n\n\n\n\n\n"},{"title":"Core.Module","page":"Essentials","location":"base/base.html#Core.Module","category":"type","text":"Module\n\nA Module is a separate global variable workspace. See module and the manual section about modules for details.\n\nModule(name::Symbol=:anonymous, std_imports=true, default_names=true)\n\nReturn a module with the specified name. A baremodule corresponds to Module(:ModuleName, false)\n\nAn empty module containing no names at all can be created with Module(:ModuleName, false, false).\nThis module will not import Base or Core and does not contain a reference to itself.\n\n\n\n\n\n"},{"title":"Core.Function","page":"Essentials","location":"base/base.html#Core.Function","category":"type","text":"Function\n\nAbstract type of all functions.\n\nExamples\n\njulia> isa(+, Function)\ntrue\n\njulia> typeof(sin)\ntypeof(sin) (singleton type of function sin, subtype of Function)\n\njulia> ans <: Function\ntrue\n\n\n\n\n\n"},{"title":"Base.hasmethod","page":"Essentials","location":"base/base.html#Base.hasmethod","category":"function","text":"hasmethod(f, t::Type{<:Tuple}[, kwnames]; world=get_world_counter())::Bool\n\nDetermine whether the given generic function has a method matching the given\nTuple of argument types with the upper bound of world age given by world.\n\nIf a tuple of keyword argument names kwnames is provided, this also checks\nwhether the method of f matching t has the given keyword argument names.\nIf the matching method accepts a variable number of keyword arguments, e.g.\nwith kwargs..., any names given in kwnames are considered valid. Otherwise\nthe provided names must be a subset of the method's keyword arguments.\n\nSee also applicable.\n\ncompat: Julia 1.2\nProviding keyword argument names requires Julia 1.2 or later.\n\nExamples\n\njulia> hasmethod(length, Tuple{Array})\ntrue\n\njulia> f(; oranges=0) = oranges;\n\njulia> hasmethod(f, Tuple{}, (:oranges,))\ntrue\n\njulia> hasmethod(f, Tuple{}, (:apples, :bananas))\nfalse\n\njulia> g(; xs...) = 4;\n\njulia> hasmethod(g, Tuple{}, (:a, :b, :c, :d))  # g accepts arbitrary kwargs\ntrue\n\n\n\n\n\n"},{"title":"Core.applicable","page":"Essentials","location":"base/base.html#Core.applicable","category":"function","text":"applicable(f, args...)::Bool\n\nDetermine whether the given generic function has a method applicable to the given arguments.\n\nSee also hasmethod.\n\nExamples\n\njulia> function f(x, y)\n           x + y\n       end;\n\njulia> applicable(f, 1)\nfalse\n\njulia> applicable(f, 1, 2)\ntrue\n\n\n\n\n\n"},{"title":"Base.isambiguous","page":"Essentials","location":"base/base.html#Base.isambiguous","category":"function","text":"Base.isambiguous(m1, m2; ambiguous_bottom=false)::Bool\n\nDetermine whether two methods m1 and m2 may be ambiguous for some call\nsignature. This test is performed in the context of other methods of the same\nfunction; in isolation, m1 and m2 might be ambiguous, but if a third method\nresolving the ambiguity has been defined, this returns false.\nAlternatively, in isolation m1 and m2 might be ordered, but if a third\nmethod cannot be sorted with them, they may cause an ambiguity together.\n\nFor parametric types, the ambiguous_bottom keyword argument controls whether\nUnion{} counts as an ambiguous intersection of type parameters – when true,\nit is considered ambiguous, when false it is not.\n\nExamples\n\njulia> foo(x::Complex{<:Integer}) = 1\nfoo (generic function with 1 method)\n\njulia> foo(x::Complex{<:Rational}) = 2\nfoo (generic function with 2 methods)\n\njulia> m1, m2 = collect(methods(foo));\n\njulia> typeintersect(m1.sig, m2.sig)\nTuple{typeof(foo), Complex{Union{}}}\n\njulia> Base.isambiguous(m1, m2, ambiguous_bottom=true)\ntrue\n\njulia> Base.isambiguous(m1, m2, ambiguous_bottom=false)\nfalse\n\n\n\n\n\n"},{"title":"Core.invoke","page":"Essentials","location":"base/base.html#Core.invoke","category":"function","text":"invoke(f, argtypes::Type, args...; kwargs...)\ninvoke(f, argtypes::Method, args...; kwargs...)\ninvoke(f, argtypes::CodeInstance, args...; kwargs...)\n\nInvoke a method for the given generic function f matching the specified types argtypes on the\nspecified arguments args and passing the keyword arguments kwargs. The arguments args must\nconform with the specified types in argtypes, i.e. conversion is not automatically performed.\nThis method allows invoking a method other than the most specific matching method, which is useful\nwhen the behavior of a more general definition is explicitly needed (often as part of the\nimplementation of a more specific method of the same function). However, because this means\nthe runtime must do more work, invoke is generally also slower–sometimes significantly\nso–than doing normal dispatch with a regular call.\n\nBe careful when using invoke for functions that you don't write. What definition is used\nfor given argtypes is an implementation detail unless the function is explicitly states\nthat calling with certain argtypes is a part of public API.  For example, the change\nbetween f1 and f2 in the example below is usually considered compatible because the\nchange is invisible by the caller with a normal (non-invoke) call.  However, the change is\nvisible if you use invoke.\n\nPassing a Method instead of a signature\n\nThe argtypes argument may be a Method, in which case the ordinary method table lookup is\nbypassed entirely and the given method is invoked directly. Needing this feature is uncommon.\nNote in particular that the specified Method may be entirely unreachable from ordinary dispatch\n(or ordinary invoke), e.g. because it was replaced or fully covered by more specific methods.\nIf the method is part of the ordinary method table, this call behaves similar\nto invoke(f, method.sig, args...).\n\ncompat: Julia 1.12\nPassing a Method requires Julia 1.12.\n\nPassing a CodeInstance instead of a signature\n\nThe argtypes argument may be a CodeInstance, bypassing both method lookup and specialization.\nThe semantics of this invocation are similar to a function pointer call of the CodeInstance's\ninvoke pointer. It is an error to invoke a CodeInstance with arguments that do not match its\nparent MethodInstance or from a world age not included in the min_world/max_world range.\nIt is undefined behavior to invoke a CodeInstance whose behavior does not match the constraints\nspecified in its fields. For some code instances with owner !== nothing (i.e. those generated\nby external compilers), it may be an error to invoke them after passing through precompilation.\nThis is an advanced interface intended for use with external compiler plugins.\n\ncompat: Julia 1.12\nPassing a CodeInstance requires Julia 1.12.\n\nExamples\n\njulia> f(x::Real) = x^2;\n\njulia> f(x::Integer) = 1 + invoke(f, Tuple{Real}, x);\n\njulia> f(2)\n5\n\njulia> f1(::Integer) = Integer\n       f1(::Real) = Real;\n\njulia> f2(x::Real) = _f2(x)\n       _f2(::Integer) = Integer\n       _f2(_) = Real;\n\njulia> f1(1)\nInteger\n\njulia> f2(1)\nInteger\n\njulia> invoke(f1, Tuple{Real}, 1)\nReal\n\njulia> invoke(f2, Tuple{Real}, 1)\nInteger\n\n\n\n\n\n"},{"title":"Base.@invoke","page":"Essentials","location":"base/base.html#Base.@invoke","category":"macro","text":"@invoke f(arg::T, ...; kwargs...)\n\nProvides a convenient way to call invoke by expanding\n@invoke f(arg1::T1, arg2::T2; kwargs...) to invoke(f, Tuple{T1,T2}, arg1, arg2; kwargs...).\nWhen an argument's type annotation is omitted, it's replaced with Core.Typeof that argument.\nTo invoke a method where an argument is untyped or explicitly typed as Any, annotate the\nargument with ::Any.\n\nIt also supports the following syntax:\n\n@invoke (x::X).f expands to invoke(getproperty, Tuple{X,Symbol}, x, :f)\n@invoke (x::X).f = v::V expands to invoke(setproperty!, Tuple{X,Symbol,V}, x, :f, v)\n@invoke (xs::Xs)[i::I] expands to invoke(getindex, Tuple{Xs,I}, xs, i)\n@invoke (xs::Xs)[i::I] = v::V expands to invoke(setindex!, Tuple{Xs,V,I}, xs, v, i)\n\nExamples\n\njulia> @macroexpand @invoke f(x::T, y)\n:(Core.invoke(f, Base.Tuple{T, Core.Typeof(y)}, x, y))\n\njulia> @invoke 420::Integer % Unsigned\n0x00000000000001a4\n\njulia> @macroexpand @invoke (x::X).f\n:(Core.invoke(Base.getproperty, Base.Tuple{X, Core.Typeof(:f)}, x, :f))\n\njulia> @macroexpand @invoke (x::X).f = v::V\n:(Core.invoke(Base.setproperty!, Base.Tuple{X, Core.Typeof(:f), V}, x, :f, v))\n\njulia> @macroexpand @invoke (xs::Xs)[i::I]\n:(Core.invoke(Base.getindex, Base.Tuple{Xs, I}, xs, i))\n\njulia> @macroexpand @invoke (xs::Xs)[i::I] = v::V\n:(Core.invoke(Base.setindex!, Base.Tuple{Xs, V, I}, xs, v, i))\n\ncompat: Julia 1.7\nThis macro requires Julia 1.7 or later.\n\ncompat: Julia 1.9\nThis macro is exported as of Julia 1.9.\n\ncompat: Julia 1.10\nThe additional syntax is supported as of Julia 1.10.\n\n\n\n\n\n"},{"title":"Base.invokelatest","page":"Essentials","location":"base/base.html#Base.invokelatest","category":"function","text":"invokelatest(f, args...; kwargs...)\n\nCalls f(args...; kwargs...), but guarantees that the most recent method of f\nwill be executed.   This is useful in specialized circumstances,\ne.g. long-running event loops or callback functions that may\ncall obsolete versions of a function f.\n(The drawback is that invokelatest is somewhat slower than calling\nf directly, and the type of the result cannot be inferred by the compiler.)\n\ncompat: Julia 1.9\nPrior to Julia 1.9, this function was not exported, and was called as Base.invokelatest.\n\n\n\n\n\n"},{"title":"Base.@invokelatest","page":"Essentials","location":"base/base.html#Base.@invokelatest","category":"macro","text":"@invokelatest f(args...; kwargs...)\n\nProvides a convenient way to call invokelatest.\n@invokelatest f(args...; kwargs...) will simply be expanded into\nBase.invokelatest(f, args...; kwargs...).\n\nIt also supports the following syntax:\n\n@invokelatest x.f expands to Base.invokelatest(getproperty, x, :f)\n@invokelatest x.f = v expands to Base.invokelatest(setproperty!, x, :f, v)\n@invokelatest xs[i] expands to Base.invokelatest(getindex, xs, i)\n@invokelatest xs[i] = v expands to Base.invokelatest(setindex!, xs, v, i)\n\nnote: Note\nIf f is a global, it will be resolved consistently\nin the (latest) world as the call target. However, all other arguments\n(as well as f itself if it is not a literal global) will be evaluated\nin the current world age.\n\ncompat: Julia 1.7\nThis macro requires Julia 1.7 or later.\n\ncompat: Julia 1.9\nPrior to Julia 1.9, this macro was not exported, and was called as Base.@invokelatest.\n\ncompat: Julia 1.10\nThe additional x.f and xs[i] syntax requires Julia 1.10.\n\n\n\n\n\n"},{"title":"new","page":"Essentials","location":"base/base.html#new","category":"keyword","text":"new, or new{A,B,...}\n\nSpecial function available to inner constructors which creates a new object\nof the type. The form new{A,B,...} explicitly specifies values of parameters for parametric types.\nSee the manual section on Inner Constructor Methods\nfor more information.\n\n\n\n\n\n"},{"title":"Base.:|>","page":"Essentials","location":"base/base.html#Base.:|>","category":"function","text":"|>(x, f)\n\nInfix operator which applies function f to the argument x.\nThis allows f(g(x)) to be written x |> g |> f.\nWhen used with anonymous functions, parentheses are typically required around\nthe definition to get the intended chain.\n\nExamples\n\njulia> 4 |> inv\n0.25\n\njulia> [2, 3, 5] |> sum |> inv\n0.1\n\njulia> [0 1; 2 3] .|> (x -> x^2) |> sum\n14\n\n\n\n\n\n"},{"title":"Base.:∘","page":"Essentials","location":"base/base.html#Base.:∘","category":"function","text":"f ∘ g\n\nCompose functions: i.e. (f ∘ g)(args...; kwargs...) means f(g(args...; kwargs...)). The ∘ symbol can be\nentered in the Julia REPL (and most editors, appropriately configured) by typing \\circ<tab>.\n\nFunction composition also works in prefix form: ∘(f, g) is the same as f ∘ g.\nThe prefix form supports composition of multiple functions: ∘(f, g, h) = f ∘ g ∘ h\nand splatting ∘(fs...) for composing an iterable collection of functions.\nThe last argument to ∘ execute first.\n\ncompat: Julia 1.4\nMultiple function composition requires at least Julia 1.4.\n\ncompat: Julia 1.5\nComposition of one function ∘(f) requires at least Julia 1.5.\n\ncompat: Julia 1.7\nUsing keyword arguments requires at least Julia 1.7.\n\nExamples\n\njulia> map(uppercase∘first, [\"apple\", \"banana\", \"carrot\"])\n3-element Vector{Char}:\n 'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n 'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)\n 'C': ASCII/Unicode U+0043 (category Lu: Letter, uppercase)\n\njulia> (==(6)∘length).([\"apple\", \"banana\", \"carrot\"])\n3-element BitVector:\n 0\n 1\n 1\n\njulia> fs = [\n           x -> 2x\n           x -> x-1\n           x -> x/2\n           x -> x+1\n       ];\n\njulia> ∘(fs...)(3)\n2.0\n\nSee also ComposedFunction, !f::Function.\n\n\n\n\n\n"},{"title":"Base.ComposedFunction","page":"Essentials","location":"base/base.html#Base.ComposedFunction","category":"type","text":"ComposedFunction{Outer,Inner} <: Function\n\nRepresents the composition of two callable objects outer::Outer and inner::Inner. That is\n\nComposedFunction(outer, inner)(args...; kw...) === outer(inner(args...; kw...))\n\nThe preferred way to construct an instance of ComposedFunction is to use the composition operator ∘:\n\njulia> sin ∘ cos === ComposedFunction(sin, cos)\ntrue\n\njulia> typeof(sin∘cos)\nComposedFunction{typeof(sin), typeof(cos)}\n\nThe composed pieces are stored in the fields of ComposedFunction and can be retrieved as follows:\n\njulia> composition = sin ∘ cos\nsin ∘ cos\n\njulia> composition.outer === sin\ntrue\n\njulia> composition.inner === cos\ntrue\n\ncompat: Julia 1.6\nComposedFunction requires at least Julia 1.6. In earlier versions ∘ returns an anonymous function instead.\n\nSee also ∘.\n\n\n\n\n\n"},{"title":"Base.splat","page":"Essentials","location":"base/base.html#Base.splat","category":"function","text":"splat(f)\n\nEquivalent to\n\n    my_splat(f) = args->f(args...)\n\ni.e. given a function returns a new function that takes one argument and splats\nit into the original function. This is useful as an adaptor to pass a\nmulti-argument function in a context that expects a single argument, but passes\na tuple as that single argument.\n\nExamples\n\njulia> map(splat(+), zip(1:3,4:6))\n3-element Vector{Int64}:\n 5\n 7\n 9\n\njulia> my_add = splat(+)\nsplat(+)\n\njulia> my_add((1,2,3))\n6\n\n\n\n\n\n"},{"title":"Base.Fix","page":"Essentials","location":"base/base.html#Base.Fix","category":"type","text":"Fix{N}(f, x)\n\nA type representing a partially-applied version of a function f, with the argument\nx fixed at position N::Int. In other words, Fix{3}(f, x) behaves similarly to\n(y1, y2, y3...; kws...) -> f(y1, y2, x, y3...; kws...).\n\ncompat: Julia 1.12\nThis general functionality requires at least Julia 1.12, while Fix1 and Fix2\nare available earlier.\n\nnote: Note\nWhen nesting multiple Fix, note that the N in Fix{N} is relative to the current\navailable arguments, rather than an absolute ordering on the target function. For example,\nFix{1}(Fix{2}(f, 4), 4) fixes the first and second arg, while Fix{2}(Fix{1}(f, 4), 4)\nfixes the first and third arg.\n\n\n\n\n\n"},{"title":"Base.Fix1","page":"Essentials","location":"base/base.html#Base.Fix1","category":"type","text":"Alias for Fix{1}. See Fix.\n\n\n\n\n\n"},{"title":"Base.Fix2","page":"Essentials","location":"base/base.html#Base.Fix2","category":"type","text":"Alias for Fix{2}. See Fix.\n\n\n\n\n\n"},{"title":"Base.Returns","page":"Essentials","location":"base/base.html#Base.Returns","category":"type","text":"f = Returns(value)\n\nCreate a callable f such that f(args...; kw...) === value holds.\n\nExamples\n\njulia> f = Returns(42);\n\njulia> f(1)\n42\n\njulia> f(\"hello\", x=32)\n42\n\njulia> f.value\n42\n\ncompat: Julia 1.7\nReturns requires at least Julia 1.7.\n\n\n\n\n\n"},{"title":"Core.eval","page":"Essentials","location":"base/base.html#Core.eval","category":"function","text":"Core.eval(m::Module, expr)\n\nEvaluate an expression in the given module and return the result.\n\n\n\n\n\n"},{"title":"eval","page":"Essentials","location":"base/base.html#eval","category":"function","text":"eval(expr)\n\nEvaluate an expression in the global scope of the containing module.\nEvery Module (except those defined with baremodule) has a private 1-argument definition\nof eval, which evaluates expressions in that module, for use inside that module.\n\n\n\n\n\n"},{"title":"Base.@eval","page":"Essentials","location":"base/base.html#Base.@eval","category":"macro","text":"@eval [mod,] ex\n\nEvaluate an expression with values interpolated into it using eval.\nIf two arguments are provided, the first is the module to evaluate in.\n\n\n\n\n\n"},{"title":"Base.evalfile","page":"Essentials","location":"base/base.html#Base.evalfile","category":"function","text":"evalfile(path::AbstractString, args::Vector{String}=String[])\n\nLoad the file into an anonymous module using include, evaluate all expressions,\nand return the value of the last expression.\nThe optional args argument can be used to set the input arguments of the script (i.e. the global ARGS variable).\nNote that definitions (e.g. methods, globals) are evaluated in the anonymous module and do not affect the current module.\n\nExamples\n\njulia> write(\"testfile.jl\", \"\"\"\n           @show ARGS\n           1 + 1\n       \"\"\");\n\njulia> x = evalfile(\"testfile.jl\", [\"ARG1\", \"ARG2\"]);\nARGS = [\"ARG1\", \"ARG2\"]\n\njulia> x\n2\n\njulia> rm(\"testfile.jl\")\n\n\n\n\n\n"},{"title":"Base.esc","page":"Essentials","location":"base/base.html#Base.esc","category":"function","text":"esc(e)\n\nOnly valid in the context of an Expr returned from a macro. Prevents the macro hygiene\npass from turning embedded variables into gensym variables. See the Macros\nsection of the Metaprogramming chapter of the manual for more details and examples.\n\n\n\n\n\n"},{"title":"Base.@inbounds","page":"Essentials","location":"base/base.html#Base.@inbounds","category":"macro","text":"@inbounds(blk)\n\nEliminates array bounds checking within expressions.\n\nIn the example below the in-range check for referencing\nelement i of array A is skipped to improve performance.\n\nfunction sum(A::AbstractArray)\n    r = zero(eltype(A))\n    for i in eachindex(A)\n        @inbounds r += A[i]\n    end\n    return r\nend\n\nwarning: Warning\nUsing @inbounds may return incorrect results/crashes/corruption\nfor out-of-bounds indices. The user is responsible for checking it manually.\nOnly use @inbounds when you are certain that all accesses are in bounds (as\nundefined behavior, e.g. crashes, might occur if this assertion is violated). For\nexample, using 1:length(A) instead of eachindex(A) in a function like\nthe one above is not safely inbounds because the first index of A may not\nbe 1 for all user defined types that subtype AbstractArray.\n\n\n\n\n\n"},{"title":"Base.@boundscheck","page":"Essentials","location":"base/base.html#Base.@boundscheck","category":"macro","text":"@boundscheck(blk)\n\nAnnotates the expression blk as a bounds checking block, allowing it to be elided by @inbounds.\n\nnote: Note\nThe function in which @boundscheck is written must be inlined into\nits caller in order for @inbounds to have effect.\n\nExamples\n\njulia> @inline function g(A, i)\n           @boundscheck checkbounds(A, i)\n           return \"accessing ($A)[$i]\"\n       end;\n\njulia> f1() = return g(1:2, -1);\n\njulia> f2() = @inbounds return g(1:2, -1);\n\njulia> f1()\nERROR: BoundsError: attempt to access 2-element UnitRange{Int64} at index [-1]\nStacktrace:\n [1] throw_boundserror(::UnitRange{Int64}, ::Tuple{Int64}) at ./abstractarray.jl:455\n [2] checkbounds at ./abstractarray.jl:420 [inlined]\n [3] g at ./none:2 [inlined]\n [4] f1() at ./none:1\n [5] top-level scope\n\njulia> f2()\n\"accessing (1:2)[-1]\"\n\nwarning: Warning\nThe @boundscheck annotation allows you, as a library writer, to opt-in to\nallowing other code to remove your bounds checks with @inbounds.\nAs noted there, the caller must verify—using information they can access—that\ntheir accesses are valid before using @inbounds. For indexing into your\nAbstractArray subclasses, for example, this involves checking the\nindices against its axes. Therefore, @boundscheck annotations\nshould only be added to a getindex or setindex!\nimplementation after you are certain its behavior is correct.\n\n\n\n\n\n"},{"title":"Base.@propagate_inbounds","page":"Essentials","location":"base/base.html#Base.@propagate_inbounds","category":"macro","text":"@propagate_inbounds\n\nTells the compiler to inline a function while retaining the caller's inbounds context.\n\n\n\n\n\n"},{"title":"Base.@inline","page":"Essentials","location":"base/base.html#Base.@inline","category":"macro","text":"@inline\n\nGive a hint to the compiler that this function is worth inlining.\n\nSmall functions typically do not need the @inline annotation,\nas the compiler does it automatically. By using @inline on bigger functions,\nan extra nudge can be given to the compiler to inline it.\n\n@inline can be applied immediately before a function definition or within a function body.\n\n# annotate long-form definition\n@inline function longdef(x)\n    ...\nend\n\n# annotate short-form definition\n@inline shortdef(x) = ...\n\n# annotate anonymous function that a `do` block creates\nf() do\n    @inline\n    ...\nend\n\ncompat: Julia 1.8\nThe usage within a function body requires at least Julia 1.8.\n\n\n\n@inline block\n\nGive a hint to the compiler that calls within block are worth inlining.\n\n# The compiler will try to inline `f`\n@inline f(...)\n\n# The compiler will try to inline `f`, `g` and `+`\n@inline f(...) + g(...)\n\nnote: Note\nA callsite annotation always has the precedence over the annotation applied to the\ndefinition of the called function:@noinline function explicit_noinline(args...)\n    # body\nend\n\nlet\n    @inline explicit_noinline(args...) # will be inlined\nend\n\nnote: Note\nThe callsite annotation applies to all calls in the block, including function arguments\nthat are themselves calls:# The compiler will not inline `getproperty`, `g` or `f`\n@noinline f(x.inner, g(y))\n\nnote: Note\nWhen there are nested callsite annotations, the innermost annotation has the precedence:@noinline let a0, b0 = ...\n    a = @inline f(a0)  # the compiler will try to inline this call\n    b = f(b0)          # the compiler will NOT try to inline this call\n    return a, b\nend\n\nwarning: Warning\nAlthough a callsite annotation will try to force inlining in regardless of the cost model,\nthere are still chances it can't succeed in it. Especially, recursive calls can not be\ninlined even if they are annotated as @inlined.\n\ncompat: Julia 1.8\nThe callsite annotation requires at least Julia 1.8.\n\n\n\n\n\n"},{"title":"Base.@noinline","page":"Essentials","location":"base/base.html#Base.@noinline","category":"macro","text":"@noinline\n\nGive a hint to the compiler that it should not inline a function.\n\nSmall functions are typically inlined automatically.\nBy using @noinline on small functions, auto-inlining can be\nprevented.\n\n@noinline can be applied immediately before a function definition or within a function body.\n\n# annotate long-form definition\n@noinline function longdef(x)\n    ...\nend\n\n# annotate short-form definition\n@noinline shortdef(x) = ...\n\n# annotate anonymous function that a `do` block creates\nf() do\n    @noinline\n    ...\nend\n\ncompat: Julia 1.8\nThe usage within a function body requires at least Julia 1.8.\n\n\n\n@noinline block\n\nGive a hint to the compiler that it should not inline the calls within block.\n\n# The compiler will try to not inline `f`\n@noinline f(...)\n\n# The compiler will try to not inline `f`, `g` and `+`\n@noinline f(...) + g(...)\n\nnote: Note\nA callsite annotation always has the precedence over the annotation applied to the\ndefinition of the called function:@inline function explicit_inline(args...)\n    # body\nend\n\nlet\n    @noinline explicit_inline(args...) # will not be inlined\nend\n\nnote: Note\nWhen there are nested callsite annotations, the innermost annotation has the precedence:@inline let a0, b0 = ...\n    a = @noinline f(a0)  # the compiler will NOT try to inline this call\n    b = f(b0)            # the compiler will try to inline this call\n    return a, b\nend\n\ncompat: Julia 1.8\nThe callsite annotation requires at least Julia 1.8.\n\n\n\nnote: Note\nIf the function is trivial (for example returning a constant) it might get inlined anyway.\n\n\n\n\n\n"},{"title":"Base.@nospecialize","page":"Essentials","location":"base/base.html#Base.@nospecialize","category":"macro","text":"@nospecialize\n\nApplied to a function argument name, hints to the compiler that the method\nimplementation should not be specialized for different types of that argument,\nbut instead use the declared type for that argument.\nIt can be applied to an argument within a formal argument list,\nor in the function body.\nWhen applied to an argument, the macro must wrap the entire argument expression, e.g.,\n@nospecialize(x::Real) or @nospecialize(i::Integer...) rather than wrapping just the argument name.\nWhen used in a function body, the macro must occur in statement position and\nbefore any code.\n\nWhen used without arguments, it applies to all arguments of the parent scope.\nIn local scope, this means all arguments of the containing function.\nIn global (top-level) scope, this means all methods subsequently defined in the current module.\n\nSpecialization can reset back to the default by using @specialize.\n\nfunction example_function(@nospecialize x)\n    ...\nend\n\nfunction example_function(x, @nospecialize(y = 1))\n    ...\nend\n\nfunction example_function(x, y, z)\n    @nospecialize x y\n    ...\nend\n\n@nospecialize\nf(y) = [x for x in y]\n@specialize\n\nnote: Note\n@nospecialize affects code generation but not inference: it limits the diversity\nof the resulting native code, but it does not impose any limitations (beyond the\nstandard ones) on type-inference. Use Base.@nospecializeinfer together with\n@nospecialize to additionally suppress inference.\n\nExamples\n\njulia> f(A::AbstractArray) = g(A)\nf (generic function with 1 method)\n\njulia> @noinline g(@nospecialize(A::AbstractArray)) = A[1]\ng (generic function with 1 method)\n\njulia> @code_typed f([1.0])\nCodeInfo(\n1 ─ %1 =    invoke g(A::AbstractArray)::Float64\n└──      return %1\n) => Float64\n\nHere, the @nospecialize annotation results in the equivalent of\n\nf(A::AbstractArray) = invoke(g, Tuple{AbstractArray}, A)\n\nensuring that only one version of native code will be generated for g,\none that is generic for any AbstractArray.\nHowever, the specific return type is still inferred for both g and f,\nand this is still used in optimizing the callers of f and g.\n\n\n\n\n\n"},{"title":"Base.@specialize","page":"Essentials","location":"base/base.html#Base.@specialize","category":"macro","text":"@specialize\n\nReset the specialization hint for an argument back to the default.\nFor details, see @nospecialize.\n\n\n\n\n\n"},{"title":"Base.@nospecializeinfer","page":"Essentials","location":"base/base.html#Base.@nospecializeinfer","category":"macro","text":"Base.@nospecializeinfer function f(args...)\n    @nospecialize ...\n    ...\nend\nBase.@nospecializeinfer f(@nospecialize args...) = ...\n\nTells the compiler to infer f using the declared types of @nospecialized arguments.\nThis can be used to limit the number of compiler-generated specializations during inference.\n\nExamples\n\njulia> f(A::AbstractArray) = g(A)\nf (generic function with 1 method)\n\njulia> @noinline Base.@nospecializeinfer g(@nospecialize(A::AbstractArray)) = A[1]\ng (generic function with 1 method)\n\njulia> @code_typed f([1.0])\nCodeInfo(\n1 ─ %1 =    invoke g(A::AbstractArray)::Any\n└──      return %1\n) => Any\n\nIn this example, f will be inferred for each specific type of A,\nbut g will only be inferred once with the declared argument type A::AbstractArray,\nmeaning that the compiler will not likely see the excessive inference time on it\nwhile it can not infer the concrete return type of it.\nWithout the @nospecializeinfer, f([1.0]) would infer the return type of g as Float64,\nindicating that inference ran for g(::Vector{Float64}) despite the prohibition on\nspecialized code generation.\n\ncompat: Julia 1.10\nUsing Base.@nospecializeinfer requires Julia version 1.10.\n\n\n\n\n\n"},{"title":"Base.@constprop","page":"Essentials","location":"base/base.html#Base.@constprop","category":"macro","text":"Base.@constprop setting [ex]\n\nControl the mode of interprocedural constant propagation for the annotated function.\n\nTwo settings are supported:\n\nBase.@constprop :aggressive [ex]: apply constant propagation aggressively.\nFor a method where the return type depends on the value of the arguments,\nthis can yield improved inference results at the cost of additional compile time.\nBase.@constprop :none [ex]: disable constant propagation. This can reduce compile\ntimes for functions that Julia might otherwise deem worthy of constant-propagation.\nCommon cases are for functions with Bool- or Symbol-valued arguments or keyword arguments.\n\nBase.@constprop can be applied immediately before a function definition or within a function body.\n\n# annotate long-form definition\nBase.@constprop :aggressive function longdef(x)\n    ...\nend\n\n# annotate short-form definition\nBase.@constprop :aggressive shortdef(x) = ...\n\n# annotate anonymous function that a `do` block creates\nf() do\n    Base.@constprop :aggressive\n    ...\nend\n\ncompat: Julia 1.10\nThe usage within a function body requires at least Julia 1.10.\n\n\n\n\n\n"},{"title":"Base.gensym","page":"Essentials","location":"base/base.html#Base.gensym","category":"function","text":"gensym([tag])\n\nGenerate a symbol unique among all calls to this function within the same process.\nIf a string or symbol tag argument is specified, it is included in the generated name.\n\nNote that packages may be precompiled in separate processes, so names will not be unique\nbetween definition time and run time.\n\n\n\n\n\n"},{"title":"Base.@gensym","page":"Essentials","location":"base/base.html#Base.@gensym","category":"macro","text":"@gensym var1 var2 ...\n\nGenerate symbols with gensym and assign them to the given variables.\nFor example, @gensym x y is transformed into x = gensym(\"x\"); y = gensym(\"y\").\n\n\n\n\n\n"},{"title":"var\"name\"","page":"Essentials","location":"base/base.html#var\"name\"","category":"keyword","text":"var\n\nThe syntax var\"#example#\" refers to a variable named Symbol(\"#example#\"),\neven though #example# is not a valid Julia identifier name.\n\nThis can be useful for interoperability with programming languages which have\ndifferent rules for the construction of valid identifiers. For example, to\nrefer to the R variable draw.segments, you can use var\"draw.segments\" in\nyour Julia code.\n\nIt is also used to show julia source code which has gone through macro\nhygiene or otherwise contains variable names which can't be parsed normally.\n\nNote that this syntax requires parser support so it is expanded directly by the\nparser rather than being implemented as a normal string macro @var_str.\n\ncompat: Julia 1.3\nThis syntax requires at least Julia 1.3.\n\n\n\n\n\n"},{"title":"Base.@goto","page":"Essentials","location":"base/base.html#Base.@goto","category":"macro","text":"@goto name\n\n@goto name unconditionally jumps to the statement at the location @label name.\n\n@label and @goto cannot create jumps to different top-level statements. Attempts cause an\nerror. To still use @goto, enclose the @label and @goto in a block.\n\n\n\n\n\n"},{"title":"Base.@label","page":"Essentials","location":"base/base.html#Base.@label","category":"macro","text":"@label name\n\nLabels a statement with the symbolic label name. The label marks the end-point\nof an unconditional jump with @goto name.\n\n\n\n\n\n"},{"title":"Base.SimdLoop.@simd","page":"Essentials","location":"base/base.html#Base.SimdLoop.@simd","category":"macro","text":"@simd\n\nAnnotate a for loop to allow the compiler to take extra liberties to allow loop re-ordering\n\nwarning: Warning\nThis feature is experimental and could change or disappear in future versions of Julia.\nIncorrect use of the @simd macro may cause unexpected results.\n\nThe object iterated over in a @simd for loop should be a one-dimensional range.\nBy using @simd, you are asserting several properties of the loop:\n\nIt is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.\nFloating-point operations on reduction variables can be reordered or contracted, possibly causing different results than without @simd.\n\nIn many cases, Julia is able to automatically vectorize inner for loops without the use of @simd.\nUsing @simd gives the compiler a little extra leeway to make it possible in more situations. In\neither case, your inner loop should have the following properties to allow vectorization:\n\nThe loop must be an innermost loop\nThe loop body must be straight-line code. Therefore, @inbounds is\n  currently needed for all array accesses. The compiler can sometimes turn\n  short &&, ||, and ?: expressions into straight-line code if it is safe\n  to evaluate all operands unconditionally. Consider using the ifelse\n  function instead of ?: in the loop if it is safe to do so.\nAccesses must have a stride pattern and cannot be \"gathers\" (random-index\n  reads) or \"scatters\" (random-index writes).\nThe stride should be unit stride.\n\nnote: Note\nThe @simd does not assert by default that the loop is completely free of loop-carried\nmemory dependencies, which is an assumption that can easily be violated in generic code.\nIf you are writing non-generic code, you can use @simd ivdep for ... end to also assert that:\n\nThere exists no loop-carried memory dependencies\nNo iteration ever waits on a previous iteration to make forward progress.\n\n\n\n\n\n"},{"title":"Base.@polly","page":"Essentials","location":"base/base.html#Base.@polly","category":"macro","text":"@polly\n\nTells the compiler to apply the polyhedral optimizer Polly to a function.\n\n\n\n\n\n"},{"title":"Base.@generated","page":"Essentials","location":"base/base.html#Base.@generated","category":"macro","text":"@generated f\n\n@generated is used to annotate a function which will be generated.\nIn the body of the generated function, only types of arguments can be read\n(not the values). The function returns a quoted expression evaluated when the\nfunction is called. The @generated macro should not be used on functions mutating\nthe global scope or depending on mutable elements.\n\nSee Metaprogramming for further details.\n\nExamples\n\njulia> @generated function bar(x)\n           if x <: Integer\n               return :(x ^ 2)\n           else\n               return :(x)\n           end\n       end\nbar (generic function with 1 method)\n\njulia> bar(4)\n16\n\njulia> bar(\"baz\")\n\"baz\"\n\n\n\n\n\n"},{"title":"Base.@assume_effects","page":"Essentials","location":"base/base.html#Base.@assume_effects","category":"macro","text":"Base.@assume_effects setting... [ex]\n\nOverride the compiler's effect modeling.\nThis macro can be used in several contexts:\n\nImmediately before a method definition, to override the entire effect modeling of the applied method.\nWithin a function body without any arguments, to override the entire effect modeling of the enclosing method.\nApplied to a code block, to override the local effect modeling of the applied code block.\n\nExamples\n\njulia> Base.@assume_effects :terminates_locally function fact(x)\n           # usage 1:\n           # this :terminates_locally allows `fact` to be constant-folded\n           res = 1\n           0 ≤ x < 20 || error(\"bad fact\")\n           while x > 1\n               res *= x\n               x -= 1\n           end\n           return res\n       end\nfact (generic function with 1 method)\n\njulia> code_typed() do\n           fact(12)\n       end |> only\nCodeInfo(\n1 ─     return 479001600\n) => Int64\n\njulia> code_typed() do\n           map((2,3,4)) do x\n               # usage 2:\n               # this :terminates_locally allows this anonymous function to be constant-folded\n               Base.@assume_effects :terminates_locally\n               res = 1\n               0 ≤ x < 20 || error(\"bad fact\")\n               while x > 1\n                   res *= x\n                   x -= 1\n               end\n               return res\n           end\n       end |> only\nCodeInfo(\n1 ─     return (2, 6, 24)\n) => Tuple{Int64, Int64, Int64}\n\njulia> code_typed() do\n           map((2,3,4)) do x\n               res = 1\n               0 ≤ x < 20 || error(\"bad fact\")\n               # usage 3:\n               # with this :terminates_locally annotation the compiler skips tainting\n               # `:terminates` effect within this `while` block, allowing the parent\n               # anonymous function to be constant-folded\n               Base.@assume_effects :terminates_locally while x > 1\n                   res *= x\n                   x -= 1\n               end\n               return res\n           end\n       end |> only\nCodeInfo(\n1 ─     return (2, 6, 24)\n) => Tuple{Int64, Int64, Int64}\n\ncompat: Julia 1.8\nUsing Base.@assume_effects requires Julia version 1.8.\n\ncompat: Julia 1.10\nThe usage within a function body requires at least Julia 1.10.\n\ncompat: Julia 1.11\nThe code block annotation requires at least Julia 1.11.\n\nwarning: Warning\nImproper use of this macro causes undefined behavior (including crashes,\nincorrect answers, or other hard to track bugs). Use with care and only as a\nlast resort if absolutely required. Even in such a case, you SHOULD take all\npossible steps to minimize the strength of the effect assertion (e.g.,\ndo not use :total if :nothrow would have been sufficient).\n\nIn general, each setting value makes an assertion about the behavior of the\nfunction, without requiring the compiler to prove that this behavior is indeed\ntrue. These assertions are made for all world ages. It is thus advisable to limit\nthe use of generic functions that may later be extended to invalidate the\nassumption (which would cause undefined behavior).\n\nThe following settings are supported.\n\n:consistent\n:effect_free\n:nothrow\n:terminates_globally\n:terminates_locally\n:notaskstate\n:inaccessiblememonly\n:noub\n:noub_if_noinbounds\n:nortcall\n:foldable\n:removable\n:total\n\nExtended help\n\n\n\n:consistent\n\nThe :consistent setting asserts that for egal (===) inputs:\n\nThe manner of termination (return value, exception, non-termination) will always be the same.\nIf the method returns, the results will always be egal.\n\nnote: Note\nThis in particular implies that the method must not return a freshly allocated\nmutable object. Multiple allocations of mutable objects (even with identical\ncontents) are not egal.\n\nnote: Note\nThe :consistent-cy assertion is made with respect to a particular world range R.\nMore formally, write fᵢ for the evaluation of f in world-age i, then this setting requires: i  R j  R x y x  y  fᵢ(x)  fⱼ(y)For @assume_effects, the range R is m.primary_world:m.deleted_world of\nthe annotated or containing method.For ordinary code instances, R is ci.min_world:ci.max_world.A further implication is that :consistent functions may not make their\nreturn value dependent on the state of the heap or any other global state\nthat is not constant over the given world age range.\n\nnote: Note\nThe :consistent-cy includes all legal rewrites performed by the optimizer.\nFor example, floating-point fastmath operations are not considered :consistent,\nbecause the optimizer may rewrite them causing the output to not be :consistent,\neven for the same world age (e.g. because one ran in the interpreter, while\nthe other was optimized).\n\nnote: Note\nIf :consistent functions terminate by throwing an exception, that exception\nitself is not required to meet the egality requirement specified above.\n\n\n\n:effect_free\n\nThe :effect_free setting asserts that the method is free of externally semantically\nvisible side effects. The following is an incomplete list of externally semantically\nvisible side effects:\n\nChanging the value of a global variable.\nMutating the heap (e.g. an array or mutable value), except as noted below\nChanging the method table (e.g. through calls to eval)\nFile/Network/etc. I/O\nTask switching\n\nHowever, the following are explicitly not semantically visible, even if they\nmay be observable:\n\nMemory allocations (both mutable and immutable)\nElapsed time\nGarbage collection\nHeap mutations of objects whose lifetime does not exceed the method (i.e.\nwere allocated in the method and do not escape).\nThe returned value (which is externally visible, but not a side effect)\n\nThe rule of thumb here is that an externally visible side effect is anything\nthat would affect the execution of the remainder of the program if the function\nwere not executed.\n\nnote: Note\nThe :effect_free assertion is made both for the method itself and any code\nthat is executed by the method. Keep in mind that the assertion must be\nvalid for all world ages and limit use of this assertion accordingly.\n\n\n\n:nothrow\n\nThe :nothrow settings asserts that this method does not throw an exception\n(i.e. will either always return a value or never return).\n\nnote: Note\nIt is permissible for :nothrow annotated methods to make use of exception\nhandling internally as long as the exception is not rethrown out of the\nmethod itself.\n\nnote: Note\nIf the execution of a method may raise MethodErrors and similar exceptions, then\nthe method is not considered as :nothrow.\nHowever, note that environment-dependent errors like StackOverflowError or InterruptException\nare not modeled by this effect and thus a method that may result in StackOverflowError\ndoes not necessarily need to be !:nothrow (although it should usually be !:terminates too).\n\n\n\n:terminates_globally\n\nThe :terminates_globally settings asserts that this method will eventually terminate\n(either normally or abnormally), i.e. does not loop indefinitely.\n\nnote: Note\nThis :terminates_globally assertion covers any other methods called by the annotated method.\n\nnote: Note\nThe compiler will consider this a strong indication that the method will\nterminate relatively quickly and may (if otherwise legal) call this\nmethod at compile time. I.e. it is a bad idea to annotate this setting\non a method that technically, but not practically, terminates.\n\n\n\n:terminates_locally\n\nThe :terminates_locally setting is like :terminates_globally, except that it only\napplies to syntactic control flow within the annotated method. It is thus\na much weaker (and thus safer) assertion that allows for the possibility of\nnon-termination if the method calls some other method that does not terminate.\n\nnote: Note\n:terminates_globally implies :terminates_locally.\n\n\n\n:notaskstate\n\nThe :notaskstate setting asserts that the method does not use or modify the\nlocal task state (task local storage, RNG state, etc.) and may thus be safely\nmoved between tasks without observable results.\n\nnote: Note\nThe implementation of exception handling makes use of state stored in the\ntask object. However, this state is currently not considered to be within\nthe scope of :notaskstate and is tracked separately using the :nothrow\neffect.\n\nnote: Note\nThe :notaskstate assertion concerns the state of the currently running task.\nIf a reference to a Task object is obtained by some other means that\ndoes not consider which task is currently running, the :notaskstate\neffect need not be tainted. This is true, even if said task object happens\nto be === to the currently running task.\n\nnote: Note\nAccess to task state usually also results in the tainting of other effects,\nsuch as :effect_free (if task state is modified) or :consistent (if\ntask state is used in the computation of the result). In particular,\ncode that is not :notaskstate, but is :effect_free and :consistent\nmay still be dead-code-eliminated and thus promoted to :total.\n\n\n\n:inaccessiblememonly\n\nThe :inaccessiblememonly setting asserts that the method does not access or modify\nexternally accessible mutable memory. This means the method can access or modify mutable\nmemory for newly allocated objects that is not accessible by other methods or top-level\nexecution before return from the method, but it can not access or modify any mutable\nglobal state or mutable memory pointed to by its arguments.\n\nnote: Note\nBelow is an incomplete list of examples that invalidate this assumption:a global reference or getglobal call to access a mutable global variable\na global assignment or setglobal! call to perform assignment to a non-constant global variable\nsetfield! call that changes a field of a global mutable variable\n\nnote: Note\nThis :inaccessiblememonly assertion covers any other methods called by the annotated method.\n\n\n\n:noub\n\nThe :noub setting asserts that the method will not execute any undefined behavior\n(for any input). Note that undefined behavior may technically cause the method to violate\nany other effect assertions (such as :consistent or :effect_free) as well, but we do\nnot model this, and they assume the absence of undefined behavior.\n\n\n\n:nortcall\n\nThe :nortcall setting asserts that the method does not call Core.Compiler.return_type,\nand that any other methods this method might call also do not call Core.Compiler.return_type.\n\nnote: Note\nTo be precise, this assertion can be used when a call to Core.Compiler.return_type is\nnot made at runtime; that is, when the result of Core.Compiler.return_type is known\nexactly at compile time and the call is eliminated by the optimizer. However, since\nwhether the result of Core.Compiler.return_type is folded at compile time depends\nheavily on the compiler's implementation, it is generally risky to assert this if\nthe method in question uses Core.Compiler.return_type in any form.\n\n\n\n:foldable\n\nThis setting is a convenient shortcut for the set of effects that the compiler\nrequires to be guaranteed to constant fold a call at compile time. It is\ncurrently equivalent to the following settings:\n\n:consistent\n:effect_free\n:terminates_globally\n:noub\n:nortcall\n\nnote: Note\nThis list in particular does not include :nothrow. The compiler will still\nattempt constant propagation and note any thrown error at compile time. Note\nhowever, that by the :consistent-cy requirements, any such annotated call\nmust consistently throw given the same argument values.\n\nnote: Note\nAn explicit @inbounds annotation inside the function will also disable\nconstant folding and not be overridden by :foldable.\n\n\n\n:removable\n\nThis setting is a convenient shortcut for the set of effects that the compiler\nrequires to be guaranteed to delete a call whose result is unused at compile time.\nIt is currently equivalent to the following settings:\n\n:effect_free\n:nothrow\n:terminates_globally\n\n\n\n:total\n\nThis setting is the maximum possible set of effects. It currently implies\nthe following other settings:\n\n:consistent\n:effect_free\n:nothrow\n:terminates_globally\n:notaskstate\n:inaccessiblememonly\n:noub\n:nortcall\n\nwarning: Warning\n:total is a very strong assertion and will likely gain additional semantics\nin future versions of Julia (e.g. if additional effects are added and included\nin the definition of :total). As a result, it should be used with care.\nWhenever possible, prefer to use the minimum possible set of specific effect\nassertions required for a particular application. In cases where a large\nnumber of effect overrides apply to a set of functions, a custom macro is\nrecommended over the use of :total.\n\n\n\nNegated effects\n\nEffect names may be prefixed by ! to indicate that the effect should be removed\nfrom an earlier meta effect. For example, :total !:nothrow indicates that while\nthe call is generally total, it may however throw.\n\n\n\n\n\n"},{"title":"Base.@deprecate","page":"Essentials","location":"base/base.html#Base.@deprecate","category":"macro","text":"@deprecate old new [export_old=true]\n\nDeprecate method old and specify the replacement call new, defining a new method old\nwith the specified signature in the process.\n\nTo prevent old from being exported, set export_old to false.\n\nSee also Base.depwarn().\n\ncompat: Julia 1.5\nAs of Julia 1.5, functions defined by @deprecate do not print warning when julia\nis run without the --depwarn=yes flag set, as the default value of --depwarn option\nis no.  The warnings are printed from tests run by Pkg.test().\n\nExamples\n\njulia> @deprecate old_export(x) new(x)\nold_export (generic function with 1 method)\n\njulia> @deprecate old_public(x) new(x) false\nold_public (generic function with 1 method)\n\nCalls to @deprecate without explicit type-annotations will define\ndeprecated methods accepting any number of positional and keyword\narguments of type Any.\n\ncompat: Julia 1.9\nKeyword arguments are forwarded when there is no explicit type\nannotation as of Julia 1.9. For older versions, you can manually\nforward positional and keyword arguments by doing @deprecate old(args...; kwargs...) new(args...; kwargs...).\n\nTo restrict deprecation to a specific signature, annotate the\narguments of old. For example,\n\njulia> new(x::Int) = x;\n\njulia> new(x::Float64) = 2x;\n\njulia> @deprecate old(x::Int) new(x);\n\njulia> methods(old)\n# 1 method for generic function \"old\" from Main:\n [1] old(x::Int64)\n     @ deprecated.jl:94\n\nwill define and deprecate a method old(x::Int) that mirrors new(x::Int) but will not\ndefine nor deprecate the method old(x::Float64).\n\n\n\n\n\n"},{"title":"Base.depwarn","page":"Essentials","location":"base/base.html#Base.depwarn","category":"function","text":"Base.depwarn(msg::String, funcsym::Symbol; force=false)\n\nPrint msg as a deprecation warning. The symbol funcsym should be the name\nof the calling function, which is used to ensure that the deprecation warning is\nonly printed the first time for each call place. Set force=true to force the\nwarning to always be shown, even if Julia was started with --depwarn=no (the\ndefault).\n\nSee also @deprecate.\n\nExamples\n\nfunction deprecated_func()\n    Base.depwarn(\"Don't use `deprecated_func()`!\", :deprecated_func)\n\n    1 + 1\nend\n\n\n\n\n\n"},{"title":"Base.Missing","page":"Essentials","location":"base/base.html#Base.Missing","category":"type","text":"Missing\n\nA type with no fields whose singleton instance missing is used\nto represent missing values.\n\nSee also: skipmissing, nonmissingtype, Nothing.\n\n\n\n\n\n"},{"title":"Base.missing","page":"Essentials","location":"base/base.html#Base.missing","category":"constant","text":"missing\n\nThe singleton instance of type Missing representing a missing value.\n\nSee also: NaN, skipmissing, nonmissingtype.\n\n\n\n\n\n"},{"title":"Base.coalesce","page":"Essentials","location":"base/base.html#Base.coalesce","category":"function","text":"coalesce(x...)\n\nReturn the first value in the arguments which is not equal to missing,\nif any. Otherwise return missing.\n\nSee also skipmissing, something, @coalesce.\n\nExamples\n\njulia> coalesce(missing, 1)\n1\n\njulia> coalesce(1, missing)\n1\n\njulia> coalesce(nothing, 1)  # returns `nothing`\n\njulia> coalesce(missing, missing)\nmissing\n\n\n\n\n\n"},{"title":"Base.@coalesce","page":"Essentials","location":"base/base.html#Base.@coalesce","category":"macro","text":"@coalesce(x...)\n\nShort-circuiting version of coalesce.\n\nExamples\n\njulia> f(x) = (println(\"f($x)\"); missing);\n\njulia> a = 1;\n\njulia> a = @coalesce a f(2) f(3) error(\"`a` is still missing\")\n1\n\njulia> b = missing;\n\njulia> b = @coalesce b f(2) f(3) error(\"`b` is still missing\")\nf(2)\nf(3)\nERROR: `b` is still missing\n[...]\n\ncompat: Julia 1.7\nThis macro is available as of Julia 1.7.\n\n\n\n\n\n"},{"title":"Base.ismissing","page":"Essentials","location":"base/base.html#Base.ismissing","category":"function","text":"ismissing(x)\n\nIndicate whether x is missing.\n\nSee also: skipmissing, isnothing, isnan.\n\n\n\n\n\n"},{"title":"Base.skipmissing","page":"Essentials","location":"base/base.html#Base.skipmissing","category":"function","text":"skipmissing(itr)\n\nReturn an iterator over the elements in itr skipping missing values.\nThe returned object can be indexed using indices of itr if the latter is indexable.\nIndices corresponding to missing values are not valid: they are skipped by keys\nand eachindex, and a MissingException is thrown when trying to use them.\n\nUse collect to obtain an Array containing the non-missing values in\nitr. Note that even if itr is a multidimensional array, the result will always\nbe a Vector since it is not possible to remove missings while preserving dimensions\nof the input.\n\nSee also coalesce, ismissing, something.\n\nExamples\n\njulia> x = skipmissing([1, missing, 2])\nskipmissing(Union{Missing, Int64}[1, missing, 2])\n\njulia> sum(x)\n3\n\njulia> x[1]\n1\n\njulia> x[2]\nERROR: MissingException: the value at index (2,) is missing\n[...]\n\njulia> argmax(x)\n3\n\njulia> collect(keys(x))\n2-element Vector{Int64}:\n 1\n 3\n\njulia> collect(skipmissing([1, missing, 2]))\n2-element Vector{Int64}:\n 1\n 2\n\njulia> collect(skipmissing([1 missing; 2 missing]))\n2-element Vector{Int64}:\n 1\n 2\n\n\n\n\n\n"},{"title":"Base.nonmissingtype","page":"Essentials","location":"base/base.html#Base.nonmissingtype","category":"function","text":"nonmissingtype(T::Type)\n\nIf T is a union of types containing Missing, return a new type with\nMissing removed.\n\nExamples\n\njulia> nonmissingtype(Union{Int64,Missing})\nInt64\n\njulia> nonmissingtype(Any)\nAny\n\ncompat: Julia 1.3\nThis function is exported as of Julia 1.3.\n\n\n\n\n\n"},{"title":"Base.run","page":"Essentials","location":"base/base.html#Base.run","category":"function","text":"run(command, args...; wait::Bool = true)\n\nRun a command object, constructed with backticks (see the Running External Programs\nsection in the manual). Throws an error if anything goes wrong, including the process\nexiting with a non-zero status (when wait is true).\n\nThe args... allow you to pass through file descriptors to the command, and are ordered\nlike regular unix file descriptors (eg stdin, stdout, stderr, FD(3), FD(4)...).\n\nIf wait is false, the process runs asynchronously. You can later wait for it\nand check its exit status by calling success on the returned process object. If the\ncommand spawns only a single process, a Process object is returned and the\nexit code can be retrieved via the exitcode field; see wait for more details.\n\nWhen wait is false, the process' I/O streams are directed to devnull.\nWhen wait is true, I/O streams are shared with the parent process.\nUse pipeline to control I/O redirection.\n\nSee also: Cmd.\n\n\n\n\n\n"},{"title":"Base.devnull","page":"Essentials","location":"base/base.html#Base.devnull","category":"constant","text":"devnull\n\nUsed in a stream redirect to discard all data written to it. Essentially equivalent to\n/dev/null on Unix or NUL on Windows. Usage:\n\nrun(pipeline(`cat test.txt`, devnull))\n\n\n\n\n\n"},{"title":"Base.success","page":"Essentials","location":"base/base.html#Base.success","category":"function","text":"success(command)\n\nRun a command object, constructed with backticks (see the Running External Programs\nsection in the manual), and tell whether it was successful (exited with a code of 0).\nAn exception is raised if the process cannot be started.\n\n\n\n\n\n"},{"title":"Base.process_running","page":"Essentials","location":"base/base.html#Base.process_running","category":"function","text":"process_running(p::Process)\n\nDetermine whether a process is currently running.\n\n\n\n\n\n"},{"title":"Base.process_exited","page":"Essentials","location":"base/base.html#Base.process_exited","category":"function","text":"process_exited(p::Process)\n\nDetermine whether a process has exited.\n\n\n\n\n\n"},{"title":"Base.kill","page":"Essentials","location":"base/base.html#Base.kill-Tuple{Base.Process, Integer}","category":"method","text":"kill(p::Process, signum=Base.SIGTERM)\n\nSend a signal to a process. The default is to terminate the process.\nReturns successfully if the process has already exited, but throws an\nerror if killing the process failed for other reasons (e.g. insufficient\npermissions).\n\n\n\n\n\n"},{"title":"Base.Sys.set_process_title","page":"Essentials","location":"base/base.html#Base.Sys.set_process_title","category":"function","text":"Sys.set_process_title(title::AbstractString)\n\nSet the process title. No-op on some operating systems.\n\n\n\n\n\n"},{"title":"Base.Sys.get_process_title","page":"Essentials","location":"base/base.html#Base.Sys.get_process_title","category":"function","text":"Sys.get_process_title()\n\nGet the process title. On some systems, will always return an empty string.\n\n\n\n\n\n"},{"title":"Base.ignorestatus","page":"Essentials","location":"base/base.html#Base.ignorestatus","category":"function","text":"ignorestatus(command)\n\nMark a command object so that running it will not throw an error if the result code is non-zero.\n\n\n\n\n\n"},{"title":"Base.detach","page":"Essentials","location":"base/base.html#Base.detach","category":"function","text":"detach(command)\n\nMark a command object so that it will be run in a new process group, allowing it to outlive the julia process, and not have Ctrl-C interrupts passed to it.\n\n\n\n\n\n"},{"title":"Base.Cmd","page":"Essentials","location":"base/base.html#Base.Cmd","category":"type","text":"Cmd(cmd::Cmd; ignorestatus, detach, windows_verbatim, windows_hide, env, dir, uid, gid)\nCmd(exec::Vector{String})\n\nConstruct a new Cmd object, representing an external program and arguments, from cmd,\nwhile changing the settings of the optional keyword arguments:\n\nignorestatus::Bool: If true (defaults to false), then the Cmd will not throw an\nerror if the return code is nonzero.\ndetach::Bool: If true (defaults to false), then the Cmd will be run in a new\nprocess group, allowing it to outlive the julia process and not have Ctrl-C passed to\nit.\nwindows_verbatim::Bool: If true (defaults to false), then on Windows the Cmd will\nsend a command-line string to the process with no quoting or escaping of arguments, even\narguments containing spaces. (On Windows, arguments are sent to a program as a single\n\"command-line\" string, and programs are responsible for parsing it into arguments. By\ndefault, empty arguments and arguments with spaces or tabs are quoted with double quotes\n\" in the command line, and \\ or \" are preceded by backslashes.\nwindows_verbatim=true is useful for launching programs that parse their command line in\nnonstandard ways.) Has no effect on non-Windows systems.\nwindows_hide::Bool: If true (defaults to false), then on Windows no new console\nwindow is displayed when the Cmd is executed. This has no effect if a console is\nalready open or on non-Windows systems.\nenv: Set environment variables to use when running the Cmd. env is either a\ndictionary mapping strings to strings, an array of strings of the form \"var=val\", an\narray or tuple of \"var\"=>val pairs. In order to modify (rather than replace) the\nexisting environment, initialize env with copy(ENV) and then set env[\"var\"]=val as\ndesired.  To add to an environment block within a Cmd object without replacing all\nelements, use addenv() which will return a Cmd object with the updated environment.\ndir::AbstractString: Specify a working directory for the command (instead\nof the current directory).\nuid::Union{Nothing,UInt32}: Set the user ID for the process (Unix only).\ngid::Union{Nothing,UInt32}: Set the group ID for the process (Unix only).\n\nFor any keywords that are not specified, the current settings from cmd are used.\n\nNote that the Cmd(exec) constructor does not create a copy of exec. Any subsequent changes to exec will be reflected in the Cmd object.\n\nThe most common way to construct a Cmd object is with command literals (backticks), e.g.\n\n`ls -l`\n\nThis can then be passed to the Cmd constructor to modify its settings, e.g.\n\nCmd(`echo \"Hello world\"`, ignorestatus=true, detach=false)\n\n\n\n\n\n"},{"title":"Base.setenv","page":"Essentials","location":"base/base.html#Base.setenv","category":"function","text":"setenv(command::Cmd, env; dir)\n\nSet environment variables to use when running the given command. env is either a\ndictionary mapping strings to strings, an array of strings of the form \"var=val\", or\nzero or more \"var\"=>val pair arguments. In order to modify (rather than replace) the\nexisting environment, create env through copy(ENV) and then setting env[\"var\"]=val\nas desired, or use addenv.\n\nThe dir keyword argument can be used to specify a working directory for the command.\ndir defaults to the currently set dir for command (which is the current working\ndirectory if not specified already).\n\nSee also Cmd, addenv, ENV, pwd.\n\n\n\n\n\n"},{"title":"Base.addenv","page":"Essentials","location":"base/base.html#Base.addenv","category":"function","text":"addenv(command::Cmd, env...; inherit::Bool = true)\n\nMerge new environment mappings into the given Cmd object, returning a new Cmd object.\nDuplicate keys are replaced.  If command does not contain any environment values set already,\nit inherits the current environment at time of addenv() call if inherit is true.\nKeys with value nothing are deleted from the env.\n\nSee also Cmd, setenv, ENV.\n\ncompat: Julia 1.6\nThis function requires Julia 1.6 or later.\n\n\n\n\n\n"},{"title":"Base.withenv","page":"Essentials","location":"base/base.html#Base.withenv","category":"function","text":"withenv(f, kv::Pair...)\n\nExecute f in an environment that is temporarily modified (not replaced as in setenv)\nby zero or more \"var\"=>val arguments kv. withenv is generally used via the\nwithenv(kv...) do ... end syntax. A value of nothing can be used to temporarily unset an\nenvironment variable (if it is set). When withenv returns, the original environment has\nbeen restored.\n\nwarning: Warning\nChanging the environment is not thread-safe. For running external commands with a different\nenvironment from the parent process, prefer using addenv over withenv.\n\n\n\n\n\n"},{"title":"Base.shell_escape","page":"Essentials","location":"base/base.html#Base.shell_escape","category":"function","text":"shell_escape(args::Union{Cmd,AbstractString...}; special::AbstractString=\"\")\n\nThe unexported shell_escape function is the inverse of the unexported Base.shell_split() function:\nit takes a string or command object and escapes any special characters in such a way that calling\nBase.shell_split() on it would give back the array of words in the original command. The special\nkeyword argument controls what characters in addition to whitespace, backslashes, quotes and\ndollar signs are considered to be special (default: none).\n\nExamples\n\njulia> Base.shell_escape(\"cat\", \"/foo/bar baz\", \"&&\", \"echo\", \"done\")\n\"cat '/foo/bar baz' && echo done\"\n\njulia> Base.shell_escape(\"echo\", \"this\", \"&&\", \"that\")\n\"echo this && that\"\n\n\n\n\n\n"},{"title":"Base.shell_split","page":"Essentials","location":"base/base.html#Base.shell_split","category":"function","text":"shell_split(command::AbstractString)\n\nSplit a shell command string into its individual components.\n\nExamples\n\njulia> Base.shell_split(\"git commit -m 'Initial commit'\")\n4-element Vector{String}:\n \"git\"\n \"commit\"\n \"-m\"\n \"Initial commit\"\n\n\n\n\n\n"},{"title":"Base.shell_escape_posixly","page":"Essentials","location":"base/base.html#Base.shell_escape_posixly","category":"function","text":"shell_escape_posixly(args::Union{Cmd,AbstractString...})\n\nThe unexported shell_escape_posixly function\ntakes a string or command object and escapes any special characters in such a way that\nit is safe to pass it as an argument to a posix shell.\n\nSee also: Base.shell_escape()\n\nExamples\n\njulia> Base.shell_escape_posixly(\"cat\", \"/foo/bar baz\", \"&&\", \"echo\", \"done\")\n\"cat '/foo/bar baz' '&&' echo done\"\n\njulia> Base.shell_escape_posixly(\"echo\", \"this\", \"&&\", \"that\")\n\"echo this '&&' that\"\n\n\n\n\n\n"},{"title":"Base.shell_escape_csh","page":"Essentials","location":"base/base.html#Base.shell_escape_csh","category":"function","text":"shell_escape_csh(args::Union{Cmd,AbstractString...})\nshell_escape_csh(io::IO, args::Union{Cmd,AbstractString...})\n\nThis function quotes any metacharacters in the string arguments such\nthat the string returned can be inserted into a command-line for\ninterpretation by the Unix C shell (csh, tcsh), where each string\nargument will form one word.\n\nIn contrast to a POSIX shell, csh does not support the use of the\nbackslash as a general escape character in double-quoted strings.\nTherefore, this function wraps strings that might contain\nmetacharacters in single quotes, except for parts that contain single\nquotes, which it wraps in double quotes instead. It switches between\nthese types of quotes as needed. Linefeed characters are escaped with\na backslash.\n\nThis function should also work for a POSIX shell, except if the input\nstring contains a linefeed (\"\\n\") character.\n\nSee also: Base.shell_escape_posixly()\n\n\n\n\n\n"},{"title":"Base.shell_escape_wincmd","page":"Essentials","location":"base/base.html#Base.shell_escape_wincmd","category":"function","text":"shell_escape_wincmd(s::AbstractString)\nshell_escape_wincmd(io::IO, s::AbstractString)\n\nThe unexported shell_escape_wincmd function escapes Windows cmd.exe shell\nmeta characters. It escapes ()!^<>&| by placing a ^ in front. An @ is\nonly escaped at the start of the string. Pairs of \" characters and the\nstrings they enclose are passed through unescaped. Any remaining \" is escaped\nwith ^ to ensure that the number of unescaped \" characters in the result\nremains even.\n\nSince cmd.exe substitutes variable references (like %USER%) before\nprocessing the escape characters ^ and \", this function makes no attempt to\nescape the percent sign (%), the presence of % in the input may cause\nsevere breakage, depending on where the result is used.\n\nInput strings with ASCII control characters that cannot be escaped (NUL, CR,\nLF) will cause an ArgumentError exception.\n\nThe result is safe to pass as an argument to a command call being processed by\nCMD.exe /S /C \" ... \" (with surrounding double-quote pair) and will be\nreceived verbatim by the target application if the input does not contain %\n(else this function will fail with an ArgumentError). The presence of % in\nthe input string may result in command injection vulnerabilities and may\ninvalidate any claim of suitability of the output of this function for use as\nan argument to cmd (due to the ordering described above), so use caution when\nassembling a string from various sources.\n\nThis function may be useful in concert with the windows_verbatim flag to\nCmd when constructing process pipelines.\n\nwincmd(c::String) =\n   run(Cmd(Cmd([\"cmd.exe\", \"/s /c \\\" $c \\\"\"]);\n           windows_verbatim=true))\nwincmd_echo(s::String) =\n   wincmd(\"echo \" * Base.shell_escape_wincmd(s))\nwincmd_echo(\"hello $(ENV[\"USERNAME\"]) & the \\\"whole\\\" world! (=^I^=)\")\n\nBut take note that if the input string s contains a %, the argument list\nand echo'ed text may get corrupted, resulting in arbitrary command execution.\nThe argument can alternatively be passed as an environment variable, which\navoids the problem with % and the need for the windows_verbatim flag:\n\ncmdargs = Base.shell_escape_wincmd(\"Passing args with %cmdargs% works 100%!\")\nrun(setenv(`cmd /C echo %cmdargs%`, \"cmdargs\" => cmdargs))\n\nwarning: Warning\nThe argument parsing done by CMD when calling batch files (either inside\n.bat files or as arguments to them) is not fully compatible with the\noutput of this function. In particular, the processing of % is different.\n\nimportant: Important\nDue to a peculiar behavior of the CMD parser/interpreter, each command\nafter a literal | character (indicating a command pipeline) must have\nshell_escape_wincmd applied twice since it will be parsed twice by CMD.\nThis implies ENV variables would also be expanded twice!\nFor example:to_print = \"All for 1 & 1 for all!\"\nto_print_esc = Base.shell_escape_wincmd(Base.shell_escape_wincmd(to_print))\nrun(Cmd(Cmd([\"cmd\", \"/S /C \\\" break | echo $(to_print_esc) \\\"\"]), windows_verbatim=true))\n\nWith an I/O stream parameter io, the result will be written there,\nrather than returned as a string.\n\nSee also Base.escape_microsoft_c_args(), Base.shell_escape_posixly().\n\nExamples\n\njulia> Base.shell_escape_wincmd(\"a^\\\"^o\\\"^u\\\"\")\n\"a^^\\\"^o\\\"^^u^\\\"\"\n\n\n\n\n\n"},{"title":"Base.escape_microsoft_c_args","page":"Essentials","location":"base/base.html#Base.escape_microsoft_c_args","category":"function","text":"escape_microsoft_c_args(args::Union{Cmd,AbstractString...})\nescape_microsoft_c_args(io::IO, args::Union{Cmd,AbstractString...})\n\nConvert a collection of string arguments into a string that can be\npassed to many Windows command-line applications.\n\nMicrosoft Windows passes the entire command line as a single string to\nthe application (unlike POSIX systems, where the shell splits the\ncommand line into a list of arguments). Many Windows API applications\n(including julia.exe), use the conventions of the [Microsoft C/C++\nruntime](https://docs.microsoft.com/en-us/cpp/c-language/parsing-c-command-line-arguments)\nto split that command line into a list of strings.\n\nThis function implements an inverse for a parser compatible with these rules.\nIt joins command-line arguments to be passed to a Windows\nC/C++/Julia application into a command line, escaping or quoting the\nmeta characters space, TAB, double quote and backslash where needed.\n\nSee also Base.shell_escape_wincmd(), Base.escape_raw_string().\n\n\n\n\n\n"},{"title":"Base.setcpuaffinity","page":"Essentials","location":"base/base.html#Base.setcpuaffinity","category":"function","text":"setcpuaffinity(original_command::Cmd, cpus) -> command::Cmd\n\nSet the CPU affinity of the command by a list of CPU IDs (1-based) cpus.  Passing\ncpus = nothing means to unset the CPU affinity if the original_command has any.\n\nThis function is supported only in Linux and Windows.  It is not supported in macOS because\nlibuv does not support affinity setting.\n\ncompat: Julia 1.8\nThis function requires at least Julia 1.8.\n\nExamples\n\nIn Linux, the taskset command line program can be used to see how setcpuaffinity works.\n\njulia> run(setcpuaffinity(`sh -c 'taskset -p $$'`, [1, 2, 5]));\npid 2273's current affinity mask: 13\n\nNote that the mask value 13 reflects that the first, second, and the fifth bits (counting\nfrom the least significant position) are turned on:\n\njulia> 0b010011\n0x13\n\n\n\n\n\n"},{"title":"Base.pipeline","page":"Essentials","location":"base/base.html#Base.pipeline-Tuple{Any, Any, Any, Vararg{Any}}","category":"method","text":"pipeline(from, to, ...)\n\nCreate a pipeline from a data source to a destination. The source and destination can be\ncommands, I/O streams, strings, or results of other pipeline calls. At least one argument\nmust be a command. Strings refer to filenames. When called with more than two arguments,\nthey are chained together from left to right. For example, pipeline(a,b,c) is equivalent to\npipeline(pipeline(a,b),c). This provides a more concise way to specify multi-stage\npipelines.\n\nExamples:\n\nrun(pipeline(`ls`, `grep xyz`))\nrun(pipeline(`ls`, \"out.txt\"))\nrun(pipeline(\"out.txt\", `grep xyz`))\n\n\n\n\n\n"},{"title":"Base.pipeline","page":"Essentials","location":"base/base.html#Base.pipeline-Tuple{Base.AbstractCmd}","category":"method","text":"pipeline(command; stdin, stdout, stderr, append=false)\n\nRedirect I/O to or from the given command. Keyword arguments specify which of the\ncommand's streams should be redirected. append controls whether file output appends to the\nfile. This is a more general version of the 2-argument pipeline function.\npipeline(from, to) is equivalent to pipeline(from, stdout=to) when from is a command,\nand to pipeline(to, stdin=from) when from is another kind of data source.\n\nExamples:\n\nrun(pipeline(`dothings`, stdout=\"out.txt\", stderr=\"errs.txt\"))\nrun(pipeline(`update`, stdout=\"log.txt\", append=true))\n\n\n\n\n\n"},{"title":"Base.Libc.gethostname","page":"Essentials","location":"base/base.html#Base.Libc.gethostname","category":"function","text":"gethostname()::String\n\nGet the local machine's host name.\n\n\n\n\n\n"},{"title":"Base.Libc.getpid","page":"Essentials","location":"base/base.html#Base.Libc.getpid","category":"function","text":"getpid()::Int32\n\nGet Julia's process ID.\n\n\n\n\n\ngetpid(process)::Int32\n\nGet the child process ID, if it still exists.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\n\n\n\n\n"},{"title":"Base.Libc.time","page":"Essentials","location":"base/base.html#Base.Libc.time-Tuple{}","category":"method","text":"time()::Float64\n\nGet the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.\n\nSee also time_ns.\n\n\n\n\n\n"},{"title":"Base.time_ns","page":"Essentials","location":"base/base.html#Base.time_ns","category":"function","text":"time_ns()::UInt64\n\nGet the time in nanoseconds relative to some machine-specific arbitrary time in the past.\nThe primary use is for measuring elapsed times during program execution. The return value is guaranteed to\nbe monotonic (mod 2⁶⁴) while the system is running, and is unaffected by clock drift or changes to local calendar time,\nbut it may change arbitrarily across system reboots or suspensions.\n\n(Although the returned time is always in nanoseconds, the timing resolution is platform-dependent.)\n\n\n\n\n\n"},{"title":"Base.@time","page":"Essentials","location":"base/base.html#Base.@time","category":"macro","text":"@time expr\n@time \"description\" expr\n\nA macro to execute an expression, printing the time it took to execute, the number of\nallocations, and the total number of bytes its execution caused to be allocated, before\nreturning the value of the expression. Any time spent garbage collecting (gc), compiling\nnew code, or recompiling invalidated code is shown as a percentage. Any lock conflicts\nwhere a ReentrantLock had to wait are shown as a count.\n\nOptionally provide a description string to print before the time report.\n\nIn some cases the system will look inside the @time expression and compile some of the\ncalled code before execution of the top-level expression begins. When that happens, some\ncompilation time will not be counted. To include this time you can run @time @eval ....\n\nSee also @showtime, @timev, @timed, @elapsed,\n@allocated, and @allocations.\n\nnote: Note\nFor more serious benchmarking, consider the @btime macro from the BenchmarkTools.jl\npackage which among other things evaluates the function multiple times in order to\nreduce noise.\n\ncompat: Julia 1.8\nThe option to add a description was introduced in Julia 1.8.Recompilation time being shown separately from compilation time was introduced in Julia 1.8\n\ncompat: Julia 1.11\nThe reporting of any lock conflicts was added in Julia 1.11.\n\njulia> x = rand(10,10);\n\njulia> @time x * x;\n  0.606588 seconds (2.19 M allocations: 116.555 MiB, 3.75% gc time, 99.94% compilation time)\n\njulia> @time x * x;\n  0.000009 seconds (1 allocation: 896 bytes)\n\njulia> @time begin\n           sleep(0.3)\n           1+1\n       end\n  0.301395 seconds (8 allocations: 336 bytes)\n2\n\njulia> @time \"A one second sleep\" sleep(1)\nA one second sleep: 1.005750 seconds (5 allocations: 144 bytes)\n\njulia> for loop in 1:3\n            @time loop sleep(1)\n        end\n1: 1.006760 seconds (5 allocations: 144 bytes)\n2: 1.001263 seconds (5 allocations: 144 bytes)\n3: 1.003676 seconds (5 allocations: 144 bytes)\n\n\n\n\n\n"},{"title":"Base.@showtime","page":"Essentials","location":"base/base.html#Base.@showtime","category":"macro","text":"@showtime expr\n\nLike @time but also prints the expression being evaluated for reference.\n\ncompat: Julia 1.8\nThis macro was added in Julia 1.8.\n\nSee also @time.\n\njulia> @showtime sleep(1)\nsleep(1): 1.002164 seconds (4 allocations: 128 bytes)\n\n\n\n\n\n"},{"title":"Base.@timev","page":"Essentials","location":"base/base.html#Base.@timev","category":"macro","text":"@timev expr\n@timev \"description\" expr\n\nThis is a verbose version of the @time macro. It first prints the same information as\n@time, then any non-zero memory allocation counters, and then returns the value of the\nexpression.\n\nOptionally provide a description string to print before the time report.\n\ncompat: Julia 1.8\nThe option to add a description was introduced in Julia 1.8.\n\nSee also @time, @timed, @elapsed,\n@allocated, and @allocations.\n\njulia> x = rand(10,10);\n\njulia> @timev x * x;\n  0.546770 seconds (2.20 M allocations: 116.632 MiB, 4.23% gc time, 99.94% compilation time)\nelapsed time (ns): 546769547\ngc time (ns):      23115606\nbytes allocated:   122297811\npool allocs:       2197930\nnon-pool GC allocs:1327\nmalloc() calls:    36\nrealloc() calls:   5\nGC pauses:         3\n\njulia> @timev x * x;\n  0.000010 seconds (1 allocation: 896 bytes)\nelapsed time (ns): 9848\nbytes allocated:   896\npool allocs:       1\n\n\n\n\n\n"},{"title":"Base.@timed","page":"Essentials","location":"base/base.html#Base.@timed","category":"macro","text":"@timed\n\nA macro to execute an expression, and return the value of the expression, elapsed time in seconds,\ntotal bytes allocated, garbage collection time, an object with various memory allocation\ncounters, compilation time in seconds, and recompilation time in seconds. Any lock conflicts\nwhere a ReentrantLock had to wait are shown as a count.\n\nIn some cases the system will look inside the @timed expression and compile some of the\ncalled code before execution of the top-level expression begins. When that happens, some\ncompilation time will not be counted. To include this time you can run @timed @eval ....\n\nSee also @time, @timev, @elapsed,\n@allocated, @allocations, and @lock_conflicts.\n\njulia> stats = @timed rand(10^6);\n\njulia> stats.time\n0.006634834\n\njulia> stats.bytes\n8000256\n\njulia> stats.gctime\n0.0055765\n\njulia> propertynames(stats.gcstats)\n(:allocd, :malloc, :realloc, :poolalloc, :bigalloc, :freecall, :total_time, :pause, :full_sweep)\n\njulia> stats.gcstats.total_time\n5576500\n\njulia> stats.compile_time\n0.0\n\njulia> stats.recompile_time\n0.0\n\n\ncompat: Julia 1.5\nThe return type of this macro was changed from Tuple to NamedTuple in Julia 1.5.\n\ncompat: Julia 1.11\nThe lock_conflicts, compile_time, and recompile_time fields were added in Julia 1.11.\n\n\n\n\n\n"},{"title":"Base.@elapsed","page":"Essentials","location":"base/base.html#Base.@elapsed","category":"macro","text":"@elapsed\n\nA macro to evaluate an expression, discarding the resulting value, instead returning the\nnumber of seconds it took to execute as a floating-point number.\n\nIn some cases the system will look inside the @elapsed expression and compile some of the\ncalled code before execution of the top-level expression begins. When that happens, some\ncompilation time will not be counted. To include this time you can run @elapsed @eval ....\n\nSee also @time, @timev, @timed,\n@allocated, and @allocations.\n\njulia> @elapsed sleep(0.3)\n0.301391426\n\n\n\n\n\n"},{"title":"Base.@allocated","page":"Essentials","location":"base/base.html#Base.@allocated","category":"macro","text":"@allocated\n\nA macro to evaluate an expression, discarding the resulting value, instead returning the\ntotal number of bytes allocated during evaluation of the expression.\n\nIf the expression is a function call, an effort is made to measure only allocations from\nthe argument expressions and during the function, excluding any overhead from calling it\nand not performing constant propagation with the provided argument values. If you want to\ninclude those effects, i.e. measuring the call site as well, use the syntax\n@allocated (()->f(1))().\n\nIt is recommended to measure function calls with only simple argument expressions, e.g.\nx = []; @allocated f(x) instead of @allocated f([]) to clarify that only f is\nbeing measured.\n\nFor more complex expressions, the code is simply run in place and therefore may see\nallocations due to the surrounding context. For example it is possible for\n@allocated f(1) and @allocated x = f(1) to give different results.\n\nSee also @allocations, @time, @timev, @timed,\nand @elapsed.\n\njulia> @allocated rand(10^6)\n8000080\n\n\n\n\n\n"},{"title":"Base.@allocations","page":"Essentials","location":"base/base.html#Base.@allocations","category":"macro","text":"@allocations\n\nA macro to evaluate an expression, discard the resulting value, and instead return the\ntotal number of allocations during evaluation of the expression.\n\nSee also @allocated, @time, @timev, @timed,\nand @elapsed.\n\njulia> @allocations rand(10^6)\n2\n\ncompat: Julia 1.9\nThis macro was added in Julia 1.9.\n\n\n\n\n\n"},{"title":"Base.@lock_conflicts","page":"Essentials","location":"base/base.html#Base.@lock_conflicts","category":"macro","text":"@lock_conflicts\n\nA macro to evaluate an expression, discard the resulting value, and instead return the\ntotal number of lock conflicts during evaluation, where a lock attempt on a ReentrantLock\nresulted in a wait because the lock was already held.\n\nSee also @time, @timev and @timed.\n\njulia> @lock_conflicts begin\n    l = ReentrantLock()\n    Threads.@threads for i in 1:Threads.nthreads()\n        lock(l) do\n        sleep(1)\n        end\n    end\nend\n5\n\ncompat: Julia 1.11\nThis macro was added in Julia 1.11.\n\n\n\n\n\n"},{"title":"Base.TRACE_EVAL","page":"Essentials","location":"base/base.html#Base.TRACE_EVAL","category":"constant","text":"Base.TRACE_EVAL\n\nGlobal control for expression tracing during top-level evaluation. This setting takes priority\nover the --trace-eval command-line option.\n\nSet to:\n\nnothing - use the command-line --trace-eval setting (default)\n:no - disable expression tracing\n:loc - show only location information during evaluation\n:full - show full expressions being evaluated\n\nExamples\n\n# Enable full expression tracing\nBase.TRACE_EVAL = :full\n\n# Show only locations\nBase.TRACE_EVAL = :loc\n\n# Disable tracing (overrides command-line setting)\nBase.TRACE_EVAL = :no\n\n# Reset to use command-line setting\nBase.TRACE_EVAL = nothing\n\nSee also: Command-line Interface for the --trace-eval option.\n\n\n\n\n\n"},{"title":"Base.EnvDict","page":"Essentials","location":"base/base.html#Base.EnvDict","category":"type","text":"EnvDict()::EnvDict\n\nA singleton of this type provides a hash table interface to environment variables.\n\n\n\n\n\n"},{"title":"Base.ENV","page":"Essentials","location":"base/base.html#Base.ENV","category":"constant","text":"ENV\n\nReference to the singleton EnvDict, providing a dictionary interface to system environment\nvariables.\n\n(On Windows, system environment variables are case-insensitive, and ENV correspondingly converts\nall keys to uppercase for display, iteration, and copying. Portable code should not rely on the\nability to distinguish variables by case, and should beware that setting an ostensibly lowercase\nvariable may result in an uppercase ENV key.)\n\nwarning: Warning\nMutating the environment is not thread-safe.\n\nExamples\n\njulia> ENV\nBase.EnvDict with \"50\" entries:\n  \"SECURITYSESSIONID\"            => \"123\"\n  \"USER\"                         => \"username\"\n  \"MallocNanoZone\"               => \"0\"\n  ⋮                              => ⋮\n\njulia> ENV[\"JULIA_EDITOR\"] = \"vim\"\n\"vim\"\n\njulia> ENV[\"JULIA_EDITOR\"]\n\"vim\"\n\nSee also: withenv, addenv.\n\n\n\n\n\n"},{"title":"Base.Sys.STDLIB","page":"Essentials","location":"base/base.html#Base.Sys.STDLIB","category":"constant","text":"Sys.STDLIB::String\n\nA string containing the full path to the directory containing the stdlib packages.\n\n\n\n\n\n"},{"title":"Base.Sys.isunix","page":"Essentials","location":"base/base.html#Base.Sys.isunix","category":"function","text":"Sys.isunix([os])\n\nPredicate for testing if the OS provides a Unix-like interface.\nSee documentation in Handling Operating System Variation.\n\n\n\n\n\n"},{"title":"Base.Sys.isapple","page":"Essentials","location":"base/base.html#Base.Sys.isapple","category":"function","text":"Sys.isapple([os])\n\nPredicate for testing if the OS is a derivative of Apple Macintosh OS X or Darwin.\nSee documentation in Handling Operating System Variation.\n\n\n\n\n\n"},{"title":"Base.Sys.islinux","page":"Essentials","location":"base/base.html#Base.Sys.islinux","category":"function","text":"Sys.islinux([os])\n\nPredicate for testing if the OS is a derivative of Linux.\nSee documentation in Handling Operating System Variation.\n\n\n\n\n\n"},{"title":"Base.Sys.isbsd","page":"Essentials","location":"base/base.html#Base.Sys.isbsd","category":"function","text":"Sys.isbsd([os])\n\nPredicate for testing if the OS is a derivative of BSD.\nSee documentation in Handling Operating System Variation.\n\nnote: Note\nThe Darwin kernel descends from BSD, which means that Sys.isbsd() is\ntrue on macOS systems. To exclude macOS from a predicate, use\nSys.isbsd() && !Sys.isapple().\n\n\n\n\n\n"},{"title":"Base.Sys.isfreebsd","page":"Essentials","location":"base/base.html#Base.Sys.isfreebsd","category":"function","text":"Sys.isfreebsd([os])\n\nPredicate for testing if the OS is a derivative of FreeBSD.\nSee documentation in Handling Operating System Variation.\n\nnote: Note\nNot to be confused with Sys.isbsd(), which is true on FreeBSD but also on\nother BSD-based systems. Sys.isfreebsd() refers only to FreeBSD.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\n\n\n\n\n"},{"title":"Base.Sys.isopenbsd","page":"Essentials","location":"base/base.html#Base.Sys.isopenbsd","category":"function","text":"Sys.isopenbsd([os])\n\nPredicate for testing if the OS is a derivative of OpenBSD.\nSee documentation in Handling Operating System Variation.\n\nnote: Note\nNot to be confused with Sys.isbsd(), which is true on OpenBSD but also on\nother BSD-based systems. Sys.isopenbsd() refers only to OpenBSD.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\n\n\n\n\n"},{"title":"Base.Sys.isnetbsd","page":"Essentials","location":"base/base.html#Base.Sys.isnetbsd","category":"function","text":"Sys.isnetbsd([os])\n\nPredicate for testing if the OS is a derivative of NetBSD.\nSee documentation in Handling Operating System Variation.\n\nnote: Note\nNot to be confused with Sys.isbsd(), which is true on NetBSD but also on\nother BSD-based systems. Sys.isnetbsd() refers only to NetBSD.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\n\n\n\n\n"},{"title":"Base.Sys.isdragonfly","page":"Essentials","location":"base/base.html#Base.Sys.isdragonfly","category":"function","text":"Sys.isdragonfly([os])\n\nPredicate for testing if the OS is a derivative of DragonFly BSD.\nSee documentation in Handling Operating System Variation.\n\nnote: Note\nNot to be confused with Sys.isbsd(), which is true on DragonFly but also on\nother BSD-based systems. Sys.isdragonfly() refers only to DragonFly.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\n\n\n\n\n"},{"title":"Base.Sys.iswindows","page":"Essentials","location":"base/base.html#Base.Sys.iswindows","category":"function","text":"Sys.iswindows([os])\n\nPredicate for testing if the OS is a derivative of Microsoft Windows NT.\nSee documentation in Handling Operating System Variation.\n\n\n\n\n\n"},{"title":"Base.Sys.windows_version","page":"Essentials","location":"base/base.html#Base.Sys.windows_version","category":"function","text":"Sys.windows_version()\n\nReturn the version number for the Windows NT Kernel as a VersionNumber,\ni.e. v\"major.minor.build\", or v\"0.0.0\" if this is not running on Windows.\n\n\n\n\n\n"},{"title":"Base.Sys.free_memory","page":"Essentials","location":"base/base.html#Base.Sys.free_memory","category":"function","text":"Sys.free_memory()\n\nGet the total free memory in RAM in bytes.\n\n\n\n\n\n"},{"title":"Base.Sys.total_memory","page":"Essentials","location":"base/base.html#Base.Sys.total_memory","category":"function","text":"Sys.total_memory()\n\nGet the total memory in RAM (including that which is currently used) in bytes.\nThis amount may be constrained, e.g., by Linux control groups. For the unconstrained\namount, see Sys.total_physical_memory().\n\n\n\n\n\n"},{"title":"Base.Sys.free_physical_memory","page":"Essentials","location":"base/base.html#Base.Sys.free_physical_memory","category":"function","text":"Sys.free_physical_memory()\n\nGet the free memory of the system in bytes. The entire amount may not be available to the\ncurrent process; use Sys.free_memory() for the actually available amount.\n\n\n\n\n\n"},{"title":"Base.Sys.total_physical_memory","page":"Essentials","location":"base/base.html#Base.Sys.total_physical_memory","category":"function","text":"Sys.total_physical_memory()\n\nGet the total memory in RAM (including that which is currently used) in bytes. The entire\namount may not be available to the current process; see Sys.total_memory().\n\n\n\n\n\n"},{"title":"Base.Sys.uptime","page":"Essentials","location":"base/base.html#Base.Sys.uptime","category":"function","text":"Sys.uptime()\n\nGet the current system uptime in seconds.\n\n\n\n\n\n"},{"title":"Base.Sys.sysimage_target","page":"Essentials","location":"base/base.html#Base.Sys.sysimage_target","category":"function","text":"Sys.sysimage_target()\n\nReturn the CPU target string that was used to build the current system image.\n\nThis function returns the original CPU target specification that was passed to Julia\nwhen the system image was compiled. This can be useful for reproducing the same\nsystem image or for understanding what CPU features were enabled during compilation.\n\nIf the system image was built with the default settings this will return \"native\".\n\nSee also JULIA_CPU_TARGET.\n\n\n\n\n\n"},{"title":"Base.Sys.isjsvm","page":"Essentials","location":"base/base.html#Base.Sys.isjsvm","category":"function","text":"Sys.isjsvm([os])\n\nPredicate for testing if Julia is running in a JavaScript VM (JSVM),\nincluding e.g. a WebAssembly JavaScript embedding in a web browser.\n\ncompat: Julia 1.2\nThis function requires at least Julia 1.2.\n\n\n\n\n\n"},{"title":"Base.Sys.loadavg","page":"Essentials","location":"base/base.html#Base.Sys.loadavg","category":"function","text":"Sys.loadavg()\n\nGet the load average. See: https://en.wikipedia.org/wiki/Load_(computing).\n\n\n\n\n\n"},{"title":"Base.Sys.isexecutable","page":"Essentials","location":"base/base.html#Base.Sys.isexecutable","category":"function","text":"isexecutable(path::String)\n\nReturn true if the given path has executable permissions.\n\nnote: Note\nThis permission may change before the user executes path,\nso it is recommended to execute the file and handle the error if that fails,\nrather than calling isexecutable first.\n\nnote: Note\nPrior to Julia 1.6, this did not correctly interrogate filesystem\nACLs on Windows, therefore it would return true for any\nfile.  From Julia 1.6 on, it correctly determines whether the\nfile is marked as executable or not.\n\nSee also ispath, isreadable, iswritable.\n\n\n\n\n\n"},{"title":"Base.Sys.isreadable","page":"Essentials","location":"base/base.html#Base.Sys.isreadable","category":"function","text":"isreadable(io)::Bool\n\nReturn false if the specified IO object is not readable.\n\nExamples\n\njulia> open(\"myfile.txt\", \"w\") do io\n           print(io, \"Hello world!\");\n           isreadable(io)\n       end\nfalse\n\njulia> open(\"myfile.txt\", \"r\") do io\n           isreadable(io)\n       end\ntrue\n\njulia> rm(\"myfile.txt\")\n\n\n\n\n\nisreadable(path::String)\n\nReturn true if the access permissions for the given path permitted reading by the current user.\n\nnote: Note\nThis permission may change before the user calls open,\nso it is recommended to just call open alone and handle the error if that fails,\nrather than calling isreadable first.\n\nnote: Note\nCurrently this function does not correctly interrogate filesystem\nACLs on Windows, therefore it can return wrong results.\n\ncompat: Julia 1.11\nThis function requires at least Julia 1.11.\n\nSee also ispath, isexecutable, iswritable.\n\n\n\n\n\n"},{"title":"Base.Sys.iswritable","page":"Essentials","location":"base/base.html#Base.Sys.iswritable","category":"function","text":"iswritable(io)::Bool\n\nReturn false if the specified IO object is not writable.\n\nExamples\n\njulia> open(\"myfile.txt\", \"w\") do io\n           print(io, \"Hello world!\");\n           iswritable(io)\n       end\ntrue\n\njulia> open(\"myfile.txt\", \"r\") do io\n           iswritable(io)\n       end\nfalse\n\njulia> rm(\"myfile.txt\")\n\n\n\n\n\niswritable(path::String)\n\nReturn true if the access permissions for the given path permitted writing by the current user.\n\nnote: Note\nThis permission may change before the user calls open,\nso it is recommended to just call open alone and handle the error if that fails,\nrather than calling iswritable first.\n\nnote: Note\nCurrently this function does not correctly interrogate filesystem\nACLs on Windows, therefore it can return wrong results.\n\ncompat: Julia 1.11\nThis function requires at least Julia 1.11.\n\nSee also ispath, isexecutable, isreadable.\n\n\n\n\n\n"},{"title":"Base.Sys.which","page":"Essentials","location":"base/base.html#Base.Sys.which","category":"function","text":"Sys.which(program_name::String)\n\nGiven a program name, search the current PATH to find the first binary with\nthe proper executable permissions that can be run and return an absolute path\nto it, or return nothing if no such program is available. If a path with\na directory in it is passed in for program_name, tests that exact path\nfor executable permissions only (with .exe and .com extensions added on\nWindows platforms); no searching of PATH is performed.\n\n\n\n\n\n"},{"title":"Base.Sys.username","page":"Essentials","location":"base/base.html#Base.Sys.username","category":"function","text":"Sys.username()::String\n\nReturn the username for the current user. If the username cannot be determined\nor is empty, this function throws an error.\n\nTo retrieve a username that is overridable via an environment variable,\ne.g., USER, consider using\n\nuser = get(Sys.username, ENV, \"USER\")\n\ncompat: Julia 1.11\nThis function requires at least Julia 1.11.\n\nSee also homedir.\n\n\n\n\n\n"},{"title":"Base.@static","page":"Essentials","location":"base/base.html#Base.@static","category":"macro","text":"@static\n\nPartially evaluate an expression at macro expansion time.\n\nThis is useful in cases where a construct would be invalid in some cases, such as a ccall\nto an os-dependent function, or macros defined in packages that are not imported.\n\n@static requires a conditional. The conditional can be in an if statement, a ternary\noperator, or &&||. The conditional is evaluated by recursively expanding macros,\nlowering and executing the resulting expressions. Then, the matching branch (if any) is\nreturned. All the other branches of the conditional are deleted before they are\nmacro-expanded (and lowered or executed).\n\nExample\n\nSuppose we want to parse an expression expr that is valid only on macOS. We could solve\nthis problem using @static with @static if Sys.isapple() expr end. In case we had\nexpr_apple for macOS and expr_others for the other operating systems, the solution with\n@static would be @static Sys.isapple() ? expr_apple : expr_others.\n\n\n\n\n\n"},{"title":"Base.VersionNumber","page":"Essentials","location":"base/base.html#Base.VersionNumber","category":"type","text":"VersionNumber\n\nVersion number type which follows the specifications of\nsemantic versioning (semver), composed of major, minor\nand patch numeric values, followed by pre-release and build\nalphanumeric annotations.\nAs an extension to this standard, Julia also allows a single, empty prerelease annotation\nif there is no build identifier present (e.g. 1.0-), or a single, empty build annotation (e.g. 1.0+).\n\nVersionNumber objects can be compared with all of the standard comparison\noperators (==, <, <=, etc.), with the result following semver v2.0.0-rc.2 rules.\nDifferent from the semver standard, build annotations are not ignored when comparing version numbers.\n\nVersionNumber has the following public fields:\n\nv.major::Integer\nv.minor::Integer\nv.patch::Integer\nv.prerelease::Tuple{Vararg{Union{Integer, AbstractString}}}\nv.build::Tuple{Vararg{Union{Integer, AbstractString}}}\n\nSee also @v_str to efficiently construct VersionNumber objects\nfrom semver-format literal strings, VERSION for the VersionNumber\nof Julia itself, and Version Number Literals\nin the manual.\n\nExamples\n\njulia> a = VersionNumber(1, 2, 3)\nv\"1.2.3\"\n\njulia> a >= v\"1.2\"\ntrue\n\njulia> b = VersionNumber(\"2.0.1-rc1\")\nv\"2.0.1-rc1\"\n\njulia> b >= v\"2.0.1\"\nfalse\n\n\n\n\n\n"},{"title":"Base.@v_str","page":"Essentials","location":"base/base.html#Base.@v_str","category":"macro","text":"@v_str\n\nString macro used to parse a string to a VersionNumber.\n\nExamples\n\njulia> v\"1.2.3\"\nv\"1.2.3\"\n\njulia> v\"2.0.1-rc1\"\nv\"2.0.1-rc1\"\n\n\n\n\n\n"},{"title":"Base.error","page":"Essentials","location":"base/base.html#Base.error","category":"function","text":"error(msg...)\n\nRaise an ErrorException with a message constructed by string(msg...).\n\n\n\n\n\nerror(message::AbstractString)\n\nRaise an ErrorException with the given message.\n\n\n\n\n\n"},{"title":"Core.throw","page":"Essentials","location":"base/base.html#Core.throw","category":"function","text":"throw(e)\n\nThrow an object as an exception.\n\nSee also: rethrow, error.\n\n\n\n\n\n"},{"title":"Base.rethrow","page":"Essentials","location":"base/base.html#Base.rethrow","category":"function","text":"rethrow()\n\nRethrow the current exception from within a catch block. The rethrown\nexception will continue propagation as if it had not been caught.\n\nnote: Note\nThe alternative form rethrow(e) allows you to associate an alternative\nexception object e with the current backtrace. However this misrepresents\nthe program state at the time of the error so you're encouraged to instead\nthrow a new exception using throw(e). In Julia 1.1 and above, using\nthrow(e) will preserve the root cause exception on the stack, as\ndescribed in current_exceptions.\n\n\n\n\n\n"},{"title":"Base.backtrace","page":"Essentials","location":"base/base.html#Base.backtrace","category":"function","text":"backtrace()\n\nGet a backtrace object for the current program point.\n\n\n\n\n\n"},{"title":"Base.catch_backtrace","page":"Essentials","location":"base/base.html#Base.catch_backtrace","category":"function","text":"catch_backtrace()\n\nGet the backtrace of the current exception, for use within catch blocks.\n\n\n\n\n\n"},{"title":"Base.current_exceptions","page":"Essentials","location":"base/base.html#Base.current_exceptions","category":"function","text":"current_exceptions(task::Task=current_task(); [backtrace::Bool=true])\n\nGet the stack of exceptions currently being handled. For nested catch blocks\nthere may be more than one current exception in which case the most recently\nthrown exception is last in the stack. The stack is returned as an\nExceptionStack which is an AbstractVector of named tuples\n(exception,backtrace). If backtrace is false, the backtrace in each pair\nwill be set to nothing.\n\nExplicitly passing task will return the current exception stack on an\narbitrary task. This is useful for inspecting tasks which have failed due to\nuncaught exceptions.\n\ncompat: Julia 1.7\nThis function went by the experimental name catch_stack() in Julia\n1.1–1.6, and had a plain Vector-of-tuples as a return type.\n\n\n\n\n\n"},{"title":"Base.@assert","page":"Essentials","location":"base/base.html#Base.@assert","category":"macro","text":"@assert cond [text]\n\nThrow an AssertionError if cond is false. This is the preferred syntax for\nwriting assertions, which are conditions that are assumed to be true, but that the user\nmight decide to check anyways, as an aid to debugging if they fail.\nThe optional message text is displayed upon assertion failure.\n\nwarning: Warning\nAn assert might be disabled at some optimization levels.\nAssert should therefore only be used as a debugging tool\nand not used for authentication verification (e.g., verifying passwords or checking array bounds).\nThe code must not rely on the side effects of running cond for the correct behavior\nof a function.\n\nExamples\n\njulia> @assert iseven(3) \"3 is an odd number!\"\nERROR: AssertionError: 3 is an odd number!\n\njulia> @assert isodd(3) \"What even are numbers?\"\n\n\n\n\n\n"},{"title":"Base.Experimental.register_error_hint","page":"Essentials","location":"base/base.html#Base.Experimental.register_error_hint","category":"function","text":"Experimental.register_error_hint(handler, exceptiontype)\n\nRegister a \"hinting\" function handler(io, exception) that can\nsuggest potential ways for users to circumvent errors.  handler\nshould examine exception to see whether the conditions appropriate\nfor a hint are met, and if so generate output to io.\nPackages should call register_error_hint from within their\n__init__ function.\n\nFor specific exception types, handler is required to accept additional arguments:\n\nMethodError: provide handler(io, exc::MethodError, argtypes, kwargs),\nwhich splits the combined arguments into positional and keyword arguments.\n\nWhen issuing a hint, the output should typically start with \\n.\n\nIf you define custom exception types, your showerror method can\nsupport hints by calling Experimental.show_error_hints.\n\nExamples\n\njulia> module Hinter\n\n       only_int(x::Int)      = 1\n       any_number(x::Number) = 2\n\n       function __init__()\n           Base.Experimental.register_error_hint(MethodError) do io, exc, argtypes, kwargs\n               if exc.f == only_int\n                    # Color is not necessary, this is just to show it's possible.\n                    print(io, \"\\nDid you mean to call \")\n                    printstyled(io, \"`any_number`?\", color=:cyan)\n               end\n           end\n       end\n\n       end\n\nThen if you call Hinter.only_int on something that isn't an Int (thereby triggering a MethodError), it issues the hint:\n\njulia> Hinter.only_int(1.0)\nERROR: MethodError: no method matching only_int(::Float64)\nThe function `only_int` exists, but no method is defined for this combination of argument types.\nDid you mean to call `any_number`?\nClosest candidates are:\n    ...\n\ncompat: Julia 1.5\nCustom error hints are available as of Julia 1.5.\n\nwarning: Warning\nThis interface is experimental and subject to change or removal without notice.\nTo insulate yourself against changes, consider putting any registrations inside an\nif isdefined(Base.Experimental, :register_error_hint) ... end block.\n\n\n\n\n\n"},{"title":"Base.Experimental.show_error_hints","page":"Essentials","location":"base/base.html#Base.Experimental.show_error_hints","category":"function","text":"Experimental.show_error_hints(io, ex, args...)\n\nInvoke all handlers from Experimental.register_error_hint for the particular\nexception type typeof(ex) and all of its supertypes. args must contain any other arguments expected by\nthe handler for that type.\n\ncompat: Julia 1.5\nCustom error hints are available as of Julia 1.5.\n\nwarning: Warning\nThis interface is experimental and subject to change or removal without notice.\n\n\n\n\n\n"},{"title":"Core.ArgumentError","page":"Essentials","location":"base/base.html#Core.ArgumentError","category":"type","text":"ArgumentError(msg)\n\nThe arguments passed to a function are invalid.\nmsg is a descriptive error message.\n\n\n\n\n\n"},{"title":"Core.AssertionError","page":"Essentials","location":"base/base.html#Core.AssertionError","category":"type","text":"AssertionError([msg])\n\nThe asserted condition did not evaluate to true.\nOptional argument msg is a descriptive error string.\n\nExamples\n\njulia> @assert false \"this is not true\"\nERROR: AssertionError: this is not true\n\nAssertionError is usually thrown from @assert.\n\n\n\n\n\n"},{"title":"Core.BoundsError","page":"Essentials","location":"base/base.html#Core.BoundsError","category":"type","text":"BoundsError([a],[i])\n\nAn indexing operation into an array, a, tried to access an out-of-bounds element at index i.\n\nExamples\n\njulia> A = fill(1.0, 7);\n\njulia> A[8]\nERROR: BoundsError: attempt to access 7-element Vector{Float64} at index [8]\n\n\njulia> B = fill(1.0, (2,3));\n\njulia> B[2, 4]\nERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [2, 4]\n\n\njulia> B[9]\nERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [9]\n\n\n\n\n\n\n"},{"title":"Base.CompositeException","page":"Essentials","location":"base/base.html#Base.CompositeException","category":"type","text":"CompositeException\n\nWrap a Vector of exceptions thrown by a Task (e.g. generated from a remote worker over a channel\nor an asynchronously executing local I/O write or a remote worker under pmap) with information about the series of exceptions.\nFor example, if a group of workers are executing several tasks, and multiple workers fail, the resulting CompositeException will\ncontain a \"bundle\" of information from each worker indicating where and why the exception(s) occurred.\n\n\n\n\n\n"},{"title":"Base.DimensionMismatch","page":"Essentials","location":"base/base.html#Base.DimensionMismatch","category":"type","text":"DimensionMismatch([msg])\n\nThe objects called do not have matching dimensionality. Optional argument msg is a\ndescriptive error string.\n\n\n\n\n\n"},{"title":"Core.DivideError","page":"Essentials","location":"base/base.html#Core.DivideError","category":"type","text":"DivideError()\n\nInteger division was attempted with a denominator value of 0.\n\nExamples\n\njulia> 2/0\nInf\n\njulia> div(2, 0)\nERROR: DivideError: integer division error\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"Core.DomainError","page":"Essentials","location":"base/base.html#Core.DomainError","category":"type","text":"DomainError(val)\nDomainError(val, msg)\n\nThe argument val to a function or constructor is outside the valid domain.\n\nExamples\n\njulia> sqrt(-1)\nERROR: DomainError with -1.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"Base.EOFError","page":"Essentials","location":"base/base.html#Base.EOFError","category":"type","text":"EOFError()\n\nNo more data was available to read from a file or stream.\n\n\n\n\n\n"},{"title":"Core.ErrorException","page":"Essentials","location":"base/base.html#Core.ErrorException","category":"type","text":"ErrorException(msg)\n\nGeneric error type. The error message, in the .msg field, may provide more specific details.\n\nExamples\n\njulia> ex = ErrorException(\"I've done a bad thing\");\n\njulia> ex.msg\n\"I've done a bad thing\"\n\n\n\n\n\n"},{"title":"Core.FieldError","page":"Essentials","location":"base/base.html#Core.FieldError","category":"type","text":"FieldError(type::DataType, field::Symbol)\n\nAn operation tried to access invalid field on an object of type.\n\ncompat: Julia 1.12\nPrior to Julia 1.12, invalid field access threw an ErrorException\n\nSee getfield\n\nExamples\n\njulia> struct AB\n          a::Float32\n          b::Float64\n       end\n\njulia> ab = AB(1, 3)\nAB(1.0f0, 3.0)\n\njulia> ab.c # field `c` doesn't exist\nERROR: FieldError: type AB has no field `c`, available fields: `a`, `b`\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"Core.InexactError","page":"Essentials","location":"base/base.html#Core.InexactError","category":"type","text":"InexactError(name::Symbol, T, val)\n\nCannot exactly convert val to type T in a method of function name.\n\nExamples\n\njulia> convert(Float64, 1+2im)\nERROR: InexactError: Float64(1 + 2im)\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"Core.InterruptException","page":"Essentials","location":"base/base.html#Core.InterruptException","category":"type","text":"InterruptException()\n\nThe process was stopped by a terminal interrupt (CTRL+C).\n\nNote that, in Julia script started without -i (interactive) option,\nInterruptException is not thrown by default.  Calling\nBase.exit_on_sigint(false) in the script\ncan recover the behavior of the REPL.  Alternatively, a Julia script\ncan be started with\n\njulia -e \"include(popfirst!(ARGS))\" script.jl\n\nto let InterruptException be thrown by CTRL+C during the execution.\n\n\n\n\n\n"},{"title":"Base.KeyError","page":"Essentials","location":"base/base.html#Base.KeyError","category":"type","text":"KeyError(key)\n\nAn indexing operation into an AbstractDict (Dict) or Set like object tried to access or\ndelete a non-existent element.\n\n\n\n\n\n"},{"title":"Core.LoadError","page":"Essentials","location":"base/base.html#Core.LoadError","category":"type","text":"LoadError(file::AbstractString, line::Int, error)\n\nAn error occurred while includeing, requireing, or using a file. The error specifics\nshould be available in the .error field.\n\ncompat: Julia 1.7\nLoadErrors are no longer emitted by @macroexpand, @macroexpand1, and macroexpand as of Julia 1.7.\n\n\n\n\n\n"},{"title":"Core.MethodError","page":"Essentials","location":"base/base.html#Core.MethodError","category":"type","text":"MethodError(f, args)\n\nA method with the required type signature does not exist in the given generic function.\nAlternatively, there is no unique most-specific method.\n\n\n\n\n\n"},{"title":"Base.MissingException","page":"Essentials","location":"base/base.html#Base.MissingException","category":"type","text":"MissingException(msg)\n\nException thrown when a missing value is encountered in a situation\nwhere it is not supported. The error message, in the msg field\nmay provide more specific details.\n\n\n\n\n\n"},{"title":"Core.OutOfMemoryError","page":"Essentials","location":"base/base.html#Core.OutOfMemoryError","category":"type","text":"OutOfMemoryError()\n\nAn operation allocated too much memory for either the system or the garbage collector to\nhandle properly.\n\n\n\n\n\n"},{"title":"Core.ReadOnlyMemoryError","page":"Essentials","location":"base/base.html#Core.ReadOnlyMemoryError","category":"type","text":"ReadOnlyMemoryError()\n\nAn operation tried to write to memory that is read-only.\n\n\n\n\n\n"},{"title":"Core.OverflowError","page":"Essentials","location":"base/base.html#Core.OverflowError","category":"type","text":"OverflowError(msg)\n\nThe result of an expression is too large for the specified type and will cause a wraparound.\n\n\n\n\n\n"},{"title":"Base.ProcessFailedException","page":"Essentials","location":"base/base.html#Base.ProcessFailedException","category":"type","text":"ProcessFailedException\n\nIndicates problematic exit status of a process.\nWhen running commands or pipelines, this is thrown to indicate\na nonzero exit code was returned (i.e. that the invoked process failed).\n\n\n\n\n\n"},{"title":"Base.TaskFailedException","page":"Essentials","location":"base/base.html#Base.TaskFailedException","category":"type","text":"TaskFailedException\n\nThis exception is thrown by a wait(t) call when task t fails.\nTaskFailedException wraps the failed task t.\n\n\n\n\n\n"},{"title":"Core.StackOverflowError","page":"Essentials","location":"base/base.html#Core.StackOverflowError","category":"type","text":"StackOverflowError()\n\nThe function call grew beyond the size of the call stack. This usually happens when a call\nrecurses infinitely.\n\n\n\n\n\n"},{"title":"Base.SystemError","page":"Essentials","location":"base/base.html#Base.SystemError","category":"type","text":"SystemError(prefix::AbstractString, [errno::Int32])\n\nA system call failed with an error code (in the errno global variable).\n\n\n\n\n\n"},{"title":"Core.TypeError","page":"Essentials","location":"base/base.html#Core.TypeError","category":"type","text":"TypeError(func::Symbol, context::AbstractString, expected::Type, got)\n\nA type assertion failure, or calling an intrinsic function with an incorrect argument type.\n\n\n\n\n\n"},{"title":"Core.UndefKeywordError","page":"Essentials","location":"base/base.html#Core.UndefKeywordError","category":"type","text":"UndefKeywordError(var::Symbol)\n\nThe required keyword argument var was not assigned in a function call.\n\nExamples\n\njulia> function my_func(;my_arg)\n           return my_arg + 1\n       end\nmy_func (generic function with 1 method)\n\njulia> my_func()\nERROR: UndefKeywordError: keyword argument `my_arg` not assigned\nStacktrace:\n [1] my_func() at ./REPL[1]:2\n [2] top-level scope at REPL[2]:1\n\n\n\n\n\n"},{"title":"Core.UndefRefError","page":"Essentials","location":"base/base.html#Core.UndefRefError","category":"type","text":"UndefRefError()\n\nThe item or field is not defined for the given object.\n\nExamples\n\njulia> struct MyType\n           a::Vector{Int}\n           MyType() = new()\n       end\n\njulia> A = MyType()\nMyType(#undef)\n\njulia> A.a\nERROR: UndefRefError: access to undefined reference\nStacktrace:\n[...]\n\n\n\n\n\n"},{"title":"Core.UndefVarError","page":"Essentials","location":"base/base.html#Core.UndefVarError","category":"type","text":"UndefVarError(var::Symbol, [scope])\n\nA symbol in the current scope is not defined.\n\nExamples\n\njulia> a\nERROR: UndefVarError: `a` not defined in `Main`\n\njulia> a = 1;\n\njulia> a\n1\n\n\n\n\n\n"},{"title":"Base.StringIndexError","page":"Essentials","location":"base/base.html#Base.StringIndexError","category":"type","text":"StringIndexError(str, i)\n\nAn error occurred when trying to access str at index i that is not valid.\n\n\n\n\n\n"},{"title":"Core.InitError","page":"Essentials","location":"base/base.html#Core.InitError","category":"type","text":"InitError(mod::Symbol, error)\n\nAn error occurred when running a module's __init__ function. The actual error thrown is\navailable in the .error field.\n\n\n\n\n\n"},{"title":"Base.retry","page":"Essentials","location":"base/base.html#Base.retry","category":"function","text":"retry(f;  delays=ExponentialBackOff(), check=nothing) -> Function\n\nReturn an anonymous function that calls function f.  If an exception arises,\nf is repeatedly called again, each time check returns true, after waiting the\nnumber of seconds specified in delays.  check should input delays's\ncurrent state and the Exception.\n\ncompat: Julia 1.2\nBefore Julia 1.2 this signature was restricted to f::Function.\n\nExamples\n\nretry(f, delays=fill(5.0, 3))\nretry(f, delays=rand(5:10, 2))\nretry(f, delays=Base.ExponentialBackOff(n=3, first_delay=5, max_delay=1000))\nretry(http_get, check=(s,e)->e.status == \"503\")(url)\nretry(read, check=(s,e)->isa(e, IOError))(io, 128; all=false)\n\n\n\n\n\n"},{"title":"Base.ExponentialBackOff","page":"Essentials","location":"base/base.html#Base.ExponentialBackOff","category":"type","text":"ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter=0.1)\n\nA Float64 iterator of length n whose elements exponentially increase at a\nrate in the interval factor * (1 ± jitter).  The first element is\nfirst_delay and all elements are clamped to max_delay.\n\n\n\n\n\n"},{"title":"Base.Timer","page":"Essentials","location":"base/base.html#Base.Timer-Tuple{Function, Real}","category":"method","text":"Timer(callback::Function, delay; interval = 0, spawn::Union{Nothing,Bool}=nothing)\n\nCreate a timer that runs the function callback at each timer expiration.\n\nWaiting tasks are woken and the function callback is called after an initial delay of delay\nseconds, and then repeating with the given interval in seconds. If interval is equal to 0, the\ncallback is only run once. The function callback is called with a single argument, the timer\nitself. Stop a timer by calling close. The callback may still be run one final time, if the timer\nhas already expired.\n\nIf spawn is true, the created task will be spawned, meaning that it will be allowed\nto move thread, which avoids the side-effect of forcing the parent task to get stuck to the thread\nit is on. If spawn is nothing (default), the task will be spawned if the parent task isn't sticky.\n\ncompat: Julia 1.12\nThe spawn argument was introduced in Julia 1.12.\n\nExamples\n\nHere the first number is printed after a delay of two seconds, then the following numbers are\nprinted quickly.\n\njulia> begin\n           i = 0\n           cb(timer) = (global i += 1; println(i))\n           t = Timer(cb, 2, interval=0.2)\n           wait(t)\n           sleep(0.5)\n           close(t)\n       end\n1\n2\n3\n\n\n\n\n\n"},{"title":"Base.Timer","page":"Essentials","location":"base/base.html#Base.Timer","category":"type","text":"Timer(delay; interval = 0)\n\nCreate a timer that wakes up tasks waiting for it (by calling wait on the timer object).\n\nWaiting tasks are woken after an initial delay of at least delay seconds, and then repeating after\nat least interval seconds again elapse. If interval is equal to 0, the timer is only triggered\nonce. When the timer is closed (by close) waiting tasks are woken with an error. Use\nisopen to check whether a timer is still active. An inactive timer will not fire.\nUse t.timeout and t.interval to read the setup conditions of a Timer t.\n\njulia> t = Timer(1.0; interval=0.5)\nTimer (open, timeout: 1.0 s, interval: 0.5 s) @0x000000010f4e6e90\n\njulia> isopen(t)\ntrue\n\njulia> t.timeout\n1.0\n\njulia> close(t)\n\njulia> isopen(t)\nfalse\n\nnote: Note\ninterval is subject to accumulating time skew. If you need precise events at a particular\nabsolute time, create a new timer at each expiration with the difference to the next time computed.\n\nnote: Note\nA Timer requires yield points to update its state. For instance, isopen(t::Timer) cannot be\nused to timeout a non-yielding while loop.\n\n!!! compat \"Julia 1.12\n    The timeout and interval readable properties were added in Julia 1.12.\n\n\n\n\n\n"},{"title":"Base.AsyncCondition","page":"Essentials","location":"base/base.html#Base.AsyncCondition","category":"type","text":"AsyncCondition()\n\nCreate an async condition that wakes up tasks waiting for it\n(by calling wait on the object)\nwhen notified from C by a call to uv_async_send.\nWaiting tasks are woken with an error when the object is closed (by close).\nUse isopen to check whether it is still active. A closed condition is inactive and will\nnot wake up tasks.\n\nThis provides an implicit acquire & release memory ordering between the sending and waiting threads.\n\n\n\n\n\n"},{"title":"Base.AsyncCondition","page":"Essentials","location":"base/base.html#Base.AsyncCondition-Tuple{Function}","category":"method","text":"AsyncCondition(callback::Function)\n\nCreate an async condition that calls the given callback function. The callback is passed one argument,\nthe async condition object itself.\n\n\n\n\n\n"},{"title":"Base.nameof","page":"Essentials","location":"base/base.html#Base.nameof-Tuple{Module}","category":"method","text":"nameof(m::Module)::Symbol\n\nGet the name of a Module as a Symbol.\n\nExamples\n\njulia> nameof(Base.Broadcast)\n:Broadcast\n\n\n\n\n\n"},{"title":"Base.parentmodule","page":"Essentials","location":"base/base.html#Base.parentmodule","category":"function","text":"parentmodule(m::Method)::Module\n\nReturn the module in which the given method m is defined.\n\ncompat: Julia 1.9\nPassing a Method as an argument requires Julia 1.9 or later.\n\n\n\n\n\nparentmodule(f::Function, types)::Module\n\nDetermine the module containing the first method of a generic function f matching\nthe specified types.\n\n\n\n\n\nparentmodule(f::Function)::Module\n\nDetermine the module containing the (first) definition of a generic\nfunction.\n\n\n\n\n\nparentmodule(t::DataType)::Module\n\nDetermine the module containing the definition of a (potentially UnionAll-wrapped) DataType.\n\nExamples\n\njulia> module Foo\n           struct Int end\n       end\nFoo\n\njulia> parentmodule(Int)\nCore\n\njulia> parentmodule(Foo.Int)\nFoo\n\n\n\n\n\nparentmodule(m::Module)::Module\n\nGet a module's enclosing Module. Main is its own parent.\n\nSee also: names, nameof, fullname, @__MODULE__.\n\nExamples\n\njulia> parentmodule(Main)\nMain\n\njulia> parentmodule(Base.Broadcast)\nBase\n\n\n\n\n\n"},{"title":"Base.pathof","page":"Essentials","location":"base/base.html#Base.pathof-Tuple{Module}","category":"method","text":"pathof(m::Module)\n\nReturn the path of the m.jl file that was used to import module m,\nor nothing if m was not imported from a package.\n\nUse dirname to get the directory part and basename\nto get the file name part of the path.\n\nSee also pkgdir.\n\n\n\n\n\n"},{"title":"Base.pkgdir","page":"Essentials","location":"base/base.html#Base.pkgdir-Tuple{Module}","category":"method","text":"pkgdir(m::Module[, paths::String...])\n\nReturn the root directory of the package that declared module m,\nor nothing if m was not declared in a package. Optionally further\npath component strings can be provided to construct a path within the\npackage root.\n\nTo get the root directory of the package that implements the current module\nthe form pkgdir(@__MODULE__) can be used.\n\nIf an extension module is given, the root of the parent package is returned.\n\njulia> pkgdir(Foo)\n\"/path/to/Foo.jl\"\n\njulia> pkgdir(Foo, \"src\", \"file.jl\")\n\"/path/to/Foo.jl/src/file.jl\"\n\nSee also pathof.\n\ncompat: Julia 1.7\nThe optional argument paths requires at least Julia 1.7.\n\n\n\n\n\n"},{"title":"Base.pkgversion","page":"Essentials","location":"base/base.html#Base.pkgversion-Tuple{Module}","category":"method","text":"pkgversion(m::Module)\n\nIf the module m belongs to a versioned package, return the\nversion number of that package. Otherwise return nothing.\n\nThe version is read from the package's Project.toml during package\nload.\n\nTo get the version of the package that imported the current module\nthe form pkgversion(@__MODULE__) can be used.\n\ncompat: Julia 1.9\nThis function was introduced in Julia 1.9.\n\n\n\n\n\n"},{"title":"Base.moduleroot","page":"Essentials","location":"base/base.html#Base.moduleroot","category":"function","text":"moduleroot(m::Module)::Module\n\nFind the root module of a given module. This is the first module in the chain of\nparent modules of m which is either a registered root module or which is its\nown parent module.\n\n\n\n\n\n"},{"title":"__module__","page":"Essentials","location":"base/base.html#__module__","category":"keyword","text":"__module__\n\nThe argument __module__ is only visible inside the macro, and it provides information\n(in the form of a Module object) about the expansion context of the macro invocation.\nSee the manual section on Macro invocation for more information.\n\n\n\n\n\n"},{"title":"__source__","page":"Essentials","location":"base/base.html#__source__","category":"keyword","text":"__source__\n\nThe argument __source__ is only visible inside the macro, and it provides information\n(in the form of a LineNumberNode object) about the parser location of the @ sign from\nthe macro invocation. See the manual section on Macro invocation for more information.\n\n\n\n\n\n"},{"title":"Base.@__MODULE__","page":"Essentials","location":"base/base.html#Base.@__MODULE__","category":"macro","text":"@__MODULE__ -> Module\n\nGet the Module of the toplevel eval,\nwhich is the Module code is currently being read from.\n\n\n\n\n\n"},{"title":"Base.@__FUNCTION__","page":"Essentials","location":"base/base.html#Base.@__FUNCTION__","category":"macro","text":"@__FUNCTION__\n\nGet the innermost enclosing function object.\n\nnote: Note\n@__FUNCTION__ has the same scoping behavior as return: when used\ninside a closure, it refers to the closure and not the outer function.\nSome macros, including @spawn, @async, etc.,\nwrap their input in closures. When @__FUNCTION__ is used within such code,\nit will refer to the closure created by the macro rather than the enclosing function.\n\nExamples\n\n@__FUNCTION__ enables recursive anonymous functions:\n\njulia> factorial = (n -> n <= 1 ? 1 : n * (@__FUNCTION__)(n - 1));\n\njulia> factorial(5)\n120\n\n@__FUNCTION__ can be combined with nameof to identify a function's\nname from within its body:\n\njulia> bar() = nameof(@__FUNCTION__);\n\njulia> bar()\n:bar\n\n\n\n\n\n"},{"title":"Base.@__FILE__","page":"Essentials","location":"base/base.html#Base.@__FILE__","category":"macro","text":"@__FILE__ -> String\n\nExpand to a string with the path to the file containing the\nmacrocall, or an empty string if evaluated by julia -e <expr>.\nReturn nothing if the macro was missing parser source information.\nAlternatively see PROGRAM_FILE.\n\n\n\n\n\n"},{"title":"Base.@__DIR__","page":"Essentials","location":"base/base.html#Base.@__DIR__","category":"macro","text":"@__DIR__ -> String\n\nMacro to obtain the absolute path of the current directory as a string.\n\nIf in a script, returns the directory of the script containing the @__DIR__ macrocall. If run from a\nREPL or if evaluated by julia -e <expr>, returns the current working directory.\n\nExamples\n\nThe example illustrates the difference in the behaviors of @__DIR__ and pwd(), by creating\na simple script in a different directory than the current working one and executing both commands:\n\njulia> cd(\"/home/JuliaUser\") # working directory\n\njulia> # create script at /home/JuliaUser/Projects\n       open(\"/home/JuliaUser/Projects/test.jl\",\"w\") do io\n           print(io, \"\"\"\n               println(\"@__DIR__ = \", @__DIR__)\n               println(\"pwd() = \", pwd())\n           \"\"\")\n       end\n\njulia> # outputs script directory and current working directory\n       include(\"/home/JuliaUser/Projects/test.jl\")\n@__DIR__ = /home/JuliaUser/Projects\npwd() = /home/JuliaUser\n\n\n\n\n\n"},{"title":"Base.@__LINE__","page":"Essentials","location":"base/base.html#Base.@__LINE__","category":"macro","text":"@__LINE__ -> Int\n\nExpand to the line number of the location of the macrocall.\nReturn 0 if the line number could not be determined.\n\n\n\n\n\n"},{"title":"Base.fullname","page":"Essentials","location":"base/base.html#Base.fullname","category":"function","text":"fullname(m::Module)\n\nGet the fully-qualified name of a module as a tuple of symbols. For example,\n\nExamples\n\njulia> fullname(Base.Iterators)\n(:Base, :Iterators)\n\njulia> fullname(Main)\n(:Main,)\n\n\n\n\n\n"},{"title":"Base.names","page":"Essentials","location":"base/base.html#Base.names","category":"function","text":"names(x::Module; all::Bool=false, imported::Bool=false, usings::Bool=false)::Vector{Symbol}\n\nGet a vector of the public names of a Module, excluding deprecated names.\nIf all is true, then the list also includes non-public names defined in the module,\ndeprecated names, and compiler-generated names.\nIf imported is true, then names explicitly imported from other modules\nare also included.\nIf usings is true, then names explicitly or implicitly imported via using are also included.\nNames are returned in sorted order.\n\nAs a special case, all names defined in Main are considered \"public\",\nsince it is not idiomatic to explicitly mark names from Main as public.\n\nnote: Note\nsym ∈ names(SomeModule) does not imply isdefined(SomeModule, sym).\nnames may return symbols marked with public or export, even if\nthey are not defined in the module.\n\nwarning: Warning\nnames may return duplicate names. The duplication happens, e.g. if an imported name\nconflicts with an already existing identifier.\n\ncompat: Julia 1.12\nThe usings argument requires Julia 1.12 or later.\n\nSee also: Base.isexported, Base.ispublic, Base.@locals, @__MODULE__.\n\n\n\n\n\n"},{"title":"Base.isexported","page":"Essentials","location":"base/base.html#Base.isexported","category":"function","text":"isexported(m::Module, s::Symbol)::Bool\n\nReturn whether a symbol is exported from a module.\n\nSee also: ispublic, names\n\njulia> module Mod\n           export foo\n           public bar\n       end\nMod\n\njulia> Base.isexported(Mod, :foo)\ntrue\n\njulia> Base.isexported(Mod, :bar)\nfalse\n\njulia> Base.isexported(Mod, :baz)\nfalse\n\n\n\n\n\n"},{"title":"Base.ispublic","page":"Essentials","location":"base/base.html#Base.ispublic","category":"function","text":"ispublic(m::Module, s::Symbol)::Bool\n\nReturn whether a symbol is marked as public in a module.\n\nExported symbols are considered public.\n\ncompat: Julia 1.11\nThis function and the notion of publicity were added in Julia 1.11.\n\nSee also: isexported, names\n\njulia> module Mod\n           export foo\n           public bar\n       end\nMod\n\njulia> Base.ispublic(Mod, :foo)\ntrue\n\njulia> Base.ispublic(Mod, :bar)\ntrue\n\njulia> Base.ispublic(Mod, :baz)\nfalse\n\n\n\n\n\n"},{"title":"Base.nameof","page":"Essentials","location":"base/base.html#Base.nameof-Tuple{Function}","category":"method","text":"nameof(f::Function)::Symbol\n\nGet the name of a generic Function as a symbol. For anonymous functions,\nthis is a compiler-generated name. For explicitly-declared subtypes of\nFunction, it is the name of the function's type.\n\n\n\n\n\n"},{"title":"Base.functionloc","page":"Essentials","location":"base/base.html#Base.functionloc-Tuple{Any, Any}","category":"method","text":"functionloc(f::Function, types)\n\nReturn a tuple (filename,line) giving the location of a generic Function definition.\n\n\n\n\n\n"},{"title":"Base.functionloc","page":"Essentials","location":"base/base.html#Base.functionloc-Tuple{Method}","category":"method","text":"functionloc(m::Method)\n\nReturn a tuple (filename,line) giving the location of a Method definition.\n\n\n\n\n\n"},{"title":"Base.@locals","page":"Essentials","location":"base/base.html#Base.@locals","category":"macro","text":"@locals()\n\nConstruct a dictionary of the names (as symbols) and values of all local\nvariables defined as of the call site.\n\ncompat: Julia 1.1\nThis macro requires at least Julia 1.1.\n\nExamples\n\njulia> let x = 1, y = 2\n           Base.@locals\n       end\nDict{Symbol, Any} with 2 entries:\n  :y => 2\n  :x => 1\n\njulia> function f(x)\n           local y\n           show(Base.@locals); println()\n           for i = 1:1\n               show(Base.@locals); println()\n           end\n           y = 2\n           show(Base.@locals); println()\n           nothing\n       end;\n\njulia> f(42)\nDict{Symbol, Any}(:x => 42)\nDict{Symbol, Any}(:i => 1, :x => 42)\nDict{Symbol, Any}(:y => 2, :x => 42)\n\n\n\n\n\n"},{"title":"Core.getglobal","page":"Essentials","location":"base/base.html#Core.getglobal","category":"function","text":"getglobal(module::Module, name::Symbol, [order::Symbol=:monotonic])\n\nRetrieve the value of the binding name from the module module. Optionally, an\natomic ordering can be defined for the operation, otherwise it defaults to\nmonotonic.\n\nWhile accessing module bindings using getfield is still supported to\nmaintain compatibility, using getglobal should always be preferred since\ngetglobal allows for control over atomic ordering (getfield is always\nmonotonic) and better signifies the code's intent both to the user as well as the\ncompiler.\n\nMost users should not have to call this function directly – The\ngetproperty function or corresponding syntax (i.e.\nmodule.name) should be preferred in all but few very specific use cases.\n\ncompat: Julia 1.9\nThis function requires Julia 1.9 or later.\n\nSee also getproperty and setglobal!.\n\nExamples\n\njulia> a = 1\n1\n\njulia> module M\n       a = 2\n       end;\n\njulia> getglobal(@__MODULE__, :a)\n1\n\njulia> getglobal(M, :a)\n2\n\n\n\n\n\n"},{"title":"Core.setglobal!","page":"Essentials","location":"base/base.html#Core.setglobal!","category":"function","text":"setglobal!(module::Module, name::Symbol, x, [order::Symbol=:monotonic])\n\nSet or change the value of the binding name in the module module to x. No\ntype conversion is performed, so if a type has already been declared for the\nbinding, x must be of appropriate type or an error is thrown.\n\nAdditionally, an atomic ordering can be specified for this operation, otherwise it\ndefaults to monotonic.\n\nUsers will typically access this functionality through the\nsetproperty! function or corresponding syntax\n(i.e. module.name = x) instead, so this is intended only for very specific use\ncases.\n\ncompat: Julia 1.9\nThis function requires Julia 1.9 or later.\n\nSee also setproperty! and getglobal\n\nExamples\n\njulia> module M; global a; end;\n\njulia> M.a  # same as `getglobal(M, :a)`\nERROR: UndefVarError: `a` not defined in `M`\nSuggestion: add an appropriate import or assignment. This global was declared but not assigned.\nStacktrace:\n [1] getproperty(x::Module, f::Symbol)\n   @ Base ./Base_compiler.jl:40\n [2] top-level scope\n   @ none:1\n\njulia> setglobal!(M, :a, 1)\n1\n\njulia> M.a\n1\n\n\n\n\n\n"},{"title":"Core.modifyglobal!","page":"Essentials","location":"base/base.html#Core.modifyglobal!","category":"function","text":"modifyglobal!(module::Module, name::Symbol, op, x, [order::Symbol=:monotonic])::Pair\n\nAtomically perform the operations to get and set a global after applying\nthe function op.\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\nSee also modifyproperty! and setglobal!.\n\n\n\n\n\n"},{"title":"Core.swapglobal!","page":"Essentials","location":"base/base.html#Core.swapglobal!","category":"function","text":"swapglobal!(module::Module, name::Symbol, x, [order::Symbol=:monotonic])\n\nAtomically perform the operations to simultaneously get and set a global.\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\nSee also swapproperty! and setglobal!.\n\n\n\n\n\n"},{"title":"Core.setglobalonce!","page":"Essentials","location":"base/base.html#Core.setglobalonce!","category":"function","text":"setglobalonce!(module::Module, name::Symbol, value,\n              [success_order::Symbol, [fail_order::Symbol=success_order]) -> success::Bool\n\nAtomically perform the operations to set a global to\na given value, only if it was previously not set.\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\nSee also setpropertyonce! and setglobal!.\n\n\n\n\n\n"},{"title":"Core.replaceglobal!","page":"Essentials","location":"base/base.html#Core.replaceglobal!","category":"function","text":"replaceglobal!(module::Module, name::Symbol, expected, desired,\n              [success_order::Symbol, [fail_order::Symbol=success_order]) -> (; old, success::Bool)\n\nAtomically perform the operations to get and conditionally set a global to\na given value.\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\nSee also replaceproperty! and setglobal!.\n\n\n\n\n\n"},{"title":"Core.declare_const","page":"Essentials","location":"base/base.html#Core.declare_const","category":"function","text":"declare_const(module::Module, name::Symbol, [x])\n\nCreate or replace the constant name in module with the new value x.  When\nreplacing, x does not need to have the same type as the original constant.\n\nWhen x is not given, name becomes an undefined constant; it cannot be read\nor written to, but can be redefined.\n\nUnlike the syntax const, calling this function does not insert Core.@latestworld to update the world age of the current frame:\n\njulia> begin\n           const x = 1\n           println(x)\n           const x = 2\n           println(x)\n           Core.declare_const(Main, :x, 3)\n           println(x)\n           Core.@latestworld\n           println(x)\n       end\n1\n2\n2\n3\n\ncompat: Julia 1.12\nThis function requires Julia 1.12 or later.  Redefining constants on earlier\nversions of Julia is unpredictable.\n\nSee also const.\n\n\n\n\n\n"},{"title":"Core.@doc","page":"Essentials","location":"base/base.html#Core.@doc","category":"macro","text":"Documentation\n\nFunctions, methods and types can be documented by placing a string before the definition:\n\n\"\"\"\n    foo(x)\n\nReturn a fooified version of `x`.\n\"\"\"\nfoo(x) = ...\n\nThe @doc macro can be used directly to both set and retrieve documentation / metadata.\nThe macro has special parsing so that the documented object may occur on the next line:\n\n@doc \"blah\"\nfunction foo() ...\n\nBy default, documentation is written as Markdown, but any object can be used as\nthe first argument.\n\nDocumenting objects separately from their definitions\n\nYou can document an object before or after its definition with\n\n@doc \"foo\" function_to_doc\n@doc \"bar\" TypeToDoc\n\nFor macros, the syntax is @doc \"macro doc\" :(Module.@macro) or @doc \"macro doc\" :(string_macro\"\") for string macros. Without the quote :() the expansion of the macro\nwill be documented.\n\nRetrieving Documentation\n\nYou can retrieve docs for functions, macros and other objects as follows:\n\n@doc foo\n@doc @time\n@doc md\"\"\n\ncompat: Julia 1.11\nIn Julia 1.11 and newer, retrieving documentation with the @doc macro requires that\nthe REPL stdlib is loaded.\n\nFunctions & Methods\n\nPlacing documentation before a method definition (e.g. function foo() ... or foo() = ...)\nwill cause that specific method to be documented, as opposed to the whole function. Method\ndocs are concatenated together in the order they were defined to provide docs for the\nfunction.\n\n\n\n\n\n"},{"title":"Base.Docs.HTML","page":"Essentials","location":"base/base.html#Base.Docs.HTML","category":"type","text":"HTML(s): Create an object that renders s as html.\n\nHTML(\"<div>foo</div>\")\n\nYou can also use a stream for large amounts of data:\n\nHTML() do io\n  println(io, \"<div>foo</div>\")\nend\n\nwarning: Warning\nHTML is currently exported to maintain\nbackwards compatibility, but this export\nis deprecated. It is recommended to use\nthis type as Docs.HTML or to explicitly\nimport it from Docs.\n\n\n\n\n\n"},{"title":"Base.Docs.Text","page":"Essentials","location":"base/base.html#Base.Docs.Text","category":"type","text":"Text(s): Create an object that renders s as plain text.\n\nText(\"foo\")\n\nYou can also use a stream for large amounts of data:\n\nText() do io\n  println(io, \"foo\")\nend\n\nwarning: Warning\nText is currently exported to maintain\nbackwards compatibility, but this export\nis deprecated. It is recommended to use\nthis type as Docs.Text or to explicitly\nimport it from Docs.\n\n\n\n\n\n"},{"title":"Base.Docs.hasdoc","page":"Essentials","location":"base/base.html#Base.Docs.hasdoc","category":"function","text":"Docs.hasdoc(mod::Module, sym::Symbol)::Bool\n\nReturn true if sym in mod has a docstring and false otherwise.\n\n\n\n\n\n"},{"title":"Base.Docs.undocumented_names","page":"Essentials","location":"base/base.html#Base.Docs.undocumented_names","category":"function","text":"undocumented_names(mod::Module; private=false)\n\nReturn a sorted vector of undocumented symbols in module (that is, lacking docstrings).\nprivate=false (the default) returns only identifiers declared with public and/or\nexport, whereas private=true returns all symbols in the module (excluding\ncompiler-generated hidden symbols starting with #).\n\nSee also: names, Docs.hasdoc, Base.ispublic.\n\n\n\n\n\n"},{"title":"Base.identify_package","page":"Essentials","location":"base/base.html#Base.identify_package","category":"function","text":"Base.identify_package(name::String)::Union{PkgId, Nothing}\nBase.identify_package(where::Union{Module,PkgId}, name::String)::Union{PkgId, Nothing}\n\nIdentify the package by its name from the current environment stack, returning\nits PkgId, or nothing if it cannot be found.\n\nIf only the name argument is provided, it searches each environment in the\nstack and its named direct dependencies.\n\nThe where argument provides the context from where to search for the\npackage: in this case it first checks if the name matches the context itself,\notherwise it searches all recursive dependencies (from the resolved manifest of\neach environment) until it locates the context where, and from there\nidentifies the dependency with the corresponding name.\n\njulia> Base.identify_package(\"Pkg\") # Pkg is a dependency of the default environment\nPkg [44cfe95a-1eb2-52ea-b672-e2afdf69b78f]\n\njulia> using LinearAlgebra\n\njulia> Base.identify_package(LinearAlgebra, \"Pkg\") # Pkg is not a dependency of LinearAlgebra\n\n\n\n\n\n"},{"title":"Base.locate_package","page":"Essentials","location":"base/base.html#Base.locate_package","category":"function","text":"Base.locate_package(pkg::PkgId)::Union{String, Nothing}\n\nThe path to the entry-point file for the package corresponding to the identifier\npkg, or nothing if not found. See also identify_package.\n\njulia> pkg = Base.identify_package(\"Pkg\")\nPkg [44cfe95a-1eb2-52ea-b672-e2afdf69b78f]\n\njulia> Base.locate_package(pkg)\n\"/path/to/julia/stdlib/v1.14/Pkg/src/Pkg.jl\"\n\n\n\n\n\n"},{"title":"Base.require","page":"Essentials","location":"base/base.html#Base.require","category":"function","text":"require(into::Module, module::Symbol)\n\nThis function is part of the implementation of using / import, if a module is not\nalready defined in Main. It can also be called directly to force reloading a module,\nregardless of whether it has been loaded before (for example, when interactively developing\nlibraries).\n\nLoads a source file, in the context of the Main module, on every active node, searching\nstandard locations for files. require is considered a top-level operation, so it sets the\ncurrent include path but does not use it to search for files (see help for include).\nThis function is typically used to load library code, and is implicitly called by using to\nload packages.\n\nWhen searching for files, require first looks for package code in the global array\nLOAD_PATH. require is case-sensitive on all platforms, including those with\ncase-insensitive filesystems like macOS and Windows.\n\nFor more details regarding code loading, see the manual sections on modules and\nparallel computing.\n\n\n\n\n\n"},{"title":"Base.compilecache","page":"Essentials","location":"base/base.html#Base.compilecache","category":"function","text":"Base.compilecache(module::PkgId)\n\nCreate a precompiled cache file for a module and all of its dependencies.\nThis can be used to reduce package load times. Cache files are stored in\nDEPOT_PATH[1]/compiled. See Module initialization and precompilation\nfor important notes.\n\n\n\n\n\n"},{"title":"Base.isprecompiled","page":"Essentials","location":"base/base.html#Base.isprecompiled","category":"function","text":"Base.isprecompiled(pkg::PkgId; ignore_loaded::Bool=false)\n\nReturn whether a given PkgId within the active project is precompiled.\n\nBy default this check observes the same approach that code loading takes\nwith respect to when different versions of dependencies are currently loaded\nto that which is expected. To ignore loaded modules and answer as if in a\nfresh julia session specify ignore_loaded=true.\n\ncompat: Julia 1.10\nThis function requires at least Julia 1.10.\n\n\n\n\n\n"},{"title":"Base.get_extension","page":"Essentials","location":"base/base.html#Base.get_extension","category":"function","text":"get_extension(parent::Module, extension::Symbol)\n\nReturn the module for extension of parent or return nothing if the extension is not loaded.\n\n\n\n\n\n"},{"title":"Base.GC.gc","page":"Essentials","location":"base/base.html#Base.GC.gc","category":"function","text":"GC.gc([full=true])\n\nPerform garbage collection. The argument full determines the kind of\ncollection: a full collection (default) traverses all live objects (i.e. full mark)\nand should reclaim memory from all unreachable objects. An incremental collection only\nreclaims memory from young objects which are not reachable.\n\nThe GC may decide to perform a full collection even if an incremental collection was\nrequested.\n\nwarning: Warning\nExcessive use will likely lead to poor performance.\n\n\n\n\n\n"},{"title":"Base.GC.enable","page":"Essentials","location":"base/base.html#Base.GC.enable","category":"function","text":"GC.enable(on::Bool)\n\nControl whether garbage collection is enabled using a boolean argument (true for enabled,\nfalse for disabled). Return previous GC state.\n\nwarning: Warning\nDisabling garbage collection should be used only with caution, as it can cause memory\nuse to grow without bound.\n\n\n\n\n\n"},{"title":"Base.GC.@preserve","page":"Essentials","location":"base/base.html#Base.GC.@preserve","category":"macro","text":"GC.@preserve x1 x2 ... xn expr\n\nMark the objects x1, x2, ... as being in use during the evaluation of the\nexpression expr. This is only required in unsafe code where expr\nimplicitly uses memory or other resources owned by one of the xs.\n\nImplicit use of x covers any indirect use of resources logically owned by\nx which the compiler cannot see. Some examples:\n\nAccessing memory of an object directly via a Ptr\nPassing a pointer to x to ccall\nUsing resources of x which would be cleaned up in the finalizer.\n\n@preserve should generally not have any performance impact in typical use\ncases where it briefly extends object lifetime. In implementation, @preserve\nhas effects such as protecting dynamically allocated objects from garbage\ncollection.\n\nExamples\n\nWhen loading from a pointer with unsafe_load, the underlying object is\nimplicitly used, for example x is implicitly used by unsafe_load(p) in the\nfollowing:\n\njulia> let\n           x = Ref{Int}(101)\n           p = Base.unsafe_convert(Ptr{Int}, x)\n           GC.@preserve x unsafe_load(p)\n       end\n101\n\nWhen passing pointers to ccall, the pointed-to object is implicitly used and\nshould be preserved. (Note however that you should normally just pass x\ndirectly to ccall which counts as an explicit use.)\n\njulia> let\n           x = \"Hello\"\n           p = pointer(x)\n           Int(GC.@preserve x @ccall strlen(p::Cstring)::Csize_t)\n           # Preferred alternative\n           Int(@ccall strlen(x::Cstring)::Csize_t)\n       end\n5\n\n\n\n\n\n"},{"title":"Base.GC.safepoint","page":"Essentials","location":"base/base.html#Base.GC.safepoint","category":"function","text":"GC.safepoint()\n\nInserts a point in the program where garbage collection may run.\n\nSafepoints are fast and do not themselves trigger garbage collection.\nHowever, if another thread has requested the GC to run, reaching a safepoint will\ncause the current thread to block and wait for the GC.\n\nThis can be useful in rare cases in multi-threaded programs where some tasks\nare allocating memory (and hence may need to run GC) but other tasks are doing\nonly simple operations (no allocation, task switches, or I/O), which do not\nyield control to Julia's runtime, and therefore blocks the GC from running.\nCalling this function periodically in the non-allocating tasks allows garbage\ncollection to run.\n\nNote that even though safepoints are fast (typically around 2 clock cycles),\nthey can still degrade performance if called in a tight loop.\n\ncompat: Julia 1.4\nThis function is available as of Julia 1.4.\n\n\n\n\n\n"},{"title":"Base.GC.enable_logging","page":"Essentials","location":"base/base.html#Base.GC.enable_logging","category":"function","text":"GC.enable_logging(on::Bool)\n\nWhen turned on, print statistics about each GC to stderr.\n\n\n\n\n\n"},{"title":"Base.GC.logging_enabled","page":"Essentials","location":"base/base.html#Base.GC.logging_enabled","category":"function","text":"GC.logging_enabled()\n\nReturn whether GC logging has been enabled via GC.enable_logging.\n\n\n\n\n\n"},{"title":"Base.Meta.lower","page":"Essentials","location":"base/base.html#Base.Meta.lower","category":"function","text":"lower(m, x)\n\nTakes the expression x and returns an equivalent expression in lowered form\nfor executing in module m.\nSee also code_lowered.\n\n\n\n\n\n"},{"title":"Base.Meta.@lower","page":"Essentials","location":"base/base.html#Base.Meta.@lower","category":"macro","text":"@lower [m] x\n\nReturn lowered form of the expression x in module m.\nBy default m is the module in which the macro is called.\nSee also lower.\n\n\n\n\n\n"},{"title":"Base.Meta.parse","page":"Essentials","location":"base/base.html#Base.Meta.parse-Tuple{AbstractString, Int64}","category":"method","text":"parse(str, start; greedy=true, raise=true, depwarn=true, filename=\"none\")\n\nParse the expression string and return an expression (which could later be\npassed to eval for execution). start is the code unit index into str of the\nfirst character to start parsing at (as with all string indexing, these are not\ncharacter indices). If greedy is true (default), parse will try to consume\nas much input as it can; otherwise, it will stop as soon as it has parsed a\nvalid expression. Incomplete but otherwise syntactically valid expressions will\nreturn Expr(:incomplete, \"(error message)\"). If raise is true (default),\nsyntax errors other than incomplete expressions will raise an error. If raise\nis false, parse will return an expression that will raise an error upon\nevaluation. If depwarn is false, deprecation warnings will be suppressed.\nThe filename argument is used to display diagnostics when an error is raised.\n\njulia> Meta.parse(\"(α, β) = 3, 5\", 1) # start of string\n(:((α, β) = (3, 5)), 16)\n\njulia> Meta.parse(\"(α, β) = 3, 5\", 1, greedy=false)\n(:((α, β)), 9)\n\njulia> Meta.parse(\"(α, β) = 3, 5\", 16) # end of string\n(nothing, 16)\n\njulia> Meta.parse(\"(α, β) = 3, 5\", 11) # index of 3\n(:((3, 5)), 16)\n\njulia> Meta.parse(\"(α, β) = 3, 5\", 11, greedy=false)\n(3, 13)\n\n\n\n\n\n"},{"title":"Base.Meta.parse","page":"Essentials","location":"base/base.html#Base.Meta.parse-Tuple{AbstractString}","category":"method","text":"parse(str; raise=true, depwarn=true, filename=\"none\")\n\nParse the expression string greedily, returning a single expression. An error is thrown if\nthere are additional characters after the first expression. If raise is true (default),\nsyntax errors will raise an error; otherwise, parse will return an expression that will\nraise an error upon evaluation.  If depwarn is false, deprecation warnings will be\nsuppressed. The filename argument is used to display diagnostics when an error is raised.\n\njulia> Meta.parse(\"x = 3\")\n:(x = 3)\n\njulia> Meta.parse(\"1.0.2\")\nERROR: ParseError:\n# Error @ none:1:1\n1.0.2\n└──┘ ── invalid numeric constant\n[...]\n\njulia> Meta.parse(\"1.0.2\"; raise = false)\n:($(Expr(:error, \"invalid numeric constant \"1.0.\"\")))\n\njulia> Meta.parse(\"x = \")\n:($(Expr(:incomplete, \"incomplete: premature end of input\")))\n\n\n\n\n\n"},{"title":"Base.Meta.ParseError","page":"Essentials","location":"base/base.html#Base.Meta.ParseError","category":"type","text":"ParseError(msg)\n\nThe expression passed to the parse function could not be interpreted as a valid Julia\nexpression.\n\n\n\n\n\n"},{"title":"Core.QuoteNode","page":"Essentials","location":"base/base.html#Core.QuoteNode","category":"type","text":"QuoteNode\n\nA quoted piece of code, that does not support interpolation. See the manual section about QuoteNodes for details.\n\n\n\n\n\n"},{"title":"Base.macroexpand","page":"Essentials","location":"base/base.html#Base.macroexpand","category":"function","text":"macroexpand(m::Module, x; recursive=true, legacyscope=true)\n\nTake the expression x and return an equivalent expression with all macros removed (expanded)\nfor executing in module m.\nThe recursive keyword controls whether deeper levels of nested macros are also expanded.\nThe legacyscope keyword controls whether legacy macroscope expansion is performed.\nThis is demonstrated in the example below:\n\njulia> module M\n           macro m1()\n               42\n           end\n           macro m2()\n               :(@m1())\n           end\n       end\nM\n\njulia> macroexpand(M, :(@m2()), recursive=true)\n42\n\njulia> macroexpand(M, :(@m2()), recursive=false)\n:(#= REPL[1]:6 =# @m1)\n\n\n\n\n\n"},{"title":"Base.macroexpand!","page":"Essentials","location":"base/base.html#Base.macroexpand!","category":"function","text":"macroexpand!(m::Module, x; recursive=true, legacyscope=false)\n\nTake the expression x and return an equivalent expression with all macros removed (expanded)\nfor executing in module m, modifying x in place without copying.\nThe recursive keyword controls whether deeper levels of nested macros are also expanded.\nThe legacyscope keyword controls whether legacy macroscope expansion is performed.\n\nThis function performs macro expansion without the initial copy step, making it more efficient\nwhen the original expression is no longer needed. By default, macroscope expansion is disabled\nfor in-place expansion as it can be called separately if needed.\n\nwarning: Warning\nThis function modifies the input expression x in place. Use macroexpand if you need\nto preserve the original expression.\n\n\n\n\n\n"},{"title":"Base.@macroexpand","page":"Essentials","location":"base/base.html#Base.@macroexpand","category":"macro","text":"@macroexpand [mod,] ex\n\nReturn equivalent expression with all macros removed (expanded).\nIf two arguments are provided, the first is the module to evaluate in.\n\nThere are differences between @macroexpand and macroexpand.\n\nWhile macroexpand takes a keyword argument recursive, @macroexpand\nis always recursive. For a non recursive macro version, see @macroexpand1.\nWhile macroexpand has an explicit module argument, @macroexpand always\nexpands with respect to the module in which it is called.\n\nThis is best seen in the following example:\n\njulia> module M\n           macro m()\n               1\n           end\n           function f()\n               (@macroexpand(@m),\n                macroexpand(M, :(@m)),\n                macroexpand(parentmodule(M), :(@m))\n               )\n           end\n       end\nM\n\njulia> macro m()\n           2\n       end\n@m (macro with 1 method)\n\njulia> M.f()\n(1, 1, 2)\n\nWith @macroexpand the expression expands where @macroexpand appears in the code (module M in the example).\nWith macroexpand the expression expands in the module given as the first argument.\n\ncompat: Julia 1.11\nThe two-argument form requires at least Julia 1.11.\n\n\n\n\n\n"},{"title":"Base.@macroexpand1","page":"Essentials","location":"base/base.html#Base.@macroexpand1","category":"macro","text":"@macroexpand1 [mod,] ex\n\nNon recursive version of @macroexpand.\n\n\n\n\n\n"},{"title":"Base.code_lowered","page":"Essentials","location":"base/base.html#Base.code_lowered","category":"function","text":"code_lowered(f, types; generated=true, debuginfo=:default)\n\nReturn an array of the lowered forms (IR) for the methods matching the given generic function\nand type signature.\n\nIf generated is false, the returned CodeInfo instances will correspond to fallback\nimplementations. An error is thrown if no fallback implementation exists.\nIf generated is true, these CodeInfo instances will correspond to the method bodies\nyielded by expanding the generators.\n\nThe keyword debuginfo controls the amount of code metadata present in the output.\n\nNote that an error will be thrown if types are not concrete types when generated is\ntrue and any of the corresponding methods are an @generated method.\n\n\n\n\n\n"},{"title":"Base.code_typed","page":"Essentials","location":"base/base.html#Base.code_typed","category":"function","text":"code_typed(f, types; kw...)\n\nReturn an array of type-inferred lowered form (IR) for the methods matching the given\ngeneric function and type signature.\n\nKeyword Arguments\n\noptimize::Bool = true: optional, controls whether additional optimizations,\nsuch as inlining, are also applied.\ndebuginfo::Symbol = :default: optional, controls the amount of code metadata present\nin the output, possible options are :source or :none.\n\nInternal Keyword Arguments\n\nThis section should be considered internal, and is only for who understands Julia compiler\ninternals.\n\nworld::UInt = Base.get_world_counter(): optional, controls the world age to use\nwhen looking up methods, use current world age if not specified.\ninterp::Core.Compiler.AbstractInterpreter = Core.Compiler.NativeInterpreter(world):\noptional, controls the abstract interpreter to use, use the native interpreter if not specified.\n\nExamples\n\nOne can put the argument types in a tuple to get the corresponding code_typed.\n\njulia> code_typed(+, (Float64, Float64))\n1-element Vector{Any}:\n CodeInfo(\n1 ─ %1 = Base.add_float(x, y)::Float64\n└──      return %1\n) => Float64\n\njulia> code_typed((typeof(-), Float64, Float64))\n1-element Vector{Any}:\n CodeInfo(\n1 ─ %1 = Base.sub_float(x, y)::Float64\n└──      return %1\n) => Float64\n\njulia> code_typed((Type{Int}, UInt8))\n1-element Vector{Any}:\n CodeInfo(\n1 ─ %1 = Core.zext_int(Core.Int64, x)::Int64\n└──      return %1\n) => Int64\n\njulia> code_typed((Returns{Int64},))\n1-element Vector{Any}:\n CodeInfo(\n1 ─ %1 =   builtin Base.getfield(obj, :value)::Int64\n└──      return %1\n) => Int64\n\n\n\n\n\n"},{"title":"Base.precompile","page":"Essentials","location":"base/base.html#Base.precompile","category":"function","text":"precompile(f, argtypes::Tuple{Vararg{Any}}, m::Method)\n\nPrecompile a specific method for the given argument types. This may be used to precompile\na different method than the one that would ordinarily be chosen by dispatch, thus\nmimicking invoke.\n\n\n\n\n\nprecompile(f, argtypes::Tuple{Vararg{Any}})\n\nCompile the given function f for the argument tuple (of types) argtypes, but do not execute it.\n\n\n\n\n\n"},{"title":"Base.jit_total_bytes","page":"Essentials","location":"base/base.html#Base.jit_total_bytes","category":"function","text":"Base.jit_total_bytes()\n\nReturn the total amount (in bytes) allocated by the just-in-time compiler\nfor e.g. native code and data.\n\n\n\n\n\n"},{"title":"Base.Meta.quot","page":"Essentials","location":"base/base.html#Base.Meta.quot","category":"function","text":"Meta.quot(ex)::Expr\n\nQuote expression ex to produce an expression with head quote. This can for\ninstance be used to represent objects of type Expr in the AST. See also the\nmanual section about QuoteNode.\n\nExamples\n\njulia> eval(Meta.quot(:x))\n:x\n\njulia> dump(Meta.quot(:x))\nExpr\n  head: Symbol quote\n  args: Array{Any}((1,))\n    1: Symbol x\n\njulia> eval(Meta.quot(:(1+2)))\n:(1 + 2)\n\n\n\n\n\n"},{"title":"Base.isexpr","page":"Essentials","location":"base/base.html#Base.isexpr","category":"function","text":"Meta.isexpr(ex, head[, n])::Bool\n\nReturn true if ex is an Expr with the given type head and optionally that\nthe argument list is of length n. head may be a Symbol or collection of\nSymbols. For example, to check that a macro was passed a function call\nexpression, you might use isexpr(ex, :call).\n\nExamples\n\njulia> ex = :(f(x))\n:(f(x))\n\njulia> Meta.isexpr(ex, :block)\nfalse\n\njulia> Meta.isexpr(ex, :call)\ntrue\n\njulia> Meta.isexpr(ex, [:block, :call]) # multiple possible heads\ntrue\n\njulia> Meta.isexpr(ex, :call, 1)\nfalse\n\njulia> Meta.isexpr(ex, :call, 2)\ntrue\n\n\n\n\n\n"},{"title":"Base.Meta.isidentifier","page":"Essentials","location":"base/base.html#Base.Meta.isidentifier","category":"function","text":" isidentifier(s) -> Bool\n\nReturn whether the symbol or string s contains characters that are parsed as\na valid ordinary identifier (not a binary/unary operator) in Julia code;\nsee also Base.isoperator.\n\nInternally Julia allows any sequence of characters in a Symbol (except \\0s),\nand macros automatically use variable names containing # in order to avoid\nnaming collision with the surrounding code. In order for the parser to\nrecognize a variable, it uses a limited set of characters (greatly extended by\nUnicode). isidentifier() makes it possible to query the parser directly\nwhether a symbol contains valid characters.\n\nExamples\n\njulia> Meta.isidentifier(:x), Meta.isidentifier(\"1x\")\n(true, false)\n\n\n\n\n\n"},{"title":"Base.Meta.isoperator","page":"Essentials","location":"base/base.html#Base.Meta.isoperator","category":"function","text":"isoperator(s::Symbol)\n\nReturn true if the symbol can be used as an operator, false otherwise.\n\nExamples\n\njulia> Meta.isoperator(:+), Meta.isoperator(:f)\n(true, false)\n\n\n\n\n\n"},{"title":"Base.Meta.isunaryoperator","page":"Essentials","location":"base/base.html#Base.Meta.isunaryoperator","category":"function","text":"isunaryoperator(s::Symbol)\n\nReturn true if the symbol can be used as a unary (prefix) operator, false otherwise.\n\nExamples\n\njulia> Meta.isunaryoperator(:-), Meta.isunaryoperator(:√), Meta.isunaryoperator(:f)\n(true, true, false)\n\n\n\n\n\n"},{"title":"Base.Meta.isbinaryoperator","page":"Essentials","location":"base/base.html#Base.Meta.isbinaryoperator","category":"function","text":"isbinaryoperator(s::Symbol)\n\nReturn true if the symbol can be used as a binary (infix) operator, false otherwise.\n\nExamples\n\njulia> Meta.isbinaryoperator(:-), Meta.isbinaryoperator(:√), Meta.isbinaryoperator(:f)\n(true, false, false)\n\n\n\n\n\n"},{"title":"Base.Meta.show_sexpr","page":"Essentials","location":"base/base.html#Base.Meta.show_sexpr","category":"function","text":"Meta.show_sexpr([io::IO,], ex)\n\nShow expression ex as a lisp style S-expression.\n\nExamples\n\njulia> Meta.show_sexpr(:(f(x, g(y,z))))\n(:call, :f, :x, (:call, :g, :y, :z))\n\n\n\n\n\n"},{"title":"C Standard Library","page":"C Standard Library","location":"base/libc.html#C-Standard-Library","category":"section","text":""},{"title":"Base.Libc.malloc","page":"C Standard Library","location":"base/libc.html#Base.Libc.malloc","category":"function","text":"malloc(size::Integer)::Ptr{Cvoid}\n\nCall malloc from the C standard library.\n\n\n\n\n\n"},{"title":"Base.Libc.calloc","page":"C Standard Library","location":"base/libc.html#Base.Libc.calloc","category":"function","text":"calloc(num::Integer, size::Integer)::Ptr{Cvoid}\n\nCall calloc from the C standard library.\n\n\n\n\n\n"},{"title":"Base.Libc.realloc","page":"C Standard Library","location":"base/libc.html#Base.Libc.realloc","category":"function","text":"realloc(addr::Ptr, size::Integer)::Ptr{Cvoid}\n\nCall realloc from the C standard library.\n\nSee warning in the documentation for free regarding only using this on memory originally\nobtained from malloc.\n\n\n\n\n\n"},{"title":"Base.memcpy","page":"C Standard Library","location":"base/libc.html#Base.memcpy","category":"function","text":"memcpy(dst::Ptr, src::Ptr, n::Integer)::Ptr{Cvoid}\n\nCall memcpy from the C standard library.\n\ncompat: Julia 1.10\nSupport for memcpy requires at least Julia 1.10.\n\n\n\n\n\n"},{"title":"Base.memmove","page":"C Standard Library","location":"base/libc.html#Base.memmove","category":"function","text":"memmove(dst::Ptr, src::Ptr, n::Integer)::Ptr{Cvoid}\n\nCall memmove from the C standard library.\n\ncompat: Julia 1.10\nSupport for memmove requires at least Julia 1.10.\n\n\n\n\n\n"},{"title":"Base.memset","page":"C Standard Library","location":"base/libc.html#Base.memset","category":"function","text":"memset(dst::Ptr, val, n::Integer)::Ptr{Cvoid}\n\nCall memset from the C standard library.\n\ncompat: Julia 1.10\nSupport for memset requires at least Julia 1.10.\n\n\n\n\n\n"},{"title":"Base.memcmp","page":"C Standard Library","location":"base/libc.html#Base.memcmp","category":"function","text":"memcmp(a::Ptr, b::Ptr, n::Integer)::Int\n\nCall memcmp from the C standard library.\n\ncompat: Julia 1.10\nSupport for memcmp requires at least Julia 1.9.\n\n\n\n\n\n"},{"title":"Base.Libc.free","page":"C Standard Library","location":"base/libc.html#Base.Libc.free","category":"function","text":"free(addr::Ptr)\n\nCall free from the C standard library. Only use this on memory obtained from malloc, not\non pointers retrieved from other C libraries. Ptr objects obtained from C libraries should\nbe freed by the free functions defined in that library, to avoid assertion failures if\nmultiple libc libraries exist on the system.\n\n\n\n\n\n"},{"title":"Base.Libc.errno","page":"C Standard Library","location":"base/libc.html#Base.Libc.errno","category":"function","text":"errno([code])\n\nGet the value of the C library's errno. If an argument is specified, it is used to set the\nvalue of errno.\n\nThe value of errno is only valid immediately after a ccall to a C library routine that\nsets it. Specifically, you cannot call errno at the next prompt in a REPL, because lots of\ncode is executed between prompts.\n\n\n\n\n\n"},{"title":"Base.Libc.strerror","page":"C Standard Library","location":"base/libc.html#Base.Libc.strerror","category":"function","text":"strerror(n=errno())\n\nConvert a system call error code to a descriptive string\n\n\n\n\n\n"},{"title":"Base.Libc.GetLastError","page":"C Standard Library","location":"base/libc.html#Base.Libc.GetLastError","category":"function","text":"GetLastError()\n\nCall the Win32 GetLastError function [only available on Windows].\n\n\n\n\n\n"},{"title":"Base.Libc.FormatMessage","page":"C Standard Library","location":"base/libc.html#Base.Libc.FormatMessage","category":"function","text":"FormatMessage(n=GetLastError())\n\nConvert a Win32 system call error code to a descriptive string [only available on Windows].\n\n\n\n\n\n"},{"title":"Base.Libc.time","page":"C Standard Library","location":"base/libc.html#Base.Libc.time-Tuple{Base.Libc.TmStruct}","category":"method","text":"time(t::TmStruct)::Float64\n\nConvert a TmStruct struct to a number of seconds since the epoch.\n\n\n\n\n\n"},{"title":"Base.Libc.strftime","page":"C Standard Library","location":"base/libc.html#Base.Libc.strftime","category":"function","text":"strftime([format], time)\n\nConvert time, given as a number of seconds since the epoch or a TmStruct, to a formatted\nstring using the given format. Supported formats are the same as those in the standard C\nlibrary.\n\n\n\n\n\n"},{"title":"Base.Libc.strptime","page":"C Standard Library","location":"base/libc.html#Base.Libc.strptime","category":"function","text":"strptime([format], timestr)\n\nParse a formatted time string into a TmStruct giving the seconds, minute, hour, date, etc.\nSupported formats are the same as those in the standard C library. On some platforms,\ntimezones will not be parsed correctly. If the result of this function will be passed to\ntime to convert it to seconds since the epoch, the isdst field should be filled in\nmanually. Setting it to -1 will tell the C library to use the current system settings to\ndetermine the timezone.\n\n\n\n\n\n"},{"title":"Base.Libc.TmStruct","page":"C Standard Library","location":"base/libc.html#Base.Libc.TmStruct","category":"type","text":"TmStruct([seconds])\n\nConvert a number of seconds since the epoch to broken-down format, with fields sec, min,\nhour, mday, month, year, wday, yday, and isdst.\n\n\n\n\n\n"},{"title":"Base.Libc.FILE","page":"C Standard Library","location":"base/libc.html#Base.Libc.FILE","category":"type","text":"FILE(::Ptr)\nFILE(::IO)\n\nA libc FILE*, representing an opened file.\n\nIt can be passed as a Ptr{FILE} argument to ccall and also supports\nseek, position and close.\n\nA FILE can be constructed from an ordinary IO object, provided it is an open file. It\nmust be closed afterward.\n\nExamples\n\njulia> using Base.Libc\n\njulia> mktemp() do _, io\n           # write to the temporary file using `puts(char*, FILE*)` from libc\n           file = FILE(io)\n           ccall(:fputs, Cint, (Cstring, Ptr{FILE}), \"hello world\", file)\n           close(file)\n           # read the file again\n           seek(io, 0)\n           read(io, String)\n       end\n\"hello world\"\n\n\n\n\n\n"},{"title":"Base.Libc.dup","page":"C Standard Library","location":"base/libc.html#Base.Libc.dup","category":"function","text":"dup(src::RawFD[, target::RawFD])::RawFD\n\nDuplicate the file descriptor src so that the duplicate refers to the same OS\nresource (e.g. a file or socket). A target file descriptor may optionally\nbe passed to use for the new duplicate.\n\n\n\n\n\n"},{"title":"Base.Libc.flush_cstdio","page":"C Standard Library","location":"base/libc.html#Base.Libc.flush_cstdio","category":"function","text":"flush_cstdio()\n\nFlushes the C stdout and stderr streams (which may have been written to by external C code).\n\n\n\n\n\n"},{"title":"Base.Libc.systemsleep","page":"C Standard Library","location":"base/libc.html#Base.Libc.systemsleep","category":"function","text":"systemsleep(s::Real)\n\nSuspends execution for s seconds.\nThis function does not yield to Julia's scheduler and therefore blocks\nthe Julia thread that it is running on for the duration of the sleep time.\n\nSee also sleep.\n\n\n\n\n\n"},{"title":"Base.Libc.mkfifo","page":"C Standard Library","location":"base/libc.html#Base.Libc.mkfifo","category":"function","text":"mkfifo(path::AbstractString, [mode::Integer]) -> path\n\nMake a FIFO special file (a named pipe) at path.  Return path as-is on success.\n\nmkfifo is supported only in Unix platforms.\n\ncompat: Julia 1.11\nmkfifo requires at least Julia 1.11.\n\n\n\n\n\n"},{"title":"The Julia REPL","page":"The Julia REPL","location":"stdlib/REPL.html#The-Julia-REPL","category":"section","text":"Julia comes with a full-featured interactive command-line REPL (read-eval-print loop) built into\nthe julia executable. In addition to allowing quick and easy evaluation of Julia statements,\nit has a searchable history, tab-completion, many helpful keybindings, and dedicated help and\nshell modes. The REPL can be started by simply calling julia with no arguments or double-clicking\non the executable:\n\nusing REPL\nio = IOBuffer()\nREPL.banner(io)\nbanner = String(take!(io))\nimport Markdown\nMarkdown.parse(\"```\\n\\$ julia\\n\\n$(banner)\\njulia>\\n```\")\n\nTo exit the interactive session, type ^D – the control key together with the d key on a blank\nline – or type exit() followed by the return or enter key. The REPL greets you with a banner\nand a julia> prompt."},{"title":"The different prompt modes","page":"The Julia REPL","location":"stdlib/REPL.html#The-different-prompt-modes","category":"section","text":""},{"title":"The Julian mode","page":"The Julia REPL","location":"stdlib/REPL.html#The-Julian-mode","category":"section","text":"The REPL has five main modes of operation. The first and most common is the Julian prompt. It\nis the default mode of operation; each new line initially starts with julia>. It is here that\nyou can enter Julia expressions. Hitting return or enter after a complete expression has been\nentered will evaluate the entry and show the result of the last expression.\n\njulia> string(1 + 2)\n\"3\"\n\nThere are a number of useful features unique to interactive work. In addition to showing the result,\nthe REPL also binds the result to the variable ans. A trailing semicolon on the line can be\nused as a flag to suppress showing the result.\n\njulia> string(3 * 4);\n\njulia> ans\n\"12\"\n\nIn Julia mode, the REPL supports something called prompt pasting. This activates when pasting text\nthat starts with julia> into the REPL. In that case, only expressions starting with julia> (as\nwell as the other REPL mode prompts: shell>, help?>, pkg> ) are parsed, but others are\nremoved. This makes it possible to paste a chunk of text that has been copied from a REPL session\nwithout having to scrub away prompts and outputs. This feature is enabled by default but can be\ndisabled or enabled at will with REPL.enable_promptpaste(::Bool). If it is enabled, you can try it\nout by pasting the code block above this paragraph straight into the REPL. This feature does not\nwork on the standard Windows command prompt due to its limitation at detecting when a paste occurs.\n\nA non-nothing result of executing an expression is displayed by the REPL using the show function\nwith a specific IOContext (via display, which defaults to calling\nshow(io, MIME(\"text/plain\"), ans), which in turn defaults to show(io, ans)).\nIn particular, the :limit attribute is set to true.\nOther attributes can receive in certain show methods a default value if it's not already set,\nlike :compact.\nIt's possible, as an experimental feature, to specify the attributes used by the REPL via the\nBase.active_repl.options.iocontext dictionary (associating values to attributes). For example:\n\njulia> rand(2, 2)\n2×2 Matrix{Float64}:\n 0.8833    0.329197\n 0.719708  0.59114\n\njulia> show(IOContext(stdout, :compact => false), \"text/plain\", rand(2, 2))\n 0.43540323669187075  0.15759787870609387\n 0.2540832269192739   0.4597637838786053\njulia> Base.active_repl.options.iocontext[:compact] = false;\n\njulia> rand(2, 2)\n2×2 Matrix{Float64}:\n 0.2083967319174056  0.13330606013126012\n 0.6244375177790158  0.9777957560761545\n\nIn order to define automatically the values of this dictionary at startup time, one can use the\natreplinit function in the ~/.julia/config/startup.jl file, for example:\n\natreplinit() do repl\n    repl.options.iocontext[:compact] = false\nend"},{"title":"Help mode","page":"The Julia REPL","location":"stdlib/REPL.html#Help-mode","category":"section","text":"When the cursor is at the beginning of the line, the prompt can be changed to a help mode by typing\n?. Julia will attempt to print help or documentation for anything entered in help mode:\n\njulia> ? # upon typing ?, the prompt changes (in place) to: help?>\n\nhelp?> string\nsearch: string String Cstring Cwstring RevString randstring bytestring SubString\n\n  string(xs...)\n\n  Create a string from any values using the print function.\n\nMacros, types and variables can also be queried:\n\nhelp?> @time\n  @time\n\n  A macro to execute an expression, printing the time it took to execute, the number of allocations,\n  and the total number of bytes its execution caused to be allocated, before returning the value of the\n  expression.\n\n  See also @timev, @timed, @elapsed, and @allocated.\n\nhelp?> Int32\nsearch: Int32 UInt32\n\n  Int32 <: Signed\n\n  32-bit signed integer type.\n\nA string or regex literal searches all docstrings using apropos:\n\nhelp?> \"aprop\"\nREPL.stripmd\nBase.Docs.apropos\n\nhelp?> r\"ap..p\"\nBase.:∘\nBase.shell_escape_posixly\nDistributed.CachingPool\nREPL.stripmd\nBase.Docs.apropos\n\nAnother feature of help mode is the ability to access extended docstrings. You can do this by typing something like ??Print rather than ?Print which will display the # Extended help section from the source codes documentation.\n\nHelp mode can be exited by pressing backspace at the beginning of the line."},{"title":"Shell mode","page":"The Julia REPL","location":"stdlib/REPL.html#man-shell-mode","category":"section","text":"Just as help mode is useful for quick access to documentation, another common task is to use the\nsystem shell to execute system commands. Just as ? entered help mode when at the beginning\nof the line, a semicolon (;) will enter the shell mode. And it can be exited by pressing backspace\nat the beginning of the line.\n\njulia> ; # upon typing ;, the prompt changes (in place) to: shell>\n\nshell> echo hello\nhello\n\nnote: Note\nFor Windows users, Julia's shell mode does not expose windows shell commands.\nHence, this will fail:\n\njulia> ; # upon typing ;, the prompt changes (in place) to: shell>\n\nshell> dir\nERROR: IOError: could not spawn `dir`: no such file or directory (ENOENT)\nStacktrace!\n.......\n\nHowever, you can get access to PowerShell like this:\n\njulia> ; # upon typing ;, the prompt changes (in place) to: shell>\n\nshell> powershell\nWindows PowerShell\nCopyright (C) Microsoft Corporation. All rights reserved.\nPS C:\\Users\\elm>\n\n... and to cmd.exe like that (see the dir command):\n\njulia> ; # upon typing ;, the prompt changes (in place) to: shell>\n\nshell> cmd\nMicrosoft Windows [version 10.0.17763.973]\n(c) 2018 Microsoft Corporation. All rights reserved.\nC:\\Users\\elm>dir\n Volume in drive C has no label\n Volume Serial Number is 1643-0CD7\n  Directory of C:\\Users\\elm\n\n29/01/2020  22:15    <DIR>          .\n29/01/2020  22:15    <DIR>          ..\n02/02/2020  08:06    <DIR>          .atom"},{"title":"Pkg mode","page":"The Julia REPL","location":"stdlib/REPL.html#Pkg-mode","category":"section","text":"The Package manager mode accepts specialized commands for loading and updating packages. It is entered\nby pressing the ] key at the Julian REPL prompt and exited by pressing CTRL-C or pressing the backspace key\nat the beginning of the line. The prompt for this mode is pkg>. It supports its own help-mode, which is\nentered by pressing ? at the beginning  of the line of the pkg> prompt. The Package manager mode is\ndocumented in the Pkg manual, available at https://julialang.github.io/Pkg.jl/v1/."},{"title":"History searching","page":"The Julia REPL","location":"stdlib/REPL.html#History-searching","category":"section","text":"In all of the above modes, the executed lines get saved to a history file, which can be searched.\n To initiate an interactive search through the previous history, type ^R – the control key\ntogether with the r key.\n\nYou will be presented with an interactive history viewer. As you type your search history will be filtered;\npressing enter will insert the selected history entry into the REPL. Detailed help for the history\nsearcher is available within the REPL with the special queries ?  and ??.\n\nAll executed commands in the Julia REPL are logged into ~/.julia/logs/repl_history.jl along with a timestamp of when it was executed\nand the current REPL mode you were in. The history searcher reads this log file in order to find the commands which you previously ran.\nMultiple REPLs can write to this file at once, and every time you begin a search the newest history is fetched.\nUse of this file can be disabled at startup by passing the --history-file=no flag to Julia."},{"title":"Key bindings","page":"The Julia REPL","location":"stdlib/REPL.html#Key-bindings","category":"section","text":"The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced\nabove (^D to exit, ^R for searching), but there are many more. In addition to the\ncontrol-key, there are also meta-key bindings. These vary more by platform, but most terminals\ndefault to using alt- or option- held down with a key to send the meta-key (or can be configured\nto do so), or pressing Esc and then the key.\n\nKeybinding Description\nProgram control \n^D Exit (when buffer is empty)\n^C Interrupt or cancel\n^L Clear console screen\nReturn/Enter, ^J New line, executing if it is complete\nmeta-Return/Enter Insert new line without executing it\n? or ; Enter help or shell mode (when at start of a line)\n^R, ^S Interactive history search, described above\nCursor movement \nRight arrow, ^F Move right one character\nLeft arrow, ^B Move left one character\nctrl-Right, meta-F Move right one word\nctrl-Left, meta-B Move left one word\nHome, ^A Move to beginning of line\nEnd, ^E Move to end of line\nUp arrow, ^P Move up one line (or change to the previous history entry that matches the text before the cursor)\nDown arrow, ^N Move down one line (or change to the next history entry that matches the text before the cursor)\nShift-Arrow Key Move cursor according to the direction of the Arrow key, while activating the region (\"shift selection\")\nPage-up, meta-P Change to the previous history entry\nPage-down, meta-N Change to the next history entry\nmeta-< Change to the first history entry (of the current session if it is before the current position in history)\nmeta-> Change to the last history entry\n^-Space Set the \"mark\" in the editing region (and de-activate the region if it's active)\n^-Space ^-Space Set the \"mark\" in the editing region and make the region \"active\", i.e. highlighted\n^G De-activate the region (i.e. make it not highlighted)\n^X^X Exchange the current position with the mark\nEditing \nBackspace, ^H Delete the previous character, or the whole region when it's active\nDelete, ^D Forward delete one character (when buffer has text)\nmeta-Backspace Delete the previous word\nmeta-d Forward delete the next word\n^W Delete previous text up to the nearest whitespace\nmeta-w Copy the current region in the kill ring\nmeta-W \"Kill\" the current region, placing the text in the kill ring\n^U \"Kill\" to beginning of line, placing the text in the kill ring\n^K \"Kill\" to end of line, placing the text in the kill ring\n^Y \"Yank\" insert the text from the kill ring\nmeta-y Replace a previously yanked text with an older entry from the kill ring\n^T Transpose the characters about the cursor\nmeta-Up arrow Transpose current line with line above\nmeta-Down arrow Transpose current line with line below\nmeta-u Change the next word to uppercase\nmeta-c Change the next word to titlecase\nmeta-l Change the next word to lowercase\n^/, ^_ Undo previous editing action\n^Q Write a number in REPL and press ^Q to open editor at corresponding stackframe or method\nmeta-Left Arrow Indent the current line on the left\nmeta-Right Arrow Indent the current line on the right\nmeta-. Insert last word from previous history entry\nmeta-e Edit the current input in an editor\nHistory search \nUp arrow, ^P, ^K Move the focus one entry up\nDown arrow, ^P, ^N Move the focus one entry down\nPage up, ^B Move the focus one page up\nPage down, ^F Move the focus one page down\nmeta-< Focus on the first (oldest) history entry\nmeta-> Focus on the last (most recent) history entry\nTab Toggle selection of the currently focused entry\nEnter Accept the currently focused/selected entries\n^S Save the focused/selected entries to the clipboard or a file\n^C, ^D, ^G Abort the history search"},{"title":"Customizing keybindings","page":"The Julia REPL","location":"stdlib/REPL.html#Customizing-keybindings","category":"section","text":"Julia's REPL keybindings may be fully customized to a user's preferences by passing a dictionary\nto REPL.setup_interface. The keys of this dictionary may be characters or strings. The key\n'*' refers to the default action. Control plus character x bindings are indicated with \"^x\".\nMeta plus x can be written \"\\\\M-x\" or \"\\ex\", and Control plus x can be written\n\"\\\\C-x\" or \"^x\".\nThe values of the custom keymap must be nothing (indicating\nthat the input should be ignored) or functions that accept the signature\n(PromptState, AbstractREPL, Char).\nThe REPL.setup_interface function must be called before the REPL is initialized, by registering\nthe operation with atreplinit . For example, to bind the up and down arrow keys to move through\nhistory without prefix search, one could put the following code in ~/.julia/config/startup.jl:\n\nimport REPL\nimport REPL.LineEdit\n\nconst mykeys = Dict{Any,Any}(\n    # Up Arrow\n    \"\\e[A\" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_prev(s, LineEdit.mode(s).hist)),\n    # Down Arrow\n    \"\\e[B\" => (s,o...)->(LineEdit.edit_move_down(s) || LineEdit.history_next(s, LineEdit.mode(s).hist))\n)\n\nfunction customize_keys(repl)\n    repl.interface = REPL.setup_interface(repl; extra_repl_keymap = mykeys)\nend\n\natreplinit(customize_keys)\n\nUsers should refer to LineEdit.jl to discover the available actions on key input."},{"title":"Automatic bracket insertion","page":"The Julia REPL","location":"stdlib/REPL.html#Automatic-bracket-insertion","category":"section","text":"The Julia REPL supports automatically inserting closing brackets, parentheses, braces, and quotes\nwhen you type the opening character.\n\nWhen enabled, typing an opening bracket (, {, or [ will automatically insert the matching\nclosing bracket ), }, or ] and position the cursor between them. The same behavior applies\nto quotes (\", ', and ). If you then type the closing character, the REPL will skip over\nthe auto-inserted character instead of inserting a duplicate. Additionally, pressing backspace\nimmediately after auto-insertion will remove both the opening and closing characters.\n\nTo disable this feature, add the following to your ~/.julia/config/startup.jl file:\n\natreplinit() do repl\n    # Robust against older julia versions\n    if hasfield(typeof(repl.options), :auto_insert_closing_bracket)\n        repl.options.auto_insert_closing_bracket = false\n    end\nend"},{"title":"Tab completion","page":"The Julia REPL","location":"stdlib/REPL.html#Tab-completion","category":"section","text":"In the Julian, pkg and help modes of the REPL, one can enter the first few characters of a function\nor type and then press the tab key to get a list all matches:\n\njulia> x[TAB]\njulia> xor\n\nIn some cases it only completes part of the name, up to the next ambiguity:\n\njulia> mapf[TAB]\njulia> mapfold\n\nIf you hit tab again, then you get the list of things that might complete this:\n\njulia> mapfold[TAB]\nmapfoldl mapfoldr\n\nWhen a single complete tab-complete result is available at the end of an input line and 2 or more characters\nhave been typed, a hint of the completion will show in a lighter color.\nThis can be disabled via Base.active_repl.options.hint_tab_completes = false or by adding\n\natreplinit() do repl\n    if VERSION >= v\"1.11.0-0\"\n        repl.options.hint_tab_completes = false\n    end\nend\n\nto your ~/.julia/config/startup.jl.\n\ncompat: Julia 1.11\nTab-complete hinting was added in Julia 1.11\n\nLike other components of the REPL, the search is case-sensitive:\n\njulia> stri[TAB]\nstride     strides     string      strip\n\njulia> Stri[TAB]\nStridedArray    StridedMatrix    StridedVecOrMat  StridedVector    String\n\nThe tab key can also be used to substitute LaTeX math symbols with their Unicode equivalents,\nand get a list of LaTeX matches as well:\n\njulia> \\pi[TAB]\njulia> π\nπ = 3.1415926535897...\n\njulia> e\\_1[TAB] = [1,0]\njulia> e₁ = [1,0]\n2-element Vector{Int64}:\n 1\n 0\n\njulia> e\\^1[TAB] = [1 0]\njulia> e¹ = [1 0]\n1×2 Matrix{Int64}:\n 1  0\n\njulia> \\sqrt[TAB]2     # √ is equivalent to the sqrt function\njulia> √2\n1.4142135623730951\n\njulia> \\hbar[TAB](h) = h / 2\\pi[TAB]\njulia> ħ(h) = h / 2π\nħ (generic function with 1 method)\n\njulia> \\h[TAB]\n\\hat              \\hermitconjmatrix  \\hkswarow          \\hrectangle\n\\hatapprox        \\hexagon           \\hookleftarrow     \\hrectangleblack\n\\hbar             \\hexagonblack      \\hookrightarrow    \\hslash\n\\heartsuit        \\hksearow          \\house             \\hspace\n\njulia> α=\"\\alpha[TAB]\"   # LaTeX completion also works in strings\njulia> α=\"α\"\n\nA full list of tab-completions can be found in the Unicode Input section of the manual.\n\nCompletion of paths works for strings and julia's shell mode:\n\njulia> path=\"/[TAB]\"\n.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/\n.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/\nshell> /[TAB]\n.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/\n.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/\n\nDictionary keys can also be tab completed:\n\njulia> foo = Dict(\"qwer1\"=>1, \"qwer2\"=>2, \"asdf\"=>3)\nDict{String,Int64} with 3 entries:\n  \"qwer2\" => 2\n  \"asdf\"  => 3\n  \"qwer1\" => 1\n\njulia> foo[\"q[TAB]\n\n\"qwer1\" \"qwer2\"\njulia> foo[\"qwer\n\nTab completion can also help completing fields:\n\njulia> x = 3 + 4im;\n\njulia> x.[TAB][TAB]\nim re\n\njulia> import UUIDs\n\njulia> UUIDs.uuid[TAB][TAB]\nuuid1        uuid4         uuid5        uuid_version\n\nFields for output from functions can also be completed:\n\njulia> split(\"\",\"\")[1].[TAB]\nlastindex  offset  string\n\nThe completion of fields for output from functions uses type inference, and it can only suggest\nfields if the function is type stable.\n\nTab completion can help with investigation of the available methods matching the input arguments:\n\njulia> max([TAB] # All methods are displayed, not shown here due to size of the list\n\njulia> max([1, 2], [TAB] # All methods where `Vector{Int}` matches as first argument\nmax(x, y) in Base at operators.jl:215\nmax(a, b, c, xs...) in Base at operators.jl:281\n\njulia> max([1, 2], max(1, 2), [TAB] # All methods matching the arguments.\nmax(x, y) in Base at operators.jl:215\nmax(a, b, c, xs...) in Base at operators.jl:281\n\nKeywords are also displayed in the suggested methods after ;, see below line where limit\nand keepempty are keyword arguments:\n\njulia> split(\"1 1 1\", [TAB]\nsplit(str::AbstractString; limit, keepempty) in Base at strings/util.jl:302\nsplit(str::T, splitter; limit, keepempty) where T<:AbstractString in Base at strings/util.jl:277\n\nThe completion of the methods uses type inference and can therefore see if the arguments match\neven if the arguments are output from functions. The function needs to be type stable for the\ncompletion to be able to remove non-matching methods.\n\nIf you wonder which methods can be used with particular argument types, use ? as the function name.\nThis shows an example of looking for functions in InteractiveUtils that accept a single string:\n\njulia> InteractiveUtils.?(\"somefile\")[TAB]\nedit(path::AbstractString) in InteractiveUtils at InteractiveUtils/src/editless.jl:197\nless(file::AbstractString) in InteractiveUtils at InteractiveUtils/src/editless.jl:266\n\nThis listed methods in the InteractiveUtils module that can be called on a string.\nBy default, this excludes methods where all arguments are typed as Any,\nbut you can see those too by holding down SHIFT-TAB instead of TAB:\n\njulia> InteractiveUtils.?(\"somefile\")[SHIFT-TAB]\napropos(string) in REPL at REPL/src/docview.jl:796\nclipboard(x) in InteractiveUtils at InteractiveUtils/src/clipboard.jl:64\ncode_llvm(f) in InteractiveUtils at InteractiveUtils/src/codeview.jl:221\ncode_native(f) in InteractiveUtils at InteractiveUtils/src/codeview.jl:243\nedit(path::AbstractString) in InteractiveUtils at InteractiveUtils/src/editless.jl:197\nedit(f) in InteractiveUtils at InteractiveUtils/src/editless.jl:225\neval(x) in InteractiveUtils at InteractiveUtils/src/InteractiveUtils.jl:3\ninclude(x) in InteractiveUtils at InteractiveUtils/src/InteractiveUtils.jl:3\nless(file::AbstractString) in InteractiveUtils at InteractiveUtils/src/editless.jl:266\nless(f) in InteractiveUtils at InteractiveUtils/src/editless.jl:274\nreport_bug(kind) in InteractiveUtils at InteractiveUtils/src/InteractiveUtils.jl:391\nseparate_kwargs(args...; kwargs...) in InteractiveUtils at InteractiveUtils/src/macros.jl:7\n\nYou can also use ?(\"somefile\")[TAB]  and look across all modules, but the method lists can be long.\n\nBy omitting the closing parenthesis, you can include functions that might require additional arguments:\n\njulia> using Mmap\n\nhelp?> Mmap.?(\"file\",[TAB]\nMmap.Anonymous(name::String, readonly::Bool, create::Bool) in Mmap at Mmap/src/Mmap.jl:16\nmmap(file::AbstractString) in Mmap at Mmap/src/Mmap.jl:245\nmmap(file::AbstractString, ::Type{T}) where T<:Array in Mmap at Mmap/src/Mmap.jl:245\nmmap(file::AbstractString, ::Type{T}, dims::Tuple{Vararg{Integer, N}}) where {T<:Array, N} in Mmap at Mmap/src/Mmap.jl:245\nmmap(file::AbstractString, ::Type{T}, dims::Tuple{Vararg{Integer, N}}, offset::Integer; grow, shared) where {T<:Array, N} in Mmap at Mmap/src/Mmap.jl:245\nmmap(file::AbstractString, ::Type{T}, len::Integer) where T<:Array in Mmap at Mmap/src/Mmap.jl:251\nmmap(file::AbstractString, ::Type{T}, len::Integer, offset::Integer; grow, shared) where T<:Array in Mmap at Mmap/src/Mmap.jl:251\nmmap(file::AbstractString, ::Type{T}, dims::Tuple{Vararg{Integer, N}}) where {T<:BitArray, N} in Mmap at Mmap/src/Mmap.jl:316\nmmap(file::AbstractString, ::Type{T}, dims::Tuple{Vararg{Integer, N}}, offset::Integer; grow, shared) where {T<:BitArray, N} in Mmap at Mmap/src/Mmap.jl:316\nmmap(file::AbstractString, ::Type{T}, len::Integer) where T<:BitArray in Mmap at Mmap/src/Mmap.jl:322\nmmap(file::AbstractString, ::Type{T}, len::Integer, offset::Integer; grow, shared) where T<:BitArray in Mmap at Mmap/src/Mmap.jl:322"},{"title":"Syntax Highlighting","page":"The Julia REPL","location":"stdlib/REPL.html#Syntax-Highlighting","category":"section","text":"The REPL provides syntax highlighting for input as you type.\nSyntax highlighting is enabled by default but can be disabled in your ~/.julia/config/startup.jl:\n\natreplinit() do repl\n    repl.options.style_input = false\nend"},{"title":"Customizing Syntax Highlighting Colors","page":"The Julia REPL","location":"stdlib/REPL.html#Customizing-Syntax-Highlighting-Colors","category":"section","text":"The default syntax highlighting theme is quite conservative but can be customized using a TOML file faces.toml (https://julialang.github.io/StyledStrings.jl/dev/#stdlib-styledstrings-face-toml) in .julia/config (or by explicitly loading the faces from a face toml file).\n\ndetails: Example: Monokai color theme (click to expand)\n\n# Monokai color theme for Julia syntax highlighting\n\n[julia_macro]\nforeground = \"#A6E22E\"\n\n[julia_symbol]\nforeground = \"#AE81FF\"\n\n[julia_singleton_identifier]\ninherit = \"julia_symbol\"\n\n[julia_type]\nforeground = \"#66D9EF\"\n\n[julia_typedec]\nforeground = \"#66D9EF\"\nweight = \"bold\"\n\n[julia_comment]\nforeground = \"#75715E\"\nitalic = true\n\n[julia_string]\nforeground = \"#E6DB74\"\n\n[julia_regex]\ninherit = \"julia_string\"\n\n[julia_backslash_literal]\nforeground = \"#FD971F\"\ninherit = \"julia_string\"\n\n[julia_string_delim]\nforeground = \"#E6DB74\"\nweight = \"bold\"\n\n[julia_cmdstring]\ninherit = \"julia_string\"\n\n[julia_char]\ninherit = \"julia_string\"\n\n[julia_char_delim]\ninherit = \"julia_string_delim\"\n\n[julia_number]\nforeground = \"#AE81FF\"\n\n[julia_bool]\nforeground = \"#AE81FF\"\nweight = \"bold\"\n\n[julia_funcall]\nforeground = \"#A6E22E\"\n\n[julia_broadcast]\nforeground = \"#F92672\"\nweight = \"bold\"\n\n[julia_builtin]\nforeground = \"#66D9EF\"\nweight = \"bold\"\n\n[julia_operator]\nforeground = \"#F92672\"\n\n[julia_comparator]\ninherit = \"julia_operator\"\n\n[julia_assignment]\nforeground = \"#F92672\"\nweight = \"bold\"\n\n[julia_keyword]\nforeground = \"#F92672\"\nweight = \"bold\"\n\n[julia_parentheses]\nforeground = \"#F8F8F2\"\n\n[julia_unpaired_parentheses]\nbackground = \"#F92672\"\nforeground = \"#F8F8F0\"\nweight = \"bold\"\n\n[julia_error]\nbackground = \"#F92672\"\nforeground = \"#F8F8F0\"\n\n[julia_rainbow_paren_1]\nforeground = \"#A6E22E\"\ninherit = \"julia_parentheses\"\n\n[julia_rainbow_paren_2]\nforeground = \"#66D9EF\"\ninherit = \"julia_parentheses\"\n\n[julia_rainbow_paren_3]\nforeground = \"#FD971F\"\ninherit = \"julia_parentheses\"\n\n[julia_rainbow_paren_4]\ninherit = \"julia_rainbow_paren_1\"\n\n[julia_rainbow_paren_5]\ninherit = \"julia_rainbow_paren_2\"\n\n[julia_rainbow_paren_6]\ninherit = \"julia_rainbow_paren_3\"\n\n# Rainbow brackets\n[julia_rainbow_bracket_1]\nforeground = \"#AE81FF\"\ninherit = \"julia_parentheses\"\n\n[julia_rainbow_bracket_2]\nforeground = \"#E6DB74\"\ninherit = \"julia_parentheses\"\n\n[julia_rainbow_bracket_3]\ninherit = \"julia_rainbow_bracket_1\"\n\n[julia_rainbow_bracket_4]\ninherit = \"julia_rainbow_bracket_2\"\n\n[julia_rainbow_bracket_5]\ninherit = \"julia_rainbow_bracket_1\"\n\n[julia_rainbow_bracket_6]\ninherit = \"julia_rainbow_bracket_2\"\n\n# Rainbow curlies\n[julia_rainbow_curly_1]\nforeground = \"#F92672\"\ninherit = \"julia_parentheses\"\n\n[julia_rainbow_curly_2]\nforeground = \"#A6E22E\"\ninherit = \"julia_parentheses\"\n\n[julia_rainbow_curly_3]\ninherit = \"julia_rainbow_curly_1\"\n\n[julia_rainbow_curly_4]\ninherit = \"julia_rainbow_curly_2\"\n\n[julia_rainbow_curly_5]\ninherit = \"julia_rainbow_curly_1\"\n\n[julia_rainbow_curly_6]\ninherit = \"julia_rainbow_curly_2\"\n\nFor a complete list of customizable faces, see the JuliaSyntaxHighlighting package documentation."},{"title":"Customising the history searcher","page":"The Julia REPL","location":"stdlib/REPL.html#Customising-the-history-searcher","category":"section","text":"The history searcher uses the following default faces, that can be customised:\n\n[REPL.History.search]\nseparator.fg  = \"blue\"\nprefix.fg = \"magenta\"\nselected.fg = \"blue\"\nunselected.fg = \"grey\"\nhint = { fg = \"magenta\", slant = \"italic\", weight =\"light\" }\nresults.inherit = \"shadow\"\nmatch = { weight = \"bold\", underline = true }"},{"title":"Customizing Colors","page":"The Julia REPL","location":"stdlib/REPL.html#Customizing-Colors","category":"section","text":"The colors used by Julia and the REPL can be customized, as well. To change the\ncolor of the Julia prompt you can add something like the following to your\n~/.julia/config/startup.jl file, which is to be placed inside your home directory:\n\nfunction customize_colors(repl)\n    repl.prompt_color = Base.text_colors[:cyan]\nend\n\natreplinit(customize_colors)\n\nThe available color keys can be seen by typing Base.text_colors in the help mode of the REPL.\nIn addition, the integers 0 to 255 can be used as color keys for terminals\nwith 256 color support.\n\nYou can also change the colors for the help and shell prompts and\ninput and answer text by setting the appropriate field of repl in the customize_colors function\nabove (respectively, help_color, shell_color, input_color, and answer_color). For the\nlatter two, be sure that the envcolors field is also set to false.\n\nIt is also possible to apply boldface formatting by using\nBase.text_colors[:bold] as a color. For instance, to print answers in\nboldface font, one can use the following as a ~/.julia/config/startup.jl:\n\nfunction customize_colors(repl)\n    repl.envcolors = false\n    repl.answer_color = Base.text_colors[:bold]\nend\n\natreplinit(customize_colors)\n\nYou can also customize the color used to render warning and informational messages by\nsetting the appropriate environment variables. For instance, to render error, warning, and informational\nmessages respectively in magenta, yellow, and cyan you can add the following to your\n~/.julia/config/startup.jl file:\n\nENV[\"JULIA_ERROR_COLOR\"] = :magenta\nENV[\"JULIA_WARN_COLOR\"] = :yellow\nENV[\"JULIA_INFO_COLOR\"] = :cyan"},{"title":"Changing the contextual module which is active at the REPL","page":"The Julia REPL","location":"stdlib/REPL.html#Changing-the-contextual-module-which-is-active-at-the-REPL","category":"section","text":"When entering expressions at the REPL, they are by default evaluated in the Main module;\n\njulia> @__MODULE__\nMain\n\nIt is possible to change this contextual module via the function\nREPL.activate(m) where m is a Module or by typing the module in the REPL\nand pressing the keybinding Alt-m with the cursor on the module name (Esc-m on MacOS).\nPressing the keybinding on an empty prompt toggles the context between the previously active\nnon-Main module and Main. The active module is shown in the prompt (unless it is Main):\n\njulia> using REPL\n\njulia> REPL.activate(Base)\n\n(Base) julia> @__MODULE__\nBase\n\n(Base) julia> using REPL # Need to load REPL into Base module to use it\n\n(Base) julia> REPL.activate(Main)\n\njulia>\n\njulia> Core<Alt-m> # using the keybinding to change module\n\n(Core) julia>\n\n(Core) julia> <Alt-m> # going back to Main via keybinding\n\njulia>\n\njulia> <Alt-m> # going back to previously-active Core via keybinding\n\n(Core) julia>\n\nFunctions that take an optional module argument often defaults to the REPL\ncontext module. As an example, calling varinfo() will show the variables of\nthe current active module:\n\njulia> module CustomMod\n           export var, f\n           var = 1\n           f(x) = x^2\n       end;\n\njulia> REPL.activate(CustomMod)\n\n(Main.CustomMod) julia> varinfo()\n  name         size summary\n  ––––––––– ––––––– ––––––––––––––––––––––––––––––––––\n  CustomMod         Module\n  f         0 bytes f (generic function with 1 method)\n  var       8 bytes Int64"},{"title":"Numbered prompt","page":"The Julia REPL","location":"stdlib/REPL.html#Numbered-prompt","category":"section","text":"It is possible to get an interface which is similar to the IPython REPL and the Mathematica notebook with numbered input prompts and output prefixes. This is done by calling REPL.numbered_prompt!(). If you want to have this enabled on startup, add\n\natreplinit() do repl\n    @eval import REPL\n    if !isdefined(repl, :interface)\n        repl.interface = REPL.setup_interface(repl)\n    end\n    REPL.numbered_prompt!(repl)\nend\n\nto your startup.jl file. In numbered prompt the variable Out[n] (where n is an integer) can be used to refer to earlier results:\n\nIn [1]: 5 + 3\nOut[1]: 8\n\nIn [2]: Out[1] + 5\nOut[2]: 13\n\nIn [3]: Out\nOut[3]: Dict{Int64, Any} with 2 entries:\n  2 => 13\n  1 => 8\n\nnote: Note\nSince all outputs from previous REPL evaluations are saved in the Out variable, one should be careful if they are returning many\nlarge in-memory objects like arrays, since they will be protected from garbage collection so long as a reference to them remains in\nOut. If you need to remove references to objects in Out, you can clear the entire history it stores with empty!(Out), or clear\nan individual entry with Out[n] = nothing."},{"title":"TerminalMenus","page":"The Julia REPL","location":"stdlib/REPL.html#TerminalMenus","category":"section","text":"TerminalMenus is a submodule of the Julia REPL and enables small, low-profile interactive menus in the terminal."},{"title":"Examples","page":"The Julia REPL","location":"stdlib/REPL.html#Examples","category":"section","text":"import REPL\nusing REPL.TerminalMenus\n\noptions = [\"apple\", \"orange\", \"grape\", \"strawberry\",\n            \"blueberry\", \"peach\", \"lemon\", \"lime\"]\n"},{"title":"RadioMenu","page":"The Julia REPL","location":"stdlib/REPL.html#RadioMenu","category":"section","text":"The RadioMenu allows the user to select one option from the list. The request\nfunction displays the interactive menu and returns the index of the selected\nchoice. If a user presses 'q' or ctrl-c, request will return a -1.\n\n# `pagesize` is the number of items to be displayed at a time.\n#  The UI will scroll if the number of options is greater\n#   than the `pagesize`\nmenu = RadioMenu(options, pagesize=4)\n\n# `request` displays the menu and returns the index after the\n#   user has selected a choice\nchoice = request(\"Choose your favorite fruit:\", menu)\n\nif choice != -1\n    println(\"Your favorite fruit is \", options[choice], \"!\")\nelse\n    println(\"Menu canceled.\")\nend\n\n\nOutput:\n\nChoose your favorite fruit:\n^  grape\n   strawberry\n > blueberry\nv  peach\nYour favorite fruit is blueberry!"},{"title":"MultiSelectMenu","page":"The Julia REPL","location":"stdlib/REPL.html#MultiSelectMenu","category":"section","text":"The MultiSelectMenu allows users to select many choices from a list.\n\n# here we use the default `pagesize` 10\nmenu = MultiSelectMenu(options)\n\n# `request` returns a `Set` of selected indices\n# if the menu us canceled (ctrl-c or q), return an empty set\nchoices = request(\"Select the fruits you like:\", menu)\n\nif length(choices) > 0\n    println(\"You like the following fruits:\")\n    for i in choices\n        println(\"  - \", options[i])\n    end\nelse\n    println(\"Menu canceled.\")\nend\n\nOutput:\n\nSelect the fruits you like:\n[press: Enter=toggle, a=all, n=none, d=done, q=abort]\n   [ ] apple\n > [X] orange\n   [X] grape\n   [ ] strawberry\n   [ ] blueberry\n   [X] peach\n   [ ] lemon\n   [ ] lime\nYou like the following fruits:\n  - orange\n  - grape\n  - peach"},{"title":"Customization / Configuration","page":"The Julia REPL","location":"stdlib/REPL.html#Customization-/-Configuration","category":"section","text":""},{"title":"ConfiguredMenu subtypes","page":"The Julia REPL","location":"stdlib/REPL.html#ConfiguredMenu-subtypes","category":"section","text":"Starting with Julia 1.6, the recommended way to configure menus is via the constructor.\nFor instance, the default multiple-selection menu\n\njulia> menu = MultiSelectMenu(options, pagesize=5);\n\njulia> request(menu) # ASCII is used by default\n[press: Enter=toggle, a=all, n=none, d=done, q=abort]\n   [ ] apple\n   [X] orange\n   [ ] grape\n > [X] strawberry\nv  [ ] blueberry\n\ncan instead be rendered with Unicode selection and navigation characters with\n\njulia> menu = MultiSelectMenu(options, pagesize=5, charset=:unicode);\n\njulia> request(menu)\n[press: Enter=toggle, a=all, n=none, d=done, q=abort]\n   ⬚ apple\n   ✓ orange\n   ⬚ grape\n → ✓ strawberry\n↓  ⬚ blueberry\n\nMore fine-grained configuration is also possible:\n\njulia> menu = MultiSelectMenu(options, pagesize=5, charset=:unicode, checked=\"YEP!\", unchecked=\"NOPE\", cursor='⧐');\n\njulia> request(menu)\njulia> request(menu)\n[press: Enter=toggle, a=all, n=none, d=done, q=abort]\n   NOPE apple\n   YEP! orange\n   NOPE grape\n ⧐ YEP! strawberry\n↓  NOPE blueberry\n\nAside from the overall charset option, for RadioMenu the configurable options are:\n\ncursor::Char='>'|'→': character to use for cursor\nup_arrow::Char='^'|'↑': character to use for up arrow\ndown_arrow::Char='v'|'↓': character to use for down arrow\nupdown_arrow::Char='I'|'↕': character to use for up/down arrow in one-line page\nscroll_wrap::Bool=false: optionally wrap-around at the beginning/end of a menu\nctrl_c_interrupt::Bool=true: If false, return empty on ^C, if true throw InterruptException() on ^C\n\nMultiSelectMenu adds:\n\nchecked::String=\"[X]\"|\"✓\": string to use for checked\nunchecked::String=\"[ ]\"|\"⬚\"): string to use for unchecked\n\nYou can create new menu types of your own.\nTypes that are derived from TerminalMenus.ConfiguredMenu configure the menu options at construction time."},{"title":"Legacy interface","page":"The Julia REPL","location":"stdlib/REPL.html#Legacy-interface","category":"section","text":"Prior to Julia 1.6, and still supported throughout Julia 1.x, one can also configure menus by calling\nTerminalMenus.config()."},{"title":"References","page":"The Julia REPL","location":"stdlib/REPL.html#References","category":"section","text":""},{"title":"REPL","page":"The Julia REPL","location":"stdlib/REPL.html#REPL","category":"section","text":""},{"title":"TerminalMenus","page":"The Julia REPL","location":"stdlib/REPL.html#TerminalMenus-2","category":"section","text":""},{"title":"Menus","page":"The Julia REPL","location":"stdlib/REPL.html#Menus","category":"section","text":""},{"title":"Configuration","page":"The Julia REPL","location":"stdlib/REPL.html#Configuration","category":"section","text":""},{"title":"User interaction","page":"The Julia REPL","location":"stdlib/REPL.html#User-interaction","category":"section","text":""},{"title":"AbstractMenu extension interface","page":"The Julia REPL","location":"stdlib/REPL.html#AbstractMenu-extension-interface","category":"section","text":"Any subtype of AbstractMenu must be mutable, and must contain the fields pagesize::Int and\npageoffset::Int.\nAny subtype must also implement the following functions:\n\nIt must also implement either options or numoptions:\n\nIf the subtype does not have a field named selected, it must also implement\n\nThe following are optional but can allow additional customization:"},{"title":"Base.atreplinit","page":"The Julia REPL","location":"stdlib/REPL.html#Base.atreplinit","category":"function","text":"atreplinit(f)\n\nRegister a one-argument function to be called before the REPL interface is initialized in\ninteractive sessions; this is useful to customize the interface. The argument of f is the\nREPL object. This function should be called from within the .julia/config/startup.jl\ninitialization file.\n\n\n\n\n\n"},{"title":"REPL.TerminalMenus.RadioMenu","page":"The Julia REPL","location":"stdlib/REPL.html#REPL.TerminalMenus.RadioMenu","category":"type","text":"RadioMenu\n\nA menu that allows a user to select a single option from a list.\n\nSample Output\n\njulia> request(RadioMenu(options, pagesize=4))\nChoose your favorite fruit:\n^  grape\n   strawberry\n > blueberry\nv  peach\nYour favorite fruit is blueberry!\n\n\n\n\n\n"},{"title":"REPL.TerminalMenus.MultiSelectMenu","page":"The Julia REPL","location":"stdlib/REPL.html#REPL.TerminalMenus.MultiSelectMenu","category":"type","text":"MultiSelectMenu\n\nA menu that allows a user to select a multiple options from a list.\n\nSample Output\n\njulia> request(MultiSelectMenu(options))\nSelect the fruits you like:\n[press: Enter=toggle, a=all, n=none, d=done, q=abort]\n   [ ] apple\n > [X] orange\n   [X] grape\n   [ ] strawberry\n   [ ] blueberry\n   [X] peach\n   [ ] lemon\n   [ ] lime\nYou like the following fruits:\n  - orange\n  - grape\n  - peach\n\n\n\n\n\n"},{"title":"REPL.TerminalMenus.Config","page":"The Julia REPL","location":"stdlib/REPL.html#REPL.TerminalMenus.Config","category":"type","text":"Config(; scroll_wrap=false, ctrl_c_interrupt=true, charset=:ascii, cursor::Char, up_arrow::Char, down_arrow::Char)\n\nConfigure behavior for selection menus via keyword arguments:\n\nscroll_wrap, if true, causes the menu to wrap around when scrolling above the first\nor below the last entry\nctrl_c_interrupt, if true, throws an InterruptException if the user hits Ctrl-C\nduring menu selection. If false, TerminalMenus.request will return the\ndefault result from TerminalMenus.selected.\ncharset affects the default values for cursor, up_arrow, and down_arrow,\nand can be :ascii or :unicode\ncursor is the character printed to indicate the option that will be chosen by\nhitting \"Enter.\" Defaults are '>' or '→', depending on charset.\nup_arrow is the character printed when the display does not include the first entry.\nDefaults are '^' or '↑', depending on charset.\ndown_arrow is the character printed when the display does not include the last entry.\nDefaults are 'v' or '↓', depending on charset.\n\nSubtypes of ConfiguredMenu will print cursor, up_arrow, and down_arrow automatically\nas needed, your writeline method should not print them.\n\ncompat: Julia 1.6\nConfig is available as of Julia 1.6. On older releases use the global CONFIG.\n\n\n\n\n\n"},{"title":"REPL.TerminalMenus.MultiSelectConfig","page":"The Julia REPL","location":"stdlib/REPL.html#REPL.TerminalMenus.MultiSelectConfig","category":"type","text":"MultiSelectConfig(; charset=:ascii, checked::String, unchecked::String, kwargs...)\n\nConfigure behavior for a multiple-selection menu via keyword arguments:\n\nchecked is the string to print when an option has been selected.\nDefaults are \"[X]\" or \"✓\", depending on charset.\nunchecked is the string to print when an option has not been selected.\nDefaults are \"[ ]\" or \"⬚\", depending on charset.\n\nAll other keyword arguments are as described for TerminalMenus.Config.\nchecked and unchecked are not printed automatically, and should be printed by\nyour writeline method.\n\ncompat: Julia 1.6\nMultiSelectConfig is available as of Julia 1.6. On older releases use the global CONFIG.\n\n\n\n\n\n"},{"title":"REPL.TerminalMenus.config","page":"The Julia REPL","location":"stdlib/REPL.html#REPL.TerminalMenus.config","category":"function","text":"config( <see arguments> )\n\nKeyword-only function to configure global menu parameters\n\nArguments\n\ncharset::Symbol=:na: ui characters to use (:ascii or :unicode); overridden by other arguments\ncursor::Char='>'|'→': character to use for cursor\nup_arrow::Char='^'|'↑': character to use for up arrow\ndown_arrow::Char='v'|'↓': character to use for down arrow\nchecked::String=\"[X]\"|\"✓\": string to use for checked\nunchecked::String=\"[ ]\"|\"⬚\"): string to use for unchecked\nscroll::Symbol=:nowrap: If :wrap wrap cursor around top and bottom, if :nowrap do not wrap cursor\nsupress_output::Bool=false: Ignored legacy argument, pass suppress_output as a keyword argument to request instead.\nctrl_c_interrupt::Bool=true: If false, return empty on ^C, if true throw InterruptException() on ^C\n\ncompat: Julia 1.6\nAs of Julia 1.6, config is deprecated. Use Config or MultiSelectConfig instead.\n\n\n\n\n\n"},{"title":"REPL.TerminalMenus.request","page":"The Julia REPL","location":"stdlib/REPL.html#REPL.TerminalMenus.request","category":"function","text":"request(m::AbstractMenu; cursor=1)\n\nDisplay the menu and enter interactive mode. cursor indicates the item\nnumber used for the initial cursor position. cursor can be either an\nInt or a RefValue{Int}. The latter is useful for observation and\ncontrol of the cursor position from the outside.\n\nReturns selected(m).\n\ncompat: Julia 1.6\nThe cursor argument requires Julia 1.6 or later.\n\n\n\n\n\nrequest([term,] msg::AbstractString, m::AbstractMenu)\n\nShorthand for println(msg); request(m).\n\n\n\n\n\n"},{"title":"REPL.TerminalMenus.pick","page":"The Julia REPL","location":"stdlib/REPL.html#REPL.TerminalMenus.pick","category":"function","text":"pick(m::AbstractMenu, cursor::Int)\n\nDefines what happens when a user presses the Enter key while the menu is open.\nIf true is returned, request() will exit.\ncursor indexes the position of the selection.\n\n\n\n\n\n"},{"title":"REPL.TerminalMenus.cancel","page":"The Julia REPL","location":"stdlib/REPL.html#REPL.TerminalMenus.cancel","category":"function","text":"cancel(m::AbstractMenu)\n\nDefine what happens when a user cancels ('q' or ctrl-c) a menu.\nrequest() will always exit after calling this function.\n\n\n\n\n\n"},{"title":"REPL.TerminalMenus.writeline","page":"The Julia REPL","location":"stdlib/REPL.html#REPL.TerminalMenus.writeline","category":"function","text":"writeline(buf::IO, m::AbstractMenu, idx::Int, iscursor::Bool)\n\nWrite the option at index idx to buf. iscursor, if true, indicates that this\nitem is at the current cursor position (the one that will be selected by hitting \"Enter\").\n\nIf m is a ConfiguredMenu, TerminalMenus will print the cursor indicator.\nOtherwise the callee is expected to handle such printing.\n\ncompat: Julia 1.6\nwriteline requires Julia 1.6 or higher.On older versions of Julia, this was\n    writeLine(buf::IO, m::AbstractMenu, idx, iscursor::Bool)\nand m is assumed to be unconfigured. The selection and cursor indicators can be\nobtained from TerminalMenus.CONFIG.This older function is supported on all Julia 1.x versions but will be dropped in Julia 2.0.\n\n\n\n\n\n"},{"title":"REPL.TerminalMenus.options","page":"The Julia REPL","location":"stdlib/REPL.html#REPL.TerminalMenus.options","category":"function","text":"options(m::AbstractMenu)\n\nReturn a list of strings to be displayed as options in the current page.\n\nAlternatively, implement numoptions, in which case options is not needed.\n\n\n\n\n\n"},{"title":"REPL.TerminalMenus.numoptions","page":"The Julia REPL","location":"stdlib/REPL.html#REPL.TerminalMenus.numoptions","category":"function","text":"numoptions(m::AbstractMenu)::Int\n\nReturn the number of options in menu m. Defaults to length(options(m)).\n\ncompat: Julia 1.6\nThis function requires Julia 1.6 or later.\n\n\n\n\n\n"},{"title":"REPL.TerminalMenus.selected","page":"The Julia REPL","location":"stdlib/REPL.html#REPL.TerminalMenus.selected","category":"function","text":"selected(m::AbstractMenu)\n\nReturn information about the user-selected option.\nBy default it returns m.selected.\n\n\n\n\n\n"},{"title":"REPL.TerminalMenus.header","page":"The Julia REPL","location":"stdlib/REPL.html#REPL.TerminalMenus.header","category":"function","text":"header(m::AbstractMenu)::String\n\nReturn a header string to be printed above the menu.\nDefaults to \"\".\n\n\n\n\n\n"},{"title":"REPL.TerminalMenus.keypress","page":"The Julia REPL","location":"stdlib/REPL.html#REPL.TerminalMenus.keypress","category":"function","text":"keypress(m::AbstractMenu, i::UInt32)::Bool\n\nHandle any non-standard keypress event.\nIf true is returned, TerminalMenus.request will exit.\nDefaults to false.\n\n\n\n\n\n"},{"title":"Network Options","page":"Network Options","location":"stdlib/NetworkOptions.html#Network-Options","category":"section","text":""},{"title":"NetworkOptions.ca_roots","page":"Network Options","location":"stdlib/NetworkOptions.html#NetworkOptions.ca_roots","category":"function","text":"ca_roots() :: Union{Nothing, String}\n\nThe ca_roots() function tells the caller where, if anywhere, to find a file or\ndirectory of PEM-encoded certificate authority roots. By default, on systems\nlike Windows and macOS where the built-in TLS engines know how to verify hosts\nusing the system's built-in certificate verification mechanism, this function\nwill return nothing. On classic UNIX systems (excluding macOS), root\ncertificates are typically stored in a file in /etc: the common places for the\ncurrent UNIX system will be searched and if one of these paths exists, it will\nbe returned; if none of these typical root certificate paths exist, then the\npath to the set of root certificates that are bundled with Julia is returned.\n\nThe default value returned by ca_roots() may be overridden by setting the\nJULIA_SSL_CA_ROOTS_PATH, SSL_CERT_DIR, or SSL_CERT_FILE environment\nvariables, in which case this function will always return the value of the first\nof these variables that is set (whether the path exists or not). If\nJULIA_SSL_CA_ROOTS_PATH is set to the empty string, then the other variables\nare ignored (as if unset); if the other variables are set to the empty string,\nthey behave is if they are not set.\n\n\n\n\n\n"},{"title":"NetworkOptions.ca_roots_path","page":"Network Options","location":"stdlib/NetworkOptions.html#NetworkOptions.ca_roots_path","category":"function","text":"ca_roots_path() :: String\n\nThe ca_roots_path() function is similar to the ca_roots() function except\nthat it always returns a path to a file or directory of PEM-encoded certificate\nauthority roots. When called on a system like Windows or macOS, where system\nroot certificates are not stored in the file system, it will currently return\nthe path to the set of root certificates that are bundled with Julia. (In the\nfuture, this function may instead extract the root certificates from the system\nand save them to a file whose path would be returned.)\n\nIf it is possible to configure a library that uses TLS to use the system\ncertificates that is generally preferable: i.e. it is better to use\nca_roots() which returns nothing to indicate that the system certs should be\nused. The ca_roots_path() function should only be used when configuring\nlibraries which require a path to a file or directory for root certificates.\n\nThe default value returned by ca_roots_path() may be overridden by setting the\nJULIA_SSL_CA_ROOTS_PATH, SSL_CERT_DIR, or SSL_CERT_FILE environment\nvariables, in which case this function will always return the value of the first\nof these variables that is set (whether the path exists or not). If\nJULIA_SSL_CA_ROOTS_PATH is set to the empty string, then the other variables\nare ignored (as if unset); if the other variables are set to the empty string,\nthey behave is if they are not set.\n\n\n\n\n\n"},{"title":"NetworkOptions.ssh_dir","page":"Network Options","location":"stdlib/NetworkOptions.html#NetworkOptions.ssh_dir","category":"function","text":"ssh_dir() :: String\n\nThe ssh_dir() function returns the location of the directory where the ssh\nprogram keeps/looks for configuration files. By default this is ~/.ssh but\nthis can be overridden by setting the environment variable SSH_DIR.\n\n\n\n\n\n"},{"title":"NetworkOptions.ssh_key_pass","page":"Network Options","location":"stdlib/NetworkOptions.html#NetworkOptions.ssh_key_pass","category":"function","text":"ssh_key_pass() :: String\n\nThe ssh_key_pass() function returns the value of the environment variable\nSSH_KEY_PASS if it is set or nothing if it is not set. In the future, this\nmay be able to find a password by other means, such as secure system storage, so\npackages that need a password to decrypt an SSH private key should use this API\ninstead of directly checking the environment variable so that they gain such\ncapabilities automatically when they are added.\n\n\n\n\n\n"},{"title":"NetworkOptions.ssh_key_name","page":"Network Options","location":"stdlib/NetworkOptions.html#NetworkOptions.ssh_key_name","category":"function","text":"ssh_key_name() :: String\n\nThe ssh_key_name() function returns the base name of key files that SSH should\nuse for when establishing a connection. There is usually no reason that this\nfunction should be called directly and libraries should generally use the\nssh_key_path and ssh_pub_key_path functions to get full paths. If the\nenvironment variable SSH_KEY_NAME is set then this function returns that;\notherwise it returns id_rsa by default.\n\n\n\n\n\n"},{"title":"NetworkOptions.ssh_key_path","page":"Network Options","location":"stdlib/NetworkOptions.html#NetworkOptions.ssh_key_path","category":"function","text":"ssh_key_path() :: String\n\nThe ssh_key_path() function returns the path of the SSH private key file that\nshould be used for SSH connections. If the SSH_KEY_PATH environment variable\nis set then it will return that value. Otherwise it defaults to returning\n\njoinpath(ssh_dir(), ssh_key_name())\n\nThis default value in turn depends on the SSH_DIR and SSH_KEY_NAME\nenvironment variables.\n\n\n\n\n\n"},{"title":"NetworkOptions.ssh_pub_key_path","page":"Network Options","location":"stdlib/NetworkOptions.html#NetworkOptions.ssh_pub_key_path","category":"function","text":"ssh_pub_key_path() :: String\n\nThe ssh_pub_key_path() function returns the path of the SSH public key file\nthat should be used for SSH connections. If the SSH_PUB_KEY_PATH environment\nvariable is set then it will return that value. If that isn't set but\nSSH_KEY_PATH is set, it will return that path with the .pub suffix appended.\nIf neither is set, it defaults to returning\n\njoinpath(ssh_dir(), ssh_key_name() * \".pub\")\n\nThis default value in turn depends on the SSH_DIR and SSH_KEY_NAME\nenvironment variables.\n\n\n\n\n\n"},{"title":"NetworkOptions.ssh_known_hosts_files","page":"Network Options","location":"stdlib/NetworkOptions.html#NetworkOptions.ssh_known_hosts_files","category":"function","text":"ssh_known_hosts_files() :: Vector{String}\n\nThe ssh_known_hosts_files() function returns a vector of paths of SSH known\nhosts files that should be used when establishing the identities of remote\nservers for SSH connections. By default this function returns\n\n[joinpath(ssh_dir(), \"known_hosts\"), bundled_known_hosts]\n\nwhere bundled_known_hosts is the path of a copy of a known hosts file that is\nbundled with this package (containing known hosts keys for github.com and\ngitlab.com). If the environment variable SSH_KNOWN_HOSTS_FILES is set,\nhowever, then its value is split into paths on the : character (or on ; on\nWindows) and this vector of paths is returned instead. If any component of this\nvector is empty, it is expanded to the default known hosts paths.\n\nPackages that use ssh_known_hosts_files() should ideally look for matching\nentries by comparing the host name and key types, considering the first entry in\nany of the files which matches to be the definitive identity of the host. If the\ncaller cannot compare the key type (e.g. because it has been hashes) then it\nmust approximate the above algorithm by looking for all matching entries for a\nhost in each file: if a file has any entries for a host then one of them must\nmatch; the caller should only continue to search further known hosts files if\nthere are no entries for the host in question in an earlier file.\n\n\n\n\n\n"},{"title":"NetworkOptions.ssh_known_hosts_file","page":"Network Options","location":"stdlib/NetworkOptions.html#NetworkOptions.ssh_known_hosts_file","category":"function","text":"ssh_known_hosts_file() :: String\n\nThe ssh_known_hosts_file() function returns a single path of an SSH known\nhosts file that should be used when establishing the identities of remote\nservers for SSH connections. It returns the first path returned by\nssh_known_hosts_files that actually exists. Callers who can look in more than\none known hosts file should use ssh_known_hosts_files instead and look for\nhost matches in all the files returned as described in that function's docs.\n\n\n\n\n\n"},{"title":"NetworkOptions.verify_host","page":"Network Options","location":"stdlib/NetworkOptions.html#NetworkOptions.verify_host","category":"function","text":"verify_host(url::AbstractString, [transport::AbstractString]) :: Bool\n\nThe verify_host function tells the caller whether the identity of a host\nshould be verified when communicating over secure transports like TLS or SSH.\nThe url argument may be:\n\na proper URL staring with proto://\nan ssh-style bare host name or host name prefixed with user@\nan scp-style host as above, followed by : and a path location\n\nIn each case the host name part is parsed out and the decision about whether to\nverify or not is made based solely on the host name, not anything else about the\ninput URL. In particular, the protocol of the URL does not matter (more below).\n\nThe transport argument indicates the kind of transport that the query is\nabout. The currently known values are SSL/ssl (alias TLS/tls) and SSH/ssh.\nIf the transport is omitted, the query will return true only if the host name should\nnot be verified regardless of transport.\n\nThe host name is matched against the host patterns in the relevant environment\nvariables depending on whether transport is supplied and what its value is:\n\nJULIA_NO_VERIFY_HOSTS — hosts that should not be verified for any transport\nJULIA_SSL_NO_VERIFY_HOSTS — hosts that should not be verified for SSL/TLS\nJULIA_SSH_NO_VERIFY_HOSTS — hosts that should not be verified for SSH\nJULIA_ALWAYS_VERIFY_HOSTS — hosts that should always be verified\n\nThe values of each of these variables is a comma-separated list of host name\npatterns with the following syntax — each pattern is split on . into parts and\neach part must one of:\n\nA literal domain name component consisting of one or more ASCII letter,\ndigit, hyphen or underscore (technically not part of a legal host name, but\nsometimes used). A literal domain name component matches only itself.\nA **, which matches zero or more domain name components.\nA *, which match any one domain name component.\n\nWhen matching a host name against a pattern list in one of these variables, the\nhost name is split on . into components and that sequence of words is matched\nagainst the pattern: a literal pattern matches exactly one host name component\nwith that value; a * pattern matches exactly one host name component with any\nvalue; a ** pattern matches any number of host name components. For example:\n\n** matches any host name\n**.org matches any host name in the .org top-level domain\nexample.com matches only the exact host name example.com\n*.example.com matches api.example.com but not example.com or\nv1.api.example.com\n**.example.com matches any domain under example.com, including\nexample.com itself, api.example.com and v1.api.example.com\n\n\n\n\n\n"},{"title":"Arrays","page":"Arrays","location":"base/arrays.html#lib-arrays","category":"section","text":""},{"title":"Constructors and Types","page":"Arrays","location":"base/arrays.html#Constructors-and-Types","category":"section","text":""},{"title":"Basic functions","page":"Arrays","location":"base/arrays.html#Basic-functions","category":"section","text":""},{"title":"Broadcast and vectorization","page":"Arrays","location":"base/arrays.html#Broadcast-and-vectorization","category":"section","text":"See also the dot syntax for vectorizing functions;\nfor example, f.(args...) implicitly calls broadcast(f, args...).\nRather than relying on \"vectorized\" methods of functions like sin\nto operate on arrays, you should use sin.(a) to vectorize via broadcast.\n\nFor specializing broadcast on custom types, see"},{"title":"Indexing and assignment","page":"Arrays","location":"base/arrays.html#Indexing-and-assignment","category":"section","text":"While most code can be written in an index-agnostic manner (see, e.g., eachindex), it can sometimes be useful to explicitly check for offset axes:"},{"title":"Views (SubArrays and other view types)","page":"Arrays","location":"base/arrays.html#Views-(SubArrays-and-other-view-types)","category":"section","text":"A “view” is a data structure that acts like an array (it is a subtype of AbstractArray), but the underlying data is actually\npart of another array.\n\nFor example, if x is an array and v = @view x[1:10], then v acts like a 10-element array, but its data is actually\naccessing the first 10 elements of x. Writing to a view, e.g. v[3] = 2, writes directly to the underlying array x\n(in this case modifying x[3]).\n\nSlicing operations like x[1:10] create a copy by default in Julia. @view x[1:10] changes it to make a view. The\n@views macro can be used on a whole block of code (e.g. @views function foo() .... end or @views begin ... end)\nto change all the slicing operations in that block to use views. Sometimes making a copy of the data is faster and\nsometimes using a view is faster, as described in the performance tips."},{"title":"Concatenation and permutation","page":"Arrays","location":"base/arrays.html#Concatenation-and-permutation","category":"section","text":""},{"title":"Array functions","page":"Arrays","location":"base/arrays.html#Array-functions","category":"section","text":""},{"title":"Combinatorics","page":"Arrays","location":"base/arrays.html#Combinatorics","category":"section","text":""},{"title":"Core.AbstractArray","page":"Arrays","location":"base/arrays.html#Core.AbstractArray","category":"type","text":"AbstractArray{T,N}\n\nSupertype for N-dimensional arrays (or array-like types) with elements of type T.\nArray and other types are subtypes of this. See the manual section on the\nAbstractArray interface.\n\nSee also: AbstractVector, AbstractMatrix, eltype, ndims.\n\n\n\n\n\n"},{"title":"Base.AbstractVector","page":"Arrays","location":"base/arrays.html#Base.AbstractVector","category":"type","text":"AbstractVector{T}\n\nSupertype for one-dimensional arrays (or array-like types) with\nelements of type T. Alias for AbstractArray{T,1}.\n\n\n\n\n\n"},{"title":"Base.AbstractMatrix","page":"Arrays","location":"base/arrays.html#Base.AbstractMatrix","category":"type","text":"AbstractMatrix{T}\n\nSupertype for two-dimensional arrays (or array-like types) with\nelements of type T. Alias for AbstractArray{T,2}.\n\n\n\n\n\n"},{"title":"Base.AbstractVecOrMat","page":"Arrays","location":"base/arrays.html#Base.AbstractVecOrMat","category":"type","text":"AbstractVecOrMat{T}\n\nUnion type of AbstractVector{T} and AbstractMatrix{T}.\n\n\n\n\n\n"},{"title":"Core.Array","page":"Arrays","location":"base/arrays.html#Core.Array","category":"type","text":"Array{T,N} <: AbstractArray{T,N}\n\nN-dimensional dense array with elements of type T.\n\n\n\n\n\n"},{"title":"Core.Array","page":"Arrays","location":"base/arrays.html#Core.Array-Tuple{UndefInitializer, Any}","category":"method","text":"Array{T}(undef, dims)\nArray{T,N}(undef, dims)\n\nConstruct an uninitialized N-dimensional Array\ncontaining elements of type T. N can either be supplied explicitly,\nas in Array{T,N}(undef, dims), or be determined by the length or number of dims.\ndims may be a tuple or a series of integer arguments corresponding to the lengths\nin each dimension. If the rank N is supplied explicitly, then it must\nmatch the length or number of dims. Here undef is\nthe UndefInitializer.\n\nExamples\n\njulia> A = Array{Float64, 2}(undef, 2, 3) # N given explicitly\n2×3 Matrix{Float64}:\n 6.90198e-310  6.90198e-310  6.90198e-310\n 6.90198e-310  6.90198e-310  0.0\n\njulia> B = Array{Float64}(undef, 4) # N determined by the input\n4-element Vector{Float64}:\n   2.360075077e-314\n NaN\n   2.2671131793e-314\n   2.299821756e-314\n\njulia> similar(B, 2, 4, 1) # use typeof(B), and the given size\n2×4×1 Array{Float64, 3}:\n[:, :, 1] =\n 2.26703e-314  2.26708e-314  0.0           2.80997e-314\n 0.0           2.26703e-314  2.26708e-314  0.0\n\n\n\n\n\n"},{"title":"Core.Array","page":"Arrays","location":"base/arrays.html#Core.Array-Tuple{Nothing, Any}","category":"method","text":"Array{T}(nothing, dims)\nArray{T,N}(nothing, dims)\n\nConstruct an N-dimensional Array containing elements of type T,\ninitialized with nothing entries. Element type T must be able\nto hold these values, i.e. Nothing <: T.\n\nExamples\n\njulia> Array{Union{Nothing, String}}(nothing, 2)\n2-element Vector{Union{Nothing, String}}:\n nothing\n nothing\n\njulia> Array{Union{Nothing, Int}}(nothing, 2, 3)\n2×3 Matrix{Union{Nothing, Int64}}:\n nothing  nothing  nothing\n nothing  nothing  nothing\n\n\n\n\n\n"},{"title":"Core.Array","page":"Arrays","location":"base/arrays.html#Core.Array-Tuple{Missing, Any}","category":"method","text":"Array{T}(missing, dims)\nArray{T,N}(missing, dims)\n\nConstruct an N-dimensional Array containing elements of type T,\ninitialized with missing entries. Element type T must be able\nto hold these values, i.e. Missing <: T.\n\nExamples\n\njulia> Array{Union{Missing, String}}(missing, 2)\n2-element Vector{Union{Missing, String}}:\n missing\n missing\n\njulia> Array{Union{Missing, Int}}(missing, 2, 3)\n2×3 Matrix{Union{Missing, Int64}}:\n missing  missing  missing\n missing  missing  missing\n\n\n\n\n\n"},{"title":"Core.UndefInitializer","page":"Arrays","location":"base/arrays.html#Core.UndefInitializer","category":"type","text":"UndefInitializer\n\nSingleton type used in array initialization, indicating the array-constructor-caller\nwould like an uninitialized array. See also undef,\nan alias for UndefInitializer().\n\nExamples\n\njulia> Array{Float64, 1}(UndefInitializer(), 3)\n3-element Vector{Float64}:\n 2.2752528595e-314\n 2.202942107e-314\n 2.275252907e-314\n\n\n\n\n\n"},{"title":"Core.undef","page":"Arrays","location":"base/arrays.html#Core.undef","category":"constant","text":"undef\n\nAlias for UndefInitializer(), which constructs an instance of the singleton type\nUndefInitializer, used in array initialization to indicate the\narray-constructor-caller would like an uninitialized array.\n\nSee also: missing, similar.\n\nExamples\n\njulia> Array{Float64, 1}(undef, 3)\n3-element Vector{Float64}:\n 2.2752528595e-314\n 2.202942107e-314\n 2.275252907e-314\n\n\n\n\n\n"},{"title":"Base.Vector","page":"Arrays","location":"base/arrays.html#Base.Vector","category":"type","text":"Vector{T} <: AbstractVector{T}\n\nOne-dimensional dense array with elements of type T, often used to represent\na mathematical vector. Alias for Array{T,1}.\n\nSee also empty, similar and zero for creating vectors.\n\n\n\n\n\n"},{"title":"Base.Vector","page":"Arrays","location":"base/arrays.html#Base.Vector-Tuple{UndefInitializer, Any}","category":"method","text":"Vector{T}(undef, n)\n\nConstruct an uninitialized Vector{T} of length n.\n\nExamples\n\njulia> Vector{Float64}(undef, 3)\n3-element Vector{Float64}:\n 6.90966e-310\n 6.90966e-310\n 6.90966e-310\n\n\n\n\n\n"},{"title":"Base.Vector","page":"Arrays","location":"base/arrays.html#Base.Vector-Tuple{Nothing, Any}","category":"method","text":"Vector{T}(nothing, m)\n\nConstruct a Vector{T} of length m, initialized with\nnothing entries. Element type T must be able to hold\nthese values, i.e. Nothing <: T.\n\nExamples\n\njulia> Vector{Union{Nothing, String}}(nothing, 2)\n2-element Vector{Union{Nothing, String}}:\n nothing\n nothing\n\n\n\n\n\n"},{"title":"Base.Vector","page":"Arrays","location":"base/arrays.html#Base.Vector-Tuple{Missing, Any}","category":"method","text":"Vector{T}(missing, m)\n\nConstruct a Vector{T} of length m, initialized with\nmissing entries. Element type T must be able to hold\nthese values, i.e. Missing <: T.\n\nExamples\n\njulia> Vector{Union{Missing, String}}(missing, 2)\n2-element Vector{Union{Missing, String}}:\n missing\n missing\n\n\n\n\n\n"},{"title":"Base.Matrix","page":"Arrays","location":"base/arrays.html#Base.Matrix","category":"type","text":"Matrix{T} <: AbstractMatrix{T}\n\nTwo-dimensional dense array with elements of type T, often used to represent\na mathematical matrix. Alias for Array{T,2}.\n\nSee also fill, zeros, undef and similar\nfor creating matrices.\n\n\n\n\n\n"},{"title":"Base.Matrix","page":"Arrays","location":"base/arrays.html#Base.Matrix-Tuple{UndefInitializer, Any, Any}","category":"method","text":"Matrix{T}(undef, m, n)\n\nConstruct an uninitialized Matrix{T} of size m×n.\n\nExamples\n\njulia> Matrix{Float64}(undef, 2, 3)\n2×3 Matrix{Float64}:\n 2.36365e-314  2.28473e-314    5.0e-324\n 2.26704e-314  2.26711e-314  NaN\n\njulia> similar(ans, Int32, 2, 2)\n2×2 Matrix{Int32}:\n 490537216  1277177453\n         1  1936748399\n\n\n\n\n\n"},{"title":"Base.Matrix","page":"Arrays","location":"base/arrays.html#Base.Matrix-Tuple{Nothing, Any, Any}","category":"method","text":"Matrix{T}(nothing, m, n)\n\nConstruct a Matrix{T} of size m×n, initialized with\nnothing entries. Element type T must be able to hold\nthese values, i.e. Nothing <: T.\n\nExamples\n\njulia> Matrix{Union{Nothing, String}}(nothing, 2, 3)\n2×3 Matrix{Union{Nothing, String}}:\n nothing  nothing  nothing\n nothing  nothing  nothing\n\n\n\n\n\n"},{"title":"Base.Matrix","page":"Arrays","location":"base/arrays.html#Base.Matrix-Tuple{Missing, Any, Any}","category":"method","text":"Matrix{T}(missing, m, n)\n\nConstruct a Matrix{T} of size m×n, initialized with\nmissing entries. Element type T must be able to hold\nthese values, i.e. Missing <: T.\n\nExamples\n\njulia> Matrix{Union{Missing, String}}(missing, 2, 3)\n2×3 Matrix{Union{Missing, String}}:\n missing  missing  missing\n missing  missing  missing\n\n\n\n\n\n"},{"title":"Base.VecOrMat","page":"Arrays","location":"base/arrays.html#Base.VecOrMat","category":"type","text":"VecOrMat{T}\n\nUnion type of Vector{T} and Matrix{T} which allows functions to accept either a Matrix or a Vector.\n\nExamples\n\njulia> Vector{Float64} <: VecOrMat{Float64}\ntrue\n\njulia> Matrix{Float64} <: VecOrMat{Float64}\ntrue\n\njulia> Array{Float64, 3} <: VecOrMat{Float64}\nfalse\n\n\n\n\n\n"},{"title":"Core.DenseArray","page":"Arrays","location":"base/arrays.html#Core.DenseArray","category":"type","text":"DenseArray{T, N} <: AbstractArray{T,N}\n\nN-dimensional dense array with elements of type T.\nThe elements of a dense array are stored contiguously in memory.\n\n\n\n\n\n"},{"title":"Base.DenseVector","page":"Arrays","location":"base/arrays.html#Base.DenseVector","category":"type","text":"DenseVector{T}\n\nOne-dimensional DenseArray with elements of type T. Alias for DenseArray{T,1}.\n\n\n\n\n\n"},{"title":"Base.DenseMatrix","page":"Arrays","location":"base/arrays.html#Base.DenseMatrix","category":"type","text":"DenseMatrix{T}\n\nTwo-dimensional DenseArray with elements of type T. Alias for DenseArray{T,2}.\n\n\n\n\n\n"},{"title":"Base.DenseVecOrMat","page":"Arrays","location":"base/arrays.html#Base.DenseVecOrMat","category":"type","text":"DenseVecOrMat{T}\n\nUnion type of DenseVector{T} and DenseMatrix{T}.\n\n\n\n\n\n"},{"title":"Base.StridedArray","page":"Arrays","location":"base/arrays.html#Base.StridedArray","category":"type","text":"StridedArray{T, N}\n\nA hard-coded Union of common array types that follow the strided array interface,\nwith elements of type T and N dimensions.\n\nIf A is a StridedArray, then its elements are stored in memory with offsets, which may\nvary between dimensions but are constant within a dimension. For example, A could\nhave stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing A along\ndimension d jumps in memory by [stride(A, d)] slots. Strided arrays are\nparticularly important and useful because they can sometimes be passed directly\nas pointers to foreign language libraries like BLAS.\n\n\n\n\n\n"},{"title":"Base.StridedVector","page":"Arrays","location":"base/arrays.html#Base.StridedVector","category":"type","text":"StridedVector{T}\n\nOne dimensional StridedArray with elements of type T.\n\n\n\n\n\n"},{"title":"Base.StridedMatrix","page":"Arrays","location":"base/arrays.html#Base.StridedMatrix","category":"type","text":"StridedMatrix{T}\n\nTwo dimensional StridedArray with elements of type T.\n\n\n\n\n\n"},{"title":"Base.StridedVecOrMat","page":"Arrays","location":"base/arrays.html#Base.StridedVecOrMat","category":"type","text":"StridedVecOrMat{T}\n\nUnion type of StridedVector and StridedMatrix with elements of type T.\n\n\n\n\n\n"},{"title":"Core.GenericMemory","page":"Arrays","location":"base/arrays.html#Core.GenericMemory","category":"type","text":"GenericMemory{kind::Symbol, T, addrspace=Core.CPU} <: DenseVector{T}\n\nFixed-size DenseVector{T}.\n\nkind can currently be either :not_atomic or :atomic. For details on what :atomic implies, see AtomicMemory\n\naddrspace can currently only be set to Core.CPU. It is designed to permit extension by other systems such as GPUs, which might define values such as:\n\nmodule CUDA\nconst Generic = bitcast(Core.AddrSpace{CUDA}, 0)\nconst Global = bitcast(Core.AddrSpace{CUDA}, 1)\nend\n\nThe exact semantics of these other addrspaces is defined by the specific backend, but will error if the user is attempting to access these on the CPU.\n\ncompat: Julia 1.11\nThis type requires Julia 1.11 or later.\n\n\n\n\n\n"},{"title":"Core.Memory","page":"Arrays","location":"base/arrays.html#Core.Memory","category":"type","text":"Memory{T} == GenericMemory{:not_atomic, T, Core.CPU}\n\nFixed-size DenseVector{T}.\n\ncompat: Julia 1.11\nThis type requires Julia 1.11 or later.\n\n\n\n\n\n"},{"title":"Core.Memory","page":"Arrays","location":"base/arrays.html#Core.Memory-Tuple{UndefInitializer, Int64}","category":"method","text":"Memory{T}(undef, n)\n\nConstruct an uninitialized Memory{T} of length n. All Memory\nobjects of length 0 might alias, since there is no reachable mutable content\nfrom them.\n\nExamples\n\njulia> Memory{Float64}(undef, 3)\n3-element Memory{Float64}:\n 6.90966e-310\n 6.90966e-310\n 6.90966e-310\n\n\n\n\n\n"},{"title":"Core.memoryref","page":"Arrays","location":"base/arrays.html#Core.memoryref","category":"function","text":"memoryref(::GenericMemory, index::Integer)\nmemoryref(::GenericMemoryRef, index::Integer)\n\nConstruct a GenericMemoryRef from a memory object and an offset index (1-based) which\ncan also be negative. This always returns an inbounds object, and will throw an\nerror if that is not possible (because the index would result in a shift\nout-of-bounds of the underlying memory).\n\n\n\n\n\nmemoryref(::GenericMemory)\n\nConstruct a GenericMemoryRef from a memory object. This does not fail, but the\nresulting memory will point out-of-bounds if and only if the memory is empty.\n\n\n\n\n\n"},{"title":"Base.memoryindex","page":"Arrays","location":"base/arrays.html#Base.memoryindex","category":"function","text":"memoryindex(ref::GenericMemoryRef)::Int\n\nGet the 1-based index of ref in its GenericMemory.\n\nExamples\n\njulia> mem = Memory{String}(undef, 10);\n\njulia> ref = Base.memoryindex(memoryref(mem, 3))\n3\n\njulia> Base.memoryindex(memoryref(Memory{Nothing}(undef, 10), 8))\n8\n\ncompat: Julia 1.13\nThis function requires at least Julia 1.13.\n\n\n\n\n\n"},{"title":"Base.Slices","page":"Arrays","location":"base/arrays.html#Base.Slices","category":"type","text":"Slices{P,SM,AX,S,N} <: AbstractSlices{S,N}\n\nAn AbstractArray of slices into a parent array over specified dimension(s),\nreturning views that select all the data from the other dimension(s).\n\nThese should typically be constructed by eachslice, eachcol or\neachrow.\n\nparent(s::Slices) will return the parent array.\n\n\n\n\n\n"},{"title":"Base.RowSlices","page":"Arrays","location":"base/arrays.html#Base.RowSlices","category":"type","text":"RowSlices{M,AX,S}\n\nA special case of Slices that is a vector of row slices of a matrix, as\nconstructed by eachrow.\n\nparent can be used to get the underlying matrix.\n\n\n\n\n\n"},{"title":"Base.ColumnSlices","page":"Arrays","location":"base/arrays.html#Base.ColumnSlices","category":"type","text":"ColumnSlices{M,AX,S}\n\nA special case of Slices that is a vector of column slices of a matrix, as\nconstructed by eachcol.\n\nparent can be used to get the underlying matrix.\n\n\n\n\n\n"},{"title":"Base.getindex","page":"Arrays","location":"base/arrays.html#Base.getindex-Tuple{Type, Vararg{Any}}","category":"method","text":"getindex(type[, elements...])\n\nConstruct a 1-d array of the specified type. This is usually called with the syntax\nType[]. Element values can be specified using Type[a,b,c,...].\n\nExamples\n\njulia> Int8[1, 2, 3]\n3-element Vector{Int8}:\n 1\n 2\n 3\n\njulia> getindex(Int8, 1, 2, 3)\n3-element Vector{Int8}:\n 1\n 2\n 3\n\n\n\n\n\n"},{"title":"Base.zeros","page":"Arrays","location":"base/arrays.html#Base.zeros","category":"function","text":"zeros([T=Float64,] dims::Tuple)\nzeros([T=Float64,] dims...)\n\nCreate an Array, with element type T, of all zeros with size specified by dims.\nSee also fill, ones, zero.\n\nExamples\n\njulia> zeros(1)\n1-element Vector{Float64}:\n 0.0\n\njulia> zeros(Int8, 2, 3)\n2×3 Matrix{Int8}:\n 0  0  0\n 0  0  0\n\n\n\n\n\n"},{"title":"Base.ones","page":"Arrays","location":"base/arrays.html#Base.ones","category":"function","text":"ones([T=Float64,] dims::Tuple)\nones([T=Float64,] dims...)\n\nCreate an Array, with element type T, of all ones with size specified by dims.\nSee also fill, zeros.\n\nExamples\n\njulia> ones(1,2)\n1×2 Matrix{Float64}:\n 1.0  1.0\n\njulia> ones(ComplexF64, 2, 3)\n2×3 Matrix{ComplexF64}:\n 1.0+0.0im  1.0+0.0im  1.0+0.0im\n 1.0+0.0im  1.0+0.0im  1.0+0.0im\n\n\n\n\n\n"},{"title":"Base.BitArray","page":"Arrays","location":"base/arrays.html#Base.BitArray","category":"type","text":"BitArray{N} <: AbstractArray{Bool, N}\n\nSpace-efficient N-dimensional boolean array, using just one bit for each boolean value.\n\nBitArrays pack up to 64 values into every 8 bytes, resulting in an 8x space efficiency\nover Array{Bool, N} and allowing some operations to work on 64 values at once.\n\nBy default, Julia returns BitArrays from broadcasting operations\nthat generate boolean elements (including dotted-comparisons like .==) as well as from\nthe functions trues and falses.\n\nnote: Note\nDue to its packed storage format, concurrent access to the elements of a BitArray\nwhere at least one of them is a write is not thread-safe.\n\n\n\n\n\n"},{"title":"Base.BitArray","page":"Arrays","location":"base/arrays.html#Base.BitArray-Tuple{UndefInitializer, Vararg{Integer}}","category":"method","text":"BitArray(undef, dims::Integer...)\nBitArray{N}(undef, dims::NTuple{N,Int})\n\nConstruct an undef BitArray with the given dimensions.\nBehaves identically to the Array constructor. See undef.\n\nExamples\n\njulia> BitArray(undef, 2, 2)\n2×2 BitMatrix:\n 0  0\n 0  0\n\njulia> BitArray(undef, (3, 1))\n3×1 BitMatrix:\n 0\n 0\n 0\n\n\n\n\n\n"},{"title":"Base.BitArray","page":"Arrays","location":"base/arrays.html#Base.BitArray-Tuple{Any}","category":"method","text":"BitArray(itr)\n\nConstruct a BitArray generated by the given iterable object.\nThe shape is inferred from the itr object.\n\nExamples\n\njulia> BitArray([1 0; 0 1])\n2×2 BitMatrix:\n 1  0\n 0  1\n\njulia> BitArray(x+y == 3 for x = 1:2, y = 1:3)\n2×3 BitMatrix:\n 0  1  0\n 1  0  0\n\njulia> BitArray(x+y == 3 for x = 1:2 for y = 1:3)\n6-element BitVector:\n 0\n 1\n 0\n 1\n 0\n 0\n\n\n\n\n\n"},{"title":"Base.trues","page":"Arrays","location":"base/arrays.html#Base.trues","category":"function","text":"trues(dims)\n\nCreate a BitArray with all values set to true.\n\nExamples\n\njulia> trues(2,3)\n2×3 BitMatrix:\n 1  1  1\n 1  1  1\n\n\n\n\n\n"},{"title":"Base.falses","page":"Arrays","location":"base/arrays.html#Base.falses","category":"function","text":"falses(dims)\n\nCreate a BitArray with all values set to false.\n\nExamples\n\njulia> falses(2,3)\n2×3 BitMatrix:\n 0  0  0\n 0  0  0\n\n\n\n\n\n"},{"title":"Base.fill","page":"Arrays","location":"base/arrays.html#Base.fill","category":"function","text":"fill(value, dims::Tuple)\nfill(value, dims...)\n\nCreate an array of size dims with every location set to value.\n\nFor example, fill(1.0, (5,5)) returns a 5×5 array of floats,\nwith 1.0 in every location of the array.\n\nThe dimension lengths dims may be specified as either a tuple or a sequence of arguments.\nAn N-length tuple or N arguments following the value specify an N-dimensional\narray. Thus, a common idiom for creating a zero-dimensional array with its only location\nset to x is fill(x).\n\nEvery location of the returned array is set to (and is thus === to)\nthe value that was passed; this means that if the value is itself modified,\nall elements of the filled array will reflect that modification because they're\nstill that very value. This is of no concern with fill(1.0, (5,5)) as the\nvalue 1.0 is immutable and cannot itself be modified, but can be unexpected\nwith mutable values like — most commonly — arrays.  For example, fill([], 3)\nplaces the very same empty array in all three locations of the returned vector:\n\njulia> v = fill([], 3)\n3-element Vector{Vector{Any}}:\n []\n []\n []\n\njulia> v[1] === v[2] === v[3]\ntrue\n\njulia> value = v[1]\nAny[]\n\njulia> push!(value, 867_5309)\n1-element Vector{Any}:\n 8675309\n\njulia> v\n3-element Vector{Vector{Any}}:\n [8675309]\n [8675309]\n [8675309]\n\nTo create an array of many independent inner arrays, use a comprehension instead.\nThis creates a new and distinct array on each iteration of the loop:\n\njulia> v2 = [[] for _ in 1:3]\n3-element Vector{Vector{Any}}:\n []\n []\n []\n\njulia> v2[1] === v2[2] === v2[3]\nfalse\n\njulia> push!(v2[1], 8675309)\n1-element Vector{Any}:\n 8675309\n\njulia> v2\n3-element Vector{Vector{Any}}:\n [8675309]\n []\n []\n\nSee also: fill!, zeros, ones, similar.\n\nExamples\n\njulia> fill(1.0, (2,3))\n2×3 Matrix{Float64}:\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\njulia> fill(42)\n0-dimensional Array{Int64, 0}:\n42\n\njulia> A = fill(zeros(2), 2) # sets both elements to the same [0.0, 0.0] vector\n2-element Vector{Vector{Float64}}:\n [0.0, 0.0]\n [0.0, 0.0]\n\njulia> A[1][1] = 42; # modifies the filled value to be [42.0, 0.0]\n\njulia> A # both A[1] and A[2] are the very same vector\n2-element Vector{Vector{Float64}}:\n [42.0, 0.0]\n [42.0, 0.0]\n\n\n\n\n\n"},{"title":"Base.fill!","page":"Arrays","location":"base/arrays.html#Base.fill!","category":"function","text":"fill!(A, x)\n\nFill array A with the value x. If x is an object reference, all elements will refer to\nthe same object. fill!(A, Foo()) will return A filled with the result of evaluating\nFoo() once.\n\nExamples\n\njulia> A = zeros(2,3)\n2×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia> fill!(A, 2.)\n2×3 Matrix{Float64}:\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n\njulia> a = [1, 1, 1]; A = fill!(Vector{Vector{Int}}(undef, 3), a); a[1] = 2; A\n3-element Vector{Vector{Int64}}:\n [2, 1, 1]\n [2, 1, 1]\n [2, 1, 1]\n\njulia> x = 0; f() = (global x += 1; x); fill!(Vector{Int}(undef, 3), f())\n3-element Vector{Int64}:\n 1\n 1\n 1\n\n\n\n\n\n"},{"title":"Base.empty","page":"Arrays","location":"base/arrays.html#Base.empty","category":"function","text":"empty(a::AbstractDict, [index_type=keytype(a)], [value_type=valtype(a)])\n\nCreate an empty AbstractDict container which can accept indices of type index_type and\nvalues of type value_type. The second and third arguments are optional and default to the\ninput's keytype and valtype, respectively. (If only one of the two types is specified,\nit is assumed to be the value_type, and the index_type we default to keytype(a)).\n\nCustom AbstractDict subtypes may choose which specific dictionary type is best suited to\nreturn for the given index and value types, by specializing on the three-argument signature.\nThe default is to return an empty Dict.\n\n\n\n\n\nempty(v::AbstractVector, [eltype])\n\nCreate an empty vector similar to v, optionally changing the eltype.\n\nSee also: empty!, isempty, isassigned.\n\nExamples\n\njulia> empty([1.0, 2.0, 3.0])\nFloat64[]\n\njulia> empty([1.0, 2.0, 3.0], String)\nString[]\n\n\n\n\n\nempty(x::Tuple)\n\nReturn an empty tuple, ().\n\n\n\n\n\n"},{"title":"Base.similar","page":"Arrays","location":"base/arrays.html#Base.similar","category":"function","text":"similar(storagetype, axes)\n\nCreate an uninitialized mutable array analogous to that specified by\nstoragetype, but with axes specified by the last\nargument.\n\nExamples:\n\nsimilar(Array{Int}, axes(A))\n\ncreates an array that \"acts like\" an Array{Int} (and might indeed be\nbacked by one), but which is indexed identically to A. If A has\nconventional indexing, this will be identical to\nArray{Int}(undef, size(A)), but if A has unconventional indexing then the\nindices of the result will match A.\n\nsimilar(BitArray, (axes(A, 2),))\n\nwould create a 1-dimensional logical array whose indices match those\nof the columns of A.\n\n\n\n\n\nsimilar(array, [element_type=eltype(array)], [dims=size(array)])\n\nCreate an uninitialized mutable array with the given element type and size, based upon the\ngiven source array. The second and third arguments are both optional, defaulting to the\ngiven array's eltype and size. The dimensions may be specified either as a single tuple\nargument or as a series of integer arguments.\n\nCustom AbstractArray subtypes may choose which specific array type is best-suited to return\nfor the given element type and dimensionality. If they do not specialize this method, the\ndefault is an Array{element_type}(undef, dims...).\n\nFor example, similar(1:10, 1, 4) returns an uninitialized Array{Int,2} since ranges are\nneither mutable nor support 2 dimensions:\n\njulia> similar(1:10, 1, 4)\n1×4 Matrix{Int64}:\n 4419743872  4374413872  4419743888  0\n\nConversely, similar(trues(10,10), 2) returns an uninitialized BitVector with two\nelements since BitArrays are both mutable and can support 1-dimensional arrays:\n\njulia> similar(trues(10,10), 2)\n2-element BitVector:\n 0\n 0\n\nSince BitArrays can only store elements of type Bool, however, if you request a\ndifferent element type it will create a regular Array instead:\n\njulia> similar(falses(10), Float64, 2, 4)\n2×4 Matrix{Float64}:\n 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n\nSee also: undef, isassigned.\n\n\n\n\n\nsimilar(A::AbstractSparseMatrixCSC{Tv,Ti}, [::Type{TvNew}, ::Type{TiNew}, m::Integer, n::Integer]) where {Tv,Ti}\n\nCreate an uninitialized mutable array with the given element type,\nindex type, and size, based upon the given source\nSparseMatrixCSC. The new sparse matrix maintains the structure of\nthe original sparse matrix, except in the case where dimensions of the\noutput matrix are different from the output.\n\nThe output matrix has zeros in the same locations as the input, but\nuninitialized values for the nonzero locations.\n\n\n\n\n\n"},{"title":"Base.ndims","page":"Arrays","location":"base/arrays.html#Base.ndims","category":"function","text":"ndims(A::AbstractArray)::Integer\n\nReturn the number of dimensions of A.\n\nSee also: size, axes.\n\nExamples\n\njulia> A = fill(1, (3,4,5));\n\njulia> ndims(A)\n3\n\n\n\n\n\n"},{"title":"Base.size","page":"Arrays","location":"base/arrays.html#Base.size","category":"function","text":"size(A::AbstractArray, [dim])\n\nReturn a tuple containing the dimensions of A. Optionally you can specify a\ndimension to just get the length of that dimension.\n\nNote that size may not be defined for arrays with non-standard indices, in which case axes\nmay be useful. See the manual chapter on arrays with custom indices.\n\nSee also: length, ndims, eachindex, sizeof.\n\nExamples\n\njulia> A = fill(1, (2,3,4));\n\njulia> size(A)\n(2, 3, 4)\n\njulia> size(A, 2)\n3\n\n\n\n\n\n"},{"title":"Base.axes","page":"Arrays","location":"base/arrays.html#Base.axes-Tuple{Any}","category":"method","text":"axes(A)\n\nReturn the tuple of valid indices for array A.\n\nSee also: size, keys, eachindex.\n\nExamples\n\njulia> A = fill(1, (5,6,7));\n\njulia> axes(A)\n(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))\n\n\n\n\n\n"},{"title":"Base.axes","page":"Arrays","location":"base/arrays.html#Base.axes-Tuple{AbstractArray, Any}","category":"method","text":"axes(A, d)\n\nReturn the valid range of indices for array A along dimension d.\n\nSee also size, and the manual chapter on arrays with custom indices.\n\nExamples\n\njulia> A = fill(1, (5,6,7));\n\njulia> axes(A, 2)\nBase.OneTo(6)\n\njulia> axes(A, 4) == 1:1  # all dimensions d > ndims(A) have size 1\ntrue\n\nUsage note\n\nEach of the indices has to be an AbstractUnitRange{<:Integer}, but at the same time can be\na type that uses custom indices. So, for example, if you need a subset, use generalized\nindexing constructs like begin/end or firstindex/lastindex:\n\nix = axes(v, 1)\nix[2:end]          # will work for eg Vector, but may fail in general\nix[(begin+1):end]  # works for generalized indexes\n\n\n\n\n\n"},{"title":"Base.length","page":"Arrays","location":"base/arrays.html#Base.length-Tuple{AbstractArray}","category":"method","text":"length(A::AbstractArray)\n\nReturn the number of elements in the array, defaults to prod(size(A)).\n\nExamples\n\njulia> length([1, 2, 3, 4])\n4\n\njulia> length([1 2; 3 4])\n4\n\n\n\n\n\n"},{"title":"Base.keys","page":"Arrays","location":"base/arrays.html#Base.keys-Tuple{AbstractArray}","category":"method","text":"keys(a::AbstractArray)\n\nReturn an efficient array describing all valid indices for a arranged in the shape of a itself.\n\nThe keys of 1-dimensional arrays (vectors) are integers, whereas all other N-dimensional\narrays use CartesianIndex to describe their locations.  Often the special array\ntypes LinearIndices and CartesianIndices are used to efficiently\nrepresent these arrays of integers and CartesianIndexes, respectively.\n\nNote that the keys of an array might not be the most efficient index type; for maximum\nperformance use  eachindex instead.\n\nExamples\n\njulia> keys([4, 5, 6])\n3-element LinearIndices{1, Tuple{Base.OneTo{Int64}}}:\n 1\n 2\n 3\n\njulia> keys([4 5; 6 7])\nCartesianIndices((2, 2))\n\n\n\n\n\n"},{"title":"Base.eachindex","page":"Arrays","location":"base/arrays.html#Base.eachindex","category":"function","text":"eachindex(A...)\neachindex(::IndexStyle, A::AbstractArray...)\n\nCreate an iterable object for visiting each index of an AbstractArray A in an efficient\nmanner. For array types that have opted into fast linear indexing (like Array), this is\nsimply the range 1:length(A) if they use 1-based indexing.\nFor array types that have not opted into fast linear indexing, a specialized Cartesian\nrange is typically returned to efficiently index into the array with indices specified\nfor every dimension.\n\nIn general eachindex accepts arbitrary iterables, including strings and dictionaries, and returns\nan iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).\n\nIf A is AbstractArray it is possible to explicitly specify the style of the indices that\nshould be returned by eachindex by passing a value having IndexStyle type as its first argument\n(typically IndexLinear() if linear indices are required or IndexCartesian() if Cartesian\nrange is wanted).\n\nIf you supply more than one AbstractArray argument, eachindex will create an\niterable object that is fast for all arguments (typically a UnitRange\nif all inputs have fast linear indexing, a CartesianIndices otherwise).\nIf the arrays have different sizes and/or dimensionalities, a DimensionMismatch exception\nwill be thrown.\n\nSee also pairs(A) to iterate over indices and values together,\nand axes(A, 2) for valid indices along one dimension.\n\nExamples\n\njulia> A = [10 20; 30 40];\n\njulia> for i in eachindex(A) # linear indexing\n           println(\"A[\", i, \"] == \", A[i])\n       end\nA[1] == 10\nA[2] == 30\nA[3] == 20\nA[4] == 40\n\njulia> for i in eachindex(view(A, 1:2, 1:1)) # Cartesian indexing\n           println(i)\n       end\nCartesianIndex(1, 1)\nCartesianIndex(2, 1)\n\n\n\n\n\n"},{"title":"Base.IndexStyle","page":"Arrays","location":"base/arrays.html#Base.IndexStyle","category":"type","text":"IndexStyle(A)\nIndexStyle(typeof(A))\n\nIndexStyle specifies the \"native indexing style\" for array A. When\nyou define a new AbstractArray type, you can choose to implement\neither linear indexing (with IndexLinear) or cartesian indexing.\nIf you decide to only implement linear indexing, then you must set this trait for your array\ntype:\n\nBase.IndexStyle(::Type{<:MyArray}) = IndexLinear()\n\nThe default is IndexCartesian().\n\nJulia's internal indexing machinery will automatically (and invisibly)\nrecompute all indexing operations into the preferred style. This allows users\nto access elements of your array using any indexing style, even when explicit\nmethods have not been provided.\n\nIf you define both styles of indexing for your AbstractArray, this\ntrait can be used to select the most performant indexing style. Some\nmethods check this trait on their inputs, and dispatch to different\nalgorithms depending on the most efficient access pattern. In\nparticular, eachindex creates an iterator whose type depends\non the setting of this trait.\n\n\n\n\n\n"},{"title":"Base.IndexLinear","page":"Arrays","location":"base/arrays.html#Base.IndexLinear","category":"type","text":"IndexLinear()\n\nSubtype of IndexStyle used to describe arrays which\nare optimally indexed by one linear index.\n\nA linear indexing style uses one integer index to describe the position in the array\n(even if it's a multidimensional array) and column-major\nordering is used to efficiently access the elements. This means that\nrequesting eachindex from an array that is IndexLinear will return\na simple one-dimensional range, even if it is multidimensional.\n\nA custom array that reports its IndexStyle as IndexLinear only needs\nto implement indexing (and indexed assignment) with a single Int index;\nall other indexing expressions — including multidimensional accesses — will\nbe recomputed to the linear index.  For example, if A were a 2×3 custom\nmatrix with linear indexing, and we referenced A[1, 3], this would be\nrecomputed to the equivalent linear index and call A[5] since 1 + 2*(3 - 1) = 5.\n\nSee also IndexCartesian.\n\n\n\n\n\n"},{"title":"Base.IndexCartesian","page":"Arrays","location":"base/arrays.html#Base.IndexCartesian","category":"type","text":"IndexCartesian()\n\nSubtype of IndexStyle used to describe arrays which\nare optimally indexed by a Cartesian index. This is the default\nfor new custom AbstractArray subtypes.\n\nA Cartesian indexing style uses multiple integer indices to describe the position in\na multidimensional array, with exactly one index per dimension. This means that\nrequesting eachindex from an array that is IndexCartesian will return\na range of CartesianIndices.\n\nA N-dimensional custom array that reports its IndexStyle as IndexCartesian needs\nto implement indexing (and indexed assignment) with exactly N Int indices;\nall other indexing expressions — including linear indexing — will\nbe recomputed to the equivalent Cartesian location.  For example, if A were a 2×3 custom\nmatrix with cartesian indexing, and we referenced A[5], this would be\nrecomputed to the equivalent Cartesian index and call A[1, 3] since 5 = 1 + 2*(3 - 1).\n\nIt is significantly more expensive to compute Cartesian indices from a linear index than it is\nto go the other way.  The former operation requires division — a very costly operation — whereas\nthe latter only uses multiplication and addition and is essentially free. This asymmetry means it\nis far more costly to use linear indexing with an IndexCartesian array than it is to use\nCartesian indexing with an IndexLinear array.\n\nSee also IndexLinear.\n\n\n\n\n\n"},{"title":"Base.conj!","page":"Arrays","location":"base/arrays.html#Base.conj!","category":"function","text":"conj!(A)\n\nTransform an array to its complex conjugate in-place.\n\nSee also conj.\n\nExamples\n\njulia> A = [1+im 2-im; 2+2im 3+im]\n2×2 Matrix{Complex{Int64}}:\n 1+1im  2-1im\n 2+2im  3+1im\n\njulia> conj!(A);\n\njulia> A\n2×2 Matrix{Complex{Int64}}:\n 1-1im  2+1im\n 2-2im  3-1im\n\n\n\n\n\n"},{"title":"Base.stride","page":"Arrays","location":"base/arrays.html#Base.stride","category":"function","text":"stride(A, k::Integer)\n\nReturn the distance in memory (in number of elements) between adjacent elements in dimension k.\n\nSee also: strides.\n\nExamples\n\njulia> A = fill(1, (3,4,5));\n\njulia> stride(A,2)\n3\n\njulia> stride(A,3)\n12\n\n\n\n\n\n"},{"title":"Base.strides","page":"Arrays","location":"base/arrays.html#Base.strides","category":"function","text":"strides(A)\n\nReturn a tuple of the memory strides in each dimension.\n\nSee also: stride.\n\nExamples\n\njulia> A = fill(1, (3,4,5));\n\njulia> strides(A)\n(1, 3, 12)\n\n\n\n\n\n"},{"title":"Base.Broadcast.broadcast","page":"Arrays","location":"base/arrays.html#Base.Broadcast.broadcast","category":"function","text":"broadcast(f, As...)\n\nBroadcast the function f over the arrays, tuples, collections, Refs and/or scalars As.\n\nBroadcasting applies the function f over the elements of the container arguments and the\nscalars themselves in As. Singleton and missing dimensions are expanded to match the\nextents of the other arguments by virtually repeating the value. By default, only a limited\nnumber of types are considered scalars, including Numbers, Strings, Symbols, Types,\nFunctions and some common singletons like missing and nothing. All other arguments are\niterated over or indexed into elementwise.\n\nThe resulting container type is established by the following rules:\n\nIf all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.\nIf at least one argument is a tuple and all others are scalars or zero-dimensional arrays,\nit returns a tuple.\nAll other combinations of arguments default to returning an Array, but\ncustom container types can define their own implementation and promotion-like\nrules to customize the result when they appear as arguments.\nThe element type is determined in the same manner as in collect.\n\nA special syntax exists for broadcasting: f.(args...) is equivalent to\nbroadcast(f, args...), and nested f.(g.(args...)) calls are fused into a\nsingle broadcast loop.\n\nExamples\n\njulia> A = [1, 2, 3, 4, 5]\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\njulia> B = [1 2; 3 4; 5 6; 7 8; 9 10]\n5×2 Matrix{Int64}:\n 1   2\n 3   4\n 5   6\n 7   8\n 9  10\n\njulia> broadcast(+, A, B)\n5×2 Matrix{Int64}:\n  2   3\n  5   6\n  8   9\n 11  12\n 14  15\n\njulia> parse.(Int, [\"1\", \"2\"])\n2-element Vector{Int64}:\n 1\n 2\n\njulia> abs.((1, -2))\n(1, 2)\n\njulia> broadcast(+, 1.0, (0, -2.0))\n(1.0, -1.0)\n\njulia> (+).([[0,2], [1,3]], Ref{Vector{Int}}([1,-1]))\n2-element Vector{Vector{Int64}}:\n [1, 1]\n [2, 2]\n\njulia> string.((\"one\",\"two\",\"three\",\"four\"), \": \", 1:4)\n4-element Vector{String}:\n \"one: 1\"\n \"two: 2\"\n \"three: 3\"\n \"four: 4\"\n\n\n\n\n\n\n"},{"title":"Base.Broadcast.broadcast!","page":"Arrays","location":"base/arrays.html#Base.Broadcast.broadcast!","category":"function","text":"broadcast!(f, dest, As...)\n\nLike broadcast, but store the result of\nbroadcast(f, As...) in the dest array.\nNote that dest is only used to store the result, and does not supply\narguments to f unless it is also listed in the As,\nas in broadcast!(f, A, A, B) to perform A[:] = broadcast(f, A, B).\n\nExamples\n\njulia> A = [1.0; 0.0]; B = [0.0; 0.0];\n\njulia> broadcast!(+, B, A, (0, -2.0));\n\njulia> B\n2-element Vector{Float64}:\n  1.0\n -2.0\n\njulia> A\n2-element Vector{Float64}:\n 1.0\n 0.0\n\njulia> broadcast!(+, A, A, (0, -2.0));\n\njulia> A\n2-element Vector{Float64}:\n  1.0\n -2.0\n\n\n\n\n\n"},{"title":"Base.Broadcast.@__dot__","page":"Arrays","location":"base/arrays.html#Base.Broadcast.@__dot__","category":"macro","text":"@. expr\n\nConvert every function call or operator in expr into a \"dot call\"\n(e.g. convert f(x) to f.(x)), and convert every assignment in expr\nto a \"dot assignment\" (e.g. convert += to .+=).\n\nIf you want to avoid adding dots for selected function calls in\nexpr, splice those function calls in with $.  For example,\n@. sqrt(abs($sort(x))) is equivalent to sqrt.(abs.(sort(x)))\n(no dot for sort).\n\n(@. is equivalent to a call to @__dot__.)\n\nExamples\n\njulia> x = 1.0:3.0; y = similar(x);\n\njulia> @. y = x + 3 * sin(x)\n3-element Vector{Float64}:\n 3.5244129544236893\n 4.727892280477045\n 3.4233600241796016\n\n\n\n\n\n"},{"title":"Base.Broadcast.BroadcastFunction","page":"Arrays","location":"base/arrays.html#Base.Broadcast.BroadcastFunction","category":"type","text":"BroadcastFunction{F} <: Function\n\nRepresents the \"dotted\" version of an operator, which broadcasts the operator over its\narguments, so BroadcastFunction(op) is functionally equivalent to (x...) -> (op).(x...).\n\nCan be created by just passing an operator preceded by a dot to a higher-order function.\n\nExamples\n\njulia> a = [[1 3; 2 4], [5 7; 6 8]];\n\njulia> b = [[9 11; 10 12], [13 15; 14 16]];\n\njulia> map(.*, a, b)\n2-element Vector{Matrix{Int64}}:\n [9 33; 20 48]\n [65 105; 84 128]\n\njulia> Base.BroadcastFunction(+)(a, b) == a .+ b\ntrue\n\ncompat: Julia 1.6\nBroadcastFunction and the standalone .op syntax are available as of Julia 1.6.\n\n\n\n\n\n"},{"title":"Base.Broadcast.BroadcastStyle","page":"Arrays","location":"base/arrays.html#Base.Broadcast.BroadcastStyle","category":"type","text":"BroadcastStyle is an abstract type and trait-function used to determine behavior of\nobjects under broadcasting. BroadcastStyle(typeof(x)) returns the style associated\nwith x. To customize the broadcasting behavior of a type, one can declare a style\nby defining a type/method pair\n\nstruct MyContainerStyle <: BroadcastStyle end\nBase.BroadcastStyle(::Type{<:MyContainer}) = MyContainerStyle()\n\nOne then writes method(s) (at least similar) operating on\nBroadcasted{MyContainerStyle}. There are also several pre-defined subtypes of BroadcastStyle\nthat you may be able to leverage; see the\nInterfaces chapter for more information.\n\n\n\n\n\n"},{"title":"Base.Broadcast.AbstractArrayStyle","page":"Arrays","location":"base/arrays.html#Base.Broadcast.AbstractArrayStyle","category":"type","text":"Broadcast.AbstractArrayStyle{N} <: BroadcastStyle is the abstract supertype for any style\nassociated with an AbstractArray type.\nThe N parameter is the dimensionality, which can be handy for AbstractArray types\nthat only support specific dimensionalities:\n\nstruct SparseMatrixStyle <: Broadcast.AbstractArrayStyle{2} end\nBase.BroadcastStyle(::Type{<:SparseMatrixCSC}) = SparseMatrixStyle()\n\nFor AbstractArray types that support arbitrary dimensionality, N can be set to Any:\n\nstruct MyArrayStyle <: Broadcast.AbstractArrayStyle{Any} end\nBase.BroadcastStyle(::Type{<:MyArray}) = MyArrayStyle()\n\nIn cases where you want to be able to mix multiple AbstractArrayStyles and keep track\nof dimensionality, your style needs to support a Val constructor:\n\nstruct MyArrayStyleDim{N} <: Broadcast.AbstractArrayStyle{N} end\n(::Type{<:MyArrayStyleDim})(::Val{N}) where N = MyArrayStyleDim{N}()\n\nNote that if two or more AbstractArrayStyle subtypes conflict, broadcasting machinery\nwill fall back to producing Arrays. If this is undesirable, you may need to\ndefine binary BroadcastStyle rules to control the output type.\n\nSee also Broadcast.DefaultArrayStyle.\n\n\n\n\n\n"},{"title":"Base.Broadcast.ArrayStyle","page":"Arrays","location":"base/arrays.html#Base.Broadcast.ArrayStyle","category":"type","text":"Broadcast.ArrayStyle{MyArrayType}() is a BroadcastStyle indicating that an object\nbehaves as an array for broadcasting. It presents a simple way to construct\nBroadcast.AbstractArrayStyles for specific AbstractArray container types.\nBroadcast styles created this way lose track of dimensionality; if keeping track is important\nfor your type, you should create your own custom Broadcast.AbstractArrayStyle.\n\n\n\n\n\n"},{"title":"Base.Broadcast.DefaultArrayStyle","page":"Arrays","location":"base/arrays.html#Base.Broadcast.DefaultArrayStyle","category":"type","text":"Broadcast.DefaultArrayStyle{N}() is a BroadcastStyle indicating that an object\nbehaves as an N-dimensional array for broadcasting. Specifically, DefaultArrayStyle is\nused for any\nAbstractArray type that hasn't defined a specialized style, and in the absence of\noverrides from other broadcast arguments the resulting output type is Array.\nWhen there are multiple inputs to broadcast, DefaultArrayStyle \"loses\" to any other Broadcast.ArrayStyle.\n\n\n\n\n\n"},{"title":"Base.Broadcast.broadcastable","page":"Arrays","location":"base/arrays.html#Base.Broadcast.broadcastable","category":"function","text":"Broadcast.broadcastable(x)\n\nReturn either x or an object like x such that it supports axes, indexing, and its type supports ndims.\n\nIf x supports iteration, the returned value should have the same axes and indexing\nbehaviors as collect(x).\n\nIf x is not an AbstractArray but it supports axes, indexing, and its type supports\nndims, then broadcastable(::typeof(x)) may be implemented to just return itself.\nFurther, if x defines its own BroadcastStyle, then it must define its\nbroadcastable method to return itself for the custom style to have any effect.\n\nExamples\n\njulia> Broadcast.broadcastable([1,2,3]) # like `identity` since arrays already support axes and indexing\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> Broadcast.broadcastable(Int) # Types don't support axes, indexing, or iteration but are commonly used as scalars\nBase.RefValue{Type{Int64}}(Int64)\n\njulia> Broadcast.broadcastable(\"hello\") # Strings break convention of matching iteration and act like a scalar instead\nBase.RefValue{String}(\"hello\")\n\n\n\n\n\n"},{"title":"Base.Broadcast.combine_axes","page":"Arrays","location":"base/arrays.html#Base.Broadcast.combine_axes","category":"function","text":"combine_axes(As...)::Tuple\n\nDetermine the result axes for broadcasting across all values in As.\n\njulia> Broadcast.combine_axes([1], [1 2; 3 4; 5 6])\n(Base.OneTo(3), Base.OneTo(2))\n\njulia> Broadcast.combine_axes(1, 1, 1)\n()\n\n\n\n\n\n"},{"title":"Base.Broadcast.combine_styles","page":"Arrays","location":"base/arrays.html#Base.Broadcast.combine_styles","category":"function","text":"combine_styles(cs...)::BroadcastStyle\n\nDecides which BroadcastStyle to use for any number of value arguments.\nUses BroadcastStyle to get the style for each argument, and uses\nresult_style to combine styles.\n\nExamples\n\njulia> Broadcast.combine_styles([1], [1 2; 3 4])\nBase.Broadcast.DefaultArrayStyle{2}()\n\n\n\n\n\n"},{"title":"Base.Broadcast.result_style","page":"Arrays","location":"base/arrays.html#Base.Broadcast.result_style","category":"function","text":"result_style(s1::BroadcastStyle[, s2::BroadcastStyle])::BroadcastStyle\n\nTakes one or two BroadcastStyles and combines them using BroadcastStyle to\ndetermine a common BroadcastStyle.\n\nExamples\n\njulia> Broadcast.result_style(Broadcast.DefaultArrayStyle{0}(), Broadcast.DefaultArrayStyle{3}())\nBase.Broadcast.DefaultArrayStyle{3}()\n\njulia> Broadcast.result_style(Broadcast.Unknown(), Broadcast.DefaultArrayStyle{1}())\nBase.Broadcast.DefaultArrayStyle{1}()\n\n\n\n\n\n"},{"title":"Base.getindex","page":"Arrays","location":"base/arrays.html#Base.getindex-Tuple{AbstractArray, Vararg{Any}}","category":"method","text":"getindex(A, inds...)\n\nReturn a subset of array A as selected by the indices inds.\n\nEach index may be any supported index type, such\nas an Integer, CartesianIndex, range, or array of supported indices.\nA : may be used to select all elements along a specific dimension, and a boolean array (e.g. an Array{Bool} or a BitArray) may be used to filter for elements where the corresponding index is true.\n\nWhen inds selects multiple elements, this function returns a newly\nallocated array. To index multiple elements without making a copy,\nuse view instead.\n\nSee the manual section on array indexing for details.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> getindex(A, 1)\n1\n\njulia> getindex(A, [2, 1])\n2-element Vector{Int64}:\n 3\n 1\n\njulia> getindex(A, 2:4)\n3-element Vector{Int64}:\n 3\n 2\n 4\n\njulia> getindex(A, 2, 1)\n3\n\njulia> getindex(A, CartesianIndex(2, 1))\n3\n\njulia> getindex(A, :, 2)\n2-element Vector{Int64}:\n 2\n 4\n\njulia> getindex(A, 2, :)\n2-element Vector{Int64}:\n 3\n 4\n\njulia> getindex(A, A .> 2)\n2-element Vector{Int64}:\n 3\n 4\n\n\n\n\n\n"},{"title":"Base.setindex!","page":"Arrays","location":"base/arrays.html#Base.setindex!-Tuple{AbstractArray, Any, Vararg{Any}}","category":"method","text":"setindex!(A, X, inds...)\nA[inds...] = X\n\nStore values from array X within some subset of A as specified by inds.\nThe syntax A[inds...] = X is equivalent to (setindex!(A, X, inds...); X).\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nExamples\n\njulia> A = zeros(2,2);\n\njulia> setindex!(A, [10, 20], [1, 2]);\n\njulia> A[[3, 4]] = [30, 40];\n\njulia> A\n2×2 Matrix{Float64}:\n 10.0  30.0\n 20.0  40.0\n\n\n\n\n\n"},{"title":"Base.nextind","page":"Arrays","location":"base/arrays.html#Base.nextind","category":"function","text":"nextind(A, i)\n\nReturn the index after i in A. The returned index is often equivalent to\ni + 1 for an integer i. This function can be useful for generic code.\n\nwarning: Warning\nThe returned index might be out of bounds. Consider using\ncheckbounds.\n\nSee also: prevind.\n\nExamples\n\njulia> x = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> nextind(x, 1) # valid result\n2\n\njulia> nextind(x, 4) # invalid result\n5\n\njulia> nextind(x, CartesianIndex(1, 1)) # valid result\nCartesianIndex(2, 1)\n\njulia> nextind(x, CartesianIndex(2, 2)) # invalid result\nCartesianIndex(1, 3)\n\n\n\n\n\n"},{"title":"Base.prevind","page":"Arrays","location":"base/arrays.html#Base.prevind","category":"function","text":"prevind(A, i)\n\nReturn the index before i in A. The returned index is often equivalent to\ni - 1 for an integer i. This function can be useful for generic code.\n\nwarning: Warning\nThe returned index might be out of bounds. Consider using\ncheckbounds.\n\nSee also: nextind.\n\nExamples\n\njulia> x = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> prevind(x, 4) # valid result\n3\n\njulia> prevind(x, 1) # invalid result\n0\n\njulia> prevind(x, CartesianIndex(2, 2)) # valid result\nCartesianIndex(1, 2)\n\njulia> prevind(x, CartesianIndex(1, 1)) # invalid result\nCartesianIndex(2, 0)\n\n\n\n\n\n"},{"title":"Base.copyto!","page":"Arrays","location":"base/arrays.html#Base.copyto!-Tuple{AbstractArray, CartesianIndices, AbstractArray, CartesianIndices}","category":"method","text":"copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -> dest\n\nCopy the block of src in the range of Rsrc to the block of dest\nin the range of Rdest. The sizes of the two regions must match.\n\nExamples\n\njulia> A = zeros(5, 5);\n\njulia> B = [1 2; 3 4];\n\njulia> Ainds = CartesianIndices((2:3, 2:3));\n\njulia> Binds = CartesianIndices(B);\n\njulia> copyto!(A, Ainds, B, Binds)\n5×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  2.0  0.0  0.0\n 0.0  3.0  4.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n"},{"title":"Base.copy!","page":"Arrays","location":"base/arrays.html#Base.copy!","category":"function","text":"copy!(dst, src) -> dst\n\nIn-place copy of src into dst, discarding any pre-existing\nelements in dst.\nIf dst and src are of the same type, dst == src should hold after\nthe call. If dst and src are vector types, they must have equal\noffset. If dst and src are multidimensional arrays, they must have\nequal axes.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nSee also copyto!.\n\nnote: Note\nWhen operating on vector types, if dst and src are not of the\nsame length, dst is resized to length(src) prior to the copy.\n\ncompat: Julia 1.1\nThis method requires at least Julia 1.1. In Julia 1.0 this method\nis available from the Future standard library as Future.copy!.\n\n\n\n\n\ncopy!(dest::AbstractMatrix, src::UniformScaling)\n\nCopies a UniformScaling onto a matrix.\n\ncompat: Julia 1.12\nThis method is available as of Julia 1.12.\n\n\n\n\n\n"},{"title":"Base.isassigned","page":"Arrays","location":"base/arrays.html#Base.isassigned","category":"function","text":"isassigned(array, i)::Bool\n\nTest whether the given array has a value associated with index i. Return false\nif the index is out of bounds, or has an undefined reference.\n\nExamples\n\njulia> isassigned(rand(3, 3), 5)\ntrue\n\njulia> isassigned(rand(3, 3), 3 * 3 + 1)\nfalse\n\njulia> mutable struct Foo end\n\njulia> v = similar(rand(3), Foo)\n3-element Vector{Foo}:\n #undef\n #undef\n #undef\n\njulia> isassigned(v, 1)\nfalse\n\n\n\n\n\n"},{"title":"Base.Colon","page":"Arrays","location":"base/arrays.html#Base.Colon","category":"type","text":"Colon()\n\nColons (:) are used to signify indexing entire objects or dimensions at once.\n\nVery few operations are defined on Colons directly; instead they are converted\nby to_indices to an internal vector type (Base.Slice) to represent the\ncollection of indices they span before being used.\n\nThe singleton instance of Colon is also a function used to construct ranges;\nsee :.\n\n\n\n\n\n"},{"title":"Base.IteratorsMD.CartesianIndex","page":"Arrays","location":"base/arrays.html#Base.IteratorsMD.CartesianIndex","category":"type","text":"CartesianIndex(i, j, k...)   -> I\nCartesianIndex((i, j, k...)) -> I\n\nCreate a multidimensional index I, which can be used for\nindexing a multidimensional array A.  In particular, A[I] is\nequivalent to A[i,j,k...].  One can freely mix integer and\nCartesianIndex indices; for example, A[Ipre, i, Ipost] (where\nIpre and Ipost are CartesianIndex indices and i is an\nInt) can be a useful expression when writing algorithms that\nwork along a single dimension of an array of arbitrary\ndimensionality.\n\nA CartesianIndex is sometimes produced by eachindex, and\nalways when iterating with an explicit CartesianIndices.\n\nAn I::CartesianIndex is treated as a \"scalar\" (not a container)\nfor broadcast.   In order to iterate over the components of a\nCartesianIndex, convert it to a tuple with Tuple(I).\n\nExamples\n\njulia> A = reshape(Vector(1:16), (2, 2, 2, 2))\n2×2×2×2 Array{Int64, 4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\n[:, :, 2, 1] =\n 5  7\n 6  8\n\n[:, :, 1, 2] =\n  9  11\n 10  12\n\n[:, :, 2, 2] =\n 13  15\n 14  16\n\njulia> A[CartesianIndex((1, 1, 1, 1))]\n1\n\njulia> A[CartesianIndex((1, 1, 1, 2))]\n9\n\njulia> A[CartesianIndex((1, 1, 2, 1))]\n5\n\ncompat: Julia 1.10\nUsing a CartesianIndex as a \"scalar\" for broadcast requires\nJulia 1.10; in previous releases, use Ref(I).\n\n\n\n\n\n"},{"title":"Base.IteratorsMD.CartesianIndices","page":"Arrays","location":"base/arrays.html#Base.IteratorsMD.CartesianIndices","category":"type","text":"CartesianIndices(sz::Dims) -> R\nCartesianIndices((istart:[istep:]istop, jstart:[jstep:]jstop, ...)) -> R\n\nDefine a region R spanning a multidimensional rectangular range\nof integer indices. These are most commonly encountered in the\ncontext of iteration, where for I in R ... end will return\nCartesianIndex indices I equivalent to the nested loops\n\nfor j = jstart:jstep:jstop\n    for i = istart:istep:istop\n        ...\n    end\nend\n\nConsequently these can be useful for writing algorithms that\nwork in arbitrary dimensions.\n\nCartesianIndices(A::AbstractArray) -> R\n\nAs a convenience, constructing a CartesianIndices from an array makes a\nrange of its indices.\n\ncompat: Julia 1.6\nThe step range method CartesianIndices((istart:istep:istop, jstart:[jstep:]jstop, ...))\nrequires at least Julia 1.6.\n\nExamples\n\njulia> foreach(println, CartesianIndices((2, 2, 2)))\nCartesianIndex(1, 1, 1)\nCartesianIndex(2, 1, 1)\nCartesianIndex(1, 2, 1)\nCartesianIndex(2, 2, 1)\nCartesianIndex(1, 1, 2)\nCartesianIndex(2, 1, 2)\nCartesianIndex(1, 2, 2)\nCartesianIndex(2, 2, 2)\n\njulia> CartesianIndices(fill(1, (2,3)))\nCartesianIndices((2, 3))\n\nConversion between linear and cartesian indices\n\nLinear index to cartesian index conversion exploits the fact that a\nCartesianIndices is an AbstractArray and can be indexed linearly:\n\njulia> cartesian = CartesianIndices((1:3, 1:2))\nCartesianIndices((1:3, 1:2))\n\njulia> cartesian[4]\nCartesianIndex(1, 2)\n\njulia> cartesian = CartesianIndices((1:2:5, 1:2))\nCartesianIndices((1:2:5, 1:2))\n\njulia> cartesian[2, 2]\nCartesianIndex(3, 2)\n\nBroadcasting\n\nCartesianIndices support broadcasting arithmetic (+ and -) with a CartesianIndex.\n\ncompat: Julia 1.1\nBroadcasting of CartesianIndices requires at least Julia 1.1.\n\njulia> CIs = CartesianIndices((2:3, 5:6))\nCartesianIndices((2:3, 5:6))\n\njulia> CI = CartesianIndex(3, 4)\nCartesianIndex(3, 4)\n\njulia> CIs .+ CI\nCartesianIndices((5:6, 9:10))\n\nFor cartesian to linear index conversion, see LinearIndices.\n\n\n\n\n\n"},{"title":"Base.Dims","page":"Arrays","location":"base/arrays.html#Base.Dims","category":"type","text":"Dims{N}\n\nAn NTuple of N Ints used to represent the dimensions\nof an AbstractArray.\n\n\n\n\n\n"},{"title":"Base.LinearIndices","page":"Arrays","location":"base/arrays.html#Base.LinearIndices","category":"type","text":"LinearIndices(A::AbstractArray)\n\nReturn a LinearIndices array with the same shape and axes as A,\nholding the linear index of each entry in A. Indexing this array with\ncartesian indices allows mapping them to linear indices.\n\nFor arrays with conventional indexing (indices start at 1), or any multidimensional\narray, linear indices range from 1 to length(A). However, for AbstractVectors\nlinear indices are axes(A, 1), and therefore do not start at 1 for vectors with\nunconventional indexing.\n\nCalling this function is the \"safe\" way to write algorithms that\nexploit linear indexing.\n\nExamples\n\njulia> A = fill(1, (5,6,7));\n\njulia> b = LinearIndices(A);\n\njulia> extrema(b)\n(1, 210)\n\nLinearIndices(inds::CartesianIndices) -> R\nLinearIndices(sz::Dims) -> R\nLinearIndices((istart:istop, jstart:jstop, ...)) -> R\n\nReturn a LinearIndices array with the specified shape or axes.\n\nExamples\n\nThe main purpose of this constructor is intuitive conversion\nfrom cartesian to linear indexing:\n\njulia> linear = LinearIndices((1:3, 1:2))\n3×2 LinearIndices{2, Tuple{UnitRange{Int64}, UnitRange{Int64}}}:\n 1  4\n 2  5\n 3  6\n\njulia> linear[1,2]\n4\n\n\n\n\n\n"},{"title":"Base.to_indices","page":"Arrays","location":"base/arrays.html#Base.to_indices","category":"function","text":"to_indices(A, I::Tuple)\n\nConvert the tuple I to a tuple of indices for use in indexing into array A.\n\nThe returned tuple must only contain either Ints or AbstractArrays of\nscalar indices that are supported by array A. It will error upon encountering\na novel index type that it does not know how to process.\n\nFor simple index types, it defers to the unexported Base.to_index(A, i) to\nprocess each index i. While this internal function is not intended to be\ncalled directly, Base.to_index may be extended by custom array or index types\nto provide custom indexing behaviors.\n\nMore complicated index types may require more context about the dimension into\nwhich they index. To support those cases, to_indices(A, I) calls\nto_indices(A, axes(A), I), which then recursively walks through both the\ngiven tuple of indices and the dimensional indices of A in tandem. As such,\nnot all index types are guaranteed to propagate to Base.to_index.\n\nExamples\n\njulia> A = zeros(1,2,3,4);\n\njulia> to_indices(A, (1,1,2,2))\n(1, 1, 2, 2)\n\njulia> to_indices(A, (1,1,2,20)) # no bounds checking\n(1, 1, 2, 20)\n\njulia> to_indices(A, (CartesianIndex((1,)), 2, CartesianIndex((3,4)))) # exotic index\n(1, 2, 3, 4)\n\njulia> to_indices(A, ([1,1], 1:2, 3, 4))\n([1, 1], 1:2, 3, 4)\n\njulia> to_indices(A, (1,2)) # no shape checking\n(1, 2)\n\n\n\n\n\n"},{"title":"Base.checkbounds","page":"Arrays","location":"base/arrays.html#Base.checkbounds","category":"function","text":"checkbounds(A, I...)\n\nThrow an error if the specified indices I are not in bounds for the given array A.\n\n\n\n\n\ncheckbounds(Bool, A, I...)\n\nReturn true if the specified indices I are in bounds for the given\narray A. Subtypes of AbstractArray should specialize this method\nif they need to provide custom bounds checking behaviors; however, in\nmany cases one can rely on A's indices and checkindex.\n\nSee also checkindex.\n\nExamples\n\njulia> A = rand(3, 3);\n\njulia> checkbounds(Bool, A, 2)\ntrue\n\njulia> checkbounds(Bool, A, 3, 4)\nfalse\n\njulia> checkbounds(Bool, A, 1:3)\ntrue\n\njulia> checkbounds(Bool, A, 1:3, 2:4)\nfalse\n\n\n\n\n\n"},{"title":"Base.checkindex","page":"Arrays","location":"base/arrays.html#Base.checkindex","category":"function","text":"checkindex(Bool, inds::AbstractUnitRange, index)\n\nReturn true if the given index is within the bounds of\ninds. Custom types that would like to behave as indices for all\narrays can extend this method in order to provide a specialized bounds\nchecking implementation.\n\nSee also checkbounds.\n\nExamples\n\njulia> checkindex(Bool, 1:20, 8)\ntrue\n\njulia> checkindex(Bool, 1:20, 21)\nfalse\n\n\n\n\n\n"},{"title":"Base.elsize","page":"Arrays","location":"base/arrays.html#Base.elsize","category":"function","text":"elsize(type)\n\nCompute the memory stride in bytes between consecutive elements of eltype\nstored inside the given type, if the array elements are stored densely with a\nuniform linear stride.\n\nExamples\n\njulia> Base.elsize(rand(Float32, 10))\n4\n\n\n\n\n\n"},{"title":"Base.require_one_based_indexing","page":"Arrays","location":"base/arrays.html#Base.require_one_based_indexing","category":"function","text":"require_one_based_indexing(A::AbstractArray)\nrequire_one_based_indexing(A,B...)\n\nThrow an ArgumentError if the indices of any argument start with something other than 1 along any axis.\nSee also has_offset_axes.\n\ncompat: Julia 1.2\nThis function requires at least Julia 1.2.\n\n\n\n\n\n"},{"title":"Base.has_offset_axes","page":"Arrays","location":"base/arrays.html#Base.has_offset_axes","category":"function","text":"has_offset_axes(A)\nhas_offset_axes(A, B, ...)\n\nReturn true if the indices of A start with something other than 1 along any axis.\nIf multiple arguments are passed, equivalent to has_offset_axes(A) || has_offset_axes(B) || ....\n\nSee also require_one_based_indexing.\n\n\n\n\n\n"},{"title":"Base.view","page":"Arrays","location":"base/arrays.html#Base.view","category":"function","text":"view(A, inds...)\n\nLike getindex, but returns a lightweight array that lazily references\n(or is effectively a view into) the parent array A at the given index or indices\ninds instead of eagerly extracting elements or constructing a copied subset.\nCalling getindex or setindex! on the returned value\n(often a SubArray) computes the indices to access or modify the\nparent array on the fly.  The behavior is undefined if the shape of the parent array is\nchanged after view is called because there is no bound check for the parent array; e.g.,\nit may cause a segmentation fault. It is likewise undefined behavior to modify the inds\narray(s) after construction of the view.\n\nSome immutable parent arrays (like ranges) may choose to simply\nrecompute a new array in some circumstances instead of returning\na SubArray if doing so is efficient and provides compatible semantics.\n\ncompat: Julia 1.6\nIn Julia 1.6 or later, view can be called on an AbstractString, returning a\nSubString.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> b = view(A, :, 1)\n2-element view(::Matrix{Int64}, :, 1) with eltype Int64:\n 1\n 3\n\njulia> fill!(b, 0)\n2-element view(::Matrix{Int64}, :, 1) with eltype Int64:\n 0\n 0\n\njulia> A # Note A has changed even though we modified b\n2×2 Matrix{Int64}:\n 0  2\n 0  4\n\njulia> view(2:5, 2:3) # returns a range as type is immutable\n3:4\n\n\n\n\n\n"},{"title":"Base.@view","page":"Arrays","location":"base/arrays.html#Base.@view","category":"macro","text":"@view A[inds...]\n\nTransform the indexing expression A[inds...] into the equivalent view call.\n\nThis can only be applied directly to a single indexing expression and is particularly\nhelpful for expressions that include the special begin or end indexing syntaxes\nlike A[begin, 2:end-1] (as those are not supported by the normal view\nfunction).\n\nNote that @view cannot be used as the target of a regular assignment (e.g.,\n@view(A[1, 2:end]) = ...), nor would the un-decorated\nindexed assignment (A[1, 2:end] = ...)\nor broadcasted indexed assignment (A[1, 2:end] .= ...) make a copy.  It can be useful,\nhowever, for updating broadcasted assignments like @view(A[1, 2:end]) .+= 1\nbecause this is a simple syntax for @view(A[1, 2:end]) .= @view(A[1, 2:end]) + 1,\nand the indexing expression on the right-hand side would otherwise make a\ncopy without the @view.\n\nSee also @views to switch an entire block of code to use views for non-scalar indexing.\n\ncompat: Julia 1.5\nUsing begin in an indexing expression to refer to the first index requires at least\nJulia 1.5.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> b = @view A[:, 1]\n2-element view(::Matrix{Int64}, :, 1) with eltype Int64:\n 1\n 3\n\njulia> fill!(b, 0)\n2-element view(::Matrix{Int64}, :, 1) with eltype Int64:\n 0\n 0\n\njulia> A\n2×2 Matrix{Int64}:\n 0  2\n 0  4\n\n\n\n\n\n"},{"title":"Base.@views","page":"Arrays","location":"base/arrays.html#Base.@views","category":"macro","text":"@views expression\n\nConvert every array-slicing operation in the given expression\n(which may be a begin/end block, loop, function, etc.)\nto return a view. Scalar indices, non-array types, and\nexplicit getindex calls (as opposed to array[...]) are\nunaffected.\n\nSimilarly, @views converts string slices into SubString views.\n\nnote: Note\nThe @views macro only affects array[...] expressions\nthat appear explicitly in the given expression, not array slicing that\noccurs in functions called by that code.\n\ncompat: Julia 1.5\nUsing begin in an indexing expression to refer to the first index was implemented\nin Julia 1.4, but was only supported by @views starting in Julia 1.5.\n\nExamples\n\njulia> A = zeros(3, 3);\n\njulia> @views for row in 1:3\n           b = A[row, :] # b is a view, not a copy\n           b .= row      # assign every element to the row index\n       end\n\njulia> A\n3×3 Matrix{Float64}:\n 1.0  1.0  1.0\n 2.0  2.0  2.0\n 3.0  3.0  3.0\n\n\n\n\n\n"},{"title":"Base.parent","page":"Arrays","location":"base/arrays.html#Base.parent","category":"function","text":"parent(A)\n\nReturn the underlying parent object of the view. This parent of objects of types SubArray, SubString, ReshapedArray\nor LinearAlgebra.Transpose is what was passed as an argument to view, reshape, transpose, etc.\nduring object creation. If the input is not a wrapped object, return the input itself. If the input is\nwrapped multiple times, only the outermost wrapper will be removed.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> V = view(A, 1:2, :)\n2×2 view(::Matrix{Int64}, 1:2, :) with eltype Int64:\n 1  2\n 3  4\n\njulia> parent(V)\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\n\n\n\n\n"},{"title":"Base.parentindices","page":"Arrays","location":"base/arrays.html#Base.parentindices","category":"function","text":"parentindices(A)\n\nReturn the indices in the parent which correspond to the view A.\n\nExamples\n\njulia> A = [1 2; 3 4];\n\njulia> V = view(A, 1, :)\n2-element view(::Matrix{Int64}, 1, :) with eltype Int64:\n 1\n 2\n\njulia> parentindices(V)\n(1, Base.Slice(Base.OneTo(2)))\n\n\n\n\n\n"},{"title":"Base.selectdim","page":"Arrays","location":"base/arrays.html#Base.selectdim","category":"function","text":"selectdim(A, d::Integer, i)\n\nReturn a view of all the data of A where the index for dimension d equals i.\n\nEquivalent to view(A,:,:,...,i,:,:,...) where i is in position d.\n\nSee also: eachslice.\n\nExamples\n\njulia> A = [1 2 3 4; 5 6 7 8]\n2×4 Matrix{Int64}:\n 1  2  3  4\n 5  6  7  8\n\njulia> selectdim(A, 2, 3)\n2-element view(::Matrix{Int64}, :, 3) with eltype Int64:\n 3\n 7\n\njulia> selectdim(A, 2, 3:4)\n2×2 view(::Matrix{Int64}, :, 3:4) with eltype Int64:\n 3  4\n 7  8\n\n\n\n\n\n"},{"title":"Base.reinterpret","page":"Arrays","location":"base/arrays.html#Base.reinterpret","category":"function","text":"reinterpret(reshape, T, A::AbstractArray{S}) -> B\n\nChange the type-interpretation of A while consuming or adding a \"channel dimension.\"\n\nIf sizeof(T) = n*sizeof(S) for n>1, A's first dimension must be\nof size n and B lacks A's first dimension. Conversely, if sizeof(S) = n*sizeof(T) for n>1,\nB gets a new first dimension of size n. The dimensionality is unchanged if sizeof(T) == sizeof(S).\n\ncompat: Julia 1.6\nThis method requires at least Julia 1.6.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> reinterpret(reshape, Complex{Int}, A)    # the result is a vector\n2-element reinterpret(reshape, Complex{Int64}, ::Matrix{Int64}) with eltype Complex{Int64}:\n 1 + 3im\n 2 + 4im\n\njulia> a = [(1,2,3), (4,5,6)]\n2-element Vector{Tuple{Int64, Int64, Int64}}:\n (1, 2, 3)\n (4, 5, 6)\n\njulia> reinterpret(reshape, Int, a)             # the result is a matrix\n3×2 reinterpret(reshape, Int64, ::Vector{Tuple{Int64, Int64, Int64}}) with eltype Int64:\n 1  4\n 2  5\n 3  6\n\n\n\n\n\nreinterpret(T::DataType, A::AbstractArray)\n\nConstruct a view of the array with the same binary data as the given\narray, but with T as element type.\n\nThis function also works on \"lazy\" array whose elements are not computed until they are explicitly retrieved.\nFor instance, reinterpret on the range 1:6 works similarly as on the dense vector collect(1:6):\n\njulia> reinterpret(Float32, UInt32[1 2 3 4 5])\n1×5 reinterpret(Float32, ::Matrix{UInt32}):\n 1.0f-45  3.0f-45  4.0f-45  6.0f-45  7.0f-45\n\njulia> reinterpret(Complex{Int}, 1:6)\n3-element reinterpret(Complex{Int64}, ::UnitRange{Int64}):\n 1 + 2im\n 3 + 4im\n 5 + 6im\n\nIf the location of padding bits does not line up between T and eltype(A), the resulting array will be\nread-only or write-only, to prevent invalid bits from being written to or read from, respectively.\n\njulia> a = reinterpret(Tuple{UInt8, UInt32}, UInt32[1, 2])\n1-element reinterpret(Tuple{UInt8, UInt32}, ::Vector{UInt32}):\n (0x01, 0x00000002)\n\njulia> a[1] = 3\nERROR: Padding of type Tuple{UInt8, UInt32} is not compatible with type UInt32.\n\njulia> b = reinterpret(UInt32, Tuple{UInt8, UInt32}[(0x01, 0x00000002)]); # showing will error\n\njulia> b[1]\nERROR: Padding of type UInt32 is not compatible with type Tuple{UInt8, UInt32}.\n\n\n\n\n\nreinterpret(::Type{Out}, x::In)\n\nChange the type-interpretation of the binary data in the isbits value x\nto that of the isbits type Out.\nThe size (ignoring padding) of Out has to be the same as that of the type of x.\nFor example, reinterpret(Float32, UInt32(7)) interprets the 4 bytes corresponding to UInt32(7) as a\nFloat32. Note that reinterpret(In, reinterpret(Out, x)) === x\n\njulia> reinterpret(Float32, UInt32(7))\n1.0f-44\n\njulia> reinterpret(NTuple{2, UInt8}, 0x1234)\n(0x34, 0x12)\n\njulia> reinterpret(UInt16, (0x34, 0x12))\n0x1234\n\njulia> reinterpret(Tuple{UInt16, UInt8}, (0x01, 0x0203))\n(0x0301, 0x02)\n\nnote: Note\nThe treatment of padding differs from reinterpret(::DataType, ::AbstractArray).\n\nwarning: Warning\nUse caution if some combinations of bits in Out are not considered valid and would\notherwise be prevented by the type's constructors and methods. Unexpected behavior\nmay result without additional validation.\n\n\n\n\n\n"},{"title":"Base.reshape","page":"Arrays","location":"base/arrays.html#Base.reshape","category":"function","text":"reshape(A, dims...)::AbstractArray\nreshape(A, dims)::AbstractArray\n\nReturn an array with the same data as A, but with different\ndimension sizes or number of dimensions. The two arrays share the same\nunderlying data, so that the result is mutable if and only if A is\nmutable, and setting elements of one alters the values of the other.\n\nThe new dimensions may be specified either as a list of arguments or\nas a shape tuple. At most one dimension may be specified with a :,\nin which case its length is computed such that its product with all\nthe specified dimensions is equal to the length of the original array\nA. The total number of elements must not change.\n\nExamples\n\njulia> A = Vector(1:16)\n16-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n\njulia> reshape(A, (4, 4))\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> reshape(A, 2, :)\n2×8 Matrix{Int64}:\n 1  3  5  7   9  11  13  15\n 2  4  6  8  10  12  14  16\n\njulia> reshape(1:6, 2, 3)\n2×3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:\n 1  3  5\n 2  4  6\n\n\n\n\n\n"},{"title":"Base.insertdims","page":"Arrays","location":"base/arrays.html#Base.insertdims","category":"function","text":"insertdims(A; dims)\n\nInverse of dropdims; return an array with new singleton dimensions\nat every dimension in dims.\n\nRepeated dimensions are forbidden and the largest entry in dims must be\nless than or equal than ndims(A) + length(dims).\n\nThe result shares the same underlying data as A, such that the\nresult is mutable if and only if A is mutable, and setting elements of one\nalters the values of the other.\n\nSee also: dropdims, reshape, vec.\n\nExamples\n\njulia> x = [1 2 3; 4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> insertdims(x, dims=3)\n2×3×1 Array{Int64, 3}:\n[:, :, 1] =\n 1  2  3\n 4  5  6\n\njulia> insertdims(x, dims=(1,2,5)) == reshape(x, 1, 1, 2, 3, 1)\ntrue\n\njulia> dropdims(insertdims(x, dims=(1,2,5)), dims=(1,2,5))\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\ncompat: Julia 1.12\nRequires Julia 1.12 or later.\n\n\n\n\n\n"},{"title":"Base.dropdims","page":"Arrays","location":"base/arrays.html#Base.dropdims","category":"function","text":"dropdims(A; dims)\n\nReturn an array with the same data as A, but with the dimensions specified by\ndims removed. size(A,d) must equal 1 for every d in dims,\nand repeated dimensions or numbers outside 1:ndims(A) are forbidden.\n\nThe result shares the same underlying data as A, such that the\nresult is mutable if and only if A is mutable, and setting elements of one\nalters the values of the other.\n\nSee also: reshape, vec.\n\nExamples\n\njulia> a = reshape(Vector(1:4),(2,2,1,1))\n2×2×1×1 Array{Int64, 4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\njulia> b = dropdims(a; dims=3)\n2×2×1 Array{Int64, 3}:\n[:, :, 1] =\n 1  3\n 2  4\n\njulia> b[1,1,1] = 5; a\n2×2×1×1 Array{Int64, 4}:\n[:, :, 1, 1] =\n 5  3\n 2  4\n\n\n\n\n\n"},{"title":"Base.vec","page":"Arrays","location":"base/arrays.html#Base.vec","category":"function","text":"vec(a::AbstractArray)::AbstractVector\n\nReshape the array a as a one-dimensional column vector. Return a if it is\nalready an AbstractVector. The resulting array\nshares the same underlying data as a, so it will only be mutable if a is\nmutable, in which case modifying one will also modify the other.\n\nExamples\n\njulia> a = [1 2 3; 4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> vec(a)\n6-element Vector{Int64}:\n 1\n 4\n 2\n 5\n 3\n 6\n\njulia> vec(1:3)\n1:3\n\nSee also reshape, dropdims.\n\n\n\n\n\n"},{"title":"Base.SubArray","page":"Arrays","location":"base/arrays.html#Base.SubArray","category":"type","text":"SubArray{T,N,P,I,L} <: AbstractArray{T,N}\n\nN-dimensional view into a parent array (of type P) with an element type T, restricted by a tuple of indices (of type I). L is true for types that support fast linear indexing, and false otherwise.\n\nConstruct SubArrays using the view function.\n\n\n\n\n\n"},{"title":"Base.cat","page":"Arrays","location":"base/arrays.html#Base.cat","category":"function","text":"cat(A...; dims)\n\nConcatenate the input arrays along the dimensions specified in dims.\n\nAlong a dimension d in dims, the size of the output array is sum(size(a,d) for a in A).\nAlong other dimensions, all input arrays should have the same size,\nwhich will also be the size of the output array along those dimensions.\n\nIf dims is a single number, the different arrays are tightly packed along that dimension.\nIf dims is an iterable containing several dimensions, the positions along these dimensions\nare increased simultaneously for each input array, filling with zero elsewhere.\nThis allows one to construct block-diagonal matrices as cat(matrices...; dims=(1,2)),\nand their higher-dimensional analogues.\n\nThe special case dims=1 is vcat, and dims=2 is hcat.\nSee also hvcat, hvncat, stack, repeat.\n\nThe keyword also accepts Val(dims).\n\ncompat: Julia 1.8\nFor multiple dimensions dims = Val(::Tuple) was added in Julia 1.8.\n\nExamples\n\nConcatenate two arrays in different dimensions:\n\njulia> a = [1 2 3]\n1×3 Matrix{Int64}:\n 1  2  3\n\njulia> b = [4 5 6]\n1×3 Matrix{Int64}:\n 4  5  6\n\njulia> cat(a, b; dims=1)\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> cat(a, b; dims=2)\n1×6 Matrix{Int64}:\n 1  2  3  4  5  6\n\njulia> cat(a, b; dims=(1, 2))\n2×6 Matrix{Int64}:\n 1  2  3  0  0  0\n 0  0  0  4  5  6\n\nExtended Help\n\nConcatenate 3D arrays:\n\njulia> a = ones(2, 2, 3);\n\njulia> b = ones(2, 2, 4);\n\njulia> c = cat(a, b; dims=3);\n\njulia> size(c) == (2, 2, 7)\ntrue\n\nConcatenate arrays of different sizes:\n\njulia> cat([1 2; 3 4], [pi, pi], fill(10, 2,3,1); dims=2)  # same as hcat\n2×6×1 Array{Float64, 3}:\n[:, :, 1] =\n 1.0  2.0  3.14159  10.0  10.0  10.0\n 3.0  4.0  3.14159  10.0  10.0  10.0\n\nConstruct a block diagonal matrix:\n\njulia> cat(true, trues(2,2), trues(4)', dims=(1,2))  # block-diagonal\n4×7 Matrix{Bool}:\n 1  0  0  0  0  0  0\n 0  1  1  0  0  0  0\n 0  1  1  0  0  0  0\n 0  0  0  1  1  1  1\n\njulia> cat(1, [2], [3;;]; dims=Val(2))\n1×3 Matrix{Int64}:\n 1  2  3\n\nnote: Note\ncat does not join two strings, you may want to use *.\n\njulia> a = \"aaa\";\n\njulia> b = \"bbb\";\n\njulia> cat(a, b; dims=1)\n2-element Vector{String}:\n \"aaa\"\n \"bbb\"\n\njulia> cat(a, b; dims=2)\n1×2 Matrix{String}:\n \"aaa\"  \"bbb\"\n\njulia> a * b\n\"aaabbb\"\n\n\n\n\n\n"},{"title":"Base.vcat","page":"Arrays","location":"base/arrays.html#Base.vcat","category":"function","text":"vcat(A...)\n\nConcatenate arrays or numbers vertically. Equivalent to cat(A...; dims=1),\nand to the syntax [a; b; c].\n\nTo concatenate a large vector of arrays, reduce(vcat, A) calls an efficient method\nwhen A isa AbstractVector{<:AbstractVecOrMat}, rather than working pairwise.\n\nSee also hcat, Iterators.flatten, stack.\n\nExamples\n\njulia> v = vcat([1,2], [3,4])\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> v == vcat(1, 2, [3,4])  # accepts numbers\ntrue\n\njulia> v == [1; 2; [3,4]]  # syntax for the same operation\ntrue\n\njulia> summary(ComplexF64[1; 2; [3,4]])  # syntax for supplying the element type\n\"4-element Vector{ComplexF64}\"\n\njulia> vcat(range(1, 2, length=3))  # collects lazy ranges\n3-element Vector{Float64}:\n 1.0\n 1.5\n 2.0\n\njulia> two = ([10, 20, 30]', Float64[4 5 6; 7 8 9])  # row vector and a matrix\n(adjoint([10, 20, 30]), [4.0 5.0 6.0; 7.0 8.0 9.0])\n\njulia> vcat(two...)\n3×3 Matrix{Float64}:\n 10.0  20.0  30.0\n  4.0   5.0   6.0\n  7.0   8.0   9.0\n\njulia> vs = [[1, 2], [3, 4], [5, 6]];\n\njulia> reduce(vcat, vs)  # more efficient than vcat(vs...)\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> ans == collect(Iterators.flatten(vs))\ntrue\n\n\n\n\n\n"},{"title":"Base.hcat","page":"Arrays","location":"base/arrays.html#Base.hcat","category":"function","text":"hcat(A...)\n\nConcatenate arrays or numbers horizontally. Equivalent to cat(A...; dims=2),\nand to the syntax [a b c] or [a;; b;; c].\n\nFor a large vector of arrays, reduce(hcat, A) calls an efficient method\nwhen A isa AbstractVector{<:AbstractVecOrMat}.\nFor a vector of vectors, this can also be written stack(A).\n\nSee also vcat, hvcat.\n\nExamples\n\njulia> hcat([1,2], [3,4], [5,6])\n2×3 Matrix{Int64}:\n 1  3  5\n 2  4  6\n\njulia> hcat(1, 2, [30 40], [5, 6, 7]')  # accepts numbers\n1×7 Matrix{Int64}:\n 1  2  30  40  5  6  7\n\njulia> ans == [1 2 [30 40] [5, 6, 7]']  # syntax for the same operation\ntrue\n\njulia> Float32[1 2 [30 40] [5, 6, 7]']  # syntax for supplying the eltype\n1×7 Matrix{Float32}:\n 1.0  2.0  30.0  40.0  5.0  6.0  7.0\n\njulia> ms = [zeros(2,2), [1 2; 3 4], [50 60; 70 80]];\n\njulia> reduce(hcat, ms)  # more efficient than hcat(ms...)\n2×6 Matrix{Float64}:\n 0.0  0.0  1.0  2.0  50.0  60.0\n 0.0  0.0  3.0  4.0  70.0  80.0\n\njulia> stack(ms) |> summary  # disagrees on a vector of matrices\n\"2×2×3 Array{Float64, 3}\"\n\njulia> hcat(Int[], Int[], Int[])  # empty vectors, each of size (0,)\n0×3 Matrix{Int64}\n\njulia> hcat([1.1, 9.9], Matrix(undef, 2, 0))  # hcat with empty 2×0 Matrix\n2×1 Matrix{Any}:\n 1.1\n 9.9\n\n\n\n\n\n"},{"title":"Base.hvcat","page":"Arrays","location":"base/arrays.html#Base.hvcat","category":"function","text":"hvcat(blocks_per_row::Union{Tuple{Vararg{Int}}, Int}, values...)\n\nHorizontal and vertical concatenation in one call. This function is called for block matrix\nsyntax. The first argument specifies the number of arguments to concatenate in each block\nrow. If the first argument is a single integer n, then all block rows are assumed to have n\nblock columns.\n\nExamples\n\njulia> a, b, c, d, e, f = 1, 2, 3, 4, 5, 6\n(1, 2, 3, 4, 5, 6)\n\njulia> [a b c; d e f]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> hvcat((3,3), a,b,c,d,e,f)\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> [a b; c d; e f]\n3×2 Matrix{Int64}:\n 1  2\n 3  4\n 5  6\n\njulia> hvcat((2,2,2), a,b,c,d,e,f)\n3×2 Matrix{Int64}:\n 1  2\n 3  4\n 5  6\njulia> hvcat((2,2,2), a,b,c,d,e,f) == hvcat(2, a,b,c,d,e,f)\ntrue\n\n\n\n\n\n"},{"title":"Base.hvncat","page":"Arrays","location":"base/arrays.html#Base.hvncat","category":"function","text":"hvncat(dim::Int, row_first, values...)\nhvncat(dims::Tuple{Vararg{Int}}, row_first, values...)\nhvncat(shape::Tuple{Vararg{Tuple}}, row_first, values...)\n\nHorizontal, vertical, and n-dimensional concatenation of many values in one call.\n\nThis function is called for block matrix syntax. The first argument either specifies the\nshape of the concatenation, similar to hvcat, as a tuple of tuples, or the dimensions that\nspecify the key number of elements along each axis, and is used to determine the output\ndimensions. The dims form is more performant, and is used by default when the concatenation\noperation has the same number of elements along each axis (e.g., [a b; c d;;; e f ; g h]).\nThe shape form is used when the number of elements along each axis is unbalanced\n(e.g., [a b ; c]). Unbalanced syntax needs additional validation overhead. The dim form\nis an optimization for concatenation along just one dimension. row_first indicates how\nvalues are ordered. The meaning of the first and second elements of shape are also\nswapped based on row_first.\n\nExamples\n\njulia> a, b, c, d, e, f = 1, 2, 3, 4, 5, 6\n(1, 2, 3, 4, 5, 6)\n\njulia> [a b c;;; d e f]\n1×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  2  3\n\n[:, :, 2] =\n 4  5  6\n\njulia> hvncat((2,1,3), false, a,b,c,d,e,f)\n2×1×3 Array{Int64, 3}:\n[:, :, 1] =\n 1\n 2\n\n[:, :, 2] =\n 3\n 4\n\n[:, :, 3] =\n 5\n 6\n\njulia> [a b;;; c d;;; e f]\n1×2×3 Array{Int64, 3}:\n[:, :, 1] =\n 1  2\n\n[:, :, 2] =\n 3  4\n\n[:, :, 3] =\n 5  6\n\njulia> hvncat(((3, 3), (3, 3), (6,)), true, a, b, c, d, e, f)\n1×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  2  3\n\n[:, :, 2] =\n 4  5  6\n\nExamples for construction of the arguments\n\n[a b c ; d e f ;;;\n g h i ; j k l ;;;\n m n o ; p q r ;;;\n s t u ; v w x]\n⇒ dims = (2, 3, 4)\n\n[a b ; c ;;; d ;;;;]\n ___   _     _\n 2     1     1 = elements in each row (2, 1, 1)\n _______     _\n 3           1 = elements in each column (3, 1)\n _____________\n 4             = elements in each 3d slice (4,)\n _____________\n 4             = elements in each 4d slice (4,)\n⇒ shape = ((2, 1, 1), (3, 1), (4,), (4,)) with `row_first` = true\n\n\n\n\n\n"},{"title":"Base.stack","page":"Arrays","location":"base/arrays.html#Base.stack","category":"function","text":"stack(f, args...; [dims])\n\nApply a function to each element of a collection, and stack the result.\nOr to several collections, zipped together.\n\nThe function should return arrays (or tuples, or other iterators) all of the same size.\nThese become slices of the result, each separated along dims (if given) or by default\nalong the last dimensions.\n\nSee also mapslices, eachcol.\n\nExamples\n\njulia> stack(c -> (c, c-32), \"julia\")\n2×5 Matrix{Char}:\n 'j'  'u'  'l'  'i'  'a'\n 'J'  'U'  'L'  'I'  'A'\n\njulia> stack(eachrow([1 2 3; 4 5 6]), (10, 100); dims=1) do row, n\n         vcat(row, row .* n, row ./ n)\n       end\n2×9 Matrix{Float64}:\n 1.0  2.0  3.0   10.0   20.0   30.0  0.1   0.2   0.3\n 4.0  5.0  6.0  400.0  500.0  600.0  0.04  0.05  0.06\n\n\n\n\n\nstack(iter; [dims])\n\nCombine a collection of arrays (or other iterable objects) of equal size\ninto one larger array, by arranging them along one or more new dimensions.\n\nBy default the axes of the elements are placed first,\ngiving size(result) = (size(first(iter))..., size(iter)...).\nThis has the same order of elements as Iterators.flatten(iter).\n\nWith keyword dims::Integer, instead the ith element of iter becomes the slice\nselectdim(result, dims, i), so that size(result, dims) == length(iter).\nIn this case stack reverses the action of eachslice with the same dims.\n\nThe various cat functions also combine arrays. However, these all\nextend the arrays' existing (possibly trivial) dimensions, rather than placing\nthe arrays along new dimensions.\nThey also accept arrays as separate arguments, rather than a single collection.\n\ncompat: Julia 1.9\nThis function requires at least Julia 1.9.\n\nExamples\n\njulia> vecs = (1:2, [30, 40], Float32[500, 600]);\n\njulia> mat = stack(vecs)\n2×3 Matrix{Float32}:\n 1.0  30.0  500.0\n 2.0  40.0  600.0\n\njulia> mat == hcat(vecs...) == reduce(hcat, collect(vecs))\ntrue\n\njulia> vec(mat) == vcat(vecs...) == reduce(vcat, collect(vecs))\ntrue\n\njulia> stack(zip(1:4, 10:99))  # accepts any iterators of iterators\n2×4 Matrix{Int64}:\n  1   2   3   4\n 10  11  12  13\n\njulia> vec(ans) == collect(Iterators.flatten(zip(1:4, 10:99)))\ntrue\n\njulia> stack(vecs; dims=1)  # unlike any cat function, 1st axis of vecs[1] is 2nd axis of result\n3×2 Matrix{Float32}:\n   1.0    2.0\n  30.0   40.0\n 500.0  600.0\n\njulia> x = rand(3,4);\n\njulia> x == stack(eachcol(x)) == stack(eachrow(x), dims=1)  # inverse of eachslice\ntrue\n\nHigher-dimensional examples:\n\njulia> A = rand(5, 7, 11);\n\njulia> E = eachslice(A, dims=2);  # a vector of matrices\n\njulia> (element = size(first(E)), container = size(E))\n(element = (5, 11), container = (7,))\n\njulia> stack(E) |> size\n(5, 11, 7)\n\njulia> stack(E) == stack(E; dims=3) == cat(E...; dims=3)\ntrue\n\njulia> A == stack(E; dims=2)\ntrue\n\njulia> M = (fill(10i+j, 2, 3) for i in 1:5, j in 1:7);\n\njulia> (element = size(first(M)), container = size(M))\n(element = (2, 3), container = (5, 7))\n\njulia> stack(M) |> size  # keeps all dimensions\n(2, 3, 5, 7)\n\njulia> stack(M; dims=1) |> size  # vec(container) along dims=1\n(35, 2, 3)\n\njulia> hvcat(5, M...) |> size  # hvcat puts matrices next to each other\n(14, 15)\n\n\n\n\n\n"},{"title":"Base.vect","page":"Arrays","location":"base/arrays.html#Base.vect","category":"function","text":"vect(X...)\n\nCreate a Vector with element type computed from the promote_typeof of the argument,\ncontaining the argument list.\n\nExamples\n\njulia> a = Base.vect(UInt8(1), 2.5, 1//2)\n3-element Vector{Float64}:\n 1.0\n 2.5\n 0.5\n\n\n\n\n\n"},{"title":"Base.circshift","page":"Arrays","location":"base/arrays.html#Base.circshift","category":"function","text":"circshift(A, shifts)\n\nCircularly shift, i.e. rotate, the data in A. The second argument is a tuple or\nvector giving the amount to shift in each dimension, or an integer to shift only in the\nfirst dimension.\n\nThe generated code is most efficient when the shift amounts are known at compile-time, i.e.,\ncompile-time constants.\n\nSee also: circshift!, circcopy!, bitrotate, <<.\n\nExamples\n\njulia> b = reshape(Vector(1:16), (4,4))\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> circshift(b, (0,2))\n4×4 Matrix{Int64}:\n  9  13  1  5\n 10  14  2  6\n 11  15  3  7\n 12  16  4  8\n\njulia> circshift(b, (-1,0))\n4×4 Matrix{Int64}:\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n 1  5   9  13\n\njulia> a = BitArray([true, true, false, false, true])\n5-element BitVector:\n 1\n 1\n 0\n 0\n 1\n\njulia> circshift(a, 1)\n5-element BitVector:\n 1\n 1\n 1\n 0\n 0\n\njulia> circshift(a, -1)\n5-element BitVector:\n 1\n 0\n 0\n 1\n 1\n\njulia> x = (1, 2, 3, 4, 5)\n(1, 2, 3, 4, 5)\n\njulia> circshift(x, 4)\n(2, 3, 4, 5, 1)\n\njulia> z = (1, 'a', -7.0, 3)\n(1, 'a', -7.0, 3)\n\njulia> circshift(z, -1)\n('a', -7.0, 3, 1)\n\n\n\n\n\n"},{"title":"Base.circshift!","page":"Arrays","location":"base/arrays.html#Base.circshift!","category":"function","text":"circshift!(dest, src, shifts)\n\nCircularly shift, i.e. rotate, the data in src, storing the result in\ndest. shifts specifies the amount to shift in each dimension.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nSee also circshift.\n\n\n\n\n\ncircshift!(a::AbstractVector, shift::Integer)\n\nCircularly shift, or rotate, the data in vector a by shift positions.\n\nExamples\n\njulia> circshift!([1, 2, 3, 4, 5], 2)\n5-element Vector{Int64}:\n 4\n 5\n 1\n 2\n 3\n\njulia> circshift!([1, 2, 3, 4, 5], -2)\n5-element Vector{Int64}:\n 3\n 4\n 5\n 1\n 2\n\n\n\n\n\n"},{"title":"Base.circcopy!","page":"Arrays","location":"base/arrays.html#Base.circcopy!","category":"function","text":"circcopy!(dest, src)\n\nCopy src to dest, indexing each dimension modulo its length.\nsrc and dest must have the same size, but can be offset in\ntheir indices; any offset results in a (circular) wraparound. If the\narrays have overlapping indices, then on the domain of the overlap\ndest agrees with src.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nSee also: circshift.\n\nExamples\n\njulia> src = reshape(Vector(1:16), (4,4))\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> dest = OffsetArray{Int}(undef, (0:3,2:5));\n\njulia> circcopy!(dest, src)\n4×4 OffsetArray(::Matrix{Int64}, 0:3, 2:5) with eltype Int64 with indices 0:3×2:5:\n 8  12  16  4\n 5   9  13  1\n 6  10  14  2\n 7  11  15  3\n\njulia> dest[1:3,2:4] == src[1:3,2:4]\ntrue\n\n\n\n\n\n"},{"title":"Base.findall","page":"Arrays","location":"base/arrays.html#Base.findall-Tuple{Any}","category":"method","text":"findall(A)\n\nReturn a vector I of the true indices or keys of A.\nIf there are no such elements of A, return an empty array.\nTo search for other kinds of values, pass a predicate as the first argument.\n\nIndices or keys are of the same type as those returned by keys(A)\nand pairs(A).\n\nSee also: findfirst, searchsorted.\n\nExamples\n\njulia> A = [true, false, false, true]\n4-element Vector{Bool}:\n 1\n 0\n 0\n 1\n\njulia> findall(A)\n2-element Vector{Int64}:\n 1\n 4\n\njulia> A = [true false; false true]\n2×2 Matrix{Bool}:\n 1  0\n 0  1\n\njulia> findall(A)\n2-element Vector{CartesianIndex{2}}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 2)\n\njulia> findall(falses(3))\nInt64[]\n\n\n\n\n\n"},{"title":"Base.findall","page":"Arrays","location":"base/arrays.html#Base.findall-Tuple{Function, Any}","category":"method","text":"findall(f::Function, A)\n\nReturn a vector I of the indices or keys of A where f(A[I]) returns true.\nIf there are no such elements of A, return an empty array.\n\nIndices or keys are of the same type as those returned by keys(A)\nand pairs(A).\n\nExamples\n\njulia> x = [1, 3, 4]\n3-element Vector{Int64}:\n 1\n 3\n 4\n\njulia> findall(isodd, x)\n2-element Vector{Int64}:\n 1\n 2\n\njulia> A = [1 2 0; 3 4 0]\n2×3 Matrix{Int64}:\n 1  2  0\n 3  4  0\njulia> findall(isodd, A)\n2-element Vector{CartesianIndex{2}}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 1)\n\njulia> findall(!iszero, A)\n4-element Vector{CartesianIndex{2}}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 1)\n CartesianIndex(1, 2)\n CartesianIndex(2, 2)\n\njulia> d = Dict(:A => 10, :B => -1, :C => 0)\nDict{Symbol, Int64} with 3 entries:\n  :A => 10\n  :B => -1\n  :C => 0\n\njulia> findall(≥(0), d)\n2-element Vector{Symbol}:\n :A\n :C\n\n\n\n\n\n\n"},{"title":"Base.findfirst","page":"Arrays","location":"base/arrays.html#Base.findfirst-Tuple{Any}","category":"method","text":"findfirst(A)\n\nReturn the index or key of the first true value in A.\nReturn nothing if no such value is found.\nTo search for other kinds of values, pass a predicate as the first argument.\n\nIndices or keys are of the same type as those returned by keys(A)\nand pairs(A).\n\nSee also: findall, findnext, findlast, searchsortedfirst.\n\nExamples\n\njulia> A = [false, false, true, false]\n4-element Vector{Bool}:\n 0\n 0\n 1\n 0\n\njulia> findfirst(A)\n3\n\njulia> findfirst(falses(3)) # returns nothing, but not printed in the REPL\n\njulia> A = [false false; true false]\n2×2 Matrix{Bool}:\n 0  0\n 1  0\n\njulia> findfirst(A)\nCartesianIndex(2, 1)\n\n\n\n\n\n"},{"title":"Base.findfirst","page":"Arrays","location":"base/arrays.html#Base.findfirst-Tuple{Function, Any}","category":"method","text":"findfirst(predicate::Function, A)\n\nReturn the index or key of the first element of A for which predicate returns true.\nReturn nothing if there is no such element.\n\nIndices or keys are of the same type as those returned by keys(A)\nand pairs(A).\n\nExamples\n\njulia> A = [1, 4, 2, 2]\n4-element Vector{Int64}:\n 1\n 4\n 2\n 2\n\njulia> findfirst(iseven, A)\n2\n\njulia> findfirst(x -> x>10, A) # returns nothing, but not printed in the REPL\n\njulia> findfirst(isequal(4), A)\n2\n\njulia> A = [1 4; 2 2]\n2×2 Matrix{Int64}:\n 1  4\n 2  2\n\njulia> findfirst(iseven, A)\nCartesianIndex(2, 1)\n\n\n\n\n\n"},{"title":"Base.findlast","page":"Arrays","location":"base/arrays.html#Base.findlast-Tuple{Any}","category":"method","text":"findlast(A)\n\nReturn the index or key of the last true value in A.\nReturn nothing if there is no true value in A.\n\nIndices or keys are of the same type as those returned by keys(A)\nand pairs(A).\n\nSee also: findfirst, findprev, findall.\n\nExamples\n\njulia> A = [true, false, true, false]\n4-element Vector{Bool}:\n 1\n 0\n 1\n 0\n\njulia> findlast(A)\n3\n\njulia> A = falses(2,2);\n\njulia> findlast(A) # returns nothing, but not printed in the REPL\n\njulia> A = [true false; true false]\n2×2 Matrix{Bool}:\n 1  0\n 1  0\n\njulia> findlast(A)\nCartesianIndex(2, 1)\n\n\n\n\n\n"},{"title":"Base.findlast","page":"Arrays","location":"base/arrays.html#Base.findlast-Tuple{Function, Any}","category":"method","text":"findlast(predicate::Function, A)\n\nReturn the index or key of the last element of A for which predicate returns true.\nReturn nothing if there is no such element.\n\nIndices or keys are of the same type as those returned by keys(A)\nand pairs(A).\n\nExamples\n\njulia> A = [1, 2, 3, 4]\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> findlast(isodd, A)\n3\n\njulia> findlast(x -> x > 5, A) # returns nothing, but not printed in the REPL\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> findlast(isodd, A)\nCartesianIndex(2, 1)\n\n\n\n\n\n"},{"title":"Base.findnext","page":"Arrays","location":"base/arrays.html#Base.findnext-Tuple{Any, Integer}","category":"method","text":"findnext(A, i)\n\nFind the next index after or including i of a true element of A,\nor nothing if not found.\n\nIndices are of the same type as those returned by keys(A)\nand pairs(A).\n\nExamples\n\njulia> A = [false, false, true, false]\n4-element Vector{Bool}:\n 0\n 0\n 1\n 0\n\njulia> findnext(A, 1)\n3\n\njulia> findnext(A, 4) # returns nothing, but not printed in the REPL\n\njulia> A = [false false; true false]\n2×2 Matrix{Bool}:\n 0  0\n 1  0\n\njulia> findnext(A, CartesianIndex(1, 1))\nCartesianIndex(2, 1)\n\n\n\n\n\n"},{"title":"Base.findnext","page":"Arrays","location":"base/arrays.html#Base.findnext-Tuple{Function, Any, Integer}","category":"method","text":"findnext(predicate::Function, A, i)\n\nFind the next index after or including i of an element of A\nfor which predicate returns true, or nothing if not found. This works for\nArrays, Strings, and most other collections that support getindex,\nkeys(A), and nextind.\n\nIndices are of the same type as those returned by keys(A)\nand pairs(A).\n\nExamples\n\njulia> A = [1, 4, 2, 2];\n\njulia> findnext(isodd, A, 1)\n1\n\njulia> findnext(isodd, A, 2) # returns nothing, but not printed in the REPL\n\njulia> A = [1 4; 2 2];\n\njulia> findnext(isodd, A, CartesianIndex(1, 1))\nCartesianIndex(1, 1)\n\njulia> findnext(isspace, \"a b c\", 3)\n4\n\n\n\n\n\n"},{"title":"Base.findprev","page":"Arrays","location":"base/arrays.html#Base.findprev-Tuple{Any, Integer}","category":"method","text":"findprev(A, i)\n\nFind the previous index before or including i of a true element of A,\nor nothing if not found.\n\nIndices are of the same type as those returned by keys(A)\nand pairs(A).\n\nSee also: findnext, findfirst, findall.\n\nExamples\n\njulia> A = [false, false, true, true]\n4-element Vector{Bool}:\n 0\n 0\n 1\n 1\n\njulia> findprev(A, 3)\n3\n\njulia> findprev(A, 1) # returns nothing, but not printed in the REPL\n\njulia> A = [false false; true true]\n2×2 Matrix{Bool}:\n 0  0\n 1  1\n\njulia> findprev(A, CartesianIndex(2, 1))\nCartesianIndex(2, 1)\n\n\n\n\n\n"},{"title":"Base.findprev","page":"Arrays","location":"base/arrays.html#Base.findprev-Tuple{Function, Any, Integer}","category":"method","text":"findprev(predicate::Function, A, i)\n\nFind the previous index before or including i of an element of A\nfor which predicate returns true, or nothing if not found. This works for\nArrays, Strings, and most other collections that support getindex,\nkeys(A), and nextind.\n\nIndices are of the same type as those returned by keys(A)\nand pairs(A).\n\nExamples\n\njulia> A = [4, 6, 1, 2]\n4-element Vector{Int64}:\n 4\n 6\n 1\n 2\n\njulia> findprev(isodd, A, 1) # returns nothing, but not printed in the REPL\n\njulia> findprev(isodd, A, 3)\n3\n\njulia> A = [4 6; 1 2]\n2×2 Matrix{Int64}:\n 4  6\n 1  2\n\njulia> findprev(isodd, A, CartesianIndex(1, 2))\nCartesianIndex(2, 1)\n\njulia> findprev(isspace, \"a b c\", 3)\n2\n\n\n\n\n\n"},{"title":"Base.permutedims","page":"Arrays","location":"base/arrays.html#Base.permutedims","category":"function","text":"permutedims(v::AbstractVector)\n\nReshape vector v into a 1 × length(v) row matrix.\nDiffers from transpose in that\nthe operation is not recursive, which is especially useful for arrays of non-numeric values\n(where the recursive transpose might throw an error).\n\nExamples\n\nUnlike transpose, permutedims can be used on vectors of\narbitrary non-numeric elements, such as strings:\n\njulia> permutedims([\"a\", \"b\", \"c\"])\n1×3 Matrix{String}:\n \"a\"  \"b\"  \"c\"\n\nFor vectors of numbers, permutedims(v) works much like transpose(v)\nexcept that the return type differs (it uses reshape\nrather than a LinearAlgebra.Transpose view, though both\nshare memory with the original array v):\n\njulia> v = [1, 2, 3, 4]\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> p = permutedims(v)\n1×4 Matrix{Int64}:\n 1  2  3  4\n\njulia> r = transpose(v)\n1×4 transpose(::Vector{Int64}) with eltype Int64:\n 1  2  3  4\n\njulia> p == r\ntrue\n\njulia> typeof(r)\nTranspose{Int64, Vector{Int64}}\n\njulia> p[1] = 5; r[2] = 6; # mutating p or r also changes v\n\njulia> v # shares memory with both p and r\n4-element Vector{Int64}:\n 5\n 6\n 3\n 4\n\nHowever, permutedims produces results that differ from transpose\nfor vectors whose elements are themselves numeric matrices:\n\njulia> V = [[[1 2; 3 4]]; [[5 6; 7 8]]]\n2-element Vector{Matrix{Int64}}:\n [1 2; 3 4]\n [5 6; 7 8]\n\njulia> permutedims(V)\n1×2 Matrix{Matrix{Int64}}:\n [1 2; 3 4]  [5 6; 7 8]\n\njulia> transpose(V)\n1×2 transpose(::Vector{Matrix{Int64}}) with eltype Transpose{Int64, Matrix{Int64}}:\n [1 3; 2 4]  [5 7; 6 8]\n\n\n\n\n\npermutedims(A::AbstractArray, perm)\npermutedims(A::AbstractMatrix)\n\nPermute the dimensions (axes) of array A. perm is a tuple or vector of ndims(A) integers\nspecifying the permutation.\n\nIf A is a 2d array (AbstractMatrix), then\nperm defaults to (2,1), swapping the two axes of A (the rows and columns\nof the matrix).   This differs from transpose in that the\noperation is not recursive, which is especially useful for arrays of non-numeric values\n(where the recursive transpose would throw an error) and/or 2d arrays that do not represent\nlinear operators.\n\nFor 1d arrays, see permutedims(v::AbstractVector), which returns a 1-row “matrix”.\n\nSee also permutedims!, PermutedDimsArray, transpose, invperm.\n\nExamples\n\n2d arrays:\n\nUnlike transpose, permutedims can be used to swap rows and columns of 2d arrays of\narbitrary non-numeric elements, such as strings:\n\njulia> A = [\"a\" \"b\" \"c\"\n            \"d\" \"e\" \"f\"]\n2×3 Matrix{String}:\n \"a\"  \"b\"  \"c\"\n \"d\"  \"e\"  \"f\"\n\njulia> permutedims(A)\n3×2 Matrix{String}:\n \"a\"  \"d\"\n \"b\"  \"e\"\n \"c\"  \"f\"\n\nAnd permutedims produces results that differ from transpose\nfor matrices whose elements are themselves numeric matrices:\n\njulia> a = [1 2; 3 4];\n\njulia> b = [5 6; 7 8];\n\njulia> c = [9 10; 11 12];\n\njulia> d = [13 14; 15 16];\n\njulia> X = [[a] [b]; [c] [d]]\n2×2 Matrix{Matrix{Int64}}:\n [1 2; 3 4]     [5 6; 7 8]\n [9 10; 11 12]  [13 14; 15 16]\n\njulia> permutedims(X)\n2×2 Matrix{Matrix{Int64}}:\n [1 2; 3 4]  [9 10; 11 12]\n [5 6; 7 8]  [13 14; 15 16]\n\njulia> transpose(X)\n2×2 transpose(::Matrix{Matrix{Int64}}) with eltype Transpose{Int64, Matrix{Int64}}:\n [1 3; 2 4]  [9 11; 10 12]\n [5 7; 6 8]  [13 15; 14 16]\n\nMulti-dimensional arrays\n\njulia> A = reshape(Vector(1:8), (2,2,2))\n2×2×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 5  7\n 6  8\n\njulia> perm = (3, 1, 2); # put the last dimension first\n\njulia> B = permutedims(A, perm)\n2×2×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  2\n 5  6\n\n[:, :, 2] =\n 3  4\n 7  8\n\njulia> A == permutedims(B, invperm(perm)) # the inverse permutation\ntrue\n\nFor each dimension i of B = permutedims(A, perm), its corresponding dimension of A\nwill be perm[i]. This means the equality size(B, i) == size(A, perm[i]) holds.\n\njulia> A = randn(5, 7, 11, 13);\n\njulia> perm = [4, 1, 3, 2];\n\njulia> B = permutedims(A, perm);\n\njulia> size(B)\n(13, 5, 11, 7)\n\njulia> size(A)[perm] == ans\ntrue\n\n\n\n\n\n"},{"title":"Base.permutedims!","page":"Arrays","location":"base/arrays.html#Base.permutedims!","category":"function","text":"permutedims!(dest, src, perm)\n\nPermute the dimensions of array src and store the result in the array dest. perm is a\nvector specifying a permutation of length ndims(src). The preallocated array dest should\nhave size(dest) == size(src)[perm] and is completely overwritten. No in-place permutation\nis supported and unexpected results will happen if src and dest have overlapping memory\nregions.\n\nSee also permutedims.\n\n\n\n\n\n"},{"title":"Base.PermutedDimsArrays.PermutedDimsArray","page":"Arrays","location":"base/arrays.html#Base.PermutedDimsArrays.PermutedDimsArray","category":"type","text":"PermutedDimsArray(A, perm) -> B\n\nGiven an AbstractArray A, create a view B such that the\ndimensions appear to be permuted. Similar to permutedims, except\nthat no copying occurs (B shares storage with A).\n\nSee also permutedims, invperm.\n\nExamples\n\njulia> A = rand(3,5,4);\n\njulia> B = PermutedDimsArray(A, (3,1,2));\n\njulia> size(B)\n(4, 3, 5)\n\njulia> B[3,1,2] == A[1,2,3]\ntrue\n\n\n\n\n\n"},{"title":"Base.promote_shape","page":"Arrays","location":"base/arrays.html#Base.promote_shape","category":"function","text":"promote_shape(s1, s2)\n\nCheck two array shapes for compatibility, allowing trailing singleton dimensions, and return\nwhichever shape has more dimensions.\n\nExamples\n\njulia> a = fill(1, (3,4,1,1,1));\n\njulia> b = fill(1, (3,4));\n\njulia> promote_shape(a,b)\n(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))\n\njulia> promote_shape((2,3,1,4), (2, 3, 1, 4, 1))\n(2, 3, 1, 4, 1)\n\n\n\n\n\n"},{"title":"Base.accumulate","page":"Arrays","location":"base/arrays.html#Base.accumulate","category":"function","text":"accumulate(op, A; dims::Integer, [init])\n\nCumulative operation op along the dimension dims of A (providing dims is optional\nfor vectors). An initial value init may optionally be provided by a keyword argument. See\nalso accumulate! to use a preallocated output array, both for performance and\nto control the precision of the output (e.g. to avoid overflow).\n\nFor common operations there are specialized variants of accumulate,\nsee cumsum, cumprod. For a lazy version, see\nIterators.accumulate.\n\ncompat: Julia 1.5\naccumulate on a non-array iterator requires at least Julia 1.5.\n\nExamples\n\njulia> accumulate(+, [1,2,3])\n3-element Vector{Int64}:\n 1\n 3\n 6\n\njulia> accumulate(min, (1, -2, 3, -4, 5), init=0)\n(0, -2, -2, -4, -4)\n\njulia> accumulate(/, (2, 4, Inf), init=100)\n(50.0, 12.5, 0.0)\n\njulia> accumulate(=>, i^2 for i in 1:3)\n3-element Vector{Any}:\n          1\n        1 => 4\n (1 => 4) => 9\n\njulia> accumulate(+, fill(1, 3, 4))\n3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\njulia> accumulate(+, fill(1, 2, 5), dims=2, init=100.0)\n2×5 Matrix{Float64}:\n 101.0  102.0  103.0  104.0  105.0\n 101.0  102.0  103.0  104.0  105.0\n\n\n\n\n\n"},{"title":"Base.accumulate!","page":"Arrays","location":"base/arrays.html#Base.accumulate!","category":"function","text":"accumulate!(op, B, A; [dims], [init])\n\nCumulative operation op on A along the dimension dims, storing the result in B.\nProviding dims is optional for vectors.  If the keyword argument init is given, its\nvalue is used to instantiate the accumulation.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nSee also accumulate, cumsum!, cumprod!.\n\nExamples\n\njulia> x = [1, 0, 2, 0, 3];\n\njulia> y = rand(5);\n\njulia> accumulate!(+, y, x);\n\njulia> y\n5-element Vector{Float64}:\n 1.0\n 1.0\n 3.0\n 3.0\n 6.0\n\njulia> A = [1 2 3; 4 5 6];\n\njulia> B = similar(A);\n\njulia> accumulate!(-, B, A, dims=1)\n2×3 Matrix{Int64}:\n  1   2   3\n -3  -3  -3\n\njulia> accumulate!(*, B, A, dims=2, init=10)\n2×3 Matrix{Int64}:\n 10   20    60\n 40  200  1200\n\n\n\n\n\n"},{"title":"Base.cumprod","page":"Arrays","location":"base/arrays.html#Base.cumprod","category":"function","text":"cumprod(itr)\n\nCumulative product of an iterator.\n\nSee also cumprod!, accumulate, cumsum.\n\ncompat: Julia 1.5\ncumprod on a non-array iterator requires at least Julia 1.5.\n\nExamples\n\njulia> cumprod(fill(1//2, 3))\n3-element Vector{Rational{Int64}}:\n 1//2\n 1//4\n 1//8\n\njulia> cumprod((1, 2, 1, 3, 1))\n(1, 2, 2, 6, 6)\n\njulia> cumprod(\"julia\")\n5-element Vector{String}:\n \"j\"\n \"ju\"\n \"jul\"\n \"juli\"\n \"julia\"\n\n\n\n\n\ncumprod(A; dims::Integer)\n\nCumulative product along the dimension dim. See also\ncumprod! to use a preallocated output array, both for performance and\nto control the precision of the output (e.g. to avoid overflow).\n\nExamples\n\njulia> a = Int8[1 2 3; 4 5 6];\n\njulia> cumprod(a, dims=1)\n2×3 Matrix{Int64}:\n 1   2   3\n 4  10  18\n\njulia> cumprod(a, dims=2)\n2×3 Matrix{Int64}:\n 1   2    6\n 4  20  120\n\n\n\n\n\n"},{"title":"Base.cumprod!","page":"Arrays","location":"base/arrays.html#Base.cumprod!","category":"function","text":"cumprod!(y::AbstractVector, x::AbstractVector)\n\nCumulative product of a vector x, storing the result in y.\nSee also cumprod.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\n\n\n\n\ncumprod!(B, A; dims::Integer)\n\nCumulative product of A along the dimension dims, storing the result in B.\nSee also cumprod.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\n\n\n\n\n"},{"title":"Base.cumsum","page":"Arrays","location":"base/arrays.html#Base.cumsum","category":"function","text":"cumsum(itr)\n\nCumulative sum of an iterator.\n\nSee also accumulate to apply functions other than +.\n\ncompat: Julia 1.5\ncumsum on a non-array iterator requires at least Julia 1.5.\n\nExamples\n\njulia> cumsum(1:3)\n3-element Vector{Int64}:\n 1\n 3\n 6\n\njulia> cumsum((true, false, true, false, true))\n(1, 1, 2, 2, 3)\n\njulia> cumsum(fill(1, 2) for i in 1:3)\n3-element Vector{Vector{Int64}}:\n [1, 1]\n [2, 2]\n [3, 3]\n\n\n\n\n\ncumsum(A; dims::Integer)\n\nCumulative sum along the dimension dims. See also cumsum! to use a\npreallocated output array, both for performance and to control the precision of\nthe output (e.g. to avoid overflow).\n\nExamples\n\njulia> a = [1 2 3; 4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> cumsum(a, dims=1)\n2×3 Matrix{Int64}:\n 1  2  3\n 5  7  9\n\njulia> cumsum(a, dims=2)\n2×3 Matrix{Int64}:\n 1  3   6\n 4  9  15\n\nnote: Note\nThe return array's eltype is Int for signed integers of less than system\nword size  and UInt for unsigned integers of less than system word size.\nTo preserve eltype of arrays with small signed or unsigned integer\naccumulate(+, A) should be used.julia> cumsum(Int8[100, 28])\n2-element Vector{Int64}:\n 100\n 128\n\njulia> accumulate(+,Int8[100, 28])\n2-element Vector{Int8}:\n  100\n -128In the former case, the integers are widened to system word size and\ntherefore the result is Int64[100, 128]. In the latter case, no such\nwidening happens and integer overflow results in Int8[100, -128].\n\n\n\n\n\n"},{"title":"Base.cumsum!","page":"Arrays","location":"base/arrays.html#Base.cumsum!","category":"function","text":"cumsum!(B, A; dims::Integer)\n\nCumulative sum of A along the dimension dims, storing the result in B. See also cumsum.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\n\n\n\n\n"},{"title":"Base.diff","page":"Arrays","location":"base/arrays.html#Base.diff","category":"function","text":"diff(A::AbstractVector)\ndiff(A::AbstractArray; dims::Integer)\n\nFinite difference operator on a vector or a multidimensional array A. In the\nlatter case the dimension to operate on needs to be specified with the dims\nkeyword argument.\n\ncompat: Julia 1.1\ndiff for arrays with dimension higher than 2 requires at least Julia 1.1.\n\nExamples\n\njulia> a = [2 4; 6 16]\n2×2 Matrix{Int64}:\n 2   4\n 6  16\n\njulia> diff(a, dims=2)\n2×1 Matrix{Int64}:\n  2\n 10\n\njulia> diff(vec(a))\n3-element Vector{Int64}:\n  4\n -2\n 12\n\n\n\n\n\n"},{"title":"Base.repeat","page":"Arrays","location":"base/arrays.html#Base.repeat","category":"function","text":"repeat(A::AbstractArray; inner=ntuple(Returns(1), ndims(A)), outer=ntuple(Returns(1), ndims(A)))\n\nConstruct an array by repeating the entries of A. The i-th element of inner specifies\nthe number of times that the individual entries of the i-th dimension of A should be\nrepeated. The i-th element of outer specifies the number of times that a slice along the\ni-th dimension of A should be repeated. If inner or outer are omitted, no repetition\nis performed.\n\nExamples\n\njulia> repeat(1:2, inner=2)\n4-element Vector{Int64}:\n 1\n 1\n 2\n 2\n\njulia> repeat(1:2, outer=2)\n4-element Vector{Int64}:\n 1\n 2\n 1\n 2\n\njulia> repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))\n4×6 Matrix{Int64}:\n 1  2  1  2  1  2\n 1  2  1  2  1  2\n 3  4  3  4  3  4\n 3  4  3  4  3  4\n\n\n\n\n\nrepeat(A::AbstractArray, counts::Integer...)\n\nConstruct an array by repeating array A a given number of times in each dimension, specified by counts.\n\nSee also: fill, Iterators.repeated, Iterators.cycle.\n\nExamples\n\njulia> repeat([1, 2, 3], 2)\n6-element Vector{Int64}:\n 1\n 2\n 3\n 1\n 2\n 3\n\njulia> repeat([1, 2, 3], 2, 3)\n6×3 Matrix{Int64}:\n 1  1  1\n 2  2  2\n 3  3  3\n 1  1  1\n 2  2  2\n 3  3  3\n\n\n\n\n\nrepeat(c::AbstractChar, r::Integer)::String\n\nRepeat a character r times. This can equivalently be accomplished by calling\nc^r.\n\nExamples\n\njulia> repeat('A', 3)\n\"AAA\"\n\n\n\n\n\nrepeat(s::AbstractString, r::Integer)\n\nRepeat a string r times. This can be written as s^r.\n\nSee also ^.\n\nExamples\n\njulia> repeat(\"ha\", 3)\n\"hahaha\"\n\n\n\n\n\n"},{"title":"Base.rot180","page":"Arrays","location":"base/arrays.html#Base.rot180","category":"function","text":"rot180(A, k)\n\nRotate matrix A 180 degrees an integer k number of times.\nIf k is even, this is equivalent to a copy.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> rot180(a,1)\n2×2 Matrix{Int64}:\n 4  3\n 2  1\n\njulia> rot180(a,2)\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\n\n\n\n\nrot180(A)\n\nRotate matrix A 180 degrees.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> rot180(a)\n2×2 Matrix{Int64}:\n 4  3\n 2  1\n\n\n\n\n\n"},{"title":"Base.rotl90","page":"Arrays","location":"base/arrays.html#Base.rotl90","category":"function","text":"rotl90(A, k)\n\nLeft-rotate matrix A 90 degrees counterclockwise an integer k number of times.\nIf k is a multiple of four (including zero), this is equivalent to a copy.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> rotl90(a,1)\n2×2 Matrix{Int64}:\n 2  4\n 1  3\n\njulia> rotl90(a,2)\n2×2 Matrix{Int64}:\n 4  3\n 2  1\n\njulia> rotl90(a,3)\n2×2 Matrix{Int64}:\n 3  1\n 4  2\n\njulia> rotl90(a,4)\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\n\n\n\n\nrotl90(A)\n\nRotate matrix A left 90 degrees.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> rotl90(a)\n2×2 Matrix{Int64}:\n 2  4\n 1  3\n\n\n\n\n\n"},{"title":"Base.rotr90","page":"Arrays","location":"base/arrays.html#Base.rotr90","category":"function","text":"rotr90(A, k)\n\nRight-rotate matrix A 90 degrees clockwise an integer k number of times.\nIf k is a multiple of four (including zero), this is equivalent to a copy.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> rotr90(a,1)\n2×2 Matrix{Int64}:\n 3  1\n 4  2\n\njulia> rotr90(a,2)\n2×2 Matrix{Int64}:\n 4  3\n 2  1\n\njulia> rotr90(a,3)\n2×2 Matrix{Int64}:\n 2  4\n 1  3\n\njulia> rotr90(a,4)\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\n\n\n\n\nrotr90(A)\n\nRotate matrix A right 90 degrees.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> rotr90(a)\n2×2 Matrix{Int64}:\n 3  1\n 4  2\n\n\n\n\n\n"},{"title":"Base.mapslices","page":"Arrays","location":"base/arrays.html#Base.mapslices","category":"function","text":"mapslices(f, A; dims)\n\nTransform the given dimensions of array A by applying a function f on each slice\nof the form A[..., :, ..., :, ...], with a colon at each d in dims. The results are\nconcatenated along the remaining dimensions.\n\nFor example, if dims = [1,2] and A is 4-dimensional, then f is called on x = A[:,:,i,j]\nfor all i and j, and f(x) becomes R[:,:,i,j] in the result R.\n\nSee also eachcol or eachslice, used with map or stack.\n\nExamples\n\njulia> A = reshape(1:30,(2,5,3))\n2×5×3 reshape(::UnitRange{Int64}, 2, 5, 3) with eltype Int64:\n[:, :, 1] =\n 1  3  5  7   9\n 2  4  6  8  10\n\n[:, :, 2] =\n 11  13  15  17  19\n 12  14  16  18  20\n\n[:, :, 3] =\n 21  23  25  27  29\n 22  24  26  28  30\n\njulia> f(x::Matrix) = fill(x[1,1], 1,4);  # returns a 1×4 matrix\n\njulia> B = mapslices(f, A, dims=(1,2))\n1×4×3 Array{Int64, 3}:\n[:, :, 1] =\n 1  1  1  1\n\n[:, :, 2] =\n 11  11  11  11\n\n[:, :, 3] =\n 21  21  21  21\n\njulia> f2(x::AbstractMatrix) = fill(x[1,1], 1,4);\n\njulia> B == stack(f2, eachslice(A, dims=3))\ntrue\n\njulia> g(x) = x[begin] // x[end-1];  # returns a number\n\njulia> mapslices(g, A, dims=[1,3])\n1×5×1 Array{Rational{Int64}, 3}:\n[:, :, 1] =\n 1//21  3//23  1//5  7//27  9//29\n\njulia> map(g, eachslice(A, dims=2))\n5-element Vector{Rational{Int64}}:\n 1//21\n 3//23\n 1//5\n 7//27\n 9//29\n\njulia> mapslices(sum, A; dims=(1,3)) == sum(A; dims=(1,3))\ntrue\n\nNotice that in eachslice(A; dims=2), the specified dimension is the\none without a colon in the slice. This is view(A,:,i,:), whereas\nmapslices(f, A; dims=(1,3)) uses A[:,i,:]. The function f may mutate\nvalues in the slice without affecting A.\n\n\n\n\n\n"},{"title":"Base.eachrow","page":"Arrays","location":"base/arrays.html#Base.eachrow","category":"function","text":"eachrow(A::AbstractVecOrMat) <: AbstractVector\n\nCreate a RowSlices object that is a vector of rows of matrix or vector A.\nRow slices are returned as AbstractVector views of A.\n\nFor the inverse, see stack(rows; dims=1).\n\nSee also eachcol, eachslice and mapslices.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\ncompat: Julia 1.9\nPrior to Julia 1.9, this returned an iterator.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> s = eachrow(a)\n2-element RowSlices{Matrix{Int64}, Tuple{Base.OneTo{Int64}}, SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}:\n [1, 2]\n [3, 4]\n\njulia> s[1]\n2-element view(::Matrix{Int64}, 1, :) with eltype Int64:\n 1\n 2\n\n\n\n\n\n"},{"title":"Base.eachcol","page":"Arrays","location":"base/arrays.html#Base.eachcol","category":"function","text":"eachcol(A::AbstractVecOrMat) <: AbstractVector\n\nCreate a ColumnSlices object that is a vector of columns of matrix or vector A.\nColumn slices are returned as AbstractVector views of A.\n\nFor the inverse, see stack(cols) or reduce(hcat, cols).\n\nSee also eachrow, eachslice and mapslices.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\ncompat: Julia 1.9\nPrior to Julia 1.9, this returned an iterator.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> s = eachcol(a)\n2-element ColumnSlices{Matrix{Int64}, Tuple{Base.OneTo{Int64}}, SubArray{Int64, 1, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}:\n [1, 3]\n [2, 4]\n\njulia> s[1]\n2-element view(::Matrix{Int64}, :, 1) with eltype Int64:\n 1\n 3\n\n\n\n\n\n"},{"title":"Base.eachslice","page":"Arrays","location":"base/arrays.html#Base.eachslice","category":"function","text":"eachslice(A::AbstractArray; dims, drop=true)\n\nCreate a sliced object, usually Slices, that is an array of slices over dimensions\ndims of A, returning views that select all the data from the other dimensions in A.\ndims can either be an integer or a tuple of integers.\n\nIf drop = true (the default), the outer slices will drop the inner dimensions, and\nthe ordering of the dimensions will match those in dims. If drop = false, then the\nslices object will have the same dimensionality as the underlying array, with inner\ndimensions having size 1.\n\nSee stack(slices; dims) for the inverse of eachslice(A; dims::Integer).\n\nSee also eachrow, eachcol, mapslices and selectdim.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\ncompat: Julia 1.9\nPrior to Julia 1.9, this returned an iterator, and only a single dimension dims was supported.\n\nExamples\n\njulia> m = [1 2 3; 4 5 6; 7 8 9]\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> s = eachslice(m, dims=1)\n3-element RowSlices{Matrix{Int64}, Tuple{Base.OneTo{Int64}}, SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}:\n [1, 2, 3]\n [4, 5, 6]\n [7, 8, 9]\n\njulia> s[1]\n3-element view(::Matrix{Int64}, 1, :) with eltype Int64:\n 1\n 2\n 3\n\njulia> eachslice(m, dims=1, drop=false)\n3×1 Slices{Matrix{Int64}, Tuple{Int64, Colon}, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}, SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}, 2}:\n [1, 2, 3]\n [4, 5, 6]\n [7, 8, 9]\n\n\n\n\n\n"},{"title":"Base.invperm","page":"Arrays","location":"base/arrays.html#Base.invperm","category":"function","text":"invperm(v)\n\nReturn the inverse permutation of v.\nIf B = A[v], then A == B[invperm(v)].\n\nSee also sortperm, invpermute!, isperm, permutedims.\n\nExamples\n\njulia> p = (2, 3, 1);\n\njulia> invperm(p)\n(3, 1, 2)\n\njulia> v = [2; 4; 3; 1];\n\njulia> invperm(v)\n4-element Vector{Int64}:\n 4\n 1\n 3\n 2\n\njulia> A = ['a','b','c','d'];\n\njulia> B = A[v]\n4-element Vector{Char}:\n 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n 'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n 'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n 'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> B[invperm(v)]\n4-element Vector{Char}:\n 'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n 'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n 'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n\n\n\n\n\n"},{"title":"Base.isperm","page":"Arrays","location":"base/arrays.html#Base.isperm","category":"function","text":"isperm(v)::Bool\n\nReturn true if v is a valid permutation.\n\nExamples\n\njulia> isperm([1; 2])\ntrue\n\njulia> isperm([1; 3])\nfalse\n\n\n\n\n\n"},{"title":"Base.permute!","page":"Arrays","location":"base/arrays.html#Base.permute!-Tuple{Any, AbstractVector}","category":"method","text":"permute!(v, p)\n\nPermute vector v according to permutation p, storing the result back into v.\nNo checking is done to verify that p is a permutation.\n\nTo return a new permutation, use v[p]. This is generally faster than permute!(v, p);\nit is even faster to write into a pre-allocated output array with u .= @view v[p].\n(Even though permute! overwrites v in-place, it internally requires some allocation.)\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nSee also invpermute!.\n\nExamples\n\njulia> A = [1, 1, 3, 4];\n\njulia> perm = [2, 4, 3, 1];\n\njulia> permute!(A, perm);\n\njulia> A\n4-element Vector{Int64}:\n 1\n 4\n 3\n 1\n\n\n\n\n\n"},{"title":"Base.invpermute!","page":"Arrays","location":"base/arrays.html#Base.invpermute!","category":"function","text":"invpermute!(v, p)\n\nLike permute!, but the inverse of the given permutation is applied.\n\nNote that if you have a pre-allocated output array (e.g. u = similar(v)),\nit is quicker to instead employ u[p] = v.  (invpermute! internally\nallocates a copy of the data.)\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nExamples\n\njulia> A = [1, 1, 3, 4];\n\njulia> perm = [2, 4, 3, 1];\n\njulia> invpermute!(A, perm);\n\njulia> A\n4-element Vector{Int64}:\n 4\n 1\n 3\n 1\n\n\n\n\n\n"},{"title":"Base.reverse","page":"Arrays","location":"base/arrays.html#Base.reverse-Tuple{AbstractVector}","category":"method","text":"reverse(A; dims=:)\n\nReverse A along dimension dims, which can be an integer (a\nsingle dimension), a tuple of integers (a tuple of dimensions)\nor : (reverse along all the dimensions, the default).  See\nalso reverse! for in-place reversal.\n\nExamples\n\njulia> b = Int64[1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> reverse(b, dims=2)\n2×2 Matrix{Int64}:\n 2  1\n 4  3\n\njulia> reverse(b)\n2×2 Matrix{Int64}:\n 4  3\n 2  1\n\ncompat: Julia 1.6\nPrior to Julia 1.6, only single-integer dims are supported in reverse.\n\n\n\n\n\n"},{"title":"Base.reverseind","page":"Arrays","location":"base/arrays.html#Base.reverseind","category":"function","text":"reverseind(v, i)\n\nGiven an index i in reverse(v), return the corresponding index in\nv so that v[reverseind(v,i)] == reverse(v)[i]. (This can be nontrivial in\ncases where v contains non-ASCII characters.)\n\nExamples\n\njulia> s = \"Julia🚀\"\n\"Julia🚀\"\n\njulia> r = reverse(s)\n\"🚀ailuJ\"\n\njulia> for i in eachindex(s)\n           print(r[reverseind(r, i)])\n       end\nJulia🚀\n\n\n\n\n\n"},{"title":"Base.reverse!","page":"Arrays","location":"base/arrays.html#Base.reverse!","category":"function","text":"reverse!(A; dims=:)\n\nLike reverse, but operates in-place in A.\n\ncompat: Julia 1.6\nMultidimensional reverse! requires Julia 1.6.\n\n\n\n\n\nreverse!(v [, start=firstindex(v) [, stop=lastindex(v) ]]) -> v\n\nIn-place version of reverse.\n\nExamples\n\njulia> A = Vector(1:5)\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\njulia> reverse!(A);\n\njulia> A\n5-element Vector{Int64}:\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\n"},{"title":"Bounds checking","page":"Bounds checking","location":"devdocs/boundscheck.html#Bounds-checking","category":"section","text":"Like many modern programming languages, Julia uses bounds checking to ensure program safety when\naccessing arrays. In tight inner loops or other performance critical situations, you may wish\nto skip these bounds checks to improve runtime performance. For instance, in order to emit vectorized\n(SIMD) instructions, your loop body cannot contain branches, and thus cannot contain bounds checks.\nConsequently, Julia includes an @inbounds(...) macro to tell the compiler to skip such bounds\nchecks within the given block. User-defined array types can use the @boundscheck(...) macro\nto achieve context-sensitive code selection."},{"title":"Eliding bounds checks","page":"Bounds checking","location":"devdocs/boundscheck.html#Eliding-bounds-checks","category":"section","text":"The @boundscheck(...) macro marks blocks of code that perform bounds checking.\nWhen such blocks are inlined into an @inbounds(...) block, the compiler may remove these blocks.\nThe compiler removes the @boundscheck block only if it is inlined into the calling function.\nFor example, you might write the method sum as:\n\nfunction sum(A::AbstractArray)\n    r = zero(eltype(A))\n    for i in eachindex(A)\n        @inbounds r += A[i]\n    end\n    return r\nend\n\nWith a custom array-like type MyArray having:\n\n@inline getindex(A::MyArray, i::Real) = (@boundscheck checkbounds(A, i); A.data[to_index(i)])\n\nThen when getindex is inlined into sum, the call to checkbounds(A, i) will be elided. If\nyour function contains multiple layers of inlining, only @boundscheck blocks at most one level\nof inlining deeper are eliminated. The rule prevents unintended changes in program behavior from\ncode further up the stack."},{"title":"Caution!","page":"Bounds checking","location":"devdocs/boundscheck.html#Caution!","category":"section","text":"It is easy to accidentally expose unsafe operations with @inbounds. You might be tempted\nto write the above example as\n\nfunction sum(A::AbstractArray)\n    r = zero(eltype(A))\n    for i in 1:length(A)\n        @inbounds r += A[i]\n    end\n    return r\nend\n\nWhich quietly assumes 1-based indexing and therefore exposes unsafe memory access when used\nwith OffsetArrays:\n\njulia> using OffsetArrays\n\njulia> sum(OffsetArray([1, 2, 3], -10))\n9164911648 # inconsistent results or segfault\n\nWhile the original source of the error here is 1:length(A), the use of @inbounds\nincreases the consequences from a bounds error to a less easily caught and debugged unsafe\nmemory access. It is often difficult or impossible to prove that a method which uses\n@inbounds is safe, so one must weigh the benefits of performance improvements against the\nrisk of segfaults and silent misbehavior, especially in public facing APIs."},{"title":"Propagating inbounds","page":"Bounds checking","location":"devdocs/boundscheck.html#Propagating-inbounds","category":"section","text":"There may be certain scenarios where for code-organization reasons you want more than one layer\nbetween the @inbounds and @boundscheck declarations. For instance, the default getindex\nmethods have the chain getindex(A::AbstractArray, i::Real) calls getindex(IndexStyle(A), A, i)\ncalls _getindex(::IndexLinear, A, i).\n\nTo override the \"one layer of inlining\" rule, a function may be marked with\nBase.@propagate_inbounds to propagate an inbounds context (or out of bounds\ncontext) through one additional layer of inlining."},{"title":"The bounds checking call hierarchy","page":"Bounds checking","location":"devdocs/boundscheck.html#The-bounds-checking-call-hierarchy","category":"section","text":"The overall hierarchy is:\n\ncheckbounds(A, I...) which calls\ncheckbounds(Bool, A, I...) which calls\ncheckbounds_indices(Bool, axes(A), I) which recursively calls\ncheckindex for each dimension\n\nHere A is the array, and I contains the \"requested\" indices. axes(A) returns a tuple\nof \"permitted\" indices of A.\n\ncheckbounds(A, I...) throws an error if the indices are invalid, whereas checkbounds(Bool, A, I...)\nreturns false in that circumstance.  checkbounds_indices discards any information about the\narray other than its axes tuple, and performs a pure indices-vs-indices comparison: this\nallows relatively few compiled methods to serve a huge variety of array types. Indices are specified\nas tuples, and are usually compared in a 1-1 fashion with individual dimensions handled by calling\nanother important function, checkindex: typically,\n\ncheckbounds_indices(Bool, (IA1, IA...), (I1, I...)) = checkindex(Bool, IA1, I1) &\n                                                      checkbounds_indices(Bool, IA, I)\n\nso checkindex checks a single dimension. All of these functions, including the unexported\ncheckbounds_indices have docstrings accessible with ? .\n\nIf you have to customize bounds checking for a specific array type, you should specialize checkbounds(Bool, A, I...).\nHowever, in most cases you should be able to rely on checkbounds_indices as long as you supply\nuseful axes for your array type.\n\nIf you have novel index types, first consider specializing checkindex, which handles a single\nindex for a particular dimension of an array. If you have a custom multidimensional index type\n(similar to CartesianIndex), then you may have to consider specializing checkbounds_indices.\n\nNote this hierarchy has been designed to reduce the likelihood of method ambiguities. We try\nto make checkbounds the place to specialize on array type, and try to avoid specializations\non index types; conversely, checkindex is intended to be specialized only on index type (especially,\nthe last argument)."},{"title":"Emit bounds checks","page":"Bounds checking","location":"devdocs/boundscheck.html#Emit-bounds-checks","category":"section","text":"Julia can be launched with --check-bounds={yes|no|auto} to emit bounds checks always, never, or respect @inbounds declarations."},{"title":"Stack Traces","page":"Stack Traces","location":"manual/stacktraces.html#Stack-Traces","category":"section","text":"The StackTraces module provides simple stack traces that are both human readable and\neasy to use programmatically."},{"title":"Viewing a stack trace","page":"Stack Traces","location":"manual/stacktraces.html#Viewing-a-stack-trace","category":"section","text":"The primary function used to obtain a stack trace is stacktrace:\n\n6-element Array{Base.StackTraces.StackFrame,1}:\n top-level scope\n eval at boot.jl:317 [inlined]\n eval(::Module, ::Expr) at REPL.jl:5\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n macro expansion at REPL.jl:116 [inlined]\n (::getfield(REPL, Symbol(\"##28#29\")){REPL.REPLBackend})() at event.jl:92\n\nCalling stacktrace() returns a vector of StackTraces.StackFrame s. For ease of use, the\nalias StackTraces.StackTrace can be used in place of Vector{StackFrame}. (Examples with [...]\nindicate that output may vary depending on how the code is run.)\n\njulia> example() = stacktrace()\nexample (generic function with 1 method)\n\njulia> example()\n7-element Array{Base.StackTraces.StackFrame,1}:\n example() at REPL[1]:1\n top-level scope\n eval at boot.jl:317 [inlined]\n[...]\n\njulia> @noinline child() = stacktrace()\nchild (generic function with 1 method)\n\njulia> @noinline parent() = child()\nparent (generic function with 1 method)\n\njulia> grandparent() = parent()\ngrandparent (generic function with 1 method)\n\njulia> grandparent()\n9-element Array{Base.StackTraces.StackFrame,1}:\n child() at REPL[3]:1\n parent() at REPL[4]:1\n grandparent() at REPL[5]:1\n[...]\n\nNote that when calling stacktrace() you'll typically see a frame with eval at boot.jl.\nWhen calling stacktrace() from the REPL you'll also have a few extra frames in the stack\nfrom REPL.jl, usually looking something like this:\n\njulia> example() = stacktrace()\nexample (generic function with 1 method)\n\njulia> example()\n7-element Array{Base.StackTraces.StackFrame,1}:\n example() at REPL[1]:1\n top-level scope\n eval at boot.jl:317 [inlined]\n eval(::Module, ::Expr) at REPL.jl:5\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n macro expansion at REPL.jl:116 [inlined]\n (::getfield(REPL, Symbol(\"##28#29\")){REPL.REPLBackend})() at event.jl:92"},{"title":"Extracting useful information","page":"Stack Traces","location":"manual/stacktraces.html#Extracting-useful-information","category":"section","text":"Each StackTraces.StackFrame contains the function name, file name, line number, lambda info, a flag\nindicating whether the frame has been inlined, a flag indicating whether it is a C function (by\ndefault C functions do not appear in the stack trace), and an integer representation of the pointer\nreturned by backtrace:\n\njulia> frame = stacktrace()[3]\neval(::Module, ::Expr) at REPL.jl:5\n\njulia> frame.func\n:eval\n\njulia> frame.file\nSymbol(\"~/julia/usr/share/julia/stdlib/v0.7/REPL/src/REPL.jl\")\n\njulia> frame.line\n5\n\njulia> frame.linfo\nMethodInstance for eval(::Module, ::Expr)\n\njulia> frame.inlined\nfalse\n\njulia> frame.from_c\nfalse\n\njulia> frame.pointer\n0x00007f92d6293171\n\nThis makes stack trace information available programmatically for logging, error handling, and\nmore."},{"title":"Error handling","page":"Stack Traces","location":"manual/stacktraces.html#Error-handling","category":"section","text":"While having easy access to information about the current state of the callstack can be helpful\nin many places, the most obvious application is in error handling and debugging.\n\njulia> @noinline bad_function() = undeclared_variable\nbad_function (generic function with 1 method)\n\njulia> @noinline example() = try\n           bad_function()\n       catch\n           stacktrace()\n       end\nexample (generic function with 1 method)\n\njulia> example()\n7-element Array{Base.StackTraces.StackFrame,1}:\n example() at REPL[2]:4\n top-level scope\n eval at boot.jl:317 [inlined]\n[...]\n\nYou may notice that in the example above the first stack frame points at line 4, where\nstacktrace is called, rather than line 2, where bad_function is called, and bad_function's\nframe is missing entirely. This is understandable, given that stacktrace is called\nfrom the context of the catch. While in this example it's fairly easy to find the actual source\nof the error, in complex cases tracking down the source of the error becomes nontrivial.\n\nThis can be remedied by passing the result of catch_backtrace to stacktrace.\nInstead of returning callstack information for the current context, catch_backtrace\nreturns stack information for the context of the most recent exception:\n\njulia> @noinline bad_function() = undeclared_variable\nbad_function (generic function with 1 method)\n\njulia> @noinline example() = try\n           bad_function()\n       catch\n           stacktrace(catch_backtrace())\n       end\nexample (generic function with 1 method)\n\njulia> example()\n8-element Array{Base.StackTraces.StackFrame,1}:\n bad_function() at REPL[1]:1\n example() at REPL[2]:2\n[...]\n\nNotice that the stack trace now indicates the appropriate line number and the missing frame.\n\njulia> @noinline child() = error(\"Whoops!\")\nchild (generic function with 1 method)\n\njulia> @noinline parent() = child()\nparent (generic function with 1 method)\n\njulia> @noinline function grandparent()\n           try\n               parent()\n           catch err\n               println(\"ERROR: \", err.msg)\n               stacktrace(catch_backtrace())\n           end\n       end\ngrandparent (generic function with 1 method)\n\njulia> grandparent()\nERROR: Whoops!\n10-element Array{Base.StackTraces.StackFrame,1}:\n error at error.jl:33 [inlined]\n child() at REPL[1]:1\n parent() at REPL[2]:1\n grandparent() at REPL[3]:3\n[...]"},{"title":"Exception stacks and current_exceptions","page":"Stack Traces","location":"manual/stacktraces.html#Exception-stacks-and-[current_exceptions](@ref)","category":"section","text":"compat: Julia 1.1\nException stacks requires at least Julia 1.1.\n\nWhile handling an exception further exceptions may be thrown. It can be useful to inspect all these exceptions to\nidentify the root cause of a problem. The julia runtime supports this by pushing each exception onto an internal\nexception stack as it occurs. When the code exits a catch normally, any exceptions which were pushed onto the stack\nin the associated try are considered to be successfully handled and are removed from the stack.\n\nThe stack of current exceptions can be accessed using the current_exceptions function. For example,\n\njulia> try\n           error(\"(A) The root cause\")\n       catch\n           try\n               error(\"(B) An exception while handling the exception\")\n           catch\n               for (exc, bt) in current_exceptions()\n                   showerror(stdout, exc, bt)\n                   println(stdout)\n               end\n           end\n       end\n(A) The root cause\nStacktrace:\n [1] error(::String) at error.jl:33\n [2] top-level scope at REPL[7]:2\n [3] eval(::Module, ::Any) at boot.jl:319\n [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n [5] macro expansion at REPL.jl:117 [inlined]\n [6] (::getfield(REPL, Symbol(\"##26#27\")){REPL.REPLBackend})() at task.jl:259\n(B) An exception while handling the exception\nStacktrace:\n [1] error(::String) at error.jl:33\n [2] top-level scope at REPL[7]:5\n [3] eval(::Module, ::Any) at boot.jl:319\n [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n [5] macro expansion at REPL.jl:117 [inlined]\n [6] (::getfield(REPL, Symbol(\"##26#27\")){REPL.REPLBackend})() at task.jl:259\n\nIn this example the root cause exception (A) is first on the stack, with a further exception (B) following it. After\nexiting both catch blocks normally (i.e., without throwing a further exception) all exceptions are removed from the stack\nand are no longer accessible.\n\nThe exception stack is stored on the Task where the exceptions occurred. When a task fails with uncaught exceptions,\ncurrent_exceptions(task) may be used to inspect the exception stack for that task."},{"title":"Comparison with backtrace","page":"Stack Traces","location":"manual/stacktraces.html#Comparison-with-[backtrace](@ref)","category":"section","text":"A call to backtrace returns a vector of Union{Ptr{Nothing}, Base.InterpreterIP}, which may then be passed into\nstacktrace for translation:\n\njulia> trace = backtrace()\n18-element Array{Union{Ptr{Nothing}, Base.InterpreterIP},1}:\n Ptr{Nothing} @0x00007fd8734c6209\n Ptr{Nothing} @0x00007fd87362b342\n Ptr{Nothing} @0x00007fd87362c136\n Ptr{Nothing} @0x00007fd87362c986\n Ptr{Nothing} @0x00007fd87362d089\n Base.InterpreterIP(CodeInfo(:(begin\n      Core.SSAValue(0) = backtrace()\n      trace = Core.SSAValue(0)\n      return Core.SSAValue(0)\n  end)), 0x0000000000000000)\n Ptr{Nothing} @0x00007fd87362e4cf\n[...]\n\njulia> stacktrace(trace)\n6-element Array{Base.StackTraces.StackFrame,1}:\n top-level scope\n eval at boot.jl:317 [inlined]\n eval(::Module, ::Expr) at REPL.jl:5\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n macro expansion at REPL.jl:116 [inlined]\n (::getfield(REPL, Symbol(\"##28#29\")){REPL.REPLBackend})() at event.jl:92\n\nNotice that the vector returned by backtrace had 18 elements, while the vector returned\nby stacktrace only has 6. This is because, by default, stacktrace removes\nany lower-level C functions from the stack. If you want to include stack frames from C calls,\nyou can do it like this:\n\njulia> stacktrace(trace, true)\n21-element Array{Base.StackTraces.StackFrame,1}:\n jl_apply_generic at gf.c:2167\n do_call at interpreter.c:324\n eval_value at interpreter.c:416\n eval_body at interpreter.c:559\n jl_interpret_toplevel_thunk_callback at interpreter.c:798\n top-level scope\n jl_interpret_toplevel_thunk at interpreter.c:807\n jl_toplevel_eval_flex at toplevel.c:856\n jl_toplevel_eval_in at builtins.c:624\n eval at boot.jl:317 [inlined]\n eval(::Module, ::Expr) at REPL.jl:5\n jl_apply_generic at gf.c:2167\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n jl_apply_generic at gf.c:2167\n macro expansion at REPL.jl:116 [inlined]\n (::getfield(REPL, Symbol(\"##28#29\")){REPL.REPLBackend})() at event.jl:92\n jl_fptr_trampoline at gf.c:1838\n jl_apply_generic at gf.c:2167\n jl_apply at julia.h:1540 [inlined]\n start_task at task.c:268\n ip:0xffffffffffffffff\n\nIndividual pointers returned by backtrace can be translated into StackTraces.StackFrame\ns by passing them into StackTraces.lookup:\n\njulia> pointer = backtrace()[1];\n\njulia> frame = StackTraces.lookup(pointer)\n1-element Array{Base.StackTraces.StackFrame,1}:\n jl_apply_generic at gf.c:2167\n\njulia> println(\"The top frame is from $(frame[1].func)!\")\nThe top frame is from jl_apply_generic!"},{"title":"Variables","page":"Variables","location":"manual/variables.html#man-variables","category":"section","text":"A variable, in Julia, is a name associated (or bound) to a value. It's useful when you want to\nstore a value (that you obtained after some math, for example) for later use. For example:\n\njulia> x = 10   # Assign the value 10 to the variable x\n10\n\njulia> x + 1    # Doing math with x's value\n11\n\njulia> x = 1 + 1   # Reassign x's value\n2\n\njulia> x = \"Hello World!\"   # You can assign values of other types, like strings of text\n\"Hello World!\"\n\nJulia provides an extremely flexible system for naming variables. Variable names are case-sensitive,\nand have no semantic meaning (that is, the language will not treat variables differently based\non their names).\n\njulia> x = 1.0\n1.0\n\njulia> y = -3\n-3\n\njulia> Z = \"My string\"\n\"My string\"\n\njulia> customary_phrase = \"Hello world!\"\n\"Hello world!\"\n\njulia> UniversalDeclarationOfHumanRightsStart = \"人人生而自由，在尊严和权利上一律平等。\"\n\"人人生而自由，在尊严和权利上一律平等。\"\n\nUnicode names (in UTF-8 encoding) are allowed:\n\njulia> δ = 0.00001\n1.0e-5\n\njulia> 안녕하세요 = \"Hello\"\n\"Hello\"\n\nIn the Julia REPL and several other Julia editing environments, you can type many Unicode math\nsymbols by typing the backslashed LaTeX symbol name followed by tab. For example, the variable\nname δ can be entered by typing \\delta-tab, or even α̂⁽²⁾ by \\alpha-tab-\\hat-\ntab-\\^(2)-tab. (If you find a symbol somewhere, e.g. in someone else's code,\nthat you don't know how to type, the REPL help will tell you: just type ? and\nthen paste the symbol.)\n\nJulia will even let you shadow existing exported constants and functions with local ones\n(although this is not recommended to avoid potential confusions):\n\njulia> pi = 3\n3\n\njulia> pi\n3\n\njulia> sqrt = 4\n4\n\njulia> length() = 5\nlength (generic function with 1 method)\n\njulia> Base.length\nlength (generic function with 79 methods)\n\nHowever, if you try to redefine a built-in constant or function that you\nhave explicitly imported, Julia will give you an error:\n\njulia> using Base: pi, sqrt\n\njulia> pi\nπ = 3.1415926535897...\n\njulia> pi = 3\nERROR: cannot assign a value to imported variable Base.pi from module Main\n\njulia> sqrt(100)\n10.0\n\njulia> sqrt = 4\nERROR: cannot assign a value to imported variable Base.sqrt from module Main\n\ncompat: Julia 1.12\nNote that in versions prior to Julia 1.12, these errors depended on use\nrather than definition of the conflicting binding."},{"title":"Allowed Variable Names","page":"Variables","location":"manual/variables.html#man-allowed-variable-names","category":"section","text":"Variable names must begin with a letter (A-Z or a-z), underscore, or a subset of Unicode code\npoints greater than 00A0; in particular, Unicode character categories\nLu/Ll/Lt/Lm/Lo/Nl (letters), Sc/So (currency and other symbols), and a few other letter-like characters\n(e.g. a subset of the Sm math symbols) are allowed. Subsequent characters may also include ! and\ndigits (0-9 and other characters in categories Nd/No), as well as other Unicode code points: diacritics\nand other modifying marks (categories Mn/Mc/Me/Sk), some punctuation connectors (category Pc),\nprimes, and a few other characters.\n\nOperators like + are also valid identifiers, but are parsed specially. In some contexts, operators\ncan be used just like variables; for example (+) refers to the addition function, and (+) = f\nwill reassign it. Most of the Unicode infix operators (in category Sm), such as ⊕, are parsed\nas infix operators and are available for user-defined methods (e.g. you can use const ⊗ = kron\nto define ⊗ as an infix Kronecker product). Operators can also be suffixed with modifying marks,\nprimes, and sub/superscripts, e.g. +̂ₐ″ is parsed as an infix operator with the same precedence as +.\nA space is required between an operator that ends with a subscript/superscript letter and a subsequent\nvariable name. For example, if +ᵃ is an operator, then +ᵃx must be written as +ᵃ x to distinguish\nit from + ᵃx where ᵃx is the variable name.\n\nA particular class of variable names is one that contains only underscores. These identifiers are write-only. I.e. they can only be assigned values, which are immediately discarded, and their values cannot be used in any way.\n\njulia> x, ___ = size([2 2; 1 1])\n(2, 2)\n\njulia> y = ___\nERROR: syntax: all-underscore identifiers are write-only and their values cannot be used in expressions\n\njulia> println(___)\nERROR: syntax: all-underscore identifiers are write-only and their values cannot be used in expressions\n\nThe only explicitly disallowed names for variables are the names of the built-in Keywords:\n\njulia> else = false\nERROR: ParseError:\n# Error @ none:1:1\nelse = false\n└──┘ ── invalid identifier\n\njulia> try = \"No\"\nERROR: ParseError:\n# Error @ none:1:1\ntry = \"No\"\n└────────┘ ── try without catch or finally\n\nSome Unicode characters are considered to be equivalent in identifiers.\nDifferent ways of entering Unicode combining characters (e.g., accents)\nare treated as equivalent (specifically, Julia identifiers are NFC.\nJulia also includes a few non-standard equivalences for characters that are\nvisually similar and are easily entered by some input methods. The Unicode\ncharacters ɛ (U+025B: Latin small letter open e) and µ (U+00B5: micro sign)\nare treated as equivalent to the corresponding Greek letters. The middle dot\n· (U+00B7) and the Greek\ninterpunct · (U+0387) are both\ntreated as the mathematical dot operator ⋅ (U+22C5).\nThe minus sign − (U+2212) is treated as equivalent to the hyphen-minus sign - (U+002D)."},{"title":"Assignment expressions and assignment versus mutation","page":"Variables","location":"manual/variables.html#man-assignment-expressions","category":"section","text":"An assignment variable = value \"binds\" the name variable to the value computed\non the right-hand side, and the whole assignment is treated by Julia as an expression\nequal to the right-hand-side value. This means that assignments can be chained\n(the same value assigned to multiple variables with variable1 = variable2 = value)\nor used in other expressions, and is also why their result is shown in the REPL as\nthe value of the right-hand side.  (In general, the REPL displays the value of whatever\nexpression you evaluate.)  For example, here the value 4 of b = 2+2 is\nused in another arithmetic operation and assignment:\n\njulia> a = (b = 2+2) + 3\n7\n\njulia> a\n7\n\njulia> b\n4\n\nA common confusion is the distinction between assignment (giving a new \"name\" to a value)\nand mutation (changing a value). If you run a = 2 followed by a = 3, you have changed\nthe \"name\" a to refer to a new value 3 … you haven't changed the number 2, so 2+2\nwill still give 4 and not 6!   This distinction becomes more clear when dealing with\nmutable types like arrays, whose contents can be changed:\n\njulia> a = [1,2,3] # an array of 3 integers\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> b = a   # both b and a are names for the same array!\n3-element Vector{Int64}:\n 1\n 2\n 3\n\nHere, the line b = a does not make a copy of the array a, it simply binds the name\nb to the same array a: both b and a \"point\" to one array [1,2,3] in memory.\nIn contrast, an assignment a[i] = value changes the contents of the array, and the\nmodified array will be visible through both the names a and b:\n\njulia> a[1] = 42     # change the first element\n42\n\njulia> a = 3.14159   # a is now the name of a different object\n3.14159\n\njulia> b   # b refers to the original array object, which has been mutated\n3-element Vector{Int64}:\n 42\n  2\n  3\n\nThat is, a[i] = value (an alias for setindex!) mutates an existing array object\nin memory, accessible via either a or b. Subsequently setting a = 3.14159\ndoes not change this array, it simply binds a to a different object; the array is still\naccessible via b. Another common syntax to mutate an existing object is\na.field = value (an alias for setproperty!), which can be used to change\na mutable struct. There is also mutation via dot assignment, for example\nb .= 5:7 (which mutates our array b in-place to contain [5,6,7]), as part of Julia's\nvectorized \"dot\" syntax.\n\nWhen you call a function in Julia, it behaves as if you assigned\nthe argument values to new variable names corresponding to the function arguments, as discussed\nin Argument-Passing Behavior.  (By convention,\nfunctions that mutate one or more of their arguments have names ending with !.)"},{"title":"Stylistic Conventions","page":"Variables","location":"manual/variables.html#Stylistic-Conventions","category":"section","text":"While Julia imposes few restrictions on valid names, it has become useful to adopt the following\nconventions:\n\nNames of variables are in lower case.\nWord separation can be indicated by underscores ('_'), but use of underscores is discouraged\nunless the name would be hard to read otherwise.\nNames of Types and Modules begin with a capital letter and word separation is shown with upper\ncamel case instead of underscores.\nNames of functions and macros are in lower case, without underscores.\nFunctions that write to their arguments have names that end in !. These are sometimes called\n\"mutating\" or \"in-place\" functions because they are intended to produce changes in their arguments\nafter the function is called, not just return a value.\n\nFor more information about stylistic conventions, see the Style Guide."},{"title":"Code Formatting Guidelines","page":"Code Formatting Guidelines","location":"devdocs/contributing/formatting.html#Code-Formatting-Guidelines","category":"section","text":""},{"title":"General Formatting Guidelines for Julia code contributions","page":"Code Formatting Guidelines","location":"devdocs/contributing/formatting.html#General-Formatting-Guidelines-for-Julia-code-contributions","category":"section","text":"Follow the latest dev version of Julia Style Guide.\nUse whitespace to make the code more readable\nNo whitespace at the end of a line (trailing whitespace)\nComments are good, especially when they explain the algorithm\nTry to adhere to a 92 character line length limit\nIt is generally preferred to use ASCII operators and identifiers over\nUnicode equivalents whenever possible\nIn docstrings refer to the language as \"Julia\" and the executable as \"julia\""},{"title":"General Formatting Guidelines For C code contributions","page":"Code Formatting Guidelines","location":"devdocs/contributing/formatting.html#General-Formatting-Guidelines-For-C-code-contributions","category":"section","text":"4 spaces per indentation level, no tabs\nSpace between if and ( (if (x) ...)\nNewline before opening { in function definitions\nf(void) for 0-argument function declarations\nNewline between } and else instead of } else {\nIf one part of an if..else chain uses { } then all should\nNo whitespace at the end of a line"},{"title":"Random Numbers","page":"Random Numbers","location":"stdlib/Random.html#Random-Numbers","category":"section","text":"Random number generation in Julia uses the Xoshiro256++ algorithm\nby default, with per-Task state.\nOther RNG types can be plugged in by inheriting the AbstractRNG type; they can then be used to\nobtain multiple streams of random numbers.\n\nThe PRNGs (pseudorandom number generators) exported by the Random package are:\n\nTaskLocalRNG: a token that represents use of the currently active Task-local stream, deterministically seeded from the parent task, or by RandomDevice (with system randomness) at program start\nXoshiro: generates a high-quality stream of random numbers with a small state vector and high performance using the Xoshiro256++ algorithm\nRandomDevice: for OS-provided entropy. This may be used for cryptographically secure random numbers (CS(P)RNG).\nMersenneTwister: an alternate high-quality PRNG which was the default in older versions of Julia, and is also quite fast, but requires much more space to store the state vector and generate a random sequence.\n\nMost functions related to random generation accept an optional AbstractRNG object as first argument.\nSome also accept dimension specifications dims... (which can also be given as a tuple) to generate\narrays of random values.\nIn a multi-threaded program, you should generally use different RNG objects from different threads\nor tasks in order to be thread-safe. However, the default RNG is thread-safe as of Julia 1.3\n(using a per-thread RNG up to version 1.6, and per-task thereafter).\n\nThe provided RNGs can generate uniform random numbers of the following types:\nFloat16, Float32, Float64, BigFloat, Bool,\nInt8, UInt8, Int16, UInt16, Int32,\nUInt32, Int64, UInt64, Int128, UInt128,\nBigInt (or complex numbers of those types).\nRandom floating point numbers are generated uniformly in 0 1). As BigInt represents\nunbounded integers, the interval must be specified (e.g. rand(big.(1:6))).\n\nAdditionally, normal and exponential distributions are implemented for some AbstractFloat and\nComplex types, see randn and randexp for details.\n\nTo generate random numbers from other distributions, see the Distributions.jl package.\n\nwarning: Warning\nBecause the precise way in which random numbers are generated is considered an implementation detail, bug fixes and speed improvements may change the stream of numbers that are generated after a version change. Relying on a specific seed or generated stream of numbers during unit testing is thus discouraged - consider testing properties of the methods in question instead."},{"title":"Random numbers module","page":"Random Numbers","location":"stdlib/Random.html#Random-numbers-module","category":"section","text":""},{"title":"Random generation functions","page":"Random Numbers","location":"stdlib/Random.html#Random-generation-functions","category":"section","text":""},{"title":"Subsequences, permutations and shuffling","page":"Random Numbers","location":"stdlib/Random.html#Subsequences,-permutations-and-shuffling","category":"section","text":""},{"title":"Generators (creation and seeding)","page":"Random Numbers","location":"stdlib/Random.html#Generators-(creation-and-seeding)","category":"section","text":""},{"title":"Hooking into the Random API","page":"Random Numbers","location":"stdlib/Random.html#rand-api-hook","category":"section","text":"There are two mostly orthogonal ways to extend Random functionalities:\n\ngenerating random values of custom types\ncreating new generators\n\nThe API for 1) is quite functional, but is relatively recent so it may still have to evolve in subsequent releases of the Random module.\nFor example, it's typically sufficient to implement one rand method in order to have all other usual methods work automatically.\n\nThe API for 2) is still rudimentary, and may require more work than strictly necessary from the implementer,\nin order to support usual types of generated values."},{"title":"Generating random values of custom types","page":"Random Numbers","location":"stdlib/Random.html#Generating-random-values-of-custom-types","category":"section","text":"Generating random values for some distributions may involve various trade-offs. Pre-computed values, such as an alias table for discrete distributions, or “squeezing” functions for univariate distributions, can speed up sampling considerably. How much information should be pre-computed can depend on the number of values we plan to draw from a distribution. Also, some random number generators can have certain properties that various algorithms may want to exploit.\n\nThe Random module defines a customizable framework for obtaining random values that can address these issues. Each invocation of rand generates a sampler which can be customized with the above trade-offs in mind, by adding methods to Sampler, which in turn can dispatch on the random number generator, the object that characterizes the distribution, and a suggestion for the number of repetitions. Currently, for the latter, Val{1} (for a single sample) and Val{Inf} (for an arbitrary number) are used, with Random.Repetition an alias for both.\n\nThe object returned by Sampler is then used to generate the random values. When implementing the random generation interface for a value X that can be sampled from, the implementer should define the method\n\nrand(rng, sampler)\n\nfor the particular sampler returned by Sampler(rng, X, repetition).\n\nSamplers can be arbitrary values that implement rand(rng, sampler), but for most applications the following predefined samplers may be sufficient:\n\nSamplerType{T}() can be used for implementing samplers that draw from type T (e.g. rand(Int)). This is the default returned by Sampler for types.\nSamplerTrivial(self) is a simple wrapper for self, which can be accessed with []. This is the recommended sampler when no pre-computed information is needed (e.g. rand(1:3)), and is the default returned by Sampler for values.\nSamplerSimple(self, data) also contains the additional data field, which can be used to store arbitrary pre-computed values, which should be computed in a custom method of Sampler.\n\nWe provide examples for each of these. We assume here that the choice of algorithm is independent of the RNG, so we use AbstractRNG in our signatures.\n\nDecoupling pre-computation from actually generating the values is part of the API, and is also available to the user. As an example, assume that rand(rng, 1:20) has to be called repeatedly in a loop: the way to take advantage of this decoupling is as follows:\n\nrng = Xoshiro()\nsp = Random.Sampler(rng, 1:20) # or Random.Sampler(Xoshiro, 1:20)\nfor x in X\n    n = rand(rng, sp) # similar to n = rand(rng, 1:20)\n    # use n\nend\n\nThis is the mechanism that is also used in the standard library, e.g. by the default implementation of random array generation (like in rand(1:20, 10))."},{"title":"Generating values from a type","page":"Random Numbers","location":"stdlib/Random.html#Generating-values-from-a-type","category":"section","text":"Given a type T, it's currently assumed that if rand(T) is defined, an object of type T will be produced. SamplerType is the default sampler for types. In order to define random generation of values of type T, the rand(rng::AbstractRNG, ::Random.SamplerType{T}) method should be defined, and should return values what rand(rng, T) is expected to return.\n\nLet's take the following example: we implement a Die type, with a variable number n of sides, numbered from 1 to n. We want rand(Die) to produce a Die with a random number of up to 20 sides (and at least 4):\n\nstruct Die\n    nsides::Int # number of sides\nend\n\nRandom.rand(rng::AbstractRNG, ::Random.SamplerType{Die}) = Die(rand(rng, 4:20))\n\n# output\n\n\nScalar and array methods for Die now work as expected:\n\njulia> rand(Die)\nDie(5)\n\njulia> rand(Xoshiro(0), Die)\nDie(10)\n\njulia> rand(Die, 3)\n3-element Vector{Die}:\n Die(9)\n Die(15)\n Die(14)\n\njulia> a = Vector{Die}(undef, 3); rand!(a)\n3-element Vector{Die}:\n Die(19)\n Die(7)\n Die(17)"},{"title":"A simple sampler without pre-computed data","page":"Random Numbers","location":"stdlib/Random.html#A-simple-sampler-without-pre-computed-data","category":"section","text":"Here we define a sampler for a collection. If no pre-computed data is required, it can be implemented with a SamplerTrivial sampler, which is in fact the default fallback for values.\n\nIn order to define random generation out of objects of type S, the following method should be defined: rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S}). Here, sp simply wraps an object of type S, which can be accessed via sp[]. Continuing the Die example, we want now to define rand(d::Die) to produce an Int corresponding to one of d's sides:\n\njulia> Random.rand(rng::AbstractRNG, d::Random.SamplerTrivial{Die}) = rand(rng, 1:d[].nsides);\n\njulia> rand(Die(4))\n1\n\njulia> rand(Die(4), 3)\n3-element Vector{Any}:\n 2\n 3\n 3\n\nGiven a collection type S, it's currently assumed that if rand(::S) is defined, an object of type eltype(S) will be produced. In the last example, a Vector{Any} is produced; the reason is that eltype(Die) == Any. The remedy is to define Base.eltype(::Type{Die}) = Int."},{"title":"Generating values for an AbstractFloat type","page":"Random Numbers","location":"stdlib/Random.html#Generating-values-for-an-AbstractFloat-type","category":"section","text":"AbstractFloat types are special-cased, because by default random values are not produced in the whole type domain, but rather in [0,1). The following method should be implemented for T <: AbstractFloat: Random.rand(::AbstractRNG, ::Random.SamplerTrivial{Random.CloseOpen01{T}})"},{"title":"An optimized sampler with pre-computed data","page":"Random Numbers","location":"stdlib/Random.html#An-optimized-sampler-with-pre-computed-data","category":"section","text":"Consider a discrete distribution, where numbers 1:n are drawn with given probabilities that sum to one. When many values are needed from this distribution, the fastest method is using an alias table. We don't provide the algorithm for building such a table here, but suppose it is available in make_alias_table(probabilities) instead, and draw_number(rng, alias_table) can be used to draw a random number from it.\n\nSuppose that the distribution is described by\n\nstruct DiscreteDistribution{V <: AbstractVector}\n    probabilities::V\nend\n\nand that we always want to build an alias table, regardless of the number of values needed (we learn how to customize this below). The methods\n\nRandom.eltype(::Type{<:DiscreteDistribution}) = Int\n\nfunction Random.Sampler(::Type{<:AbstractRNG}, distribution::DiscreteDistribution, ::Repetition)\n    SamplerSimple(distribution, make_alias_table(distribution.probabilities))\nend\n\nshould be defined to return a sampler with pre-computed data, then\n\nfunction rand(rng::AbstractRNG, sp::SamplerSimple{<:DiscreteDistribution})\n    draw_number(rng, sp.data)\nend\n\nwill be used to draw the values."},{"title":"Custom sampler types","page":"Random Numbers","location":"stdlib/Random.html#Custom-sampler-types","category":"section","text":"The SamplerSimple type is sufficient for most use cases with precomputed data. However, in order to demonstrate how to use custom sampler types, here we implement something similar to SamplerSimple.\n\nGoing back to our Die example: rand(::Die) uses random generation from a range, so there is an opportunity for this optimization. We call our custom sampler SamplerDie.\n\nimport Random: Sampler, rand\n\nstruct SamplerDie <: Sampler{Int} # generates values of type Int\n    die::Die\n    sp::Sampler{Int} # this is an abstract type, so this could be improved\nend\n\nSampler(RNG::Type{<:AbstractRNG}, die::Die, r::Random.Repetition) =\n    SamplerDie(die, Sampler(RNG, 1:die.nsides, r))\n# the `r` parameter will be explained later on\n\nrand(rng::AbstractRNG, sp::SamplerDie) = rand(rng, sp.sp)\n\nIt's now possible to get a sampler with sp = Sampler(rng, die), and use sp instead of die in any rand call involving rng. In the simplistic example above, die doesn't need to be stored in SamplerDie but this is often the case in practice.\n\nOf course, this pattern is so frequent that the helper type used above, namely Random.SamplerSimple, is available,\nsaving us the definition of SamplerDie: we could have implemented our decoupling with:\n\nSampler(RNG::Type{<:AbstractRNG}, die::Die, r::Random.Repetition) =\n    SamplerSimple(die, Sampler(RNG, 1:die.nsides, r))\n\nrand(rng::AbstractRNG, sp::SamplerSimple{Die}) = rand(rng, sp.data)\n\nHere, sp.data refers to the second parameter in the call to the SamplerSimple constructor\n(in this case equal to Sampler(rng, 1:die.nsides, r)), while the Die object can be accessed\nvia sp[].\n\nLike SamplerDie, any custom sampler must be a subtype of Sampler{T} where T is the type\nof the generated values. Note that SamplerSimple(x, data) isa Sampler{eltype(x)},\nso this constrains what the first argument to SamplerSimple can be\n(it's recommended to use SamplerSimple like in the Die example, where\nx is simply forwarded while defining a Sampler method).\nSimilarly, SamplerTrivial(x) isa Sampler{eltype(x)}.\n\nAnother helper type is currently available for other cases, Random.SamplerTag, but is\nconsidered as internal API, and can break at any time without proper deprecations."},{"title":"Using distinct algorithms for scalar or array generation","page":"Random Numbers","location":"stdlib/Random.html#Using-distinct-algorithms-for-scalar-or-array-generation","category":"section","text":"In some cases, whether one wants to generate only a handful of values or a large number of values\nwill have an impact on the choice of algorithm. This is handled with the third parameter of the\nSampler constructor. Let's assume we defined two helper types for Die, say SamplerDie1\nwhich should be used to generate only few random values, and SamplerDieMany for many values.\nWe can use those types as follows:\n\nSampler(RNG::Type{<:AbstractRNG}, die::Die, ::Val{1}) = SamplerDie1(...)\nSampler(RNG::Type{<:AbstractRNG}, die::Die, ::Val{Inf}) = SamplerDieMany(...)\n\nOf course, rand must also be defined on those types (i.e. rand(::AbstractRNG, ::SamplerDie1) and rand(::AbstractRNG, ::SamplerDieMany)). Note that, as usual, SamplerTrivial and SamplerSimple can be used if custom types are not necessary.\n\nNote: Sampler(rng, x) is simply a shorthand for Sampler(rng, x, Val(Inf)), and\nRandom.Repetition is an alias for Union{Val{1}, Val{Inf}}."},{"title":"Creating new generators","page":"Random Numbers","location":"stdlib/Random.html#Creating-new-generators","category":"section","text":"The API is not clearly defined yet, but as a rule of thumb:\n\nany rand method producing \"basic\" types (isbitstype integer and floating types in Base)\nshould be defined for this specific RNG, if they are needed;\nother documented rand methods accepting an AbstractRNG should work out of the box,\n(provided the methods from 1) what are relied on are implemented),\nbut can of course be specialized for this RNG if there is room for optimization;\ncopy for pseudo-RNGs should return an independent copy that generates the exact same random sequence as the\noriginal from that point when called in the same way. When this is not feasible (e.g. hardware-based RNGs),\ncopy must not be implemented.\n\nConcerning 1), a rand method may happen to work automatically, but it's not officially\nsupported and may break without warnings in a subsequent release.\n\nTo define a new rand method for an hypothetical MyRNG generator, and a value specification s\n(e.g. s == Int, or s == 1:10) of type S==typeof(s) or S==Type{s} if s is a type,\nthe same two methods as we saw before must be defined:\n\nSampler(::Type{MyRNG}, ::S, ::Repetition), which returns an object of type say SamplerS\nrand(rng::MyRNG, sp::SamplerS)\n\nIt can happen that Sampler(rng::AbstractRNG, ::S, ::Repetition) is\nalready defined in the Random module. It would then be possible to\nskip step 1) in practice (if one wants to specialize generation for\nthis particular RNG type), but the corresponding SamplerS type is\nconsidered as internal detail, and may be changed without warning."},{"title":"Specializing array generation","page":"Random Numbers","location":"stdlib/Random.html#Specializing-array-generation","category":"section","text":"In some cases, for a given RNG type, generating an array of random\nvalues can be more efficient with a specialized method than by merely\nusing the decoupling technique explained before. This is for example\nthe case for MersenneTwister, which natively writes random values in\nan array.\n\nTo implement this specialization for MyRNG\nand for a specification s, producing elements of type S,\nthe following method can be defined:\nrand!(rng::MyRNG, a::AbstractArray{S}, ::SamplerS),\nwhere SamplerS is the type of the sampler returned by Sampler(MyRNG, s, Val(Inf)).\nInstead of AbstractArray, it's possible to implement the functionality only for a subtype, e.g. Array{S}.\nThe non-mutating array method of rand will automatically call this specialization internally."},{"title":"Reproducibility","page":"Random Numbers","location":"stdlib/Random.html#Reproducibility","category":"section","text":"By using an RNG parameter initialized with a given seed, you can reproduce the same pseudorandom\nnumber sequence when running your program multiple times. However, a minor release of Julia (e.g.\n1.3 to 1.4) may change the sequence of pseudorandom numbers generated from a specific seed.\n(Even if the sequence produced by a low-level function like\nrand does not change, the output of higher-level functions like randsubseq may\nchange due to algorithm updates.) Rationale: guaranteeing that pseudorandom streams never change\nprohibits many algorithmic improvements.\n\nIf you need to guarantee exact reproducibility of random data, it is advisable to simply save the\ndata (e.g. as a supplementary attachment in a scientific publication). (You can also, of course,\nspecify a particular Julia version and package manifest, especially if you require bit\nreproducibility.)\n\nSoftware tests that rely on specific \"random\" data should also generally either save the data,\nembed it into the test code, or use third-party packages like\nStableRNGs.jl. On the other hand, tests that should\npass for most random data (e.g. testing A \\ (A*x) ≈ x for a random matrix A = randn(n,n)) can\nuse an RNG with a fixed seed to ensure that simply running the test many times does not encounter a\nfailure due to very improbable data (e.g. an extremely ill-conditioned matrix).\n\nThe statistical distribution from which random samples are drawn is guaranteed to be the same\nacross any minor Julia releases."},{"title":"Random.Random","page":"Random Numbers","location":"stdlib/Random.html#Random.Random","category":"module","text":"Random\n\nSupport for generating random numbers. Provides rand, randn,\nAbstractRNG, Xoshiro, MersenneTwister, and RandomDevice.\n\n\n\n\n\n"},{"title":"Base.rand","page":"Random Numbers","location":"stdlib/Random.html#Base.rand","category":"function","text":"rand([rng=default_rng()], [S], [dims...])\n\nPick a random element or array of random elements from the set of values specified by S;\nS can be\n\nan indexable collection (for example 1:9 or ('x', \"y\", :z))\nan AbstractDict or AbstractSet object\na string (considered as a collection of characters), or\na type from the list below, corresponding to the specified set of values\nconcrete integer types sample from typemin(S):typemax(S) (excepting BigInt which is not supported)\nconcrete floating point types sample from [0, 1)\nconcrete complex types Complex{T} if T is a sampleable type take their real and imaginary components\nindependently from the set of values corresponding to T, but are not supported if T is not sampleable.\nall <:AbstractChar types sample from the set of valid Unicode scalars\na user-defined type and set of values; for implementation guidance please see Hooking into the Random API\na tuple type of known size and where each parameter of S is itself a sampleable type; return a value of type S.\nNote that tuple types such as Tuple{Vararg{T}} (unknown size) and Tuple{1:2} (parameterized with a value) are not supported\na Pair type, e.g. Pair{X, Y} such that rand is defined for X and Y,\nin which case random pairs are produced.\n\nS defaults to Float64.\nWhen only one argument is passed besides the optional rng and is a Tuple, it is interpreted\nas a collection of values (S) and not as dims.\n\nSee also randn for normally distributed numbers, and rand! and randn! for the in-place equivalents.\n\ncompat: Julia 1.1\nSupport for S as a tuple requires at least Julia 1.1.\n\ncompat: Julia 1.11\nSupport for S as a Tuple type requires at least Julia 1.11.\n\nExamples\n\njulia> rand(Int, 2)\n2-element Vector{Int64}:\n 1339893410598768192\n 1575814717733606317\n\njulia> using Random\n\njulia> rand(Xoshiro(0), Dict(1=>2, 3=>4))\n3 => 4\n\njulia> rand((2, 3))\n3\n\njulia> rand(Float64, (2, 3))\n2×3 Matrix{Float64}:\n 0.999717  0.0143835  0.540787\n 0.696556  0.783855   0.938235\n\nnote: Note\nThe complexity of rand(rng, s::Union{AbstractDict,AbstractSet})\nis linear in the length of s, unless an optimized method with\nconstant complexity is available, which is the case for Dict,\nSet and dense BitSets. For more than a few calls, use rand(rng, collect(s)) instead, or either rand(rng, Dict(s)) or rand(rng, Set(s)) as appropriate.\n\n\n\n\n\n"},{"title":"Random.rand!","page":"Random Numbers","location":"stdlib/Random.html#Random.rand!","category":"function","text":"rand!([rng=default_rng()], A, [S=eltype(A)])\n\nPopulate the array A with random values. If S is specified\n(S can be a type or a collection, cf. rand for details),\nthe values are picked randomly from S.\nThis is equivalent to copyto!(A, rand(rng, S, size(A)))\nbut without allocating a new array.\n\nExamples\n\njulia> rand!(Xoshiro(123), zeros(5))\n5-element Vector{Float64}:\n 0.521213795535383\n 0.5868067574533484\n 0.8908786980927811\n 0.19090669902576285\n 0.5256623915420473\n\n\n\n\n\n"},{"title":"Random.bitrand","page":"Random Numbers","location":"stdlib/Random.html#Random.bitrand","category":"function","text":"bitrand([rng=default_rng()], [dims...])\n\nGenerate a BitArray of random boolean values.\n\nExamples\n\njulia> bitrand(Xoshiro(123), 10)\n10-element BitVector:\n 0\n 1\n 0\n 1\n 0\n 1\n 0\n 0\n 1\n 1\n\n\n\n\n\n"},{"title":"Base.randn","page":"Random Numbers","location":"stdlib/Random.html#Base.randn","category":"function","text":"randn([rng=default_rng()], [T=Float64], [dims...])\n\nGenerate a normally-distributed random number of type T\nwith mean 0 and standard deviation 1.\nGiven the optional dims argument(s), generate an array of size dims of such numbers.\nJulia's standard library supports randn for any floating-point type\nthat implements rand, e.g. the Base types\nFloat16, Float32, Float64 (the default), and BigFloat,\nalong with their Complex counterparts.\n\n(When T is complex, the values are drawn\nfrom the circularly symmetric complex normal distribution of variance 1, corresponding to real and imaginary parts\nhaving independent normal distribution with mean zero and variance 1/2).\n\nSee also randn! to act in-place.\n\nExamples\n\nGenerating a single random number (with the default Float64 type):\n\njulia> randn()\n-0.942481877315864\n\nGenerating a matrix of normal random numbers (with the default Float64 type):\n\njulia> randn(2,3)\n2×3 Matrix{Float64}:\n  1.18786   -0.678616   1.49463\n -0.342792  -0.134299  -1.45005\n\nSetting up of the random number generator rng with a user-defined seed (for reproducible numbers)\nand using it to generate a random Float32 number or a matrix of ComplexF32 random numbers:\n\njulia> using Random\n\njulia> rng = Xoshiro(123);\n\njulia> randn(rng, Float32)\n-0.6457307f0\n\njulia> randn(rng, ComplexF32, (2, 3))\n2×3 Matrix{ComplexF32}:\n  -1.03467-1.14806im  0.693657+0.056538im   0.291442+0.419454im\n -0.153912+0.34807im    1.0954-0.948661im  -0.543347-0.0538589im\n\n\n\n\n\n"},{"title":"Random.randn!","page":"Random Numbers","location":"stdlib/Random.html#Random.randn!","category":"function","text":"randn!([rng=default_rng()], A::AbstractArray) -> A\n\nFill the array A with normally-distributed (mean 0, standard deviation 1) random numbers.\nAlso see the rand function.\n\nExamples\n\njulia> randn!(Xoshiro(123), zeros(5))\n5-element Vector{Float64}:\n -0.6457306721039767\n -1.4632513788889214\n -1.6236037455860806\n -0.21766510678354617\n  0.4922456865251828\n\n\n\n\n\n"},{"title":"Random.randexp","page":"Random Numbers","location":"stdlib/Random.html#Random.randexp","category":"function","text":"randexp([rng=default_rng()], [T=Float64], [dims...])\n\nGenerate a random number of type T according to the\nexponential distribution with scale 1.\nOptionally generate an array of such random numbers.\nThe Base module currently provides an implementation for the types\nFloat16, Float32, and Float64 (the default).\n\nExamples\n\njulia> rng = Xoshiro(123);\n\njulia> randexp(rng, Float32)\n1.1757717f0\n\njulia> randexp(rng, 3, 3)\n3×3 Matrix{Float64}:\n 1.37766  0.456653  0.236418\n 3.40007  0.229917  0.0684921\n 0.48096  0.577481  0.71835\n\n\n\n\n\n"},{"title":"Random.randexp!","page":"Random Numbers","location":"stdlib/Random.html#Random.randexp!","category":"function","text":"randexp!([rng=default_rng()], A::AbstractArray) -> A\n\nFill the array A with random numbers following the exponential distribution\n(with scale 1).\n\nExamples\n\njulia> randexp!(Xoshiro(123), zeros(5))\n5-element Vector{Float64}:\n 1.1757716836348473\n 1.758884569451514\n 1.0083623637301151\n 0.3510644315565272\n 0.6348266443720407\n\n\n\n\n\n"},{"title":"Random.randstring","page":"Random Numbers","location":"stdlib/Random.html#Random.randstring","category":"function","text":"randstring([rng=default_rng()], [chars], [len=8])\n\nCreate a random string of length len, consisting of characters from\nchars, which defaults to the set of upper- and lower-case letters\nand the digits 0-9. The optional rng argument specifies a random\nnumber generator, see Random Numbers.\n\nExamples\n\njulia> Random.seed!(3); randstring()\n\"Lxz5hUwn\"\n\njulia> randstring(Xoshiro(3), 'a':'z', 6)\n\"iyzcsm\"\n\njulia> randstring(\"ACGT\")\n\"TGCTCCTC\"\n\nnote: Note\nchars can be any collection of characters, of type Char or\nUInt8 (more efficient), provided rand can randomly\npick characters from it.\n\n\n\n\n\n"},{"title":"Random.randsubseq","page":"Random Numbers","location":"stdlib/Random.html#Random.randsubseq","category":"function","text":"randsubseq([rng=default_rng(),] A, p) -> Vector\n\nReturn a vector consisting of a random subsequence of the given array A, where each\nelement of A is included (in order) with independent probability p. (Complexity is\nlinear in p*length(A), so this function is efficient even if p is small and A is\nlarge.) Technically, this process is known as \"Bernoulli sampling\" of A.\n\nExamples\n\njulia> randsubseq(Xoshiro(123), 1:8, 0.3)\n2-element Vector{Int64}:\n 4\n 7\n\n\n\n\n\n"},{"title":"Random.randsubseq!","page":"Random Numbers","location":"stdlib/Random.html#Random.randsubseq!","category":"function","text":"randsubseq!([rng=default_rng(),] S, A, p)\n\nLike randsubseq, but the results are stored in S\n(which is resized as needed).\n\nExamples\n\njulia> S = Int64[];\n\njulia> randsubseq!(Xoshiro(123), S, 1:8, 0.3)\n2-element Vector{Int64}:\n 4\n 7\n\njulia> S\n2-element Vector{Int64}:\n 4\n 7\n\n\n\n\n\n"},{"title":"Random.randperm","page":"Random Numbers","location":"stdlib/Random.html#Random.randperm","category":"function","text":"randperm([rng=default_rng(),] n::Integer)\n\nConstruct a random permutation of length n. The optional rng\nargument specifies a random number generator (see [Random\nNumbers](@ref)). The element type of the result is the same as the type\nof n.\n\nTo randomly permute an arbitrary vector, see shuffle or\nshuffle!.\n\ncompat: Julia 1.1\nIn Julia 1.1 randperm returns a vector v with eltype(v) == typeof(n)\nwhile in Julia 1.0 eltype(v) == Int.\n\nExamples\n\njulia> randperm(Xoshiro(0), 6)\n6-element Vector{Int64}:\n 5\n 1\n 2\n 6\n 3\n 4\n\n\n\n\n\n"},{"title":"Random.randperm!","page":"Random Numbers","location":"stdlib/Random.html#Random.randperm!","category":"function","text":"randperm!([rng=default_rng(),] A::AbstractArray{<:Integer})\n\nConstruct in A a random permutation of length length(A). The\noptional rng argument specifies a random number generator (see\nRandom Numbers). To randomly permute an arbitrary vector, see\nshuffle or shuffle!.\n\ncompat: Julia 1.13\nA isa Array was required prior to Julia v1.13.\n\nExamples\n\njulia> randperm!(Xoshiro(0), Vector{Int}(undef, 6))\n6-element Vector{Int64}:\n 5\n 1\n 2\n 6\n 3\n 4\n\n\n\n\n\n"},{"title":"Random.randcycle","page":"Random Numbers","location":"stdlib/Random.html#Random.randcycle","category":"function","text":"randcycle([rng=default_rng(),] n::Integer)\n\nConstruct a random cyclic permutation of length n. The optional rng\nargument specifies a random number generator, see Random Numbers.\nThe element type of the result is the same as the type of n.\n\nHere, a \"cyclic permutation\" means that all of the elements lie within\na single cycle.  If n > 0, there are (n-1) possible cyclic permutations,\nwhich are sampled uniformly.  If n == 0, randcycle returns an empty vector.\n\nrandcycle! is an in-place variant of this function.\n\ncompat: Julia 1.1\nIn Julia 1.1 and above, randcycle returns a vector v with\neltype(v) == typeof(n) while in Julia 1.0 eltype(v) == Int.\n\nExamples\n\njulia> randcycle(Xoshiro(0), 6)\n6-element Vector{Int64}:\n 5\n 1\n 4\n 6\n 3\n 2\n\n\n\n\n\n"},{"title":"Random.randcycle!","page":"Random Numbers","location":"stdlib/Random.html#Random.randcycle!","category":"function","text":"randcycle!([rng=default_rng(),] A::AbstractArray{<:Integer})\n\nConstruct in A a random cyclic permutation of length n = length(A).\nThe optional rng argument specifies a random number generator, see\nRandom Numbers.\n\nHere, a \"cyclic permutation\" means that all of the elements lie within a single cycle.\nIf A is nonempty (n > 0), there are (n-1) possible cyclic permutations,\nwhich are sampled uniformly.  If A is empty, randcycle! leaves it unchanged.\n\nrandcycle is a variant of this function that allocates a new vector.\n\ncompat: Julia 1.13\nA isa Array was required prior to Julia v1.13.\n\nExamples\n\njulia> randcycle!(Xoshiro(0), Vector{Int}(undef, 6))\n6-element Vector{Int64}:\n 5\n 1\n 4\n 6\n 3\n 2\n\n\n\n\n\n"},{"title":"Random.shuffle","page":"Random Numbers","location":"stdlib/Random.html#Random.shuffle","category":"function","text":"shuffle([rng=default_rng(),] v::Union{NTuple,AbstractArray})\n\nReturn a randomly permuted copy of v. The optional rng argument specifies a random\nnumber generator (see Random Numbers).\nTo permute v in-place, see shuffle!. To obtain randomly permuted\nindices, see randperm.\n\ncompat: Julia 1.13\nShuffling an NTuple value requires Julia v1.13 or above.\n\nExamples\n\njulia> shuffle(Xoshiro(0), 1:6)\n6-element Vector{Int64}:\n 5\n 1\n 2\n 6\n 3\n 4\n\n\n\n\n\n"},{"title":"Random.shuffle!","page":"Random Numbers","location":"stdlib/Random.html#Random.shuffle!","category":"function","text":"shuffle!([rng=default_rng(),] v::AbstractArray)\n\nIn-place version of shuffle: randomly permute v in-place,\noptionally supplying the random-number generator rng.\n\nExamples\n\njulia> shuffle!(Xoshiro(0), Vector(1:6))\n6-element Vector{Int64}:\n 5\n 1\n 2\n 6\n 3\n 4\n\n\n\n\n\n"},{"title":"Random.default_rng","page":"Random Numbers","location":"stdlib/Random.html#Random.default_rng","category":"function","text":"Random.default_rng() -> rng\n\nReturn the default global random number generator (RNG), which is used by rand-related functions when\nno explicit RNG is provided.\n\nWhen the Random module is loaded, the default RNG is randomly seeded, via Random.seed!():\nthis means that each time a new julia session is started, the first call to rand() produces a different\nresult, unless seed!(seed) is called first.\n\nIt is thread-safe: distinct threads can safely call rand-related functions on default_rng() concurrently,\ne.g. rand(default_rng()).\n\nnote: Note\nThe type of the default RNG is an implementation detail. Across different versions of\nJulia, you should not expect the default RNG to always have the same type, nor that it will\nproduce the same stream of random numbers for a given seed.\n\ncompat: Julia 1.3\nThis function was introduced in Julia 1.3.\n\n\n\n\n\n"},{"title":"Random.seed!","page":"Random Numbers","location":"stdlib/Random.html#Random.seed!","category":"function","text":"seed!([rng=default_rng()], seed) -> rng\nseed!([rng=default_rng()]) -> rng\n\nReseed the random number generator: rng will give a reproducible\nsequence of numbers if and only if a seed is provided. Some RNGs\ndon't accept a seed, like RandomDevice.\nAfter the call to seed!, rng is equivalent to a newly created\nobject initialized with the same seed.\n\nThe types of accepted seeds depend on the type of rng, but in general,\ninteger seeds should work. Providing nothing as the seed should be\nequivalent to not providing one.\n\nIf rng is not specified, it defaults to seeding the state of the\nshared task-local generator.\n\nExamples\n\njulia> Random.seed!(1234);\n\njulia> x1 = rand(2)\n2-element Vector{Float64}:\n 0.32597672886359486\n 0.5490511363155669\n\njulia> Random.seed!(1234);\n\njulia> x2 = rand(2)\n2-element Vector{Float64}:\n 0.32597672886359486\n 0.5490511363155669\n\njulia> x1 == x2\ntrue\n\njulia> rng = Xoshiro(1234); rand(rng, 2) == x1\ntrue\n\njulia> Xoshiro(1) == Random.seed!(rng, 1)\ntrue\n\njulia> rand(Random.seed!(rng), Bool) # not reproducible\ntrue\n\njulia> rand(Random.seed!(rng), Bool) # not reproducible either\nfalse\n\njulia> rand(Xoshiro(), Bool) # not reproducible either\ntrue\n\n\n\n\n\n"},{"title":"Random.AbstractRNG","page":"Random Numbers","location":"stdlib/Random.html#Random.AbstractRNG","category":"type","text":"AbstractRNG\n\nSupertype for random number generators such as MersenneTwister and RandomDevice.\n\n\n\n\n\n"},{"title":"Random.TaskLocalRNG","page":"Random Numbers","location":"stdlib/Random.html#Random.TaskLocalRNG","category":"type","text":"TaskLocalRNG\n\nThe TaskLocalRNG has state that is local to its task, not its thread.\nIt is seeded upon task creation, from the state of its parent task, but without\nadvancing the state of the parent's RNG.\n\nAs an upside, the TaskLocalRNG is pretty fast, and permits reproducible\nmultithreaded simulations (barring race conditions), independent of scheduler\ndecisions. As long as the number of threads is not used to make decisions on\ntask creation, simulation results are also independent of the number of available\nthreads / CPUs. The random stream should not depend on hardware specifics, up to\nendianness and possibly word size.\n\nWhen seeding TaskLocalRNG() with seed!, the passed seed, if any,\nmay be any integer.\n\ncompat: Julia 1.11\nSeeding TaskLocalRNG() with a negative integer seed requires at least Julia 1.11.\n\ncompat: Julia 1.10\nTask creation no longer advances the parent task's RNG state as of Julia 1.10.\n\n\n\n\n\n"},{"title":"Random.Xoshiro","page":"Random Numbers","location":"stdlib/Random.html#Random.Xoshiro","category":"type","text":"Xoshiro(seed::Union{Integer, AbstractString})\nXoshiro()\n\nXoshiro256++ is a fast pseudorandom number generator described by David Blackman and\nSebastiano Vigna in \"Scrambled Linear Pseudorandom Number Generators\",\nACM Trans. Math. Softw., 2021. Reference implementation is available\nat https://prng.di.unimi.it\n\nApart from the high speed, Xoshiro has a small memory footprint, making it suitable for\napplications where many different random states need to be held for long time.\n\nJulia's Xoshiro implementation has a bulk-generation mode; this seeds new virtual PRNGs\nfrom the parent, and uses SIMD to generate in parallel (i.e. the bulk stream consists of\nmultiple interleaved xoshiro instances).\nThe virtual PRNGs are discarded once the bulk request has been serviced (and should cause\nno heap allocations).\n\nIf no seed is provided, a randomly generated one is created (using entropy from the system).\nSee the seed! function for reseeding an already existing Xoshiro object.\n\ncompat: Julia 1.11\nPassing a negative integer seed requires at least Julia 1.11.\n\nExamples\n\njulia> using Random\n\njulia> rng = Xoshiro(1234);\n\njulia> x1 = rand(rng, 2)\n2-element Vector{Float64}:\n 0.32597672886359486\n 0.5490511363155669\n\njulia> rng = Xoshiro(1234);\n\njulia> x2 = rand(rng, 2)\n2-element Vector{Float64}:\n 0.32597672886359486\n 0.5490511363155669\n\njulia> x1 == x2\ntrue\n\n\n\n\n\n"},{"title":"Random.MersenneTwister","page":"Random Numbers","location":"stdlib/Random.html#Random.MersenneTwister","category":"type","text":"MersenneTwister(seed)\nMersenneTwister()\n\nCreate a MersenneTwister RNG object. Different RNG objects can have\ntheir own seeds, which may be useful for generating different streams\nof random numbers.\nThe seed may be an integer, a string, or a vector of UInt32 integers.\nIf no seed is provided, a randomly generated one is created (using entropy from the system).\nSee the seed! function for reseeding an already existing MersenneTwister object.\n\ncompat: Julia 1.11\nPassing a negative integer seed requires at least Julia 1.11.\n\nExamples\n\njulia> rng = MersenneTwister(123);\n\njulia> x1 = rand(rng, 2)\n2-element Vector{Float64}:\n 0.37453777969575874\n 0.8735343642013971\n\njulia> x2 = rand(MersenneTwister(123), 2)\n2-element Vector{Float64}:\n 0.37453777969575874\n 0.8735343642013971\n\njulia> x1 == x2\ntrue\n\n\n\n\n\n"},{"title":"Random.RandomDevice","page":"Random Numbers","location":"stdlib/Random.html#Random.RandomDevice","category":"type","text":"RandomDevice()\n\nCreate a RandomDevice RNG object.\nTwo such objects will always generate different streams of random numbers.\nThe entropy is obtained from the operating system.\n\n\n\n\n\n"},{"title":"Random.Sampler","page":"Random Numbers","location":"stdlib/Random.html#Random.Sampler","category":"type","text":"Sampler(rng, x, repetition = Val(Inf))\n\nReturn a sampler object that can be used to generate random values from rng for x.\n\nWhen sp = Sampler(rng, x, repetition), rand(rng, sp) will be used to draw random values,\nand should be defined accordingly.\n\nrepetition can be Val(1) or Val(Inf), and should be used as a suggestion for deciding\nthe amount of precomputation, if applicable.\n\nRandom.SamplerType and Random.SamplerTrivial are default fallbacks for\ntypes and values, respectively. Random.SamplerSimple can be used to store\npre-computed values without defining extra types for only this purpose.\n\n\n\n\n\n"},{"title":"Random.SamplerType","page":"Random Numbers","location":"stdlib/Random.html#Random.SamplerType","category":"type","text":"SamplerType{T}()\n\nA sampler for types, containing no other information. The default fallback for Sampler\nwhen called with types.\n\n\n\n\n\n"},{"title":"Random.SamplerTrivial","page":"Random Numbers","location":"stdlib/Random.html#Random.SamplerTrivial","category":"type","text":"SamplerTrivial(x)\n\nCreate a sampler that just wraps the given value x. This is the default fall-back for\nvalues.\nThe eltype of this sampler is equal to eltype(x).\n\nThe recommended use case is sampling from values without precomputed data.\n\n\n\n\n\n"},{"title":"Random.SamplerSimple","page":"Random Numbers","location":"stdlib/Random.html#Random.SamplerSimple","category":"type","text":"SamplerSimple(x, data)\n\nCreate a sampler that wraps the given value x and the data.\nThe eltype of this sampler is equal to eltype(x).\n\nThe recommended use case is sampling from values with precomputed data.\n\n\n\n\n\n"},{"title":"Profiling","page":"Profiling","location":"stdlib/Profile.html#lib-profiling","category":"section","text":""},{"title":"CPU Profiling","page":"Profiling","location":"stdlib/Profile.html#CPU-Profiling","category":"section","text":"There are two main approaches to CPU profiling julia code:"},{"title":"Via @profile","page":"Profiling","location":"stdlib/Profile.html#Via-@profile","category":"section","text":"Where profiling is enabled for a given call via the @profile macro.\n\njulia> using Profile\n\njulia> @profile foo()\n\njulia> Profile.print()\nOverhead ╎ [+additional indent] Count File:Line; Function\n=========================================================\n    ╎147  @Base/client.jl:506; _start()\n        ╎ 147  @Base/client.jl:318; exec_options(opts::Base.JLOptions)\n..."},{"title":"Triggered During Execution","page":"Profiling","location":"stdlib/Profile.html#Triggered-During-Execution","category":"section","text":"Tasks that are already running can also be profiled for a fixed time period at any user-triggered time.\n\nTo trigger the profiling:\n\nMacOS & FreeBSD (BSD-based platforms): Use ctrl-t or pass a SIGINFO signal to the julia process i.e. % kill -INFO $julia_pid\nLinux: Pass a SIGUSR1 signal to the julia process i.e. % kill -USR1 $julia_pid\nWindows: Not currently supported.\n\nFirst, a single stack trace at the instant that the signal was thrown is shown, then a 1 second profile is collected,\nfollowed by the profile report at the next yield point, which may be at task completion for code without yield points\ne.g. tight loops.\n\nOptionally set environment variable JULIA_PROFILE_PEEK_HEAP_SNAPSHOT to 1 to also automatically collect a\nheap snapshot.\n\njulia> foo()\n##== the user sends a trigger while foo is running ==##\nload: 2.53  cmd: julia 88903 running 6.16u 0.97s\n\n======================================================================================\nInformation request received. A stacktrace will print followed by a 1.0 second profile\n======================================================================================\n\nsignal (29): Information request: 29\n__psynch_cvwait at /usr/lib/system/libsystem_kernel.dylib (unknown line)\n_pthread_cond_wait at /usr/lib/system/libsystem_pthread.dylib (unknown line)\n...\n\n======================================================================\nProfile collected. A report will print if the Profile module is loaded\n======================================================================\n\nOverhead ╎ [+additional indent] Count File:Line; Function\n=========================================================\nThread 1 Task 0x000000011687c010 Total snapshots: 572. Utilization: 100%\n   ╎147 @Base/client.jl:506; _start()\n       ╎ 147 @Base/client.jl:318; exec_options(opts::Base.JLOptions)\n...\n\nThread 2 Task 0x0000000116960010 Total snapshots: 572. Utilization: 0%\n   ╎572 @Base/task.jl:587; task_done_hook(t::Task)\n      ╎ 572 @Base/task.jl:879; wait()\n..."},{"title":"Customization","page":"Profiling","location":"stdlib/Profile.html#Customization","category":"section","text":"The duration of the profiling can be adjusted via Profile.set_peek_duration\n\nThe profile report is broken down by thread and task. Pass a no-arg function to Profile.peek_report[] to override this.\ni.e. Profile.peek_report[] = () -> Profile.print() to remove any grouping. This could also be overridden by an external\nprofile data consumer."},{"title":"Reference","page":"Profiling","location":"stdlib/Profile.html#Reference","category":"section","text":"The methods in Profile are not exported and need to be called e.g. as Profile.print()."},{"title":"Memory profiling","page":"Profiling","location":"stdlib/Profile.html#Memory-profiling","category":"section","text":"The methods in Profile.Allocs are not exported and need to be called e.g. as Profile.Allocs.fetch()."},{"title":"Heap Snapshots","page":"Profiling","location":"stdlib/Profile.html#Heap-Snapshots","category":"section","text":"The methods in Profile are not exported and need to be called e.g. as Profile.take_heap_snapshot().\n\njulia> using Profile\n\njulia> Profile.take_heap_snapshot(\"snapshot.heapsnapshot\")\n\nTraces and records julia objects on the heap. This only records objects known to the Julia\ngarbage collector. Memory allocated by external libraries not managed by the garbage\ncollector will not show up in the snapshot.\n\nTo avoid OOMing while recording the snapshot, we added a streaming option to stream out the heap snapshot\ninto four files,\n\njulia> using Profile\n\njulia> Profile.take_heap_snapshot(\"snapshot\"; streaming=true)\n\nwhere \"snapshot\" is the filepath as the prefix for the generated files.\n\nOnce the snapshot files are generated, they could be assembled offline with the following command:\n\njulia> using Profile\n\njulia> Profile.HeapSnapshot.assemble_snapshot(\"snapshot\", \"snapshot.heapsnapshot\")\n\nThe resulting heap snapshot file can be uploaded to chrome devtools to be viewed.\nFor more information, see the chrome devtools docs.\nAn alternative for analyzing Chromium heap snapshots is with the VS Code extension\nms-vscode.vscode-js-profile-flame.\n\nThe Firefox heap snapshots are of a different format, and Firefox currently may\nnot be used for viewing the heap snapshots generated by Julia."},{"title":"Profile.@profile","page":"Profiling","location":"stdlib/Profile.html#Profile.@profile","category":"macro","text":"@profile\n\n@profile <expression> runs your expression while taking periodic backtraces. These are\nappended to an internal buffer of backtraces.\n\n\n\n\n\n"},{"title":"Profile.clear","page":"Profiling","location":"stdlib/Profile.html#Profile.clear","category":"function","text":"clear()\n\nClear any existing backtraces from the internal buffer.\n\n\n\n\n\n"},{"title":"Profile.print","page":"Profiling","location":"stdlib/Profile.html#Profile.print","category":"function","text":"print([io::IO = stdout,] [data::Vector = fetch()], [lidict::Union{LineInfoDict, LineInfoFlatDict} = getdict(data)]; kwargs...)\nprint(path::String, [cols::Int = 1000], [data::Vector = fetch()], [lidict::Union{LineInfoDict, LineInfoFlatDict} = getdict(data)]; kwargs...)\n\nPrints profiling results to io (by default, stdout). If you do not\nsupply a data vector, the internal buffer of accumulated backtraces\nwill be used. Paths are clickable links in supported terminals and\nspecialized for JULIA_EDITOR with line numbers, or just file\nlinks if no editor is set.\n\nThe keyword arguments can be any combination of:\n\nformat – Determines whether backtraces are printed with (default, :tree) or without (:flat)\nindentation indicating tree structure.\nC – If true, backtraces from C and Fortran code are shown (normally they are excluded).\ncombine – If true (default), instruction pointers are merged that correspond to the same line of code.\nmaxdepth – Limits the depth higher than maxdepth in the :tree format.\nsortedby – Controls the order in :flat format. :filefuncline (default) sorts by the source\n line, :count sorts in order of number of collected samples, and :overhead sorts by the number of samples\n incurred by each function by itself.\ngroupby – Controls grouping over tasks and threads, or no grouping. Options are :none (default), :thread, :task,\n [:thread, :task], or [:task, :thread] where the last two provide nested grouping.\nnoisefloor – Limits frames that exceed the heuristic noise floor of the sample (only applies to format :tree).\n A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which n <= noisefloor * √N,\n where n is the number of samples on this line, and N is the number of samples for the callee.\nmincount – Limits the printout to only those lines with at least mincount occurrences.\nrecur – Controls the recursion handling in :tree format. :off (default) prints the tree as normal. :flat instead\n compresses any recursion (by ip), showing the approximate effect of converting any self-recursion into an iterator.\n :flatc does the same but also includes collapsing of C frames (may do odd things around jl_apply).\nthreads::Union{Int,AbstractVector{Int}} – Specify which threads to include snapshots from in the report. Note that\n this does not control which threads samples are collected on (which may also have been collected on another machine).\ntasks::Union{Int,AbstractVector{Int}} – Specify which tasks to include snapshots from in the report. Note that this\n does not control which tasks samples are collected within.\n\ncompat: Julia 1.8\nThe groupby, threads, and tasks keyword arguments were introduced in Julia 1.8.\n\nnote: Note\nProfiling on windows is limited to the main thread. Other threads have not been sampled and will not show in the report.\n\n\n\n\n\nprint([io::IO = stdout,] data::Vector, lidict::LineInfoDict; kwargs...)\n\nPrints profiling results to io. This variant is used to examine results exported by a\nprevious call to retrieve. Supply the vector data of backtraces and\na dictionary lidict of line information.\n\nSee Profile.print([io], data) for an explanation of the valid keyword arguments.\n\n\n\n\n\n"},{"title":"Profile.init","page":"Profiling","location":"stdlib/Profile.html#Profile.init","category":"function","text":"init(; n::Integer, delay::Real)\n\nConfigure the delay between backtraces (measured in seconds), and the number n of instruction pointers that may be\nstored per thread. Each instruction pointer corresponds to a single line of code; backtraces generally consist of a long\nlist of instruction pointers. Note that 6 spaces for instruction pointers per backtrace are used to store metadata and two\nNULL end markers. Current settings can be obtained by calling this function with no arguments, and each can be set independently\nusing keywords or in the order (n, delay).\n\n\n\n\n\n"},{"title":"Profile.fetch","page":"Profiling","location":"stdlib/Profile.html#Profile.fetch","category":"function","text":"fetch(;include_meta = true) -> data\n\nReturn a copy of the buffer of profile backtraces. Note that the\nvalues in data have meaning only on this machine in the current session, because it\ndepends on the exact memory addresses used in JIT-compiling. This function is primarily for\ninternal use; retrieve may be a better choice for most users.\nBy default metadata such as threadid and taskid is included. Set include_meta to false to strip metadata.\n\n\n\n\n\n"},{"title":"Profile.retrieve","page":"Profiling","location":"stdlib/Profile.html#Profile.retrieve","category":"function","text":"retrieve(; kwargs...) -> data, lidict\n\n\"Exports\" profiling results in a portable format, returning the set of all backtraces\n(data) and a dictionary that maps the (session-specific) instruction pointers in data to\nLineInfo values that store the file name, function name, and line number. This function\nallows you to save profiling results for future analysis.\n\n\n\n\n\n"},{"title":"Profile.callers","page":"Profiling","location":"stdlib/Profile.html#Profile.callers","category":"function","text":"callers(funcname, [data, lidict], [filename=<filename>], [linerange=<start:stop>])::Vector{Tuple{count, lineinfo}}\n\nGiven a previous profiling run, determine who called a particular function. Supplying the\nfilename (and optionally, range of line numbers over which the function is defined) allows\nyou to disambiguate an overloaded method. The returned value is a vector containing a count\nof the number of calls and line information about the caller. One can optionally supply\nbacktrace data obtained from retrieve; otherwise, the current internal\nprofile buffer is used.\n\n\n\n\n\n"},{"title":"Profile.clear_malloc_data","page":"Profiling","location":"stdlib/Profile.html#Profile.clear_malloc_data","category":"function","text":"clear_malloc_data()\n\nClears any stored memory allocation data when running julia with --track-allocation.\nExecute the command(s) you want to test (to force JIT-compilation), then call\nclear_malloc_data. Then execute your command(s) again, quit\nJulia, and examine the resulting *.mem files.\n\n\n\n\n\n"},{"title":"Profile.get_peek_duration","page":"Profiling","location":"stdlib/Profile.html#Profile.get_peek_duration","category":"function","text":"get_peek_duration()\n\nGet the duration in seconds of the profile \"peek\" that is triggered via SIGINFO or SIGUSR1, depending on platform.\n\n\n\n\n\n"},{"title":"Profile.set_peek_duration","page":"Profiling","location":"stdlib/Profile.html#Profile.set_peek_duration","category":"function","text":"set_peek_duration(t::Float64)\n\nSet the duration in seconds of the profile \"peek\" that is triggered via SIGINFO or SIGUSR1, depending on platform.\n\n\n\n\n\n"},{"title":"Profile.Allocs.@profile","page":"Profiling","location":"stdlib/Profile.html#Profile.Allocs.@profile","category":"macro","text":"Profile.Allocs.@profile [sample_rate=0.1] expr\n\nProfile allocations that happen during expr, returning\nboth the result and AllocResults struct.\n\nA sample rate of 1.0 will record everything; 0.0 will record nothing.\n\njulia> Profile.Allocs.@profile sample_rate=0.01 peakflops()\n1.03733270279065e11\n\njulia> results = Profile.Allocs.fetch()\n\njulia> last(sort(results.allocs, by=x->x.size))\nProfile.Allocs.Alloc(Vector{Any}, Base.StackTraces.StackFrame[_new_array_ at array.c:127, ...], 5576)\n\nSee the profiling tutorial in the Julia documentation for more information.\n\ncompat: Julia 1.11\nOlder versions of Julia could not capture types in all cases. In older versions of\nJulia, if you see an allocation of type Profile.Allocs.UnknownType, it means that\nthe profiler doesn't know what type of object was allocated. This mainly happened when\nthe allocation was coming from generated code produced by the compiler. See\nissue #43688 for more info.Since Julia 1.11, all allocations should have a type reported.\n\ncompat: Julia 1.8\nThe allocation profiler was added in Julia 1.8.\n\n\n\n\n\n"},{"title":"Profile.Allocs.clear","page":"Profiling","location":"stdlib/Profile.html#Profile.Allocs.clear","category":"function","text":"Profile.Allocs.clear()\n\nClear all previously profiled allocation information from memory.\n\n\n\n\n\n"},{"title":"Profile.Allocs.print","page":"Profiling","location":"stdlib/Profile.html#Profile.Allocs.print","category":"function","text":"Profile.Allocs.print([io::IO = stdout,] [data::AllocResults = fetch()]; kwargs...)\n\nPrints profiling results to io (by default, stdout). If you do not\nsupply a data vector, the internal buffer of accumulated backtraces\nwill be used.\n\nSee Profile.print for an explanation of the valid keyword arguments.\n\n\n\n\n\n"},{"title":"Profile.Allocs.fetch","page":"Profiling","location":"stdlib/Profile.html#Profile.Allocs.fetch","category":"function","text":"Profile.Allocs.fetch()\n\nRetrieve the recorded allocations, and decode them into Julia\nobjects which can be analyzed.\n\n\n\n\n\n"},{"title":"Profile.Allocs.start","page":"Profiling","location":"stdlib/Profile.html#Profile.Allocs.start","category":"function","text":"Profile.Allocs.start(sample_rate::Real)\n\nBegin recording allocations with the given sample rate\nA sample rate of 1.0 will record everything; 0.0 will record nothing.\n\n\n\n\n\n"},{"title":"Profile.Allocs.stop","page":"Profiling","location":"stdlib/Profile.html#Profile.Allocs.stop","category":"function","text":"Profile.Allocs.stop()\n\nStop recording allocations.\n\n\n\n\n\n"},{"title":"Profile.take_heap_snapshot","page":"Profiling","location":"stdlib/Profile.html#Profile.take_heap_snapshot","category":"function","text":"Profile.take_heap_snapshot(filepath::String, all_one::Bool=false;\n                           redact_data::Bool=true, streaming::Bool=false)\nProfile.take_heap_snapshot(all_one::Bool=false; redact_data:Bool=true,\n                           dir::String=nothing, streaming::Bool=false)\n\nWrite a snapshot of the heap, in the JSON format expected by the Chrome\nDevtools Heap Snapshot viewer (.heapsnapshot extension) to a file\n($pid_$timestamp.heapsnapshot) in the current directory by default (or tempdir if\nthe current directory is unwritable), or in dir if given, or the given\nfull file path, or IO stream.\n\nIf all_one is true, then report the size of every object as one so they can be easily\ncounted. Otherwise, report the actual size.\n\nIf redact_data is true (default), then do not emit the contents of any object.\n\nIf streaming is true, we will stream the snapshot data out into four files, using filepath\nas the prefix, to avoid having to hold the entire snapshot in memory. This option should be\nused for any setting where your memory is constrained. These files can then be reassembled\nby calling Profile.HeapSnapshot.assemble_snapshot(), which can\nbe done offline.\n\nNOTE: We strongly recommend setting streaming=true for performance reasons. Reconstructing\nthe snapshot from the parts requires holding the entire snapshot in memory, so if the\nsnapshot is large, you can run out of memory while processing it. Streaming allows you to\nreconstruct the snapshot offline, after your workload is done running.\nIf you do attempt to collect a snapshot with streaming=false (the default, for\nbackwards-compatibility) and your process is killed, note that this will always save the\nparts in the same directory as your provided filepath, so you can still reconstruct the\nsnapshot after the fact, via assemble_snapshot().\n\n\n\n\n\n"},{"title":"Core.Builtins","page":"Core.Builtins","location":"devdocs/builtins.html#lib-builtins","category":"section","text":"The following builtin functions are considered unstable, but provide the basic\ndefinitions for what defines the abilities and behaviors of a Julia\nprogram. They are typically accessed through a higher level generic API."},{"title":"Raw access to memory","page":"Core.Builtins","location":"devdocs/builtins.html#Raw-access-to-memory","category":"section","text":""},{"title":"Managed memory","page":"Core.Builtins","location":"devdocs/builtins.html#Managed-memory","category":"section","text":""},{"title":"Module bindings","page":"Core.Builtins","location":"devdocs/builtins.html#Module-bindings","category":"section","text":""},{"title":"Other","page":"Core.Builtins","location":"devdocs/builtins.html#Other","category":"section","text":""},{"title":"Core.Intrinsics.pointerref","page":"Core.Builtins","location":"devdocs/builtins.html#Core.Intrinsics.pointerref","category":"function","text":"Core.Intrinsics.pointerref(p::Ptr{T}, i::Int, align::Int)\n\nLoad a value of type T from the address of the ith element (1-indexed)\nstarting at p. This is equivalent to the C expression p[i-1].\n\nThe alignment must be a power of two, or 0, indicating the default alignment\nfor T. If p[i-1] is out of bounds, invalid, or is not aligned, the behavior\nis undefined. An alignment of 1 is always safe.\n\nSee also unsafe_load.\n\n\n\n\n\n"},{"title":"Core.Intrinsics.pointerset","page":"Core.Builtins","location":"devdocs/builtins.html#Core.Intrinsics.pointerset","category":"function","text":"Core.Intrinsics.pointerset(p::Ptr{T}, x::T, i::Int, align::Int)\n\nStore a value of type T to the address of the ith element (1-indexed)\nstarting at p.  This is equivalent to the C expression p[i-1] = x.\n\nThe alignment must be a power of two, or 0, indicating the default alignment\nfor T. If p[i-1] is out of bounds, invalid, or is not aligned, the behavior\nis undefined. An alignment of 1 is always safe.\n\nSee also unsafe_store!.\n\n\n\n\n\n"},{"title":"Core.Intrinsics.atomic_pointerref","page":"Core.Builtins","location":"devdocs/builtins.html#Core.Intrinsics.atomic_pointerref","category":"function","text":"Core.Intrinsics.atomic_pointerref(pointer::Ptr{T}, order::Symbol) --> T\n\ncompat: Julia 1.7\nThis function requires Julia 1.7 or later.\n\nSee unsafe_load.\n\n\n\n\n\n"},{"title":"Core.Intrinsics.atomic_pointerset","page":"Core.Builtins","location":"devdocs/builtins.html#Core.Intrinsics.atomic_pointerset","category":"function","text":"Core.Intrinsics.atomic_pointerset(pointer::Ptr{T}, new::T, order::Symbol) --> pointer\n\ncompat: Julia 1.7\nThis function requires Julia 1.7 or later.\n\nSee unsafe_store!.\n\n\n\n\n\n"},{"title":"Core.Intrinsics.atomic_pointerswap","page":"Core.Builtins","location":"devdocs/builtins.html#Core.Intrinsics.atomic_pointerswap","category":"function","text":"Core.Intrinsics.atomic_pointerswap(pointer::Ptr{T}, new::T, order::Symbol) --> old\n\ncompat: Julia 1.7\nThis function requires Julia 1.7 or later.\n\nSee unsafe_swap!.\n\n\n\n\n\n"},{"title":"Core.Intrinsics.atomic_pointermodify","page":"Core.Builtins","location":"devdocs/builtins.html#Core.Intrinsics.atomic_pointermodify","category":"function","text":"Core.Intrinsics.atomic_pointermodify(pointer::Ptr{T}, function::(old::T,arg::S)->T, arg::S, order::Symbol) --> old\n\ncompat: Julia 1.7\nThis function requires Julia 1.7 or later.\n\nSee unsafe_modify!.\n\n\n\n\n\n"},{"title":"Core.Intrinsics.atomic_pointerreplace","page":"Core.Builtins","location":"devdocs/builtins.html#Core.Intrinsics.atomic_pointerreplace","category":"function","text":"Core.Intrinsics.atomic_pointerreplace(pointer::Ptr{T}, expected::Any, new::T, success_order::Symbol, failure_order::Symbol) --> (old, cmp)\n\ncompat: Julia 1.7\nThis function requires Julia 1.7 or later.\n\nSee unsafe_replace!.\n\n\n\n\n\n"},{"title":"Core.memorynew","page":"Core.Builtins","location":"devdocs/builtins.html#Core.memorynew","category":"function","text":"Core.memorynew(::Type{T} where T <: GenericMemory, n::Int)\n\nConstruct an uninitialized GenericMemory of length n.\n\nSee also Memory, Memory{T}(undef, n).\n\n\n\n\n\n"},{"title":"Core.memoryrefnew","page":"Core.Builtins","location":"devdocs/builtins.html#Core.memoryrefnew","category":"function","text":"Core.memoryrefnew(::GenericMemory)\nCore.memoryrefnew(::GenericMemoryRef, index::Int, [boundscheck::Bool])\n\nReturn a GenericMemoryRef for a GenericMemory. See memoryref.\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\n\n\n\n\n"},{"title":"Core.memoryrefoffset","page":"Core.Builtins","location":"devdocs/builtins.html#Core.memoryrefoffset","category":"function","text":"Core..memoryrefoffset(::GenericMemoryRef)\n\nReturn the offset index that was used to construct the MemoryRef. See memoryref.\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\n\n\n\n\n"},{"title":"Core.memoryrefget","page":"Core.Builtins","location":"devdocs/builtins.html#Core.memoryrefget","category":"function","text":"Core.memoryrefget(::GenericMemoryRef, ordering::Symbol, boundscheck::Bool)\n\nReturn the value stored at the MemoryRef, throwing a BoundsError if the Memory is empty. See ref[].\nThe memory ordering specified must be compatible with the isatomic parameter.\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\n\n\n\n\n"},{"title":"Core.memoryrefset!","page":"Core.Builtins","location":"devdocs/builtins.html#Core.memoryrefset!","category":"function","text":"Core.memoryrefset!(::GenericMemoryRef, value, ordering::Symbol, boundscheck::Bool)\n\nStore the value to the MemoryRef, throwing a BoundsError if the Memory is empty. See ref[] = value.\nThe memory ordering specified must be compatible with the isatomic parameter.\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\n\n\n\n\n"},{"title":"Core.memoryref_isassigned","page":"Core.Builtins","location":"devdocs/builtins.html#Core.memoryref_isassigned","category":"function","text":"Core.memoryref_isassigned(::GenericMemoryRef, ordering::Symbol, boundscheck::Bool)\n\nReturn whether there is a value stored at the MemoryRef, returning false if the Memory\nis empty. See isassigned(::Base.RefValue), Core.memoryrefget.\nThe memory ordering specified must be compatible with the isatomic parameter.\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\n\n\n\n\n"},{"title":"Core.memoryrefswap!","page":"Core.Builtins","location":"devdocs/builtins.html#Core.memoryrefswap!","category":"function","text":"Core.memoryrefswap!(::GenericMemoryRef, value, ordering::Symbol, boundscheck::Bool)\n\nAtomically perform the operations to simultaneously get and set a MemoryRef value.\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\nSee also swapproperty! and Core.memoryrefset!.\n\n\n\n\n\n"},{"title":"Core.memoryrefmodify!","page":"Core.Builtins","location":"devdocs/builtins.html#Core.memoryrefmodify!","category":"function","text":"Core.memoryrefmodify!(::GenericMemoryRef, op, value, ordering::Symbol, boundscheck::Bool)::Pair\n\nAtomically perform the operations to get and set a MemoryRef value after applying\nthe function op.\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\nSee also modifyproperty! and Core.memoryrefset!.\n\n\n\n\n\n"},{"title":"Core.memoryrefreplace!","page":"Core.Builtins","location":"devdocs/builtins.html#Core.memoryrefreplace!","category":"function","text":"Core.memoryrefreplace!(::GenericMemoryRef, expected, desired,\n                       success_order::Symbol, fail_order::Symbol=success_order, boundscheck::Bool) -> (; old, success::Bool)\n\nAtomically perform the operations to get and conditionally set a MemoryRef value.\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\nSee also replaceproperty! and Core.memoryrefset!.\n\n\n\n\n\n"},{"title":"Core.memoryrefsetonce!","page":"Core.Builtins","location":"devdocs/builtins.html#Core.memoryrefsetonce!","category":"function","text":"Core.memoryrefsetonce!(::GenericMemoryRef, value,\n                       success_order::Symbol, fail_order::Symbol=success_order, boundscheck::Bool) -> success::Bool\n\nAtomically perform the operations to set a MemoryRef to\na given value, only if it was previously not set.\n\ncompat: Julia 1.11\nThis function requires Julia 1.11 or later.\n\nSee also setpropertyonce! and Core.memoryrefset!.\n\n\n\n\n\n"},{"title":"Core.get_binding_type","page":"Core.Builtins","location":"devdocs/builtins.html#Core.get_binding_type","category":"function","text":"Core.get_binding_type(module::Module, name::Symbol)\n\nRetrieve the declared type of the binding name from the module module.\n\ncompat: Julia 1.9\nThis function requires Julia 1.9 or later.\n\n\n\n\n\n"},{"title":"Core.IntrinsicFunction","page":"Core.Builtins","location":"devdocs/builtins.html#Core.IntrinsicFunction","category":"type","text":"Core.IntrinsicFunction <: Core.Builtin <: Function\n\nThe Core.IntrinsicFunction function define some basic primitives for what defines the\nabilities and behaviors of a Julia program\n\n\n\n\n\n"},{"title":"Core.Intrinsics","page":"Core.Builtins","location":"devdocs/builtins.html#Core.Intrinsics","category":"module","text":"Core.Intrinsics\n\nThe Core.Intrinsics module holds the Core.IntrinsicFunction objects.\n\n\n\n\n\n"},{"title":"Core.IR","page":"Core.Builtins","location":"devdocs/builtins.html#Core.IR","category":"module","text":"Core.IR\n\nThe Core.IR module exports the IR object model.\n\n\n\n\n\n"},{"title":"Base.quoted","page":"Core.Builtins","location":"devdocs/builtins.html#Base.quoted","category":"function","text":"quoted(x)\n\nReturn x made safe for inserting as a constant into IR. Note that this does\nnot make it safe for inserting into an AST, since eval will sometimes copy some\ntypes of AST object inside, and even may sometimes evaluate and interpolate any\n$ inside, depending on the context.\n\n\n\n\n\n"},{"title":"Base.isa_ast_node","page":"Core.Builtins","location":"devdocs/builtins.html#Base.isa_ast_node","category":"function","text":"isa_ast_node(x)\n\nReturn false if x is not interpreted specially by any of inference, lowering,\nor codegen as either an AST or IR special form.\n\n\n\n\n\n"},{"title":"Performance Tips","page":"Performance Tips","location":"manual/performance-tips.html#man-performance-tips","category":"section","text":"In the following sections, we briefly go through a few techniques that can help make your Julia\ncode run as fast as possible."},{"title":"Table of contents","page":"Performance Tips","location":"manual/performance-tips.html#man-performance-tips-toc","category":"section","text":"Pages = [\"performance-tips.md\"]\nDepth = 3"},{"title":"General advice","page":"Performance Tips","location":"manual/performance-tips.html#General-advice","category":"section","text":""},{"title":"Performance critical code should be inside a function","page":"Performance Tips","location":"manual/performance-tips.html#Performance-critical-code-should-be-inside-a-function","category":"section","text":"Any code that is performance critical should be inside a function. Code inside functions tends to run much faster than top level code, due to how Julia's compiler works.\n\nThe use of functions is not only important for performance: functions are more reusable and testable, and clarify what steps are being done and what their inputs and outputs are, Write functions, not just scripts is also a recommendation of Julia's Styleguide.\n\nThe functions should take arguments, instead of operating directly on global variables, see the next point."},{"title":"Avoid untyped global variables","page":"Performance Tips","location":"manual/performance-tips.html#Avoid-untyped-global-variables","category":"section","text":"The value of an untyped global variable might change at any point, possibly leading to a change of its type. This makes\nit difficult for the compiler to optimize code using global variables. This also applies to type-valued variables,\ni.e. type aliases on the global level. Variables should be local, or passed as arguments to functions, whenever possible.\n\nWe find that global names are frequently constants, and declaring them as such greatly improves\nperformance:\n\nconst DEFAULT_VAL = 0\n\nIf a non-constant global is known to always be of the same type, the type should be annotated; const globals need not be annotated because their type is inferred from their initialization value.\n\nUses of untyped globals can be optimized by annotating their types at the point of use:\n\nglobal x = rand(1000)\n\nfunction loop_over_global()\n    s = 0.0\n    for i in x::Vector{Float64}\n        s += i\n    end\n    return s\nend\n\nPassing arguments to functions is better style. It leads to more reusable code and clarifies what the inputs and outputs are.\n\nnote: Note\nAll code in the REPL is evaluated in global scope, so a variable defined and assigned\nat top level will be a global variable. Variables defined at top level scope inside\nmodules are also global.\n\nIn the following REPL session:\n\njulia> x = 1.0\n1.0\n\nis equivalent to:\n\njulia> global x = 1.0\n1.0\n\nso all the performance issues discussed previously apply."},{"title":"Measure performance with @time and pay attention to memory allocation","page":"Performance Tips","location":"manual/performance-tips.html#Measure-performance-with-[@time](@ref)-and-pay-attention-to-memory-allocation","category":"section","text":"A useful tool for measuring performance is the @time macro. We here repeat the example\nwith the global variable above, but this time with the type annotation removed:\n\njulia> x = rand(1000);\n\njulia> function sum_global()\n           s = 0.0\n           for i in x\n               s += i\n           end\n           return s\n       end;\n\njulia> @time sum_global()\n  0.011539 seconds (9.08 k allocations: 373.386 KiB, 98.69% compilation time)\n523.0007221951678\n\njulia> @time sum_global()\n  0.000091 seconds (3.49 k allocations: 70.156 KiB)\n523.0007221951678\n\nOn the first call (@time sum_global()) the function gets compiled. (If you've not yet used @time\nin this session, it will also compile functions needed for timing.)  You should not take the results\nof this run seriously. For the second run, note that in addition to reporting the time, it also\nindicated that a significant amount of memory was allocated. We are here just computing a sum over all elements in\na vector of 64-bit floats so there should be no need to allocate (heap) memory.\n\nWe should clarify that what @time reports is specifically heap allocations, which are typically needed for either\nmutable objects or for creating/growing variable-sized containers (such as Array or Dict, strings, or \"type-unstable\"\nobjects whose type is only known at runtime). Allocating (or deallocating) such blocks of memory may require an expensive function\ncall to libc (e.g. via malloc in C), and they must be tracked for garbage collection. In contrast, immutable values like\nnumbers (except bignums), tuples, and immutable structs can be stored much more cheaply, e.g. in stack or CPU-register\nmemory, so one doesn’t typically worry about the performance cost of \"allocating\" them.\n\nUnexpected memory allocation is almost always a sign of some problem with your code, usually a\nproblem with type-stability or creating many small temporary arrays.\nConsequently, in addition to the allocation itself, it's very likely\nthat the code generated for your function is far from optimal. Take such indications seriously\nand follow the advice below.\n\nFor more information about memory management and garbage collection in Julia, see Memory Management and Garbage Collection.\n\nIn this particular case, the memory allocation is due to the usage of a type-unstable global variable x, so if we instead pass x as an argument to the function it no longer allocates memory\n(the remaining allocation reported below is due to running the @time macro in global scope)\nand is significantly faster after the first call:\n\njulia> x = rand(1000);\n\njulia> function sum_arg(x)\n           s = 0.0\n           for i in x\n               s += i\n           end\n           return s\n       end;\n\njulia> @time sum_arg(x)\n  0.007551 seconds (3.98 k allocations: 200.548 KiB, 99.77% compilation time)\n523.0007221951678\n\njulia> @time sum_arg(x)\n  0.000006 seconds (1 allocation: 16 bytes)\n523.0007221951678\n\nThe 1 allocation seen is from running the @time macro itself in global scope. If we instead run\nthe timing in a function, we can see that indeed no allocations are performed:\n\njulia> time_sum(x) = @time sum_arg(x);\n\njulia> time_sum(x)\n  0.000002 seconds\n523.0007221951678\n\nIn some situations, your function may need to allocate memory as part of its operation, and this\ncan complicate the simple picture above. In such cases, consider using one of the tools\nbelow to diagnose problems, or write a version of your function that separates allocation from\nits algorithmic aspects (see Pre-allocating outputs).\n\nnote: Note\nFor more serious benchmarking, consider the BenchmarkTools.jl\npackage which among other things evaluates the function multiple times in order to reduce noise."},{"title":"Break functions into multiple definitions","page":"Performance Tips","location":"manual/performance-tips.html#Break-functions-into-multiple-definitions","category":"section","text":"Writing a function as many small definitions allows the compiler to directly call the most applicable\ncode, or even inline it.\n\nHere is an example of a \"compound function\" that should really be written as multiple definitions:\n\nusing LinearAlgebra\n\nfunction mynorm(A)\n    if isa(A, Vector)\n        return sqrt(real(dot(A,A)))\n    elseif isa(A, Matrix)\n        return maximum(svdvals(A))\n    else\n        error(\"mynorm: invalid argument\")\n    end\nend\n\nThis can be written more concisely and efficiently as:\n\nmynorm(x::Vector) = sqrt(real(dot(x, x)))\nmynorm(A::Matrix) = maximum(svdvals(A))\n\nIt should however be noted that the compiler is quite efficient at optimizing away the dead branches in code\nwritten as the mynorm example."},{"title":"Tools","page":"Performance Tips","location":"manual/performance-tips.html#tools","category":"section","text":"Julia and its package ecosystem includes tools that may help you diagnose problems and improve\nthe performance of your code:\n\nProfiling allows you to measure the performance of your running code and identify lines\nthat serve as bottlenecks. For complex projects, the ProfileView\npackage can help you visualize your profiling results.\nThe JET package can help you find common performance problems in your code.\nUnexpectedly-large memory allocations–as reported by @time, @allocated, or\nthe profiler (through calls to the garbage-collection routines)–hint that there might be issues\nwith your code. If you don't see another reason for the allocations, suspect a type problem.\n You can also start Julia with the --track-allocation=user option and examine the resulting\n*.mem files to see information about where those allocations occur. See Memory allocation analysis.\n@code_warntype generates a representation of your code that can be helpful in finding expressions\nthat result in type uncertainty. See @code_warntype below."},{"title":"Type inference","page":"Performance Tips","location":"manual/performance-tips.html#Type-inference","category":"section","text":"In many languages with optional type declarations, adding declarations is the principal way to\nmake code run faster. This is not the case in Julia. In Julia, the compiler generally knows\nthe types of all function arguments, local variables, and expressions. However, there are a few\nspecific instances where declarations are helpful."},{"title":"Avoid containers with abstract type parameters","page":"Performance Tips","location":"manual/performance-tips.html#man-performance-abstract-container","category":"section","text":"When working with parameterized types, including arrays, it is best to avoid parameterizing with\nabstract types where possible.\n\nConsider the following:\n\njulia> a = Real[]\nReal[]\n\njulia> push!(a, 1); push!(a, 2.0); push!(a, π)\n3-element Vector{Real}:\n 1\n 2.0\n π = 3.1415926535897...\n\nBecause a is an array of abstract type Real, it must be able to hold any\nReal value. Since Real objects can be of arbitrary size and structure, a must be\nrepresented as an array of pointers to individually allocated Real objects. However, if we instead\nonly allow numbers of the same type, e.g. Float64, to be stored in a these can be stored more\nefficiently:\n\njulia> a = Float64[]\nFloat64[]\n\njulia> push!(a, 1); push!(a, 2.0); push!(a,  π)\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.141592653589793\n\nAssigning numbers into a will now convert them to Float64 and a will be stored as\na contiguous block of 64-bit floating-point values that can be manipulated efficiently.\n\nIf you cannot avoid containers with abstract value types, it is sometimes better to\nparametrize with Any to avoid runtime type checking. E.g. IdDict{Any, Any} performs\nbetter than IdDict{Type, Vector}\n\nSee also the discussion under Parametric Types."},{"title":"Avoid fields with abstract type","page":"Performance Tips","location":"manual/performance-tips.html#Avoid-fields-with-abstract-type","category":"section","text":"Types can be declared without specifying the types of their fields:\n\njulia> struct MyAmbiguousType\n           a\n       end\n\nThis allows a to be of any type. This can often be useful, but it does have a downside: for\nobjects of type MyAmbiguousType, the compiler will not be able to generate high-performance\ncode. The reason is that the compiler uses the types of objects, not their values, to determine\nhow to build code. Unfortunately, very little can be inferred about an object of type MyAmbiguousType:\n\njulia> b = MyAmbiguousType(\"Hello\")\nMyAmbiguousType(\"Hello\")\n\njulia> c = MyAmbiguousType(17)\nMyAmbiguousType(17)\n\njulia> typeof(b)\nMyAmbiguousType\n\njulia> typeof(c)\nMyAmbiguousType\n\nThe values of b and c have the same type, yet their underlying representation of data in memory is very\ndifferent. Even if you stored just numeric values in field a, the fact that the memory representation\nof a UInt8 differs from a Float64 also means that the CPU needs to handle\nthem using two different kinds of instructions. Since the required information is not available\nin the type, such decisions have to be made at run-time. This slows performance.\n\nYou can do better by declaring the type of a. Here, we are focused on the case where a might\nbe any one of several types, in which case the natural solution is to use parameters. For example:\n\njulia> mutable struct MyType{T<:AbstractFloat}\n           a::T\n       end\n\nThis is a better choice than\n\njulia> mutable struct MyStillAmbiguousType\n           a::AbstractFloat\n       end\n\nbecause the first version specifies the type of a from the type of the wrapper object. For\nexample:\n\njulia> m = MyType(3.2)\nMyType{Float64}(3.2)\n\njulia> t = MyStillAmbiguousType(3.2)\nMyStillAmbiguousType(3.2)\n\njulia> typeof(m)\nMyType{Float64}\n\njulia> typeof(t)\nMyStillAmbiguousType\n\nThe type of field a can be readily determined from the type of m, but not from the type of\nt. Indeed, in t it's possible to change the type of the field a:\n\njulia> typeof(t.a)\nFloat64\n\njulia> t.a = 4.5f0\n4.5f0\n\njulia> typeof(t.a)\nFloat32\n\nIn contrast, once m is constructed, the type of m.a cannot change:\n\njulia> m.a = 4.5f0\n4.5f0\n\njulia> typeof(m.a)\nFloat64\n\nThe fact that the type of m.a is known from m's type—coupled with the fact that its type\ncannot change mid-function—allows the compiler to generate highly-optimized code for objects\nlike m but not for objects like t.\n\nOf course, all of this is true only if we construct m with a concrete type. We can break this\nby explicitly constructing it with an abstract type:\n\njulia> m = MyType{AbstractFloat}(3.2)\nMyType{AbstractFloat}(3.2)\n\njulia> typeof(m.a)\nFloat64\n\njulia> m.a = 4.5f0\n4.5f0\n\njulia> typeof(m.a)\nFloat32\n\nFor all practical purposes, such objects behave identically to those of MyStillAmbiguousType.\n\nIt's quite instructive to compare the sheer amount of code generated for a simple function\n\nfunc(m::MyType) = m.a+1\n\nusing\n\ncode_llvm(func, Tuple{MyType{Float64}})\ncode_llvm(func, Tuple{MyType{AbstractFloat}})\n\nFor reasons of length the results are not shown here, but you may wish to try this yourself. Because\nthe type is fully-specified in the first case, the compiler doesn't need to generate any code\nto resolve the type at run-time. This results in shorter and faster code.\n\nOne should also keep in mind that not-fully-parameterized types behave like abstract types. For example, even though a fully specified Array{T,n} is concrete, Array itself with no parameters given is not concrete:\n\njulia> !isconcretetype(Array), !isabstracttype(Array), isstructtype(Array), !isconcretetype(Array{Int}), isconcretetype(Array{Int,1})\n(true, true, true, true, true)\n\nIn this case, it would be better to avoid declaring MyType with a field a::Array and instead declare the field as a::Array{T,N} or as a::A, where {T,N} or A are parameters of MyType.\n\nThe previous advice is especially useful when the fields of a struct are meant to be functions, or more generally callable objects.\nIt is very tempting to define a struct as follows:\n\nstruct MyCallableWrapper\n    f::Function\nend\n\nBut since Function is an abstract type, every call to wrapper.f will require dynamic dispatch, due to the type instability of accessing the field f.\nInstead, you should write something like:\n\nstruct MyCallableWrapper{F}\n    f::F\nend\n\nwhich has nearly identical behavior but will be much faster (because the type instability is eliminated).\nNote that we do not impose F<:Function: this means callable objects which do not subtype Function are also allowed for the field f."},{"title":"Avoid fields with abstract containers","page":"Performance Tips","location":"manual/performance-tips.html#Avoid-fields-with-abstract-containers","category":"section","text":"The same best practices also work for container types:\n\njulia> struct MySimpleContainer{A<:AbstractVector}\n           a::A\n       end\n\njulia> struct MyAmbiguousContainer{T}\n           a::AbstractVector{T}\n       end\n\njulia> struct MyAlsoAmbiguousContainer\n           a::Array\n       end\n\nFor example:\n\njulia> c = MySimpleContainer(1:3);\n\njulia> typeof(c)\nMySimpleContainer{UnitRange{Int64}}\n\njulia> c = MySimpleContainer([1:3;]);\n\njulia> typeof(c)\nMySimpleContainer{Vector{Int64}}\n\njulia> b = MyAmbiguousContainer(1:3);\n\njulia> typeof(b)\nMyAmbiguousContainer{Int64}\n\njulia> b = MyAmbiguousContainer([1:3;]);\n\njulia> typeof(b)\nMyAmbiguousContainer{Int64}\n\njulia> d = MyAlsoAmbiguousContainer(1:3);\n\njulia> typeof(d), typeof(d.a)\n(MyAlsoAmbiguousContainer, Vector{Int64})\n\njulia> d = MyAlsoAmbiguousContainer(1:1.0:3);\n\njulia> typeof(d), typeof(d.a)\n(MyAlsoAmbiguousContainer, Vector{Float64})\n\n\nFor MySimpleContainer, the object is fully-specified by its type and parameters, so the compiler\ncan generate optimized functions. In most instances, this will probably suffice.\n\nWhile the compiler can now do its job perfectly well, there are cases where you might wish that\nyour code could do different things depending on the element type of a. Usually the best\nway to achieve this is to wrap your specific operation (here, foo) in a separate function:\n\njulia> function sumfoo(c::MySimpleContainer)\n           s = 0\n           for x in c.a\n               s += foo(x)\n           end\n           s\n       end\nsumfoo (generic function with 1 method)\n\njulia> foo(x::Integer) = x\nfoo (generic function with 1 method)\n\njulia> foo(x::AbstractFloat) = round(x)\nfoo (generic function with 2 methods)\n\nThis keeps things simple, while allowing the compiler to generate optimized code in all cases.\n\nHowever, there are cases where you may need to declare different versions of the outer function\nfor different element types or types of the AbstractVector of the field a in MySimpleContainer.\nYou could do it like this:\n\njulia> function myfunc(c::MySimpleContainer{<:AbstractArray{<:Integer}})\n           return c.a[1]+1\n       end\nmyfunc (generic function with 1 method)\n\njulia> function myfunc(c::MySimpleContainer{<:AbstractArray{<:AbstractFloat}})\n           return c.a[1]+2\n       end\nmyfunc (generic function with 2 methods)\n\njulia> function myfunc(c::MySimpleContainer{Vector{T}}) where T <: Integer\n           return c.a[1]+3\n       end\nmyfunc (generic function with 3 methods)\n\njulia> myfunc(MySimpleContainer(1:3))\n2\n\njulia> myfunc(MySimpleContainer(1.0:3))\n3.0\n\njulia> myfunc(MySimpleContainer([1:3;]))\n4"},{"title":"Annotate values taken from untyped locations","page":"Performance Tips","location":"manual/performance-tips.html#Annotate-values-taken-from-untyped-locations","category":"section","text":"It is often convenient to work with data structures that may contain values of any type (arrays\nof type Array{Any}). But, if you're using one of these structures and happen to know the type\nof an element, it helps to share this knowledge with the compiler:\n\nfunction foo(a::Vector{Any})\n    x = a[1]::Int32\n    b = x+1\n    ...\nend\n\nHere, we happened to know that the first element of a would be an Int32. Making\nan annotation like this has the added benefit that it will raise a run-time error if the\nvalue is not of the expected type, potentially catching certain bugs earlier.\n\nIn the case that the type of a[1] is not known precisely, x can be declared via\nx = convert(Int32, a[1])::Int32. The use of the convert function allows a[1]\nto be any object convertible to an Int32 (such as UInt8), thus increasing the genericity\nof the code by loosening the type requirement. Notice that convert itself needs a type\nannotation in this context in order to achieve type stability. This is because the compiler\ncannot deduce the type of the return value of a function, even convert, unless the types of\nall the function's arguments are known.\n\nType annotation will not enhance (and can actually hinder) performance if the type is abstract,\nor constructed at run-time. This is because the compiler cannot use the annotation to specialize\nthe subsequent code, and the type-check itself takes time. For example, in the code:\n\nfunction nr(a, prec)\n    ctype = prec == 32 ? Float32 : Float64\n    b = Complex{ctype}(a)\n    c = (b + 1.0f0)::Complex{ctype}\n    abs(c)\nend\n\nthe annotation of c harms performance. To write performant code involving types constructed at\nrun-time, use the function-barrier technique discussed below, and ensure\nthat the constructed type appears among the argument types of the kernel function so that the kernel\noperations are properly specialized by the compiler. For example, in the above snippet, as soon as\nb is constructed, it can be passed to another function k, the kernel. If, for example, function\nk declares b as an argument of type Complex{T}, where T is a type parameter, then a type annotation\nappearing in an assignment statement within k of the form:\n\nc = (b + 1.0f0)::Complex{T}\n\ndoes not hinder performance (but does not help either) since the compiler can determine the type of c\nat the time k is compiled."},{"title":"Be aware of when Julia avoids specializing","page":"Performance Tips","location":"manual/performance-tips.html#Be-aware-of-when-Julia-avoids-specializing","category":"section","text":"As a heuristic, Julia avoids automatically specializing on argument type parameters in three\nspecific cases: Type, Function, and Vararg. Julia will always specialize when the argument is\nused within the method, but not if the argument is just passed through to another function. This\nusually has no performance impact at runtime and\nimproves compiler performance. If you find it does have a\nperformance impact at runtime in your case, you can trigger specialization by adding a type\nparameter to the method declaration. Here are some examples:\n\nThis will not specialize:\n\nfunction f_type(t)  # or t::Type\n    x = ones(t, 10)\n    return sum(map(sin, x))\nend\n\nbut this will:\n\nfunction g_type(t::Type{T}) where T\n    x = ones(T, 10)\n    return sum(map(sin, x))\nend\n\nThese will not specialize:\n\nf_func(f, num) = ntuple(f, div(num, 2))\ng_func(g::Function, num) = ntuple(g, div(num, 2))\n\nbut this will:\n\nh_func(h::H, num) where {H} = ntuple(h, div(num, 2))\n\nThis will not specialize:\n\nf_vararg(x::Int...) = tuple(x...)\n\nbut this will:\n\ng_vararg(x::Vararg{Int, N}) where {N} = tuple(x...)\n\nOne only needs to introduce a single type parameter to force specialization, even if the other types are unconstrained. For example, this will also specialize, and is useful when the arguments are not all of the same type:\n\nh_vararg(x::Vararg{Any, N}) where {N} = tuple(x...)\n\nNote that @code_typed and friends will always show you specialized code, even if Julia\nwould not normally specialize that method call. You need to check the\nmethod internals if you want to see whether specializations are generated\nwhen argument types are changed, i.e., if Base.specializations(@which f(...)) contains specializations\nfor the argument in question."},{"title":"Write \"type-stable\" functions","page":"Performance Tips","location":"manual/performance-tips.html#Write-\"type-stable\"-functions","category":"section","text":"When possible, it helps to ensure that a function always returns a value of the same type. Consider\nthe following definition:\n\npos(x) = x < 0 ? 0 : x\n\nAlthough this seems innocent enough, the problem is that 0 is an integer (of type Int) and\nx might be of any type. Thus, depending on the value of x, this function might return a value\nof either of two types. This behavior is allowed, and may be desirable in some cases. But it can\neasily be fixed as follows:\n\npos(x) = x < 0 ? zero(x) : x\n\nThere is also a oneunit function, and a more general oftype(x, y) function, which\nreturns y converted to the type of x."},{"title":"Avoid changing the type of a variable","page":"Performance Tips","location":"manual/performance-tips.html#Avoid-changing-the-type-of-a-variable","category":"section","text":"An analogous \"type-stability\" problem exists for variables used repeatedly within a function:\n\nfunction foo()\n    x = 1\n    for i = 1:10\n        x /= rand()\n    end\n    return x\nend\n\nLocal variable x starts as an integer, and after one loop iteration becomes a floating-point\nnumber (the result of / operator). This makes it more difficult for the compiler to\noptimize the body of the loop. There are several possible fixes:\n\nInitialize x with x = 1.0\nDeclare the type of x explicitly as x::Float64 = 1\nUse an explicit conversion by x = oneunit(Float64)\nInitialize with the first loop iteration, to x = 1 / rand(), then loop for i = 2:10"},{"title":"Separate kernel functions (aka, function barriers)","page":"Performance Tips","location":"manual/performance-tips.html#kernel-functions","category":"section","text":"Many functions follow a pattern of performing some set-up work, and then running many iterations\nto perform a core computation. Where possible, it is a good idea to put these core computations\nin separate functions. For example, the following contrived function returns an array of a randomly-chosen\ntype:\n\njulia> function strange_twos(n)\n           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)\n           for i = 1:n\n               a[i] = 2\n           end\n           return a\n       end;\n\njulia> strange_twos(3)\n3-element Vector{Int64}:\n 2\n 2\n 2\n\nThis should be written as:\n\njulia> function fill_twos!(a)\n           for i = eachindex(a)\n               a[i] = 2\n           end\n       end;\n\njulia> function strange_twos(n)\n           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)\n           fill_twos!(a)\n           return a\n       end;\n\njulia> strange_twos(3)\n3-element Vector{Int64}:\n 2\n 2\n 2\n\nJulia's compiler specializes code for argument types at function boundaries, so in the original\nimplementation it does not know the type of a during the loop (since it is chosen randomly).\nTherefore the second version is generally faster since the inner loop can be recompiled as part\nof fill_twos! for different types of a.\n\nThe second form is also often better style and can lead to more code reuse.\n\nThis pattern is used in several places in Julia Base. For example, see vcat and hcat\nin abstractarray.jl,\nor the fill! function, which we could have used instead of writing our own fill_twos!.\n\nFunctions like strange_twos occur when dealing with data of uncertain type, for example data\nloaded from an input file that might contain either integers, floats, strings, or something else."},{"title":"@code_warntype","page":"Performance Tips","location":"manual/performance-tips.html#man-code-warntype","category":"section","text":"The macro @code_warntype (or its function variant code_warntype) can sometimes\nbe helpful in diagnosing type-related problems. Here's an example:\n\njulia> @noinline pos(x) = x < 0 ? 0 : x;\n\njulia> function f(x)\n           y = pos(x)\n           return sin(y*x + 1)\n       end;\n\njulia> @code_warntype f(3.2)\nMethodInstance for f(::Float64)\n  from f(x) @ Main REPL[9]:1\nArguments\n  #self#::Core.Const(f)\n  x::Float64\nLocals\n  y::Union{Float64, Int64}\nBody::Float64\n1 ─      (y = Main.pos(x))\n│   %2 = (y * x)::Float64\n│   %3 = (%2 + 1)::Float64\n│   %4 = Main.sin(%3)::Float64\n└──      return %4\n\nInterpreting the output of @code_warntype, like that of its cousins @code_lowered,\n@code_typed, @code_llvm, and @code_native, takes a little practice.\nYour code is being presented in form that has been heavily digested on its way to generating\ncompiled machine code. Most of the expressions are annotated by a type, indicated by the ::T\n(where T might be Float64, for example). The most important characteristic of @code_warntype\nis that non-concrete types are displayed in red; since this document is written in Markdown, which has no color,\nin this document, red text is denoted by uppercase.\n\nAt the top, the inferred return type of the function is shown as Body::Float64.\nThe next lines represent the body of f in Julia's SSA IR form.\nThe numbered boxes are labels and represent targets for jumps (via goto) in your code.\nLooking at the body, you can see that the first thing that happens is that pos is called and the\nreturn value has been inferred as the Union type Union{Float64, Int64} shown in uppercase since\nit is a non-concrete type. This means that we cannot know the exact return type of pos based on the\ninput types. However, the result of y*xis a Float64 no matter if y is a Float64 or Int64\nThe net result is that f(x::Float64) will not be type-unstable\nin its output, even if some of the intermediate computations are type-unstable.\n\nHow you use this information is up to you. Obviously, it would be far and away best to fix pos\nto be type-stable: if you did so, all of the variables in f would be concrete, and its performance\nwould be optimal. However, there are circumstances where this kind of ephemeral type instability\nmight not matter too much: for example, if pos is never used in isolation, the fact that f's\noutput is type-stable (for Float64 inputs) will shield later code from the propagating\neffects of type instability. This is particularly relevant in cases where fixing the type instability\nis difficult or impossible. In such cases, the tips above (e.g., adding type annotations and/or\nbreaking up functions) are your best tools to contain the \"damage\" from type instability.\nAlso, note that even Julia Base has functions that are type unstable.\nFor example, the function findfirst returns the index into an array where a key is found,\nor nothing if it is not found, a clear type instability. In order to make it easier to find the\ntype instabilities that are likely to be important, Unions containing either missing or nothing\nare color highlighted in yellow, instead of red.\n\nThe following examples may help you interpret expressions marked as containing non-concrete types:\n\nFunction body starting with Body::Union{T1,T2})\nInterpretation: function with unstable return type\nSuggestion: make the return value type-stable, even if you have to annotate it\ninvoke Main.g(%%x::Int64)::Union{Float64, Int64}\nInterpretation: call to a type-unstable function g.\nSuggestion: fix the function, or if necessary annotate the return value\ninvoke Base.getindex(%%x::Array{Any,1}, 1::Int64)::Any\nInterpretation: accessing elements of poorly-typed arrays\nSuggestion: use arrays with better-defined types, or if necessary annotate the type of individual\nelement accesses\nBase.getfield(%%x, :(:data))::Array{Float64,N} where N\nInterpretation: getting a field that is of non-concrete type. In this case, the type of x, say ArrayContainer, had a\nfield data::Array{T}. But Array needs the dimension N, too, to be a concrete type.\nSuggestion: use concrete types like Array{T,3} or Array{T,N}, where N is now a parameter\nof ArrayContainer"},{"title":"Performance of captured variable","page":"Performance Tips","location":"manual/performance-tips.html#man-performance-captured","category":"section","text":"Consider the following example that defines an inner function:\n\nfunction abmult(r::Int)\n    if r < 0\n        r = -r\n    end\n    f = x -> x * r\n    return f\nend\n\nFunction abmult returns a function f that multiplies its argument by\nthe absolute value of r. The inner function assigned to f is called a\n\"closure\". Inner functions are also used by the\nlanguage for do-blocks and for generator expressions.\n\nThis style of code presents performance challenges for the language.\nThe parser, when translating it into lower-level instructions,\nsubstantially reorganizes the above code by extracting the\ninner function to a separate code block.  \"Captured\" variables such as r\nthat are shared by inner functions and their enclosing scope are\nalso extracted into a heap-allocated \"box\" accessible to both inner and\nouter functions because the language specifies that r in the\ninner scope must be identical to r in the outer scope even after the\nouter scope (or another inner function) modifies r.\n\nThe discussion in the preceding paragraph referred to the \"parser\", that is, the phase\nof compilation that takes place when the module containing abmult is first loaded,\nas opposed to the later phase when it is first invoked. The parser does not \"know\" that\nInt is a fixed type, or that the statement r = -r transforms an Int to another Int.\nThe magic of type inference takes place in the later phase of compilation.\n\nThus, the parser does not know that r has a fixed type (Int).\nNor that r does not change value once the inner function is created (so that\nthe box is unneeded). Therefore, the parser emits code for\nbox that holds an object with an abstract type such as Any, which\nrequires run-time type dispatch for each occurrence of r. This can be\nverified by applying @code_warntype to the above function. Both the boxing\nand the run-time type dispatch can cause loss of performance.\n\nIf captured variables are used in a performance-critical section of the code,\nthen the following tips help ensure that their use is performant. First, if\nit is known that a captured variable does not change its type, then this can\nbe declared explicitly with a type annotation (on the variable, not the\nright-hand side):\n\nfunction abmult2(r0::Int)\n    r::Int = r0\n    if r < 0\n        r = -r\n    end\n    f = x -> x * r\n    return f\nend\n\nThe type annotation partially recovers lost performance due to capturing because\nthe parser can associate a concrete type to the object in the box.\nGoing further, if the captured variable does not need to be boxed at all (because it\nwill not be reassigned after the closure is created), this can be indicated\nwith let blocks as follows.\n\nfunction abmult3(r::Int)\n    if r < 0\n        r = -r\n    end\n    f = let r = r\n            x -> x * r\n    end\n    return f\nend\n\nThe let block creates a new variable r whose scope is only the\ninner function. The second technique recovers full language performance\nin the presence of captured variables. Note that this is a rapidly\nevolving aspect of the compiler, and it is likely that future releases\nwill not require this degree of programmer annotation to attain performance.\nIn the mean time, some user-contributed packages like\nFastClosures automate the\ninsertion of let statements as in abmult3."},{"title":"Use @__FUNCTION__ for recursive closures","page":"Performance Tips","location":"manual/performance-tips.html#Use-@__FUNCTION__-for-recursive-closures","category":"section","text":"For recursive closures specifically, the @__FUNCTION__ macro can avoid both type instability and boxing.\n\nFirst, let's see the unoptimized version:\n\nfunction make_fib_unoptimized()\n    fib(n) = n <= 1 ? 1 : fib(n - 1) + fib(n - 2)  # fib is boxed\n    return fib\nend\n\nThe fib function is boxed, meaning the return type is inferred as Any:\n\n@code_warntype make_fib_unoptimized()\n\nNow, to eliminate this type instability, we can instead use @__FUNCTION__ to refer to the concrete function object:\n\nfunction make_fib_optimized()\n    fib(n) = n <= 1 ? 1 : (@__FUNCTION__)(n - 1) + (@__FUNCTION__)(n - 2)\n    return fib\nend\n\nThis gives us a concrete return type:\n\n@code_warntype make_fib_optimized()"},{"title":"Types with values-as-parameters","page":"Performance Tips","location":"manual/performance-tips.html#man-performance-value-type","category":"section","text":"Let's say you want to create an N-dimensional array that has size 3 along each axis. Such arrays\ncan be created like this:\n\njulia> A = fill(5.0, (3, 3))\n3×3 Matrix{Float64}:\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n\nThis approach works very well: the compiler can figure out that A is an Array{Float64,2} because\nit knows the type of the fill value (5.0::Float64) and the dimensionality ((3, 3)::NTuple{2,Int}).\nThis implies that the compiler can generate very efficient code for any future usage of A in\nthe same function.\n\nBut now let's say you want to write a function that creates a 3×3×... array in arbitrary dimensions;\nyou might be tempted to write a function\n\njulia> function array3(fillval, N)\n           fill(fillval, ntuple(d->3, N))\n       end\narray3 (generic function with 1 method)\n\njulia> array3(5.0, 2)\n3×3 Matrix{Float64}:\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n\nThis works, but (as you can verify for yourself using @code_warntype array3(5.0, 2)) the problem\nis that the output type cannot be inferred: the argument N is a value of type Int, and type-inference\ndoes not (and cannot) predict its value in advance. This means that code using the output of this\nfunction has to be conservative, checking the type on each access of A; such code will be very\nslow.\n\nNow, one very good way to solve such problems is by using the function-barrier technique.\nHowever, in some cases you might want to eliminate the type-instability altogether. In such cases,\none approach is to pass the dimensionality as a parameter, for example through Val{T}() (see\n\"Value types\"):\n\njulia> function array3(fillval, ::Val{N}) where N\n           fill(fillval, ntuple(d->3, Val(N)))\n       end\narray3 (generic function with 1 method)\n\njulia> array3(5.0, Val(2))\n3×3 Matrix{Float64}:\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n\nJulia has a specialized version of ntuple that accepts a Val{::Int} instance as the second\nparameter; by passing N as a type-parameter, you make its \"value\" known to the compiler.\nConsequently, this version of array3 allows the compiler to predict the return type.\n\nHowever, making use of such techniques can be surprisingly subtle. For example, it would be of\nno help if you called array3 from a function like this:\n\nfunction call_array3(fillval, n)\n    A = array3(fillval, Val(n))\nend\n\nHere, you've created the same problem all over again: the compiler can't guess what n is,\nso it doesn't know the type of Val(n). Attempting to use Val, but doing so incorrectly, can\neasily make performance worse in many situations. (Only in situations where you're effectively\ncombining Val with the function-barrier trick, to make the kernel function more efficient, should\ncode like the above be used.)\n\nAn example of correct usage of Val would be:\n\nfunction filter3(A::AbstractArray{T,N}) where {T,N}\n    kernel = array3(1, Val(N))\n    filter(A, kernel)\nend\n\nIn this example, N is passed as a parameter, so its \"value\" is known to the compiler. Essentially,\nVal(T) works only when T is either hard-coded/literal (Val(3)) or already specified in the\ntype-domain."},{"title":"The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)","page":"Performance Tips","location":"manual/performance-tips.html#The-dangers-of-abusing-multiple-dispatch-(aka,-more-on-types-with-values-as-parameters)","category":"section","text":"Once one learns to appreciate multiple dispatch, there's an understandable tendency to go overboard\nand try to use it for everything. For example, you might imagine using it to store information,\ne.g.\n\nstruct Car{Make, Model}\n    year::Int\n    ...more fields...\nend\n\nand then dispatch on objects like Car{:Honda,:Accord}(year, args...).\n\nThis might be worthwhile when either of the following are true:\n\nYou require CPU-intensive processing on each Car, and it becomes vastly more efficient if you\nknow the Make and Model at compile time and the total number of different Make or Model\nthat will be used is not too large.\nYou have homogeneous lists of the same type of Car to process, so that you can store them all\nin an Array{Car{:Honda,:Accord},N}.\n\nWhen the latter holds, a function processing such a homogeneous array can be productively specialized:\nJulia knows the type of each element in advance (all objects in the container have the same concrete\ntype), so Julia can \"look up\" the correct method calls when the function is being compiled (obviating\nthe need to check at run-time) and thereby emit efficient code for processing the whole list.\n\nWhen these do not hold, then it's likely that you'll get no benefit; worse, the resulting \"combinatorial\nexplosion of types\" will be counterproductive. If items[i+1] has a different type than item[i],\nJulia has to look up the type at run-time, search for the appropriate method in method tables,\ndecide (via type intersection) which one matches, determine whether it has been JIT-compiled yet\n(and do so if not), and then make the call. In essence, you're asking the full type- system and\nJIT-compilation machinery to basically execute the equivalent of a switch statement or dictionary\nlookup in your own code.\n\nSome run-time benchmarks comparing (1) type dispatch, (2) dictionary lookup, and (3) a \"switch\"\nstatement can be found on discourse.\n\nPerhaps even worse than the run-time impact is the compile-time impact: Julia will compile specialized\nfunctions for each different Car{Make, Model}; if you have hundreds or thousands of such types,\nthen every function that accepts such an object as a parameter (from a custom get_year function\nyou might write yourself, to the generic push! function in Julia Base) will have hundreds\nor thousands of variants compiled for it. Each of these increases the size of the cache of compiled\ncode, the length of internal lists of methods, etc. Excess enthusiasm for values-as-parameters\ncan easily waste enormous resources."},{"title":"Memory management and arrays","page":"Performance Tips","location":"manual/performance-tips.html#Memory-management-and-arrays","category":"section","text":""},{"title":"Pre-allocate outputs","page":"Performance Tips","location":"manual/performance-tips.html#Pre-allocate-outputs","category":"section","text":"If your function returns an Array or some other complex type, it may have to allocate memory.\nUnfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.\n\nSometimes you can circumvent the need to allocate memory on each function call by preallocating\nthe output. As a trivial example, compare\n\njulia> function xinc(x)\n           return [x + i for i  in 1:3000]\n       end;\n\njulia> function loopinc()\n           y = 0\n           for i = 1:10^5\n               ret = xinc(i)\n               y += ret[2]\n           end\n           return y\n       end;\n\nwith\n\njulia> function xinc!(ret::AbstractVector{T}, x::T) where T\n           for i in 1:3000\n               ret[i] = x+i\n           end\n           nothing\n       end;\n\njulia> function loopinc_prealloc()\n           ret = Vector{Int}(undef, 3000)\n           y = 0\n           for i = 1:10^5\n               xinc!(ret, i)\n               y += ret[2]\n           end\n           return y\n       end;\n\nTiming results:\n\njulia> @time loopinc()\n  0.297454 seconds (200.00 k allocations: 2.239 GiB, 39.80% gc time)\n5000250000\n\njulia> @time loopinc_prealloc()\n  0.009410 seconds (2 allocations: 23.477 KiB)\n5000250000\n\nPreallocation has other advantages, for example by allowing the caller to control the \"output\"\ntype from an algorithm. In the example above, we could have passed a SubArray rather than an\nArray, had we so desired.\n\nTaken to its extreme, pre-allocation can make your code uglier, so performance measurements and\nsome judgment may be required. However, for \"vectorized\" (element-wise) functions, the convenient\nsyntax x .= f.(y) can be used for in-place operations with fused loops and no temporary arrays\n(see the dot syntax for vectorizing functions)."},{"title":"Consider using views for slices","page":"Performance Tips","location":"manual/performance-tips.html#man-performance-views","category":"section","text":"In Julia, an array \"slice\" expression like array[1:5, :] creates\na copy of that data (except on the left-hand side of an assignment,\nwhere array[1:5, :] = ... assigns in-place to that portion of array).\nIf you are doing many operations on the slice, this can be good for\nperformance because it is more efficient to work with a smaller\ncontiguous copy than it would be to index into the original array.\nOn the other hand, if you are just doing a few simple operations on\nthe slice, the cost of the allocation and copy operations can be\nsubstantial.\n\nAn alternative is to create a \"view\" of the array, which is\nan array object (a SubArray) that actually references the data\nof the original array in-place, without making a copy. (If you\nwrite to a view, it modifies the original array's data as well.)\nThis can be done for individual slices by calling view,\nor more simply for a whole expression or block of code by putting\n@views in front of that expression. For example:\n\njulia> fcopy(x) = sum(x[2:end-1]);\n\njulia> @views fview(x) = sum(x[2:end-1]);\n\njulia> x = rand(10^6);\n\njulia> @time fcopy(x);\n  0.003051 seconds (3 allocations: 7.629 MB)\n\njulia> @time fview(x);\n  0.001020 seconds (1 allocation: 16 bytes)\n\nNotice both the 3× speedup and the decreased memory allocation\nof the fview version of the function."},{"title":"Consider StaticArrays.jl for small fixed-size vector/matrix operations","page":"Performance Tips","location":"manual/performance-tips.html#Consider-StaticArrays.jl-for-small-fixed-size-vector/matrix-operations","category":"section","text":"If your application involves many small (< 100 element) arrays of fixed sizes (i.e. the size is\nknown prior to execution), then you might want to consider using the StaticArrays.jl package.\nThis package allows you to represent such arrays in a way that avoids unnecessary heap allocations and allows the compiler to\nspecialize code for the size of the array, e.g. by completely unrolling vector operations (eliminating the loops) and storing elements in CPU registers.\n\nFor example, if you are doing computations with 2d geometries, you might have many computations with 2-component vectors. By\nusing the SVector type from StaticArrays.jl, you can use convenient vector notation and operations like norm(3v - w) on\nvectors v and w, while allowing the compiler to unroll the code to a minimal computation equivalent to @inbounds hypot(3v[1]-w[1], 3v[2]-w[2])."},{"title":"More dots: Fuse vectorized operations","page":"Performance Tips","location":"manual/performance-tips.html#More-dots:-Fuse-vectorized-operations","category":"section","text":"Julia has a special dot syntax that converts\nany scalar function into a \"vectorized\" function call, and any operator\ninto a \"vectorized\" operator, with the special property that nested\n\"dot calls\" are fusing: they are combined at the syntax level into\na single loop, without allocating temporary arrays. If you use .= and\nsimilar assignment operators, the result can also be stored in-place\nin a pre-allocated array (see above).\n\nIn a linear-algebra context, this means that even though operations like\nvector + vector and vector * scalar are defined, it can be advantageous\nto instead use vector .+ vector and vector .* scalar because the\nresulting loops can be fused with surrounding computations. For example,\nconsider the two functions:\n\njulia> f(x) = 3x.^2 + 4x + 7x.^3;\n\njulia> fdot(x) = @. 3x^2 + 4x + 7x^3; # equivalent to 3 .* x.^2 .+ 4 .* x .+ 7 .* x.^3\n\nBoth f and fdot compute the same thing. However, fdot\n(defined with the help of the @. macro) is\nsignificantly faster when applied to an array:\n\njulia> x = rand(10^6);\n\njulia> @time f(x);\n  0.019049 seconds (16 allocations: 45.777 MiB, 18.59% gc time)\n\njulia> @time fdot(x);\n  0.002790 seconds (6 allocations: 7.630 MiB)\n\njulia> @time f.(x);\n  0.002626 seconds (8 allocations: 7.630 MiB)\n\nThat is, fdot(x) is ten times faster and allocates 1/6 the\nmemory of f(x), because each * and + operation in f(x) allocates\na new temporary array and executes in a separate loop. In this example\nf.(x) is as fast as fdot(x) but in many contexts it is more\nconvenient to sprinkle some dots in your expressions than to\ndefine a separate function for each vectorized operation."},{"title":"Fewer dots: Unfuse certain intermediate broadcasts","page":"Performance Tips","location":"manual/performance-tips.html#man-performance-unfuse","category":"section","text":"The dot loop fusion mentioned above enables concise and idiomatic code to express highly performant operations. However, it is important to remember that the fused operation will be computed at every iteration of the broadcast. This means that in some situations, particularly in the presence of composed or multidimensional broadcasts, an expression with dot calls may be computing a function more times than intended. As an example, say we want to build a random matrix whose rows have Euclidean norm one. We might write something like the following:\n\njulia> x = rand(1000, 1000);\n\njulia> d = sum(abs2, x; dims=2);\n\njulia> @time x ./= sqrt.(d);\n  0.002049 seconds (4 allocations: 96 bytes)\n\nThis will work. However, this expression will actually recompute sqrt(d[i]) for every element in the row x[i, :], meaning that many more square roots are computed than necessary. To see precisely over which indices the broadcast will iterate, we can call Broadcast.combine_axes on the arguments of the fused expression. This will return a tuple of ranges whose entries correspond to the axes of iteration; the product of lengths of these ranges will be the total number of calls to the fused operation.\n\nIt follows that when some components of the broadcast expression are constant along an axis—like the sqrt along the second dimension in the preceding example—there is potential for a performance improvement by forcibly \"unfusing\" those components, i.e. allocating the result of the broadcasted operation in advance and reusing the cached value along its constant axis. Some such potential approaches are to use temporary variables, wrap components of a dot expression in identity, or use an equivalent intrinsically vectorized (but non-fused) function.\n\njulia> @time let s = sqrt.(d); x ./= s end;\n  0.000809 seconds (5 allocations: 8.031 KiB)\n\njulia> @time x ./= identity(sqrt.(d));\n  0.000608 seconds (5 allocations: 8.031 KiB)\n\njulia> @time x ./= map(sqrt, d);\n  0.000611 seconds (4 allocations: 8.016 KiB)\n\nAny of these options yields approximately a three-fold speedup at the cost of an allocation; for large broadcastables this speedup can be asymptotically very large."},{"title":"Access arrays in memory order, along columns","page":"Performance Tips","location":"manual/performance-tips.html#man-performance-column-major","category":"section","text":"Multidimensional arrays in Julia are stored in column-major order. This means that arrays are\nstacked one column at a time. This can be verified using the vec function or the syntax [:]\nas shown below (notice that the array is ordered [1 3 2 4], not [1 2 3 4]):\n\njulia> x = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> x[:]\n4-element Vector{Int64}:\n 1\n 3\n 2\n 4\n\nThis convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to\nname a few). The alternative to column-major ordering is row-major ordering, which is the convention\nadopted by C and Python (numpy) among other languages. Remembering the ordering of arrays can\nhave significant performance effects when looping over arrays. A rule of thumb to keep in mind\nis that with column-major arrays, the first index changes most rapidly. Essentially this means\nthat looping will be faster if the inner-most loop index is the first to appear in a slice expression.\nKeep in mind that indexing an array with : is an implicit loop that iteratively accesses all elements within a particular dimension; it can be faster to extract columns than rows, for example.\n\nConsider the following contrived example. Imagine we wanted to write a function that accepts a\nVector and returns a square Matrix with either the rows or the columns filled with copies\nof the input vector. Assume that it is not important whether rows or columns are filled with these\ncopies (perhaps the rest of the code can be easily adapted accordingly). We could conceivably\ndo this in at least four ways (in addition to the recommended call to the built-in repeat):\n\nfunction copy_cols(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for i = inds\n        out[:, i] = x\n    end\n    return out\nend\n\nfunction copy_rows(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for i = inds\n        out[i, :] = x\n    end\n    return out\nend\n\nfunction copy_col_row(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for col = inds, row = inds\n        out[row, col] = x[row]\n    end\n    return out\nend\n\nfunction copy_row_col(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for row = inds, col = inds\n        out[row, col] = x[col]\n    end\n    return out\nend\n\nNow we will time each of these functions using the same random 10000 by 1 input vector:\n\njulia> x = randn(10000);\n\njulia> fmt(f) = println(rpad(string(f)*\": \", 14, ' '), @elapsed f(x))\n\njulia> map(fmt, [copy_cols, copy_rows, copy_col_row, copy_row_col]);\ncopy_cols:    0.331706323\ncopy_rows:    1.799009911\ncopy_col_row: 0.415630047\ncopy_row_col: 1.721531501\n\nNotice that copy_cols is much faster than copy_rows. This is expected because copy_cols\nrespects the column-based memory layout of the Matrix and fills it one column at a time. Additionally,\ncopy_col_row is much faster than copy_row_col because it follows our rule of thumb that the\nfirst element to appear in a slice expression should be coupled with the inner-most loop."},{"title":"Copying data is not always bad","page":"Performance Tips","location":"manual/performance-tips.html#Copying-data-is-not-always-bad","category":"section","text":"Arrays are stored contiguously in memory, lending themselves to CPU vectorization\nand fewer memory accesses due to caching. These are the same reasons that it is recommended\nto access arrays in column-major order (see above). Irregular access patterns and non-contiguous\nviews can drastically slow down computations on arrays because of non-sequential memory access.\n\nCopying irregularly-accessed data into a contiguous array before repeatedly accessing it can result\nin a large speedup, such as in the example below. Here, a matrix is being accessed at\nrandomly-shuffled indices before being multiplied. Copying into plain arrays speeds up the\nmultiplication even with the added cost of copying and allocation.\n\njulia> using Random\n\njulia> A = randn(3000, 3000);\n\njulia> x = randn(2000);\n\njulia> inds = shuffle(1:3000)[1:2000];\n\njulia> function iterated_neural_network(A, x, depth)\n           for _ in 1:depth\n               x .= max.(0, A * x)\n           end\n           argmax(x)\n       end\n\njulia> @time iterated_neural_network(view(A, inds, inds), x, 10)\n  0.324903 seconds (12 allocations: 157.562 KiB)\n1569\n\njulia> @time iterated_neural_network(A[inds, inds], x, 10)\n  0.054576 seconds (13 allocations: 30.671 MiB, 13.33% gc time)\n1569\n\nProvided there is enough memory, the cost of copying the view to an array is outweighed\nby the speed boost from doing the repeated matrix multiplications on a contiguous array."},{"title":"Multithreading and linear algebra","page":"Performance Tips","location":"manual/performance-tips.html#man-multithreading-linear-algebra","category":"section","text":"This section applies to multithreaded Julia code which, in each thread, performs linear algebra operations.\nIndeed, these linear algebra operations involve BLAS / LAPACK calls, which are themselves multithreaded.\nIn this case, one must ensure that cores aren't oversubscribed due to the two different types of multithreading.\n\nJulia compiles and uses its own copy of OpenBLAS for linear algebra, whose number of threads is controlled by the environment variable OPENBLAS_NUM_THREADS.\nIt can either be set as a command line option when launching Julia, or modified during the Julia session with BLAS.set_num_threads(N) (the submodule BLAS is exported by using LinearAlgebra).\nIts current value can be accessed with BLAS.get_num_threads().\n\nWhen the user does not specify anything, Julia tries to choose a reasonable value for the number of OpenBLAS threads (e.g. based on the platform, the Julia version, etc.).\nHowever, it is generally recommended to check and set the value manually.\nThe OpenBLAS behavior is as follows:\n\nIf OPENBLAS_NUM_THREADS=1, OpenBLAS uses the calling Julia thread(s), i.e. it \"lives in\" the Julia thread that runs the computation.\nIf OPENBLAS_NUM_THREADS=N>1, OpenBLAS creates and manages its own pool of threads (N in total). There is just one OpenBLAS thread pool shared among all Julia threads.\n\nWhen you start Julia in multithreaded mode with JULIA_NUM_THREADS=X, it is generally recommended to set OPENBLAS_NUM_THREADS=1.\nGiven the behavior described above, increasing the number of BLAS threads to N>1 can very easily lead to worse performance, in particular when N<<X.\nHowever this is just a rule of thumb, and the best way to set each number of threads is to experiment on your specific application."},{"title":"Alternative linear algebra backends","page":"Performance Tips","location":"manual/performance-tips.html#man-backends-linear-algebra","category":"section","text":"As an alternative to OpenBLAS, there exist several other backends that can help with linear algebra performance.\nProminent examples include MKL.jl and AppleAccelerate.jl.\n\nThese are external packages, so we will not discuss them in detail here.\nPlease refer to their respective documentations (especially because they have different behaviors than OpenBLAS with respect to multithreading)."},{"title":"Execution latency, package loading and package precompiling time","page":"Performance Tips","location":"manual/performance-tips.html#Execution-latency,-package-loading-and-package-precompiling-time","category":"section","text":""},{"title":"Reducing time to first plot etc.","page":"Performance Tips","location":"manual/performance-tips.html#Reducing-time-to-first-plot-etc.","category":"section","text":"The first time a julia method is called it (and any methods it calls, or ones that can be statically determined) will be\ncompiled. The @time macro family illustrates this.\n\njulia> foo() = rand(2,2) * rand(2,2)\nfoo (generic function with 1 method)\n\njulia> @time @eval foo();\n  0.252395 seconds (1.12 M allocations: 56.178 MiB, 2.93% gc time, 98.12% compilation time)\n\njulia> @time @eval foo();\n  0.000156 seconds (63 allocations: 2.453 KiB)\n\nNote that @time @eval is better for measuring compilation time because without @eval, some compilation may\nalready be done before timing starts.\n\nWhen developing a package, you may be able to improve the experience of your users with precompilation\nso that when they use the package, the code they use is already compiled. To precompile package code effectively, it's\nrecommended to use PrecompileTools.jl to run a\n\"precompile workload\" during precompilation time that is representative of typical package usage, which will cache the\nnative compiled code into the package pkgimage cache, greatly reducing \"time to first execution\" (often referred to as\nTTFX) for such usage.\n\nNote that PrecompileTools.jl workloads can be\ndisabled and sometimes configured via Preferences if you do not want to spend the extra time precompiling, which\nmay be the case during development of a package."},{"title":"Reducing package loading time","page":"Performance Tips","location":"manual/performance-tips.html#Reducing-package-loading-time","category":"section","text":"Keeping the time taken to load the package down is usually helpful.\nGeneral good practice for package developers includes:\n\nReduce your dependencies to those you really need. Consider using package extensions to support interoperability with other packages without bloating your essential dependencies.\nAvoid use of __init__() functions unless there is no alternative, especially those which might trigger a lot\nof compilation, or just take a long time to execute.\nWhere possible, fix invalidations among your dependencies and from your package code.\n\nThe tool @time_imports can be useful in the REPL to review the above factors.\n\njulia> @time @time_imports using Plots\n      0.5 ms  Printf\n     16.4 ms  Dates\n      0.7 ms  Statistics\n               ┌ 23.8 ms SuiteSparse_jll.__init__() 86.11% compilation time (100% recompilation)\n     90.1 ms  SuiteSparse_jll 91.57% compilation time (82% recompilation)\n      0.9 ms  Serialization\n               ┌ 39.8 ms SparseArrays.CHOLMOD.__init__() 99.47% compilation time (100% recompilation)\n    166.9 ms  SparseArrays 23.74% compilation time (100% recompilation)\n      0.4 ms  Statistics → SparseArraysExt\n      0.5 ms  TOML\n      8.0 ms  Preferences\n      0.3 ms  PrecompileTools\n      0.2 ms  Reexport\n... many deps omitted for example ...\n      1.4 ms  Tar\n               ┌ 73.8 ms p7zip_jll.__init__() 99.93% compilation time (100% recompilation)\n     79.4 ms  p7zip_jll 92.91% compilation time (100% recompilation)\n               ┌ 27.7 ms GR.GRPreferences.__init__() 99.77% compilation time (100% recompilation)\n     43.0 ms  GR 64.26% compilation time (100% recompilation)\n               ┌ 2.1 ms Plots.__init__() 91.80% compilation time (100% recompilation)\n    300.9 ms  Plots 0.65% compilation time (100% recompilation)\n  1.795602 seconds (3.33 M allocations: 190.153 MiB, 7.91% gc time, 39.45% compilation time: 97% of which was recompilation)\n\n\nNotice that in this example there are multiple packages loaded, some with __init__() functions, some of which cause\ncompilation of which some is recompilation. Recompilation is caused by earlier packages invalidating methods, then in\nthese cases when the following packages run their __init__() function some hit recompilation before the code can be run.\n\nFurther, note the Statistics extension SparseArraysExt has been activated because SparseArrays is in the dependency\ntree. i.e. see 0.4 ms  Statistics → SparseArraysExt.\n\nThis report gives a good opportunity to review whether the cost of dependency load time is worth the functionality it brings.\nAlso the Pkg utility why can be used to report why an indirect dependency exists.\n\n(CustomPackage) pkg> why FFMPEG_jll\n  Plots → FFMPEG → FFMPEG_jll\n  Plots → GR → GR_jll → FFMPEG_jll\n\nor to see the indirect dependencies that a package brings in, you can pkg> rm the package, see the deps that are removed\nfrom the manifest, then revert the change with pkg> undo.\n\nIf loading time is dominated by slow __init__() methods having compilation, one verbose way to identify what is being\ncompiled is to use the julia args --trace-compile=stderr --trace-compile-timing which will report a precompile\nstatement each time a method is compiled, along with how long compilation took. The InteractiveUtils macro\n@trace_compile provides a way to enable those args for a specific call. So a call for a complete report report would look like:\n\njulia> @time @time_imports @trace_compile using CustomPackage\n...\n\nNote the --startup-file=no which helps isolate the test from packages you may have in your startup.jl.\n\nMore analysis of the reasons for recompilation can be achieved with the\nSnoopCompile package."},{"title":"Tracing expression evaluation","page":"Performance Tips","location":"manual/performance-tips.html#Tracing-expression-evaluation","category":"section","text":"If you need to understand what code is being evaluated during test or script execution,\nyou can use the --trace-eval command-line option or the Base.TRACE_EVAL global control to trace the outermost expressions being evaluated (top-level statements). Note this does not individually report the contents of function calls or code blocks:\n\n# Show only location information during evaluation\njulia --trace-eval=loc script.jl\n\n# Show full expressions being evaluated\njulia --trace-eval=full script.jl\n\nYou can also control this programmatically:\n\n# Enable full expression tracing\nBase.TRACE_EVAL = :full\n\n# Show only locations\nBase.TRACE_EVAL = :loc\n\n# Disable tracing\nBase.TRACE_EVAL = :no\n\n# Reset to use command-line setting\nBase.TRACE_EVAL = nothing"},{"title":"Reducing precompilation time","page":"Performance Tips","location":"manual/performance-tips.html#Reducing-precompilation-time","category":"section","text":"If package precompilation is taking a long time, one option is to set the following internal and then precompile.\n\njulia> Base.PRECOMPILE_TRACE_COMPILE[] = \"stderr\"\n\npkg> precompile\n\nThis has the effect of setting --trace-compile=stderr --trace-compile-timing in the precompilation processes themselves,\nso will show which methods are precompiled and how long they took to precompile.\n\nThere are also profiling options such as using the external profiler Tracy to profile the precompilation process."},{"title":"Miscellaneous","page":"Performance Tips","location":"manual/performance-tips.html#Miscellaneous","category":"section","text":""},{"title":"Tweaks","page":"Performance Tips","location":"manual/performance-tips.html#Tweaks","category":"section","text":"These are some minor points that might help in tight inner loops.\n\nAvoid unnecessary arrays. For example, instead of sum([x,y,z]) use x+y+z.\nUse abs2(z) instead of abs(z)^2 for complex z. In general, try to rewrite\ncode to use abs2 instead of abs for complex arguments.\nUse div(x,y) for truncating division of integers instead of trunc(x/y), fld(x,y)\ninstead of floor(x/y), and cld(x,y) instead of ceil(x/y)."},{"title":"Fix deprecation warnings","page":"Performance Tips","location":"manual/performance-tips.html#Fix-deprecation-warnings","category":"section","text":"A deprecated function internally performs a lookup in order to print a relevant warning only once.\nThis extra lookup can cause a significant slowdown, so all uses of deprecated functions should\nbe modified as suggested by the warnings."},{"title":"Performance Annotations","page":"Performance Tips","location":"manual/performance-tips.html#man-performance-annotations","category":"section","text":"Sometimes you can enable better optimization by promising certain program properties.\n\nUse @inbounds to eliminate array bounds checking within expressions. Be certain before doing\nthis. If the indices are ever out of bounds, you may suffer crashes or silent corruption.\nUse @fastmath to allow floating point optimizations that are correct for real numbers, but lead\nto differences for IEEE numbers. Be careful when doing this, as this may change numerical results.\nThis corresponds to the -ffast-math option of clang.\nWrite @simd in front of for loops to promise that the iterations are independent and may be\nreordered. Note that in many cases, Julia can automatically vectorize code without the @simd macro;\nit is only beneficial in cases where such a transformation would otherwise be illegal, including cases\nlike allowing floating-point re-associativity and ignoring dependent memory accesses (@simd ivdep).\nAgain, be very careful when asserting @simd as erroneously annotating a loop with dependent iterations\nmay result in unexpected results. In particular, note that setindex! on some AbstractArray subtypes is\ninherently dependent upon iteration order. This feature is experimental\nand could change or disappear in future versions of Julia.\n\nThe common idiom of using 1:n to index into an AbstractArray is not safe if the Array uses unconventional indexing,\nand may cause a segmentation fault if bounds checking is turned off. Use LinearIndices(x) or eachindex(x)\ninstead (see also Arrays with custom indices).\n\nnote: Note\nWhile @simd needs to be placed directly in front of an innermost for loop, both @inbounds and @fastmath\ncan be applied to either single expressions or all the expressions that appear within nested blocks of code, e.g.,\nusing @inbounds begin or @inbounds for ....\n\nHere is an example with both @inbounds and @simd markup (we here use @noinline to prevent\nthe optimizer from trying to be too clever and defeat our benchmark):\n\n@noinline function inner(x, y)\n    s = zero(eltype(x))\n    for i in eachindex(x, y)\n        @inbounds s += x[i]*y[i]\n    end\n    return s\nend\n\n@noinline function innersimd(x, y)\n    s = zero(eltype(x))\n    @simd for i in eachindex(x, y)\n        @inbounds s += x[i] * y[i]\n    end\n    return s\nend\n\nfunction timeit(n, reps)\n    x = rand(Float32, n)\n    y = rand(Float32, n)\n    s = zero(Float64)\n    time = @elapsed for j in 1:reps\n        s += inner(x, y)\n    end\n    println(\"GFlop/sec        = \", 2n*reps / time*1E-9)\n    time = @elapsed for j in 1:reps\n        s += innersimd(x, y)\n    end\n    println(\"GFlop/sec (SIMD) = \", 2n*reps / time*1E-9)\nend\n\ntimeit(1000, 1000)\n\nOn a computer with a 2.4GHz Intel Core i5 processor, this produces:\n\nGFlop/sec        = 1.9467069505224963\nGFlop/sec (SIMD) = 17.578554163920018\n\n(GFlop/sec measures the performance, and larger numbers are better.)\n\nHere is an example with all three kinds of markup. This program first calculates the finite difference\nof a one-dimensional array, and then evaluates the L2-norm of the result:\n\nfunction init!(u::Vector)\n    n = length(u)\n    dx = 1.0 / (n-1)\n    @fastmath @inbounds @simd for i in 1:n #by asserting that `u` is a `Vector` we can assume it has 1-based indexing\n        u[i] = sin(2pi*dx*i)\n    end\nend\n\nfunction deriv!(u::Vector, du)\n    n = length(u)\n    dx = 1.0 / (n-1)\n    @fastmath @inbounds du[1] = (u[2] - u[1]) / dx\n    @fastmath @inbounds @simd for i in 2:n-1\n        du[i] = (u[i+1] - u[i-1]) / (2*dx)\n    end\n    @fastmath @inbounds du[n] = (u[n] - u[n-1]) / dx\nend\n\nfunction mynorm(u::Vector)\n    n = length(u)\n    T = eltype(u)\n    s = zero(T)\n    @fastmath @inbounds @simd for i in 1:n\n        s += u[i]^2\n    end\n    @fastmath @inbounds return sqrt(s)\nend\n\nfunction main()\n    n = 2000\n    u = Vector{Float64}(undef, n)\n    init!(u)\n    du = similar(u)\n\n    deriv!(u, du)\n    nu = mynorm(du)\n\n    @time for i in 1:10^6\n        deriv!(u, du)\n        nu = mynorm(du)\n    end\n\n    println(nu)\nend\n\nmain()\n\nOn a computer with a 2.7 GHz Intel Core i7 processor, this produces:\n\n$ julia wave.jl;\n  1.207814709 seconds\n4.443986180758249\n\n$ julia --math-mode=ieee wave.jl;\n  4.487083643 seconds\n4.443986180758249\n\nHere, the option --math-mode=ieee disables the @fastmath macro, so that we can compare results.\n\nIn this case, the speedup due to @fastmath is a factor of about 3.7. This is unusually large\n– in general, the speedup will be smaller. (In this particular example, the working set of the\nbenchmark is small enough to fit into the L1 cache of the processor, so that memory access latency\ndoes not play a role, and computing time is dominated by CPU usage. In many real world programs\nthis is not the case.) Also, in this case this optimization does not change the result – in\ngeneral, the result will be slightly different. In some cases, especially for numerically unstable\nalgorithms, the result can be very different.\n\nThe annotation @fastmath re-arranges floating point expressions, e.g. changing the order of\nevaluation, or assuming that certain special cases (inf, nan) cannot occur. In this case (and\non this particular computer), the main difference is that the expression 1 / (2*dx) in the function\nderiv is hoisted out of the loop (i.e. calculated outside the loop), as if one had written\nidx = 1 / (2*dx). In the loop, the expression ... / (2*dx) then becomes ... * idx, which\nis much faster to evaluate. Of course, both the actual optimization that is applied by the compiler\nas well as the resulting speedup depend very much on the hardware. You can examine the change\nin generated code by using Julia's code_native function.\n\nNote that @fastmath also assumes that NaNs will not occur during the computation, which can lead to surprising behavior:\n\njulia> f(x) = isnan(x);\n\njulia> f(NaN)\ntrue\n\njulia> f_fast(x) = @fastmath isnan(x);\n\njulia> f_fast(NaN)\nfalse"},{"title":"Treat Subnormal Numbers as Zeros","page":"Performance Tips","location":"manual/performance-tips.html#Treat-Subnormal-Numbers-as-Zeros","category":"section","text":"Subnormal numbers, formerly called denormal numbers,\nare useful in many contexts, but incur a performance penalty on some hardware. A call set_zero_subnormals(true)\ngrants permission for floating-point operations to treat subnormal inputs or outputs as zeros,\nwhich may improve performance on some hardware. A call set_zero_subnormals(false) enforces\nstrict IEEE behavior for subnormal numbers.\n\nBelow is an example where subnormals noticeably impact performance on some hardware:\n\nfunction timestep(b::Vector{T}, a::Vector{T}, Δt::T) where T\n    @assert length(a)==length(b)\n    n = length(b)\n    b[1] = 1                            # Boundary condition\n    for i=2:n-1\n        b[i] = a[i] + (a[i-1] - T(2)*a[i] + a[i+1]) * Δt\n    end\n    b[n] = 0                            # Boundary condition\nend\n\nfunction heatflow(a::Vector{T}, nstep::Integer) where T\n    b = similar(a)\n    for t=1:div(nstep,2)                # Assume nstep is even\n        timestep(b,a,T(0.1))\n        timestep(a,b,T(0.1))\n    end\nend\n\nheatflow(zeros(Float32,10),2)           # Force compilation\nfor trial=1:6\n    a = zeros(Float32,1000)\n    set_zero_subnormals(iseven(trial))  # Odd trials use strict IEEE arithmetic\n    @time heatflow(a,1000)\nend\n\nThis gives an output similar to\n\n  0.002202 seconds (1 allocation: 4.063 KiB)\n  0.001502 seconds (1 allocation: 4.063 KiB)\n  0.002139 seconds (1 allocation: 4.063 KiB)\n  0.001454 seconds (1 allocation: 4.063 KiB)\n  0.002115 seconds (1 allocation: 4.063 KiB)\n  0.001455 seconds (1 allocation: 4.063 KiB)\n\nNote how each even iteration is significantly faster.\n\nThis example generates many subnormal numbers because the values in a become an exponentially\ndecreasing curve, which slowly flattens out over time.\n\nTreating subnormals as zeros should be used with caution, because doing so breaks some identities,\nsuch as x-y == 0 implies x == y:\n\njulia> x = 3f-38; y = 2f-38;\n\njulia> set_zero_subnormals(true); (x - y, x == y)\n(0.0f0, false)\n\njulia> set_zero_subnormals(false); (x - y, x == y)\n(1.0000001f-38, false)\n\nIn some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise.\n For example, instead of initializing a with zeros, initialize it with:\n\na = rand(Float32,1000) * 1.f-9"},{"title":"Avoid string interpolation for I/O","page":"Performance Tips","location":"manual/performance-tips.html#Avoid-string-interpolation-for-I/O","category":"section","text":"When writing data to a file (or other I/O device), forming extra intermediate strings is a source\nof overhead. Instead of:\n\nprintln(file, \"$a $b\")\n\nuse:\n\nprintln(file, a, \" \", b)\n\nThe first version of the code forms a string, then writes it to the file, while the second version\nwrites values directly to the file. Also notice that in some cases string interpolation can be\nharder to read. Consider:\n\nprintln(file, \"$(f(a))$(f(b))\")\n\nversus:\n\nprintln(file, f(a), f(b))"},{"title":"Avoid eager string materialization","page":"Performance Tips","location":"manual/performance-tips.html#Avoid-eager-string-materialization","category":"section","text":"In settings where a string representation of an object is only needed\nconditionally (e.g. in error paths of functions or conditional warnings such as\ndeprecations), it is advisable to avoid the overhead of eagerly materializing\nthe string. Since Julia 1.8, this can be achieved via\nLazyString and the corresponding string macro @lazy_str.\n\nFor example, instead of:\n\nBase.depwarn(\"`foo` is deprecated for type $(typeof(x))\", :bar)\n\nuse:\n\nBase.depwarn(lazy\"`foo` is deprecated for type $(typeof(x))\", :bar)\n\nor the equivalent macro-free version:\n\nBase.depwarn(LazyString(\"`foo` is deprecated for type \", typeof(x)), :bar)\n\nThrough this approach, the interpolated string will only be constructed when it is actually displayed."},{"title":"Optimize network I/O during parallel execution","page":"Performance Tips","location":"manual/performance-tips.html#Optimize-network-I/O-during-parallel-execution","category":"section","text":"When executing a remote function in parallel:\n\nusing Distributed\n\nresponses = Vector{Any}(undef, nworkers())\n@sync begin\n    for (idx, pid) in enumerate(workers())\n        Threads.@spawn responses[idx] = remotecall_fetch(foo, pid, args...)\n    end\nend\n\nis faster than:\n\nusing Distributed\n\nrefs = Vector{Any}(undef, nworkers())\nfor (idx, pid) in enumerate(workers())\n    refs[idx] = @spawnat pid foo(args...)\nend\nresponses = [fetch(r) for r in refs]\n\nThe former results in a single network round-trip to every worker, while the latter results in\ntwo network calls - first by the @spawnat and the second due to the fetch\n(or even a wait).\nThe fetch/wait is also being executed serially resulting in an overall poorer performance."},{"title":"Use MutableArithmetics for more control over allocation for mutable arithmetic types","page":"Performance Tips","location":"manual/performance-tips.html#man-perftips-mutablearithmetics","category":"section","text":"Some Number subtypes, such as BigInt or BigFloat, may\nbe implemented as mutable struct types, or they may have mutable\ncomponents. The arithmetic interfaces in Julia Base usually opt for convenience\nover efficiency in such cases, so using them in a naive manner may result in\nsuboptimal performance. The abstractions of the\nMutableArithmetics\npackage, on the other hand, make it possible to exploit the mutability of such types\nfor writing fast code that allocates only as much as necessary. MutableArithmetics\nalso makes it possible to copy values of mutable arithmetic types explicitly when\nnecessary. MutableArithmetics is a user package and is not affiliated with the\nJulia project."},{"title":"Julia Documentation","page":"Julia Documentation","location":"index.html","category":"section","text":"io = IOBuffer()\nrelease = isempty(VERSION.prerelease)\nv = \"$(VERSION.major).$(VERSION.minor)\"\n!release && (v = v*\"-$(first(VERSION.prerelease))\")\nprint(io, \"\"\"\n    # Julia $(v) Documentation\n\n    Welcome to the documentation for Julia $(v).\n\n    \"\"\")\nif !release\n    print(io,\"\"\"\n        !!! warning \"Work in progress!\"\n            This documentation is for an unreleased, in-development, version of Julia.\n        \"\"\")\nend\nimport Markdown\nMarkdown.parse(String(take!(io)))\n\nPlease read the release notes to see what has changed since the last release.\n\nrelease = isempty(VERSION.prerelease)\nfile = release ? \"julia-$(VERSION).pdf\" :\n       \"julia-$(VERSION.major).$(VERSION.minor).$(VERSION.patch)-$(first(VERSION.prerelease)).pdf\"\nurl = \"https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/$(file)\"\nimport Markdown\nMarkdown.parse(\"\"\"\n!!! note\n    The documentation is also available in PDF format: [$file]($url).\n\"\"\")"},{"title":"Introduction","page":"Julia Documentation","location":"index.html#man-introduction","category":"section","text":"Scientific computing has traditionally required the highest performance, yet domain experts have\nlargely moved to slower dynamic languages for daily work. We believe there are many good reasons\nto prefer dynamic languages for these applications, and we do not expect their use to diminish.\nFortunately, modern language design and compiler techniques make it possible to mostly eliminate\nthe performance trade-off and provide a single environment productive enough for prototyping and\nefficient enough for deploying performance-intensive applications. The Julia programming language\nfills this role: it is a flexible dynamic language, appropriate for scientific and numerical computing,\nwith performance comparable to traditional statically-typed languages.\n\nBecause Julia's compiler is different from the interpreters used for languages like Python or\nR, you may find that Julia's performance is unintuitive at first. If you find that something is\nslow, we highly recommend reading through the Performance Tips section before trying anything\nelse. Once you understand how Julia works, it is easy to write code that is nearly as fast as C."},{"title":"Julia Compared to Other Languages","page":"Julia Documentation","location":"index.html#man-julia-compared-other-languages","category":"section","text":"Julia features optional typing, multiple dispatch, and good performance, achieved using type inference\nand just-in-time (JIT) compilation (and\noptional ahead-of-time compilation),\nimplemented using LLVM. It is multi-paradigm,\ncombining features of imperative, functional, and object-oriented programming. Julia provides\nease and expressiveness for high-level numerical computing, in the same way as languages such\nas R, MATLAB, and Python, but also supports general programming. To achieve this, Julia builds\nupon the lineage of mathematical programming languages, but also borrows much from popular dynamic\nlanguages, including Lisp, Perl,\nPython, Lua,\nand Ruby.\n\nThe most significant departures of Julia from typical dynamic languages are:\n\nThe core language imposes very little; Julia Base and the standard library are written in Julia itself, including\nprimitive operations like integer arithmetic\nA rich language of types for constructing and describing objects, that can also optionally be\nused to make type declarations\nThe ability to define function behavior across many combinations of argument types via multiple dispatch\nAutomatic generation of efficient, specialized code for different argument types\nGood performance, approaching that of statically-compiled languages like C\n\nAlthough one sometimes speaks of dynamic languages as being \"typeless\", they are definitely not.\nEvery object, whether primitive or user-defined, has a type. The lack of type declarations in\nmost dynamic languages, however, means that one cannot instruct the compiler about the types of\nvalues, and often cannot explicitly talk about types at all. In static languages, on the other\nhand, while one can – and usually must – annotate types for the compiler, types exist only at\ncompile time and cannot be manipulated or expressed at run time. In Julia, types are themselves\nrun-time objects, and can also be used to convey information to the compiler."},{"title":"What Makes Julia, Julia?","page":"Julia Documentation","location":"index.html#man-what-makes-julia","category":"section","text":"While the casual programmer need not explicitly use types or multiple dispatch, they are the core\nunifying features of Julia: functions are defined on different combinations of argument types,\nand applied by dispatching to the most specific matching definition. This model is a good fit\nfor mathematical programming, where it is unnatural for the first argument to \"own\" an operation\nas in traditional object-oriented dispatch. Operators are just functions with special notation\n– to extend addition to new user-defined data types, you define new methods for the + function.\nExisting code then seamlessly applies to the new data types.\n\nPartly because of run-time type inference (augmented by optional type annotations), and partly\nbecause of a strong focus on performance from the inception of the project, Julia's computational\nefficiency exceeds that of other dynamic languages, and even rivals that of statically-compiled\nlanguages. For large scale numerical problems, speed always has been, continues to be, and probably\nalways will be crucial: the amount of data being processed has easily kept pace with Moore's Law\nover the past decades."},{"title":"Advantages of Julia","page":"Julia Documentation","location":"index.html#man-advantages-of-julia","category":"section","text":"Julia aims to create an unprecedented combination of ease-of-use, power, and efficiency in a single\nlanguage. In addition to the above, some advantages of Julia over comparable systems include:\n\nFree and open source (MIT licensed)\nUser-defined types are as fast and compact as built-ins\nNo need to vectorize code for performance; devectorized code is fast\nDesigned for parallelism and distributed computation\nLightweight \"green\" threading (coroutines)\nUnobtrusive yet powerful type system\nElegant and extensible conversions and promotions for numeric and other types\nEfficient support for Unicode, including but not limited\nto UTF-8\nCall C functions directly (no wrappers or special APIs needed)\nPowerful shell-like capabilities for managing other processes\nLisp-like macros and other metaprogramming facilities"},{"title":"Important Links","page":"Julia Documentation","location":"index.html#man-important-links","category":"section","text":"A non-exhaustive list of links that will be useful as you learn and use the Julia programming language:\n\nJulia Homepage\nInstall Julia\nDiscussion forum\nJulia YouTube\nFind Julia Packages\nLearning Resources"},{"title":"printf() and stdio in the Julia runtime","page":"printf() and stdio in the Julia runtime","location":"devdocs/stdio.html#printf()-and-stdio-in-the-Julia-runtime","category":"section","text":""},{"title":"Libuv wrappers for stdio","page":"printf() and stdio in the Julia runtime","location":"devdocs/stdio.html#Libuv-wrappers-for-stdio","category":"section","text":"julia.h defines libuv wrappers for the stdio.h streams:\n\nuv_stream_t *JL_STDIN;\nuv_stream_t *JL_STDOUT;\nuv_stream_t *JL_STDERR;\n\n... and corresponding output functions:\n\nint jl_printf(uv_stream_t *s, const char *format, ...);\nint jl_vprintf(uv_stream_t *s, const char *format, va_list args);\n\nThese printf functions are used by the .c files in the src/ and cli/ directories wherever stdio is\nneeded to ensure that output buffering is handled in a unified way.\n\nIn special cases, like signal handlers, where the full libuv infrastructure is too heavy, jl_safe_printf()\ncan be used to write(2) directly to STDERR_FILENO:\n\nvoid jl_safe_printf(const char *str, ...);"},{"title":"Interface between JL_STD* and Julia code","page":"printf() and stdio in the Julia runtime","location":"devdocs/stdio.html#Interface-between-JL_STD*-and-Julia-code","category":"section","text":"Base.stdin, Base.stdout and Base.stderr are bound to the JL_STD* libuv\nstreams defined in the runtime.\n\nJulia's __init__() function (in base/sysimg.jl) calls reinit_stdio() (in base/stream.jl)\nto create Julia objects for Base.stdin, Base.stdout and Base.stderr.\n\nreinit_stdio() uses ccall to retrieve pointers to JL_STD* and calls jl_uv_handle_type()\nto inspect the type of each stream. It then creates a Julia Base.IOStream, Base.TTY or Base.PipeEndpoint\nobject to represent each stream, e.g.:\n\n$ julia -e 'println(typeof((stdin, stdout, stderr)))'\nTuple{Base.TTY,Base.TTY,Base.TTY}\n\n$ julia -e 'println(typeof((stdin, stdout, stderr)))' < /dev/null 2>/dev/null\nTuple{IOStream,Base.TTY,IOStream}\n\n$ echo hello | julia -e 'println(typeof((stdin, stdout, stderr)))' | cat\nTuple{Base.PipeEndpoint,Base.PipeEndpoint,Base.TTY}\n\nThe Base.read and Base.write methods for these streams use ccall\nto call libuv wrappers in src/jl_uv.c, e.g.:\n\nstream.jl: function write(s::IO, p::Ptr, nb::Integer)\n               -> ccall(:jl_uv_write, ...)\n  jl_uv.c:          -> int jl_uv_write(uv_stream_t *stream, ...)\n                        -> uv_write(uvw, stream, buf, ...)"},{"title":"printf() during initialization","page":"printf() and stdio in the Julia runtime","location":"devdocs/stdio.html#printf()-during-initialization","category":"section","text":"The libuv streams relied upon by jl_printf() etc., are not available until midway through\ninitialization of the runtime (see init.c, init_stdio()). Error messages or warnings that\nneed to be printed before this are routed to the standard C library fwrite() function by the\nfollowing mechanism:\n\nIn sys.c, the JL_STD* stream pointers are statically initialized to integer constants: STD*_FILENO (0, 1 and 2).\nIn jl_uv.c the jl_uv_puts() function checks its uv_stream_t* stream argument and calls\nfwrite() if stream is set to STDOUT_FILENO or STDERR_FILENO.\n\nThis allows for uniform use of jl_printf() throughout the runtime regardless of whether or not\nany particular piece of code is reachable before initialization is complete."},{"title":"Legacy ios.c library","page":"printf() and stdio in the Julia runtime","location":"devdocs/stdio.html#Legacy-ios.c-library","category":"section","text":"The src/support/ios.c library is inherited from femtolisp.\nIt provides cross-platform buffered file IO and in-memory temporary buffers.\n\nios.c is still used by:\n\nsrc/flisp/*.c\nsrc/dump.c – for serialization file IO and for memory buffers.\nsrc/staticdata.c – for serialization file IO and for memory buffers.\nbase/iostream.jl – for file IO (see base/fs.jl for libuv equivalent).\n\nUse of ios.c in these modules is mostly self-contained and separated from the libuv I/O system.\nHowever, there is one place\nwhere femtolisp calls through to jl_printf() with a legacy ios_t stream.\n\nThere is a hack in ios.h that makes the ios_t.bm field line up with the uv_stream_t.type\nand ensures that the values used for ios_t.bm to not overlap with valid UV_HANDLE_TYPE values.\n This allows uv_stream_t pointers to point to ios_t streams.\n\nThis is needed because jl_printf() caller jl_static_show() is passed an ios_t stream by\nfemtolisp's fl_print() function. Julia's jl_uv_puts() function has special handling for this:\n\nif (stream->type > UV_HANDLE_TYPE_MAX) {\n    return ios_write((ios_t*)stream, str, n);\n}"},{"title":"Diagnostics used by the package ecosystem","page":"Diagnostics used by the package ecosystem","location":"devdocs/diagnostics.html#Diagnostics-used-by-the-package-ecosystem","category":"section","text":"This page documents \"hooks\" embedded in Julia that are primarily used by\nexternal tools. Many of these tools are designed to perform analyses that are\ntoo complicated to be made part of Julia proper."},{"title":"SnoopCompile","page":"Diagnostics used by the package ecosystem","location":"devdocs/diagnostics.html#SnoopCompile","category":"section","text":"SnoopCompile \"snoops\" on Julia's compiler to extract information for analysis\nabout invalidations and type-inference. There are a few internals it uses for\ndifferent purposes:\n\nrecording invalidations: Base.StaticData.debug_method_invalidation and\nccall(:jl_debug_method_invalidation, ...): these record different modes of\ninvalidation. Users of SnoopCompile will transiently turn these on when, e.g.,\nloading packages. Each produces a standard log format; messing with the log\nformat might require a complementary pull request to SnoopCompile.\nSnoopCompile will process these logs and generate trees of invalidated\nCodeInstances that are attributable to specific changes in the method tables\nor bindings.\nobserving inference: ccall(:jl_set_newly_inferred, ...) and\nccall(:jl_set_inference_entrance_backtraces, ...): these are used to\nunderstand how inference gets triggered. The main purpose is to allow\nperformance diagnostics to understand sources of TTFX. The second of these\nccalls records a backtrace on every entrance to type-inference, so that\nSnoopCompile can determine the caller of a dynamically-dispatched call. This\nis needed to attribute \"cause\" for new type inference.\nThe jl_set_inference_entrance_backtraces function accepts an array where\ninference entrance events will be recorded. Each inference event stores two\nconsecutive array elements: first the CodeInstance object, then the\nbacktrace representation. So for N inference events, the array will contain 2N\nelements arranged as: [ci₁, bt₁, ci₂, bt₂, ..., ciₙ, btₙ].\nNote that the backtrace elements btᵢ contain raw backtrace data that\ntypically needs to be processed using stacktrace(Base._reformat_bt(btᵢ...)).\nto convert them into a usable stack trace format for analysis."},{"title":"Calling Conventions","page":"Calling Conventions","location":"devdocs/callconv.html#Calling-Conventions","category":"section","text":"Julia uses three calling conventions for four distinct purposes:\n\nName Prefix Purpose\nNative julia_ Speed via specialized signatures\nJL Call jlcall_ Wrapper for generic calls\nJL Call jl_ Builtins\nC ABI jlcapi_ Wrapper callable from C"},{"title":"Julia Native Calling Convention","page":"Calling Conventions","location":"devdocs/callconv.html#Julia-Native-Calling-Convention","category":"section","text":"The native calling convention is designed for fast non-generic calls. It usually uses a specialized\nsignature.\n\nLLVM ghosts (zero-length types) are omitted.\nLLVM scalars and vectors are passed by value.\nLLVM aggregates (arrays and structs) are passed by reference.\n\nA small return value is returned as LLVM return values. A large return value is returned via\nthe \"structure return\" (sret) convention, where the caller provides a pointer to a return slot.\n\nAn argument or return value that is a homogeneous tuple is sometimes represented as an LLVM vector\ninstead of an LLVM array."},{"title":"JL Call Convention","page":"Calling Conventions","location":"devdocs/callconv.html#JL-Call-Convention","category":"section","text":"The JL Call convention is for builtins and generic dispatch. Hand-written functions using this\nconvention are declared via the macro JL_CALLABLE. The convention uses exactly 3 parameters:\n\nF  - Julia representation of function that is being applied\nargs - pointer to array of pointers to boxes\nnargs - length of the array\n\nThe return value is a pointer to a box."},{"title":"C ABI","page":"Calling Conventions","location":"devdocs/callconv.html#C-ABI","category":"section","text":"C ABI wrappers enable calling Julia from C. The wrapper calls a function using the native calling\nconvention.\n\nTuples are always represented as C arrays."},{"title":"StyledStrings","page":"StyledStrings","location":"stdlib/StyledStrings.html#stdlib-styledstrings","category":"section","text":"note: Note\nThe API for StyledStrings and AnnotatedStrings is considered experimental and is subject to change between\nJulia versions."},{"title":"Styling","page":"StyledStrings","location":"stdlib/StyledStrings.html#stdlib-styledstrings-styling","category":"section","text":"When working with strings, formatting and styling often appear as a secondary\nconcern.\n\nFor instance, when printing to a terminal you might want to sprinkle [ANSI\nescape\nsequences](https://en.wikipedia.org/wiki/ANSIescapecode#SGR(SelectGraphicRendition)parameters)\nin the output, when outputting HTML styling constructs (<span style=\"...\">,\netc.) serve a similar purpose, and so on. It is possible to simply insert the\nraw styling constructs into the string next to the content itself, but it\nquickly becomes apparent that this is not well suited for anything but the most\nbasic use cases. Not all terminals support the same ANSI codes, the styling\nconstructs need to be painstakingly removed when calculating the width of\nalready-styled content, and that's before you even get into handling multiple\noutput formats.\n\nInstead of leaving this headache to be widely experienced downstream, it is\ntackled head-on by the introduction of a special string type\n(AnnotatedString). This string type wraps any other\nAbstractString type and allows for formatting information to be applied to regions (e.g.\ncharacters 1 through to 7 are bold and red).\n\nRegions of a string are styled by applying Faces\n(think \"typeface\") to them — a structure that holds styling information. As a\nconvenience, faces in the global faces dictionary (e.g. shadow) can just be\nnamed instead of giving the Face directly.\n\nAlong with these capabilities, we also provide a convenient way for constructing\nAnnotatedStrings, detailed in [Styled String\nLiterals](@ref stdlib-styledstring-literals).\n\nusing StyledStrings\nstyled\"{yellow:hello} {blue:there}\""},{"title":"Annotated Strings","page":"StyledStrings","location":"stdlib/StyledStrings.html#man-annotated-strings","category":"section","text":"It is sometimes useful to be able to hold metadata relating to regions of a\nstring. A AnnotatedString wraps another string and\nallows for regions of it to be annotated with labelled values (:label => value).\nAll generic string operations are applied to the underlying string. However,\nwhen possible, styling information is preserved. This means you can manipulate a\nAnnotatedString —taking substrings, padding them,\nconcatenating them with other strings— and the metadata annotations will \"come\nalong for the ride\".\n\nThis string type is fundamental to the [StyledStrings stdlib](@ref\nstdlib-styledstrings), which uses :face-labelled annotations to hold styling\ninformation.\n\nWhen concatenating a AnnotatedString, take care to use\nannotatedstring instead of string if you want\nto keep the string annotations.\n\njulia> str = AnnotatedString(\"hello there\", [(1:5, :word, :greeting), (7:11, :label, 1)])\n\"hello there\"\n\njulia> length(str)\n11\n\njulia> lpad(str, 14)\n\"   hello there\"\n\njulia> typeof(lpad(str, 7))\nAnnotatedString{String}\n\njulia> str2 = AnnotatedString(\" julia\", [(2:6, :face, :magenta)])\n\" julia\"\n\njulia> annotatedstring(str, str2)\n\"hello there julia\"\n\njulia> str * str2 == annotatedstring(str, str2) # *-concatenation works\ntrue\n\nThe annotations of a AnnotatedString can be accessed\nand modified via the annotations and\nannotate! functions."},{"title":"Styling via AnnotatedStrings","page":"StyledStrings","location":"stdlib/StyledStrings.html#Styling-via-[AnnotatedString](@ref-Base.AnnotatedString)s","category":"section","text":""},{"title":"Faces","page":"StyledStrings","location":"stdlib/StyledStrings.html#stdlib-styledstrings-faces","category":"section","text":""},{"title":"The Face type","page":"StyledStrings","location":"stdlib/StyledStrings.html#The-Face-type","category":"section","text":"A Face specifies details of a typeface that text can be set in. It\ncovers a set of basic attributes that generalize well across different formats,\nnamely:\n\nfont\nheight\nweight\nslant\nforeground\nbackground\nunderline\nstrikethrough\ninverse\ninherit\n\nFor details on the particular forms these attributes take, see the\nFace docstring, but of particular interest is inherit as it allows\nyou to inherit attributes from other Faces."},{"title":"The global faces dictionary","page":"StyledStrings","location":"stdlib/StyledStrings.html#The-global-faces-dictionary","category":"section","text":"To make referring to particular styles more convenient, there is a global\nDict{Symbol, Face} that allows for Faces to be\nreferred to simply by name. Packages can add faces to this dictionary via the\naddface! function, and the loaded faces can be\neasily customized.\n\nwarning: Appropriate face naming\nAny package registering new faces should ensure that they are prefixed\nby the package name, i.e. follow the format mypackage_myface.\nThis is important for predictability, and to prevent name clashes.Furthermore, packages should take care to use (and introduce) semantic\nfaces (like code) over direct colours and styles (like cyan). This is helpful\nin a number of ways, from making the intent in usage more obvious, aiding\ncomposability, and making user customisation more intuitive.\n\nThere are two set of exemptions to the package-prefix rule:\n\nthe set of basic faces that are part of the default value of the faces dictionary\nfaces introduced by Julia's own standard library, namely JuliaSyntaxHighlighting"},{"title":"Basic faces","page":"StyledStrings","location":"stdlib/StyledStrings.html#stdlib-styledstrings-basic-faces","category":"section","text":"Basic faces are intended to represent a general idea that is widely applicable.\n\nFor setting some text with a certain attribute, we have the bold, light,\nitalic, underline, strikethrough, and inverse faces.\n\nThere are also named faces for the 16 terminal colors: black, red, green,\nyellow, blue, magenta, cyan, white, bright_black/grey/gray,\nbright_red, bright_green, bright_blue, bright_magenta, bright_cyan,\nand bright_white.\n\nFor shadowed text (i.e. dim but there) there is the shadow face. To indicate a\nselected region, there is the region face. Similarly for emphasis and\nhighlighting the emphasis and highlight faces are defined. There is also\ncode for code-like text.\n\nFor visually indicating the severity of messages, the error, warning,\nsuccess, info, note, and tip faces are defined."},{"title":"Customisation of faces (Faces.toml)","page":"StyledStrings","location":"stdlib/StyledStrings.html#stdlib-styledstrings-face-toml","category":"section","text":"It is good for the name faces in the global face dictionary to be customizable.\nTheming and aesthetics are nice, and it is important for accessibility reasons\ntoo. A TOML file can be parsed into a list of Face specifications that\nare merged with the pre-existing entry in the face dictionary.\n\nA Face is represented in TOML like so:\n\n[facename]\nattribute = \"value\"\n...\n\n[package.facename]\nattribute = \"value\"\n\nFor example, if the shadow face is too hard to read it can be made brighter\nlike so:\n\n[shadow]\nforeground = \"white\"\n\nOn initialization, the config/faces.toml file under the first Julia depot (usually ~/.julia) is loaded."},{"title":"Applying faces to a AnnotatedString","page":"StyledStrings","location":"stdlib/StyledStrings.html#Applying-faces-to-a-AnnotatedString","category":"section","text":"By convention, the :face attributes of a [AnnotatedString](@ref\nBase.AnnotatedString) hold information on the Faces\nthat currently apply. This can be given in multiple forms, as a single Symbol\nnaming a Faces in the global face dictionary, a\nFace itself, or a vector of either.\n\nThe show(::IO, ::MIME\"text/plain\", ::AnnotatedString) and show(::IO, ::MIME\"text/html\", ::AnnotatedString) methods both look at the :face attributes\nand merge them all together when determining the overall styling.\n\nWe can supply :face attributes to a AnnotatedString during construction, add\nthem to the properties list afterwards, or use the convenient [Styled String\nliterals](@ref stdlib-styledstring-literals).\n\nstr1 = AnnotatedString(\"blue text\", [(1:9, :face, :blue)])\nstr2 = styled\"{blue:blue text}\"\nstr1 == str2\nsprint(print, str1, context = :color => true)\nsprint(show, MIME(\"text/html\"), str1, context = :color => true)"},{"title":"Styled String Literals","page":"StyledStrings","location":"stdlib/StyledStrings.html#stdlib-styledstring-literals","category":"section","text":"To ease construction of AnnotatedStrings with Faces applied,\nthe styled\"...\" styled string literal allows for the content and\nattributes to be easily expressed together via a custom grammar.\n\nWithin a styled\"...\" literal, curly braces are considered\nspecial characters and must be escaped in normal usage (\\{, \\}). This allows\nthem to be used to express annotations with (nestable) {annotations...:text}\nconstructs.\n\nThe annotations... component is a comma-separated list of three types of annotations.\n\nFace names\nInline Face expressions (key=val,...)\nkey=value pairs\n\nInterpolation is possible everywhere except for inline face keys.\n\nFor more information on the grammar, see the extended help of the\nstyled\"...\" docstring.\n\nAs an example, we can demonstrate the list of built-in faces mentioned above like so:\n\njulia> println(styled\"\nThe basic font-style attributes are {bold:bold}, {light:light}, {italic:italic},\n{underline:underline}, and {strikethrough:strikethrough}.\n\nIn terms of color, we have named faces for the 16 standard terminal colors:\n {black:■} {red:■} {green:■} {yellow:■} {blue:■} {magenta:■} {cyan:■} {white:■}\n {bright_black:■} {bright_red:■} {bright_green:■} {bright_yellow:■} {bright_blue:■} {bright_magenta:■} {bright_cyan:■} {bright_white:■}\n\nSince {code:bright_black} is effectively grey, we define two aliases for it:\n{code:grey} and {code:gray} to allow for regional spelling differences.\n\nTo flip the foreground and background colors of some text, you can use the\n{code:inverse} face, for example: {magenta:some {inverse:inverse} text}.\n\nThe intent-based basic faces are {shadow:shadow} (for dim but visible text),\n{region:region} for selections, {emphasis:emphasis}, and {highlight:highlight}.\nAs above, {code:code} is used for code-like text.\n\nLastly, we have the 'message severity' faces: {error:error}, {warning:warning},\n{success:success}, {info:info}, {note:note}, and {tip:tip}.\n\nRemember that all these faces (and any user or package-defined ones) can\narbitrarily nest and overlap, {region,tip:like {bold,italic:so}}.\")\n\nDocumenter doesn't properly represent all the styling above, so I've converted it manually to HTML and LaTeX.\n\n<pre>\n The basic font-style attributes are <span style=\"font-weight: 700;\">bold</span>, <span style=\"font-weight: 300;\">light</span>, <span style=\"font-style: italic;\">italic</span>,\n <span style=\"text-decoration: underline;\">underline</span>, and <span style=\"text-decoration: line-through\">strikethrough</span>.\n\n In terms of color, we have named faces for the 16 standard terminal colors:\n  <span style=\"color: #1c1a23;\">■</span> <span style=\"color: #a51c2c;\">■</span> <span style=\"color: #25a268;\">■</span> <span style=\"color: #e5a509;\">■</span> <span style=\"color: #195eb3;\">■</span> <span style=\"color: #803d9b;\">■</span> <span style=\"color: #0097a7;\">■</span> <span style=\"color: #dddcd9;\">■</span>\n  <span style=\"color: #76757a;\">■</span> <span style=\"color: #ed333b;\">■</span> <span style=\"color: #33d079;\">■</span> <span style=\"color: #f6d22c;\">■</span> <span style=\"color: #3583e4;\">■</span> <span style=\"color: #bf60ca;\">■</span> <span style=\"color: #26c6da;\">■</span> <span style=\"color: #f6f5f4;\">■</span>\n\n Since <span style=\"color: #0097a7;\">bright_black</span> is effectively grey, we define two aliases for it:\n <span style=\"color: #0097a7;\">grey</span> and <span style=\"color: #0097a7;\">gray</span> to allow for regional spelling differences.\n\n To flip the foreground and background colors of some text, you can use the\n <span style=\"color: #0097a7;\">inverse</span> face, for example: <span style=\"color: #803d9b;\">some </span><span style=\"background-color: #803d9b;\">inverse</span><span style=\"color: #803d9b;\"> text</span>.\n\n The intent-based basic faces are <span style=\"color: #76757a;\">shadow</span> (for dim but visible text),\n <span style=\"background-color: #3a3a3a;\">region</span> for selections, <span style=\"color: #195eb3;\">emphasis</span>, and <span style=\"background-color: #195eb3;\">highlight</span>.\n As above, <span style=\"color: #0097a7;\">code</span> is used for code-like text.\n\n Lastly, we have the 'message severity' faces: <span style=\"color: #ed333b;\">error</span>, <span style=\"color: #e5a509;\">warning</span>,\n <span style=\"color: #25a268;\">success</span>, <span style=\"color: #26c6da;\">info</span>, <span style=\"color: #76757a;\">note</span>, and <span style=\"color: #33d079;\">tip</span>.\n\n Remember that all these faces (and any user or package-defined ones) can\n arbitrarily nest and overlap, <span style=\"color: #33d079;background-color: #3a3a3a;\">like <span style=\"font-weight: 700;font-style: italic;\">so</span></span>.</pre>\n\n\\begingroup\n\\ttfamily\n\\setlength{\\parindent}{0pt}\n\\setlength{\\parskip}{\\baselineskip}\n\nThe basic font-style attributes are {\\fontseries{b}\\selectfont bold}, {\\fontseries{l}\\selectfont light}, {\\fontshape{it}\\selectfont italic},\\\\\n\\underline{underline}, and {strikethrough}.\n\nIn terms of color, we have named faces for the 16 standard terminal colors:\\\\\n{\\color[HTML]{1c1a23}\\(\\blacksquare\\)} {\\color[HTML]{a51c2c}\\(\\blacksquare\\)} {\\color[HTML]{25a268}\\(\\blacksquare\\)}\n{\\color[HTML]{e5a509}\\(\\blacksquare\\)} {\\color[HTML]{195eb3}\\(\\blacksquare\\)} {\\color[HTML]{803d9b}\\(\\blacksquare\\)}\n{\\color[HTML]{0097a7}\\(\\blacksquare\\)} {\\color[HTML]{dddcd9}\\(\\blacksquare\\)} \\\\\n{\\color[HTML]{76757a}\\(\\blacksquare\\)} {\\color[HTML]{ed333b}\\(\\blacksquare\\)} {\\color[HTML]{33d079}\\(\\blacksquare\\)} {\\color[HTML]{f6d22c}\\(\\blacksquare\\)} {\\color[HTML]{3583e4}\\(\\blacksquare\\)} {\\color[HTML]{bf60ca}\\(\\blacksquare\\)} {\\color[HTML]{26c6da}\\(\\blacksquare\\)} {\\color[HTML]{f6f5f4}\\(\\blacksquare\\)}\n\nSince {\\color[HTML]{0097a7}bright\\_black} is effectively grey, we define two aliases for it:\\\\\n{\\color[HTML]{0097a7}grey} and {\\color[HTML]{0097a7}gray} to allow for regional spelling differences.\n\nTo flip the foreground and background colors of some text, you can use the\\\\\n{\\color[HTML]{0097a7}inverse} face, for example: {\\color[HTML]{803d9b}some \\colorbox[HTML]{803d9b}{\\color[HTML]{000000}inverse} text}.\n\nThe intent-based basic faces are {\\color[HTML]{76757a}shadow} (for dim but visible text),\\\\\n\\colorbox[HTML]{3a3a3a}{region} for selections, {\\color[HTML]{195eb3}emphasis}, and \\colorbox[HTML]{195eb3}{highlight}.\\\\\nAs above, {\\color[HTML]{0097a7}code} is used for code-like text.\n\nLastly, we have the 'message severity' faces: {\\color[HTML]{ed333b}error}, {\\color[HTML]{e5a509}warning},\\\\\n{\\color[HTML]{25a268}success}, {\\color[HTML]{26c6da}info}, {\\color[HTML]{76757a}note}, and {\\color[HTML]{33d079}tip}.\n\nRemember that all these faces (and any user or package-defined ones) can\\\\\narbitrarily nest and overlap, \\colorbox[HTML]{3a3a3a}{\\color[HTML]{33d079}like\n  {\\fontseries{b}\\fontshape{it}\\selectfont so}}.\n\\endgroup"},{"title":"API reference","page":"StyledStrings","location":"stdlib/StyledStrings.html#stdlib-styledstrings-api","category":"section","text":""},{"title":"Styling and Faces","page":"StyledStrings","location":"stdlib/StyledStrings.html#Styling-and-Faces","category":"section","text":""},{"title":"StyledStrings.StyledMarkup.@styled_str","page":"StyledStrings","location":"stdlib/StyledStrings.html#StyledStrings.StyledMarkup.@styled_str","category":"macro","text":"@styled_str -> AnnotatedString\n\nConstruct a styled string. Within the string, {<specs>:<content>} structures\napply the formatting to <content>, according to the list of comma-separated\nspecifications <specs>. Each spec can either take the form of a face name,\nan inline face specification, or a key=value pair. The value must be wrapped\nby {...} should it contain any of the characters ,=:{}.\n\nString interpolation with $ functions in the same way as regular strings,\nexcept quotes need to be escaped. Faces, keys, and values can also be\ninterpolated with $.\n\nExample\n\nstyled\"The {bold:{italic:quick} {(foreground=#cd853f):brown} fox} jumped over the {link={https://en.wikipedia.org/wiki/Laziness}:lazy} dog\"\n\nExtended help\n\nThis macro can be described by the following EBNF grammar:\n\nstyledstring = { styled | interpolated | escaped | plain } ;\n\nspecialchar = '{' | '}' | '$' | '\\\"' ;\nanychar = [\\u0-\\u1fffff] ;\nplain = { anychar - specialchar } ;\nescaped = '\\\\', specialchar ;\n\ninterpolated = '$', ? expr ? | '$(', ? expr ?, ')' ;\n\nstyled = '{', ws, annotations, ':', content, '}' ;\ncontent = { interpolated | plain | escaped | styled } ;\nannotations = annotation | annotations, ws, ',', ws, annotation ;\nannotation = face | inlineface | keyvalue ;\nws = { ' ' | '\\t' | '\\n' } ; (* whitespace *)\n\nface = facename | interpolated ;\nfacename = [A-Za-z0-9_]+ ;\n\ninlineface = '(', ws, [ faceprop ], { ws, ',', faceprop }, ws, ')' ;\nfaceprop = [a-z]+, ws, '=', ws, ( [^,)]+ | interpolated) ;\n\nkeyvalue = key, ws, '=', ws, value ;\nkey = ( [^\\0${}=,:], [^\\0=,:]* ) | interpolated ;\nvalue = simplevalue | curlybraced | interpolated ;\ncurlybraced = '{' { escaped | plain } '}' ;\nsimplevalue = [^${},:], [^,:]* ;\n\nAn extra stipulation not encoded in the above grammar is that plain should be\na valid input to unescape_string, with specialchar kept.\n\nThe above grammar for inlineface is simplified, as the actual implementation\nis a bit more sophisticated. The full behaviour is given below.\n\nfaceprop = ( 'face', ws, '=', ws, ( ? string ? | interpolated ) ) |\n           ( 'height', ws, '=', ws, ( ? number ? | interpolated ) ) |\n           ( 'weight', ws, '=', ws, ( symbol | interpolated ) ) |\n           ( 'slant', ws, '=', ws, ( symbol | interpolated ) ) |\n           ( ( 'foreground' | 'fg' | 'background' | 'bg' ),\n               ws, '=', ws, ( simplecolor | interpolated ) ) |\n           ( 'underline', ws, '=', ws, ( underline | interpolated ) ) |\n           ( 'strikethrough', ws, '=', ws, ( bool | interpolated ) ) |\n           ( 'inverse', ws, '=', ws, ( bool | interpolated ) ) |\n           ( 'inherit', ws, '=', ws, ( inherit | interpolated ) ) ;\n\nnothing = 'nothing' ;\nbool = 'true' | 'false' ;\nsymbol = [^ ,)]+ ;\nhexcolor = ('#' | '0x'), [0-9a-f]{6} ;\nsimplecolor = hexcolor | symbol | nothing ;\n\nunderline = nothing | bool | simplecolor | underlinestyled;\nunderlinestyled = '(', ws, ('' | nothing | simplecolor | interpolated), ws,\n                  ',', ws, ( symbol | interpolated ), ws ')' ;\n\ninherit = ( '[', inheritval, { ',', inheritval }, ']' ) | inheritval;\ninheritval = ws, ':'?, symbol ;\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.styled","page":"StyledStrings","location":"stdlib/StyledStrings.html#StyledStrings.StyledMarkup.styled","category":"function","text":"styled(content::AbstractString) -> AnnotatedString\n\nConstruct a styled string. Within the string, {<specs>:<content>} structures\napply the formatting to <content>, according to the list of comma-separated\nspecifications <specs>. Each spec can either take the form of a face name,\nan inline face specification, or a key=value pair. The value must be wrapped\nby {...} should it contain any of the characters ,=:{}.\n\nThis is a functional equivalent of the @styled_str macro, just without\ninterpolation capabilities.\n\n\n\n\n\n"},{"title":"StyledStrings.Face","page":"StyledStrings","location":"stdlib/StyledStrings.html#StyledStrings.Face","category":"type","text":"A Face is a collection of graphical attributes for displaying text.\nFaces control how text is displayed in the terminal, and possibly other\nplaces too.\n\nMost of the time, a Face will be stored in the global faces dicts as a\nunique association with a face name Symbol, and will be most often referred to\nby this name instead of the Face object itself.\n\nAttributes\n\nAll attributes can be set via the keyword constructor, and default to nothing.\n\nheight (an Int or Float64): The height in either deci-pt (when an Int),\nor as a factor of the base size (when a Float64).\nweight (a Symbol): One of the symbols (from faintest to densest)\n:thin, :extralight, :light, :semilight, :normal,\n:medium, :semibold, :bold, :extrabold, or :black.\nIn terminals any weight greater than :normal is displayed as bold,\nand in terminals that support variable-brightness text, any weight\nless than :normal is displayed as faint.\nslant (a Symbol): One of the symbols :italic, :oblique, or :normal.\nforeground (a SimpleColor): The text foreground color.\nbackground (a SimpleColor): The text background color.\nunderline, the text underline, which takes one of the following forms:\na Bool: Whether the text should be underlined or not.\n\na SimpleColor: The text should be underlined with this color.\n\na Tuple{Nothing, Symbol}: The text should be underlined using the style\nset by the Symbol, one of :straight, :double, :curly, :dotted,\nor :dashed.\n\na Tuple{SimpleColor, Symbol}: The text should be underlined in the specified\nSimpleColor, and using the style specified by the Symbol, as before.\nstrikethrough (a Bool): Whether the text should be struck through.\ninverse (a Bool): Whether the foreground and background colors should be\ninverted.\ninherit (a Vector{Symbol}): Names of faces to inherit from,\nwith earlier faces taking priority. All faces inherit from the :default face.\n\n\n\n\n\n"},{"title":"StyledStrings.addface!","page":"StyledStrings","location":"stdlib/StyledStrings.html#StyledStrings.addface!","category":"function","text":"addface!(name::Symbol => default::Face)\n\nCreate a new face by the name name. So long as no face already exists by this\nname, default is added to both FACES.default and (a copy of) to\nFACES.current, with the current value returned.\n\nShould the face name already exist, nothing is returned.\n\nExamples\n\njulia> addface!(:mypkg_myface => Face(slant=:italic, underline=true))\nFace (sample)\n         slant: italic\n     underline: true\n\n\n\n\n\n"},{"title":"StyledStrings.withfaces","page":"StyledStrings","location":"stdlib/StyledStrings.html#StyledStrings.withfaces","category":"function","text":"withfaces(f, kv::Pair...)\nwithfaces(f, kvpair_itr)\n\nExecute f with FACES.current temporarily modified by zero or more :name => val arguments kv, or kvpair_itr which produces kv-form values.\n\nwithfaces is generally used via the withfaces(kv...) do ... end syntax. A\nvalue of nothing can be used to temporarily unset a face (if it has been\nset). When withfaces returns, the original FACES.current has been\nrestored.\n\nExamples\n\njulia> withfaces(:yellow => Face(foreground=:red), :green => :blue) do\n           println(styled\"{yellow:red} and {green:blue} mixed make {magenta:purple}\")\n       end\nred and blue mixed make purple\n\n\n\n\n\n"},{"title":"StyledStrings.SimpleColor","page":"StyledStrings","location":"stdlib/StyledStrings.html#StyledStrings.SimpleColor","category":"type","text":"struct SimpleColor\n\nA basic representation of a color, intended for string styling purposes.\nIt can either contain a named color (like :red), or an RGBTuple which\nis a NamedTuple specifying an r, g, b color with a bit-depth of 8.\n\nConstructors\n\nSimpleColor(name::Symbol)  # e.g. :red\nSimpleColor(rgb::RGBTuple) # e.g. (r=1, b=2, g=3)\nSimpleColor(r::Integer, b::Integer, b::Integer)\nSimpleColor(rgb::UInt32)   # e.g. 0x123456\n\nAlso see tryparse(SimpleColor, rgb::String).\n\n\n\n\n\n"},{"title":"Base.parse","page":"StyledStrings","location":"stdlib/StyledStrings.html#Base.parse-Tuple{Type{StyledStrings.SimpleColor}, String}","category":"method","text":"parse(::Type{SimpleColor}, rgb::String)\n\nAn analogue of tryparse(SimpleColor, rgb::String) (which see),\nthat raises an error instead of returning nothing.\n\n\n\n\n\n"},{"title":"Base.tryparse","page":"StyledStrings","location":"stdlib/StyledStrings.html#Base.tryparse-Tuple{Type{StyledStrings.SimpleColor}, String}","category":"method","text":"tryparse(::Type{SimpleColor}, rgb::String)\n\nAttempt to parse rgb as a SimpleColor. If rgb starts with\n# and has a length of 7, it is converted into a RGBTuple-backed SimpleColor.\nIf rgb starts with a-z, rgb is interpreted as a color name\nand converted to a Symbol-backed SimpleColor.\n\nOtherwise, nothing is returned.\n\nExamples\n\njulia> tryparse(SimpleColor, \"blue\")\nSimpleColor(blue)\n\njulia> tryparse(SimpleColor, \"#9558b2\")\nSimpleColor(#9558b2)\n\njulia> tryparse(SimpleColor, \"#nocolor\")\n\n\n\n\n\n"},{"title":"Base.merge","page":"StyledStrings","location":"stdlib/StyledStrings.html#Base.merge-Tuple{StyledStrings.Face, StyledStrings.Face}","category":"method","text":"merge(initial::StyledStrings.Face, others::StyledStrings.Face...)\n\nMerge the properties of the initial face and others, with later faces taking priority.\n\nThis is used to combine the styles of multiple faces, and to resolve inheritance.\n\n\n\n\n\n"},{"title":"Interactive Utilities","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#man-interactive-utils","category":"section","text":"The InteractiveUtils module provides utilities for interactive use of Julia,\nsuch as code introspection and clipboard access.\nIt is intended for interactive work and is loaded automatically in interactive mode."},{"title":"Base.Docs.apropos","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#Base.Docs.apropos","category":"function","text":"apropos([io::IO=stdout], pattern::Union{AbstractString,Regex})\n\nSearch available docstrings for entries containing pattern.\n\nWhen pattern is a string, case is ignored. Results are printed to io.\n\napropos can be called from the help mode in the REPL by wrapping the query in double quotes:\n\nhelp?> \"pattern\"\n\ncompat: Julia 1.11\nIn Julia 1.11 and newer, apropos requires that the REPL stdlib is loaded.\n\n\n\n\n\n"},{"title":"InteractiveUtils.varinfo","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.varinfo","category":"function","text":"varinfo(m::Module=Main, pattern::Regex=r\"\"; all=false, imported=false, recursive=false, sortby::Symbol=:name, minsize::Int=0)\n\nReturn a markdown table giving information about public global variables in a module, optionally restricted\nto those matching pattern.\n\nThe memory consumption estimate is an approximate lower bound on the size of the internal structure of the object.\n\nall : also list non-public objects defined in the module, deprecated objects, and compiler-generated objects.\nimported : also list objects explicitly imported from other modules.\nrecursive : recursively include objects in sub-modules, observing the same settings in each.\nsortby : the column to sort results by. Options are :name (default), :size, and :summary.\nminsize : only includes objects with size at least minsize bytes. Defaults to 0.\n\nThe output of varinfo is intended for display purposes only.  See also names to get an array of symbols defined in\na module, which is suitable for more general manipulations.\n\n\n\n\n\n"},{"title":"InteractiveUtils.versioninfo","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.versioninfo","category":"function","text":"versioninfo(io::IO=stdout; verbose::Bool=false)\n\nPrint information about the version of Julia in use. The output is\ncontrolled with boolean keyword arguments:\n\nverbose: print all additional information\n\nwarning: Warning\nThe output of this function may contain sensitive information. Before sharing the output,\nplease review the output and remove any data that should not be shared publicly.\n\nSee also: VERSION.\n\n\n\n\n\n"},{"title":"InteractiveUtils.methodswith","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.methodswith","category":"function","text":"methodswith(typ[, module or function]; supertypes::Bool=false)\n\nReturn an array of methods with an argument of type typ.\n\nThe optional second argument restricts the search to a particular module or function\n(the default is all top-level modules).\n\nIf keyword supertypes is true, also return arguments with a parent type of typ,\nexcluding type Any.\n\nSee also: methods.\n\n\n\n\n\n"},{"title":"InteractiveUtils.subtypes","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.subtypes","category":"function","text":"subtypes(T::DataType)\n\nReturn a list of immediate subtypes of DataType T. Note that all currently loaded subtypes\nare included, including those not visible in the current module.\n\nSee also supertype, supertypes, methodswith.\n\nExamples\n\njulia> subtypes(Integer)\n3-element Vector{Any}:\n Bool\n Signed\n Unsigned\n\n\n\n\n\n"},{"title":"InteractiveUtils.supertypes","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.supertypes","category":"function","text":"supertypes(T::Type)\n\nReturn a tuple (T, ..., Any) of T and all its supertypes, as determined by\nsuccessive calls to the supertype function, listed in order of <:\nand terminated by Any.\n\nSee also subtypes.\n\nExamples\n\njulia> supertypes(Int)\n(Int64, Signed, Integer, Real, Number, Any)\n\n\n\n\n\n"},{"title":"InteractiveUtils.edit","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.edit-Tuple{AbstractString, Integer}","category":"method","text":"edit(path::AbstractString, line::Integer=0, column::Integer=0)\n\nEdit a file or directory optionally providing a line number to edit the file at.\nReturn to the julia prompt when you quit the editor. The editor can be changed\nby setting JULIA_EDITOR, VISUAL or EDITOR as an environment variable.\n\ncompat: Julia 1.9\nThe column argument requires at least Julia 1.9.\n\nSee also InteractiveUtils.define_editor.\n\n\n\n\n\n"},{"title":"InteractiveUtils.edit","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.edit-Tuple{Any}","category":"method","text":"edit(function, [types])\nedit(module)\n\nEdit the definition of a function, optionally specifying a tuple of types to indicate which\nmethod to edit. For modules, open the main source file. The module needs to be loaded with\nusing or import first.\n\ncompat: Julia 1.1\nedit on modules requires at least Julia 1.1.\n\nTo ensure that the file can be opened at the given line, you may need to call\nInteractiveUtils.define_editor first.\n\n\n\n\n\n"},{"title":"InteractiveUtils.@edit","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.@edit","category":"macro","text":"@edit\n\nEvaluates the arguments to the function or macro call, determines their types, and calls the edit\nfunction on the resulting expression.\n\nSee also: @less, @which.\n\n\n\n\n\n"},{"title":"InteractiveUtils.define_editor","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.define_editor","category":"function","text":"define_editor(fn, pattern; wait=false)\n\nDefine a new editor matching pattern that can be used to open a file (possibly\nat a given line number) using fn.\n\nThe fn argument is a function that determines how to open a file with the\ngiven editor. It should take four arguments, as follows:\n\ncmd - a base command object for the editor\npath - the path to the source file to open\nline - the line number to open the editor at\ncolumn - the column number to open the editor at\n\nEditors which cannot open to a specific line with a command or a specific column\nmay ignore the line and/or column argument. The fn callback must return\neither an appropriate Cmd object to open a file or nothing to indicate that\nthey cannot edit this file. Use nothing to indicate that this editor is not\nappropriate for the current environment and another editor should be attempted.\nIt is possible to add more general editing hooks that need not spawn\nexternal commands by pushing a callback directly to the vector EDITOR_CALLBACKS.\n\nThe pattern argument is a string, regular expression, or an array of strings\nand regular expressions. For the fn to be called, one of the patterns must\nmatch the value of EDITOR, VISUAL or JULIA_EDITOR. For strings, the string\nmust equal the basename of the first word of the editor command, with\nits extension, if any, removed. E.g. \"vi\" doesn't match \"vim -g\" but matches\n\"/usr/bin/vi -m\"; it also matches vi.exe. If pattern is a regex it is\nmatched against all of the editor command as a shell-escaped string. An array\npattern matches if any of its items match. If multiple editors match, the one\nadded most recently is used.\n\nBy default julia does not wait for the editor to close, running it in the\nbackground. However, if the editor is terminal based, you will probably want to\nset wait=true and julia will wait for the editor to close before resuming.\n\nIf one of the editor environment variables is set, but no editor entry matches it,\nthe default editor entry is invoked:\n\n(cmd, path, line, column) -> `$cmd $path`\n\nNote that many editors are already defined. All of the following commands should\nalready work:\n\nemacs\nemacsclient\nvim\nnvim\nnano\nmicro\nkak\nhelix\ntextmate\nmate\nkate\nsubl\natom\nnotepad++\nVisual Studio Code\nopen\npycharm\nbbedit\n\nExamples\n\nThe following defines the usage of terminal-based emacs:\n\ndefine_editor(\n    r\"\\bemacs\\b.*\\s(-nw|--no-window-system)\\b\", wait=true) do cmd, path, line\n    `$cmd +$line $path`\nend\n\ncompat: Julia 1.4\ndefine_editor was introduced in Julia 1.4.\n\n\n\n\n\n"},{"title":"InteractiveUtils.less","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.less-Tuple{AbstractString}","category":"method","text":"less(file::AbstractString, [line::Integer])\n\nShow a file using the default pager, optionally providing a starting line number. Returns to\nthe julia prompt when you quit the pager.\n\n\n\n\n\n"},{"title":"InteractiveUtils.less","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.less-Tuple{Any}","category":"method","text":"less(function, [types])\n\nShow the definition of a function using the default pager, optionally specifying a tuple of\ntypes to indicate which method to see.\n\n\n\n\n\n"},{"title":"InteractiveUtils.@less","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.@less","category":"macro","text":"@less\n\nEvaluates the arguments to the function or macro call, determines their types, and calls the less\nfunction on the resulting expression.\n\nSee also: @edit, @which, @code_lowered.\n\n\n\n\n\n"},{"title":"InteractiveUtils.@which","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.@which","category":"macro","text":"@which\n\nApplied to a function or macro call, it evaluates the arguments to the specified call, and\nreturns the Method object for the method that would be called for those arguments. Applied\nto a variable, it returns the module in which the variable was bound. It calls out to the\nwhich function.\n\nSee also: @less, @edit.\n\n\n\n\n\n"},{"title":"InteractiveUtils.@functionloc","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.@functionloc","category":"macro","text":"@functionloc\n\nApplied to a function or macro call, it evaluates the arguments to the specified call, and\nreturns a tuple (filename,line) giving the location for the method that would be called for those arguments.\nIt calls out to the functionloc function.\n\n\n\n\n\n"},{"title":"InteractiveUtils.@code_lowered","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.@code_lowered","category":"macro","text":"@code_lowered\n\nEvaluates the arguments to the function or macro call, determines their types, and calls\ncode_lowered on the resulting expression.\n\nSee also: code_lowered, @code_warntype, @code_typed, @code_llvm, @code_native.\n\n\n\n\n\n"},{"title":"InteractiveUtils.@code_typed","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.@code_typed","category":"macro","text":"@code_typed\n\nEvaluates the arguments to the function or macro call, determines their types, and calls\ncode_typed on the resulting expression. Use the optional argument optimize with\n\n@code_typed optimize=true foo(x)\n\nto control whether additional optimizations, such as inlining, are also applied.\n\nSee also: code_typed, @code_warntype, @code_lowered, @code_llvm, @code_native.\n\n\n\n\n\n"},{"title":"InteractiveUtils.code_warntype","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.code_warntype","category":"function","text":"code_warntype([io::IO], f, types; debuginfo=:default)\n\nPrints lowered and type-inferred ASTs for the methods matching the given generic function\nand type signature to io which defaults to stdout. The ASTs are annotated in such a way\nas to cause non-concrete types which may be problematic for performance to be emphasized\n(if color is available, displayed in red). This serves as a warning of potential type instability.\n\nNot all non-concrete types are particularly problematic for performance, and the performance\ncharacteristics of a particular type is an implementation detail of the compiler.\ncode_warntype will err on the side of coloring types red if they might be a performance\nconcern, so some types may be colored red even if they do not impact performance.\nSmall unions of concrete types are usually not a concern, so these are highlighted in yellow.\n\nKeyword argument debuginfo may be one of :source, :none or :default, to specify the verbosity of code comments.\nUnless the user changes Base.IRShow.default_debuginfo[], the value :default is equivalent to :source.\n\nSee the @code_warntype section in the Performance Tips page of the manual for more information.\n\nSee also: @code_warntype, code_typed, code_lowered, code_llvm, code_native.\n\n\n\n\n\n"},{"title":"InteractiveUtils.@code_warntype","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.@code_warntype","category":"macro","text":"@code_warntype\n\nEvaluates the arguments to the function or macro call, determines their types, and calls\ncode_warntype on the resulting expression.\n\nSee also: code_warntype, @code_typed, @code_lowered, @code_llvm, @code_native.\n\n\n\n\n\n"},{"title":"InteractiveUtils.code_llvm","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.code_llvm","category":"function","text":"code_llvm([io=stdout,], f, types; raw=false, dump_module=false, optimize=true, debuginfo=:default)\n\nPrints the LLVM bitcodes generated for running the method matching the given generic\nfunction and type signature to io.\n\nIf the optimize keyword is unset, the code will be shown before LLVM optimizations.\nAll metadata and dbg.* calls are removed from the printed bitcode. For the full IR, set the raw keyword to true.\nTo dump the entire module that encapsulates the function (with declarations), set the dump_module keyword to true.\nKeyword argument debuginfo may be one of source (default) or none, to specify the verbosity of code comments.\n\nSee also: @code_llvm, code_warntype, code_typed, code_lowered, code_native.\n\n\n\n\n\n"},{"title":"InteractiveUtils.@code_llvm","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.@code_llvm","category":"macro","text":"@code_llvm\n\nEvaluates the arguments to the function or macro call, determines their types, and calls\ncode_llvm on the resulting expression.\nSet the optional keyword arguments raw, dump_module, debuginfo, optimize\nby putting them and their value before the function call, like this:\n\n@code_llvm raw=true dump_module=true debuginfo=:default f(x)\n@code_llvm optimize=false f(x)\n\noptimize controls whether additional optimizations, such as inlining, are also applied.\nraw makes all metadata and dbg.* calls visible.\ndebuginfo may be one of :source (default) or :none,  to specify the verbosity of code comments.\ndump_module prints the entire module that encapsulates the function.\n\nSee also: code_llvm, @code_warntype, @code_typed, @code_lowered, @code_native.\n\n\n\n\n\n"},{"title":"InteractiveUtils.code_native","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.code_native","category":"function","text":"code_native([io=stdout,], f, types; syntax=:intel, debuginfo=:default, binary=false, dump_module=true, raw=false)\n\nPrints the native assembly instructions generated for running the method matching the given\ngeneric function and type signature to io.\n\nSet assembly syntax by setting syntax to :intel (default) for intel syntax or :att for AT&T syntax.\nSpecify verbosity of code comments by setting debuginfo to :source (equivalently, :default) or :none.\nIf binary is true, also print the binary machine code for each instruction precedented by an abbreviated address.\nIf dump_module is false, do not print metadata such as rodata or directives.\nIf raw is false (default), uninteresting instructions (like the safepoint function prologue) are elided.\n\nSee also: @code_native, code_warntype, code_typed, code_lowered, code_llvm.\n\n\n\n\n\n"},{"title":"InteractiveUtils.@code_native","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.@code_native","category":"macro","text":"@code_native\n\nEvaluates the arguments to the function or macro call, determines their types, and calls\ncode_native on the resulting expression.\n\nSet any of the optional keyword arguments syntax, debuginfo, binary or dump_module\nby putting it before the function call, like this:\n\n@code_native syntax=:intel debuginfo=:default binary=true dump_module=false f(x)\n\nSet assembly syntax by setting syntax to :intel (default) for Intel syntax or :att for AT&T syntax.\nSpecify verbosity of code comments by setting debuginfo to :source (default) or :none.\nIf binary is true, also print the binary machine code for each instruction precedented by an abbreviated address.\nIf dump_module is false, do not print metadata such as rodata or directives.\n\nSee also: code_native, @code_warntype, @code_typed, @code_lowered, @code_llvm.\n\n\n\n\n\n"},{"title":"Base.@time_imports","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#Base.@time_imports","category":"macro","text":"@time_imports\n\nA macro to execute an expression and produce a report of any time spent importing packages and their\ndependencies. Any compilation time will be reported as a percentage, and how much of which was recompilation, if any.\n\nOne line is printed per package or package extension. The duration shown is the time to import that package itself, not including the time to load any of its dependencies.\n\nOn Julia 1.9+ package extensions will show as Parent → Extension.\n\nnote: Note\nDuring the load process a package sequentially imports all of its dependencies, not just its direct dependencies.\n\njulia> @time_imports using CSV\n     50.7 ms  Parsers 17.52% compilation time\n      0.2 ms  DataValueInterfaces\n      1.6 ms  DataAPI\n      0.1 ms  IteratorInterfaceExtensions\n      0.1 ms  TableTraits\n     17.5 ms  Tables\n     26.8 ms  PooledArrays\n    193.7 ms  SentinelArrays 75.12% compilation time\n      8.6 ms  InlineStrings\n     20.3 ms  WeakRefStrings\n      2.0 ms  TranscodingStreams\n      1.4 ms  Zlib_jll\n      1.8 ms  CodecZlib\n      0.8 ms  Compat\n     13.1 ms  FilePathsBase 28.39% compilation time\n   1681.2 ms  CSV 92.40% compilation time\n\ncompat: Julia 1.8\nThis macro requires at least Julia 1.8\n\n\n\n\n\n"},{"title":"Base.@trace_compile","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#Base.@trace_compile","category":"macro","text":"@trace_compile\n\nA macro to execute an expression and show any methods that were compiled (or recompiled in yellow),\nlike the julia args --trace-compile=stderr --trace-compile-timing but specifically for a call.\n\njulia> @trace_compile rand(2,2) * rand(2,2)\n#=   39.1 ms =# precompile(Tuple{typeof(Base.rand), Int64, Int64})\n#=  102.0 ms =# precompile(Tuple{typeof(Base.:(*)), Array{Float64, 2}, Array{Float64, 2}})\n2×2 Matrix{Float64}:\n 0.421704  0.864841\n 0.211262  0.444366\n\ncompat: Julia 1.12\nThis macro requires at least Julia 1.12\n\n\n\n\n\n"},{"title":"Base.@trace_dispatch","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#Base.@trace_dispatch","category":"macro","text":"@trace_dispatch\n\nA macro to execute an expression and report methods that were compiled via dynamic dispatch,\nlike the julia arg --trace-dispatch=stderr but specifically for a call.\n\ncompat: Julia 1.12\nThis macro requires at least Julia 1.12\n\n\n\n\n\n"},{"title":"InteractiveUtils.clipboard","page":"Interactive Utilities","location":"stdlib/InteractiveUtils.html#InteractiveUtils.clipboard","category":"function","text":"clipboard(x)\n\nSend a printed form of x to the operating system clipboard (\"copy\").\n\n\n\n\n\nclipboard()::String\n\nReturn a string with the contents of the operating system clipboard (\"paste\").\n\n\n\n\n\n"},{"title":"isbits Union Optimizations","page":"isbits Union Optimizations","location":"devdocs/isbitsunionarrays.html#isbits-Union-Optimizations","category":"section","text":"In Julia, the Array type holds both \"bits\" values as well as heap-allocated \"boxed\" values. The distinction is whether the value itself is stored inline (in the direct allocated memory of the array), or if the memory of the array is simply a collection of pointers to objects allocated elsewhere. In terms of performance, accessing values inline is clearly an advantage over having to follow a pointer to the actual value. The definition of \"isbits\" generally means any Julia type with a fixed, determinate size, meaning no \"pointer\" fields, see ?isbitstype.\n\nJulia also supports Union types, quite literally the union of a set of types. Custom Union type definitions can be extremely handy for applications wishing to \"cut across\" the nominal type system (i.e. explicit subtype relationships) and define methods or functionality on these, otherwise unrelated, set of types. A compiler challenge, however, is in determining how to treat these Union types. The naive approach (and indeed, what Julia itself did pre-0.7), is to simply make a \"box\" and then a pointer in the box to the actual value, similar to the previously mentioned \"boxed\" values. This is unfortunate, however, because of the number of small, primitive \"bits\" types (think UInt8, Int32, Float64, etc.) that would easily fit themselves inline in this \"box\" without needing any indirection for value access. There are two main ways Julia can take advantage of this optimization as of 0.7: isbits Union fields in types, and isbits Union Arrays."},{"title":"isbits Union Structs","page":"isbits Union Optimizations","location":"devdocs/isbitsunionarrays.html#isbits-Union-Structs","category":"section","text":"Julia now includes an optimization wherein \"isbits Union\" fields in types (mutable struct, struct, etc.) will be stored inline.\nThis is accomplished by determining the \"inline size\" of the Union type\n(e.g. Union{UInt8, Int16} will have a size of two bytes, which represents the size needed of the largest Union type Int16),\nand in addition, allocating an extra \"type tag byte\" (UInt8), whose value signals the type of the actual value stored inline of the \"Union bytes\".\nThe type tag byte value is the index of the actual value's type in the Union type's order of types.\nFor example, a type tag value of 0x02 for a field with type Union{Nothing, UInt8, Int16} would indicate that an Int16 value is stored in\nthe 16 bits of the field in the structure's memory;\na 0x01 value would indicate that a UInt8 value was stored in the first 8 bits of the 16 bits of the field's memory.\nLastly, a value of 0x00 signals that the nothing value will be returned for this field, even though, as a singleton\ntype with a single type instance, it technically has a size of 0. The type tag byte for a type's Union field is stored\ndirectly after the field's computed Union memory."},{"title":"isbits Union Memory","page":"isbits Union Optimizations","location":"devdocs/isbitsunionarrays.html#isbits-Union-Memory","category":"section","text":"Julia can now also store \"isbits Union\" values inline in a Memory, as opposed to requiring\nan indirection box. The optimization is accomplished by storing an extra \"type tag memory\"\nof bytes, one byte per element, alongside the bytes of the actual data. This type tag memory\nserves the same function as the type field case: its value signals the type of the actual\nstored Union value. The \"type tag memory\" directly follows the regular data space. So the\nformula to access an isbits Union Array's type tag bytes is a->data + a->length * a->elsize."},{"title":"Handling Operating System Variation","page":"Handling Operating System Variation","location":"manual/handling-operating-system-variation.html#Handling-Operating-System-Variation","category":"section","text":"When writing cross-platform applications or libraries, it is often necessary to allow for\ndifferences between operating systems. The variable Sys.KERNEL can be used to handle such\ncases. There are several functions in the Sys module intended to make this easier, such as\nisunix, islinux, isapple, isbsd, isfreebsd, and iswindows. These may be used\nas follows:\n\nif Sys.iswindows()\n    windows_specific_thing(a)\nend\n\nNote that islinux, isapple, and isfreebsd are mutually exclusive subsets of isunix.\nAdditionally, there is a macro @static which makes it possible to use these functions to\nconditionally hide invalid code, as demonstrated in the following examples.\n\nSimple blocks:\n\nccall((@static Sys.iswindows() ? :_fopen : :fopen), ...)\n\nComplex blocks:\n\n@static if Sys.islinux()\n    linux_specific_thing(a)\nelseif Sys.isapple()\n    apple_specific_thing(a)\nelse\n    generic_thing(a)\nend\n\nWhen nesting conditionals, the @static must be repeated for each level\n(parentheses optional, but recommended for readability):\n\n@static Sys.iswindows() ? :a : (@static Sys.isapple() ? :b : :c)"}]
}
